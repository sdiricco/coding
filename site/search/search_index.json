{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Learn Benvenuto! In questa repository puoi trovare appunti di informatica ed elettronica. In particolare puoi trovare corsi dalla programmazione web ai sistemi embedded, tutorial su sistemi operativi come Linux o Android e qualche nozione di elettronica come supporto alla programmazione per sistemi embedded Learn Sviluppo web front-end Scripting & linguaggi general purpose Sistemi embedded Sistemi embedded Automotive Ambienti di Sviluppo Sistemi operativi Metodologie di sviluppo software Sviluppo web front-end Html : In informatica l'HyperText Markup Language (traduzione letterale: linguaggio a marcatori per ipertesti), comunemente noto con l'acronimo HTML, \u00e8 un linguaggio di markup Css : Il CSS (sigla di Cascading Style Sheets, in italiano fogli di stile a cascata), in informatica, \u00e8 un linguaggio usato per definire la formattazione di documenti HTML, XHTML e XML, ad esempio i siti web e relative pagine web. Javascript : Attualmente quasi tutte le pagine web contengono JavaScript, un linguaggio di scripting che viene eseguito dal browser del visitatore Typescript : E' un linguaggio di programmazione open source sviluppato da Microsoft. Si tratta di un Super-set di JavaScript che basa le sue caratteristiche su ECMAScript 6 react.js : React \u00e8 una libreria JavaScript per la creazione di interfacce utente Scripting & linguaggi general purpose Espressioni regolari : Un'espressione regolare \u00e8 una sequenza di simboli che identifica un insieme di stringhe Java : In informatica Java \u00e8 un linguaggio di programmazione ad alto livello, orientato agli oggetti e a tipizzazione statica, che si appoggia sull'omonima piattaforma C++ : In informatica C++ \u00e8 un linguaggio di programmazione general-purpose, sviluppato in origine da Bjarne Stroustrup nei Bell Labs nel 1983 come evoluzione del linguaggio C inserendo la programmazione orientata agli oggetti, col tempo ha avuto notevoli evoluzioni, come l'introduzione dell'astrazione rispetto al tipo. Python : Python \u00e8 un linguaggio di programmazione di pi\u00f9 \"alto livello\" rispetto alla maggior parte degli altri linguaggi, orientato a oggetti, adatto, tra gli altri usi, a sviluppare applicazioni distribuite, scripting, computazione numerica e system testing. Sistemi embedded Arduino : Arduino \u00e8 una piattaforma hardware composta da una serie di schede elettroniche dotate di un microcontrollore Espruino : Espruino \u00e8 un interprete JavaScript open source per microcontrollori Raspberry pi pico : E' un chip progettato da Raspberry Pi (RP2040) con un dual core ARM Cortex-M0+ dual core con clock a 133 MHz con memoria flash QSPI integrata da 2 MB. \u00c8 possibile programmarlo in MicroPython. Sistemi embedded Automotive Protocollo LIN : Local Interconnect Network (LIN) \u00e8 un protocollo di comunicazione seriale a bassa velocit\u00e0 su cavo singolo progettato per applicazioni automotive Ambienti di Sviluppo Editor di testo : E' un programma per la composizione di testi. Un semplice editor \u00e8 generalmente incluso in ogni sistema operativo e utilizzato dai programmatori come ambiente di sviluppo Sistemi operativi Android : Android \u00e8 un sistema operativo per dispositivi mobili sviluppato da Google, progettato principalmente per sistemi embedded quali smartphone e tablet, con interfacce utente specializzate per televisori, automobili, orologi da polso, occhiali .. Altro freenas : TrueNAS \u00e8 un sistema operativo open source basato su FreeBSD che permette di costruire un dispositivo collegato ad una rete di computer la cui funzione principale \u00e8 quella di condividere tra gli utenti della rete una Area di storage, cio\u00e8 un NAS Soft mod ps2 : Tramite questa modifica sar\u00e0 possibile caricare i giochi tramite hard disk cloudReady Os : CloudReady Os \u00e8 un sistema operativo basato su Chromium OS, proprio come Chrome OS il sistema operativo utilizzato nei chromebook.","title":"Learn"},{"location":"#learn","text":"Benvenuto! In questa repository puoi trovare appunti di informatica ed elettronica. In particolare puoi trovare corsi dalla programmazione web ai sistemi embedded, tutorial su sistemi operativi come Linux o Android e qualche nozione di elettronica come supporto alla programmazione per sistemi embedded Learn Sviluppo web front-end Scripting & linguaggi general purpose Sistemi embedded Sistemi embedded Automotive Ambienti di Sviluppo Sistemi operativi Metodologie di sviluppo software","title":"Learn"},{"location":"#sviluppo-web-front-end","text":"Html : In informatica l'HyperText Markup Language (traduzione letterale: linguaggio a marcatori per ipertesti), comunemente noto con l'acronimo HTML, \u00e8 un linguaggio di markup Css : Il CSS (sigla di Cascading Style Sheets, in italiano fogli di stile a cascata), in informatica, \u00e8 un linguaggio usato per definire la formattazione di documenti HTML, XHTML e XML, ad esempio i siti web e relative pagine web. Javascript : Attualmente quasi tutte le pagine web contengono JavaScript, un linguaggio di scripting che viene eseguito dal browser del visitatore Typescript : E' un linguaggio di programmazione open source sviluppato da Microsoft. Si tratta di un Super-set di JavaScript che basa le sue caratteristiche su ECMAScript 6 react.js : React \u00e8 una libreria JavaScript per la creazione di interfacce utente","title":"Sviluppo web front-end"},{"location":"#scripting-linguaggi-general-purpose","text":"Espressioni regolari : Un'espressione regolare \u00e8 una sequenza di simboli che identifica un insieme di stringhe Java : In informatica Java \u00e8 un linguaggio di programmazione ad alto livello, orientato agli oggetti e a tipizzazione statica, che si appoggia sull'omonima piattaforma C++ : In informatica C++ \u00e8 un linguaggio di programmazione general-purpose, sviluppato in origine da Bjarne Stroustrup nei Bell Labs nel 1983 come evoluzione del linguaggio C inserendo la programmazione orientata agli oggetti, col tempo ha avuto notevoli evoluzioni, come l'introduzione dell'astrazione rispetto al tipo. Python : Python \u00e8 un linguaggio di programmazione di pi\u00f9 \"alto livello\" rispetto alla maggior parte degli altri linguaggi, orientato a oggetti, adatto, tra gli altri usi, a sviluppare applicazioni distribuite, scripting, computazione numerica e system testing.","title":"Scripting &amp; linguaggi general purpose"},{"location":"#sistemi-embedded","text":"Arduino : Arduino \u00e8 una piattaforma hardware composta da una serie di schede elettroniche dotate di un microcontrollore Espruino : Espruino \u00e8 un interprete JavaScript open source per microcontrollori Raspberry pi pico : E' un chip progettato da Raspberry Pi (RP2040) con un dual core ARM Cortex-M0+ dual core con clock a 133 MHz con memoria flash QSPI integrata da 2 MB. \u00c8 possibile programmarlo in MicroPython.","title":"Sistemi embedded"},{"location":"#sistemi-embedded-automotive","text":"Protocollo LIN : Local Interconnect Network (LIN) \u00e8 un protocollo di comunicazione seriale a bassa velocit\u00e0 su cavo singolo progettato per applicazioni automotive","title":"Sistemi embedded Automotive"},{"location":"#ambienti-di-sviluppo","text":"Editor di testo : E' un programma per la composizione di testi. Un semplice editor \u00e8 generalmente incluso in ogni sistema operativo e utilizzato dai programmatori come ambiente di sviluppo","title":"Ambienti di Sviluppo"},{"location":"#sistemi-operativi","text":"Android : Android \u00e8 un sistema operativo per dispositivi mobili sviluppato da Google, progettato principalmente per sistemi embedded quali smartphone e tablet, con interfacce utente specializzate per televisori, automobili, orologi da polso, occhiali ..","title":"Sistemi operativi"},{"location":"#altro","text":"freenas : TrueNAS \u00e8 un sistema operativo open source basato su FreeBSD che permette di costruire un dispositivo collegato ad una rete di computer la cui funzione principale \u00e8 quella di condividere tra gli utenti della rete una Area di storage, cio\u00e8 un NAS Soft mod ps2 : Tramite questa modifica sar\u00e0 possibile caricare i giochi tramite hard disk cloudReady Os : CloudReady Os \u00e8 un sistema operativo basato su Chromium OS, proprio come Chrome OS il sistema operativo utilizzato nei chromebook.","title":"Altro"},{"location":"android/","text":"Android Fix - Nexus 5x bootloop Android 8.1 Puoi trovare la guida che ho seguito su xda Ho seguito il primo metodo che esegue il fix sull'ultima versione della rom stock android (8.1). Il secondo, esegue il fix su una custom ROM (Lineage OS). Materiale Avrai bisogno di: - Driver fastboot-adb windows: adb-setup-1.4.3 - minimal-adb-and-fastboot-tool: platform-tools_r31.0.2-windows - Andorid 8.1 stock image: stock image - custom bootloader: boot Dopodich\u00e8: Installa i driver fastboot-adb Accendi lo smartphone fastboot mode POW + VOL- Scompatta la stock image ed esegui il file 'flash-all.bat'. Quando si riavvia il telefono torna in fastboot mode Copia il file boot.img all'internod della cartella platform-tools_r31.0.2-windows/platform-tools Esegui il comando: fastboot flash boot boot.img","title":"Android"},{"location":"android/#android","text":"","title":"Android"},{"location":"android/#fix-nexus-5x-bootloop","text":"","title":"Fix - Nexus 5x bootloop"},{"location":"android/#android-81","text":"Puoi trovare la guida che ho seguito su xda Ho seguito il primo metodo che esegue il fix sull'ultima versione della rom stock android (8.1). Il secondo, esegue il fix su una custom ROM (Lineage OS).","title":"Android 8.1"},{"location":"android/#materiale","text":"Avrai bisogno di: - Driver fastboot-adb windows: adb-setup-1.4.3 - minimal-adb-and-fastboot-tool: platform-tools_r31.0.2-windows - Andorid 8.1 stock image: stock image - custom bootloader: boot Dopodich\u00e8: Installa i driver fastboot-adb Accendi lo smartphone fastboot mode POW + VOL- Scompatta la stock image ed esegui il file 'flash-all.bat'. Quando si riavvia il telefono torna in fastboot mode Copia il file boot.img all'internod della cartella platform-tools_r31.0.2-windows/platform-tools Esegui il comando: fastboot flash boot boot.img","title":"Materiale"},{"location":"arduino/","text":"Arduino Arduino Lezione 01 Lezione 02 Alimentare arduino Lezione 03 Pin I/O Lezione 04 Sketch Primo sketch - LED Blink Lezione 05 PWM Lezione 06 Documentazione Linguaggio Arduino Binary Clock Collegamenti Hardware Il codice RTC e display 7 segmenti EEPROM SLEEP MODE Contatto magnetico RTC e Display I2C Lezione 01 Arduino \u00e8 una scheda elettronica per realizzare prototipi. Il cuore di arduino \u00e8 il microcontrollore . Il modello Arduino UNO R3 utilizza il microcontrollore Atmega328P . Un microcontrollore (in inglese microcontroller in acronimo MCU ovvero MicroController Unit), in elettronica digitale, \u00e8 un dispositivo elettronico integrato su singolo circuito elettronico, nato come evoluzione alternativa al microprocessore e utilizzato generalmente in sistemi embedded ovvero per applicazioni specifiche di controllo digitale. La scehda di Arduino, attraverso il microcontrollore, comunica con il mondo esterno attraverso i suoi PIN. Un microcontrollore in genere svolge un compito molto specifico come leggere il valore di certi sensori collegati in ingresso o settare le uscite collegate a qualche attuatore. Ci sono molti componenti elettronici interfacciabili direttamente con Arduino Lezione 02 Alimentare arduino Puoi alimentare Arduino con il connettore DC con una tensione nel range 6-20V Puoi inoltre utilizzare il cavo usb collegato a PC o un a un caricatore per smartphone. Il cavo USB \u00e8 inoltre indispensabile per il caricamento del programma da PC alla memoria interna del microcontrollore Puoi alimentare Arduino manualmente attraverso il pin Vin con una tensione esatta di 5V . Una volta alimentato Arduino puoi prelevare le tensioni di 5v , 3.3v e il riferimento GND dagli omonimi pin. Esiste inoltre un tasto RESET che consente il riavvio di Arduino. E' possibile inoltre riavviare Arduino attraverso il pin RESET con un apposito segnale di reset . Lezione 03 Pin I/O Pin Digitali Ci sono 14 PIN digitali numerati da 0 - 13 per l'interfacciamento digitale con il mondo esterno. Possono essere utili per collegare LED, tasti, display LCD, matrici di LED e molto altro. In generale \u00e8 possibile collegare ogni dispositivo digitale ovvero componenti che ricevono o trasmettono solo due possibili valori di tensione 5V , 0V . Alucuni pin sono marcati con una ~ . Sono dedicati al modulo PWM che studieremo pi\u00f9 avanti. Pin Analogici Ci sono inoltre 5 PIN numerati da 14 - 19 per l'interfacciamento con segnali analogici in ingresso come sensori di temperatura, microfoni o in generale qualsiasi segnale elettrico che varia in modo continuo nel range [0v - 5v] . Lezione 04 Sketch Lo Sketch \u00e8 il programma, la logica. Arduino utilizza come linguaggio di programmazione il C++ ma fornisce anche delle funzioni di interfacciamento o meglio delle classi e dei metodi per l'accesso in modo semplificato all'Hardware. Per far ci\u00f2, all'accensione del microcontrollore, Arduino configura i registri interni dei moduli del microcontrollore con un settaggio standard e \"maschera\" queste operazioni all'utente finale mostrando solo due macroblocchi: setup loop In linea generale possiamo affermare che: setup: i comandi scritti all'interno di questo blocco vengono eseguiti una sola volta all'avvio di Arduino. loop i comandi scritti all'interno di questo blocco vengono eseguiti ciclicamente dopo l'avvio di Arduino fino al riavvio o spegnimento della board. Driver necessari Normalmente, installando l'IDE Arduino ti troverai installati anche tutti i driver necessari per comunicare con la scheda. Se acquisti un Arduino clone tuttavia potresti aver bisogno dei driver (per Windows) poich\u00e8 spesso i componenti hardware non sono proprio gli stessi. Da questa pagina \u00e8 possibile scaricare i driver necessari. Trovi un file eseguibile anche all'interno di questa repository al percorso files/CH341SER.EXE Primo sketch - LED Blink Come primo Sketch vedremo come far lampeggiare un LED. Useremo il LED connesso direttamente ad arduino al pin 13 . Per far ci\u00f2 dovremo: in void setup {} : - Impostare il pin 13 come output in void loop(){} : - Scrivere il valore logico HIGH sul pin 13 per fornire 5v ed accendere il led tramite l'istruzione digitalWrite() - Inserire un ritardo che esprime il tempo in cui il pin star\u00e0 acceso con l'istruzione delay() - Scrivere il valore logico LOW sul pin 13 per togliere l'alimentazione e spegnere il led tramite l'istruzione digitalWrite() - Inserire un ritardo che esprime il tempo in cui il pin star\u00e0 spento con l'istruzione delay() Poich\u00e8 il void loop(){} esegue in loop le istruzioni, realizzerai un lampeggio del LED infinito. Il codice completo: void setup () { // initialize digital pin LED_BUILTIN as an output. pinMode ( 13 , OUTPUT ); } // the loop function runs over and over again forever void loop () { digitalWrite ( 13 , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( 13 , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } Adesso \u00e8 sufficiente: - Premere il tasto Verifica che controller\u00e0 la sintassi e ti avviser\u00e0 se hai inserito qualche comando non valido nella finestra nera in basso - Premere il tasto Esegui che andr\u00e0 a inserire il codice all'interno della memoria di Arduino e a procedere con l'esecuzione dello sketch E' possibile trovare questo sketch esempio su File/Esempi/01.Basics/Blink Apparir\u00e0 come: /* Blink Turns an LED on for one second, then off for one second, repeatedly. Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to the correct LED pin independent of which board is used. If you want to know what pin the on-board LED is connected to on your Arduino model, check the Technical Specs of your board at: https://www.arduino.cc/en/Main/Products modified 8 May 2014 by Scott Fitzgerald modified 2 Sep 2016 by Arturo Guadalupi modified 8 Sep 2016 by Colby Newman This example code is in the public domain. http://www.arduino.cc/en/Tutorial/Blink */ // the setup function runs once when you press reset or power the board void setup () { // initialize digital pin LED_BUILTIN as an output. pinMode ( LED_BUILTIN , OUTPUT ); } // the loop function runs over and over again forever void loop () { digitalWrite ( LED_BUILTIN , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( LED_BUILTIN , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } L'unica differenza che trovi \u00e8 LED_BUILTIN . E' una costante il cui valore \u00e8 pari a 13 . Il valore di tutte le costanti di Arduino le puoi trovare sulla documentazione ufficiale: Arduino - constants Lezione 05 PWM In elettronica e telecomunicazioni la modulazione di larghezza di impulso (o PWM, acronimo del corrispettivo inglese pulse-width modulation) \u00e8 un tipo di modulazione digitale che permette di ottenere una tensione media variabile dipendente dal rapporto tra la durata dell'impulso positivo e dell'intero periodo (duty cycle). Allo stesso modo, \u00e8 fondamentalmente utilizzato per protocolli di comunicazione in cui l'informazione \u00e8 codificata sotto forma di durata nel tempo di ciascun impulso. Grazie ai moderni microcontrollori, \u00e8 possibile attivare o disattivare un interruttore ad alta frequenza e allo stesso modo rilevare lo stato e il periodo di un impulso. Poich\u00e8 arduino \u00e8 alimentato a 5V se volessi ottenere un valore medio pari a 2.5V in uscita da un pin digitale dovrei generare un segnale PWM con le seguenti caratteristiche: Frequenza: fissa. Valori standard di frequenza per i segnali PWM vanno da qualche centinaia di Hz a qualche Khz . Il valore di frequenza \u00e8 stabilito internamente da Arduino quindi per adesso non dovrai preoccupartene. Duty cicle: 50% . Per impostare il duty cicle si imposta un valore nel range 0-255 all'interno della funzione analogWrite() . Attraverso la proporzione: dutyCicle% : 100% = value: 255 Poich\u00e8 vogliamo dutyCicle% = 50% , allora value = 127 Nel prossimo esempio generer\u00f2 un segnale PWM con duty cicle = 50% per controllare la luminosit\u00e0 di un LED. Per far ci\u00f2 \u00e8 necessario: - collegare un LED a un PIN qualsiasi con uscita PWM. Sono quelli identificati dal simbolo ~ . Utilizzer\u00f2 il pin 9 - chiamare il comando analogWrite() specificando come primo parametro il pin sul quale si desidera generare il segnale PWM , quindi il pin 9 e come secondo parametro il duty cicle espresso con un numero da [0 - 255] . Per ottenere un duty cicle del 50% scriver\u00f2 127 Lo sketch completo \u00e8: void setup () { } void loop () { analogWrite ( 9 , 127 ); } Arduino fornisce un esepio pi\u00f9 compelto all'interno della cartella degli esempi File/Esempi/01.Basics/Fade /* Fade This example shows how to fade an LED on pin 9 using the analogWrite() function. The analogWrite() function uses PWM, so if you want to change the pin you're using, be sure to use another PWM capable pin. On most Arduino, the PWM pins are identified with a \"~\" sign, like ~3, ~5, ~6, ~9, ~10 and ~11. This example code is in the public domain. http://www.arduino.cc/en/Tutorial/Fade */ int led = 9 ; // the PWM pin the LED is attached to int brightness = 0 ; // how bright the LED is int fadeAmount = 5 ; // how many points to fade the LED by // the setup routine runs once when you press reset: void setup () { // declare pin 9 to be an output: pinMode ( led , OUTPUT ); } // the loop routine runs over and over again forever: void loop () { // set the brightness of pin 9: analogWrite ( led , brightness ); // change the brightness for next time through the loop: brightness = brightness + fadeAmount ; // reverse the direction of the fading at the ends of the fade: if ( brightness <= 0 || brightness >= 255 ) { fadeAmount = - fadeAmount ; } // wait for 30 milliseconds to see the dimming effect delay ( 30 ); } In questo esempio il LED, connesso al PIN 9 si accender\u00e0 e si spegner\u00e0 in modo graduale. Per ottenere questo effetto si agisce su parametro che regola il duty cicle che in questo programma \u00e8 definito dalla variabile brightness . In pratica il software imposta una brightness pari a 0 aumenta la variabile brightness del valore pari a fadeAmount (impostata a 5 ) secondo l'espressione brightness = brightness + fadeAmount che diventa quindi brightness = brightness + 5 Ripete questa operazione ogni 30 millisecondi . In questo modo il LED aumenter\u00e0 la sua luminosit\u00e0 in modo graduale Una volta che brightness \u00e8 arrivata al valore massimo, brightness >= 255 , inverte il valore di fadeAmount . In questo caso quindi l'espressione diventa brightness = brightness - 5 . Ripete questa operazione ogni 30 millisecondi . Il risultato \u00e8 che il LED diminuir\u00e0 la sua luminosit\u00e0 in modo graduale. Una volta che brightness \u00e8 arrivata al valore minimo, brightness <= 0 , inverte il valore di fadeAmount . In questo caso quindi l'espressione torna a essere brightness = brightness + 5 . Ripete questa operazione ogni 30 millisecondi . E continua fino al reset di Arduino. Domanda: Quanto impiega il ciclo di accensione? vista l'espressione brightness = brightness + fadeAmount e visto il ritardo pari a 30ms , si ha che brightness passa da 0 255 in 51 step ( 255/5 ) e quindi il ciclo di accensione graduale dura 30ms*51 = 1.53 secondi . Poich\u00e8 il ciclo di spegnimento \u00e8 simmetrico, se ne deduce che il ciclo completo (accensione + spegnimento) dura poco pi\u00f9 di 3 secondi Puoi provare: Puoi provare a cambiare il ritardo di 30ms o il fadeAmount per cambiare la velocit\u00e0 di accensione/spegnimento. Puoi anche impostare un valore minimo di brightness e un valore massimo Ecco un esempio: /* Fade This example shows how to fade an LED on pin 9 using the analogWrite() function. The analogWrite() function uses PWM, so if you want to change the pin you're using, be sure to use another PWM capable pin. On most Arduino, the PWM pins are identified with a \"~\" sign, like ~3, ~5, ~6, ~9, ~10 and ~11. This example code is in the public domain. http://www.arduino.cc/en/Tutorial/Fade */ int led = 9 ; // the PWM pin the LED is attached to int brightness = 0 ; // how bright the LED is int fadeAmount = 2 ; // how many points to fade the LED by byte maxBrightness = 200 ; byte minBrightness = 10 ; // the setup routine runs once when you press reset: void setup () { // declare pin 9 to be an output: pinMode ( led , OUTPUT ); } // the loop routine runs over and over again forever: void loop () { // set the brightness of pin 9: analogWrite ( led , brightness ); // change the brightness for next time through the loop: brightness = brightness + fadeAmount ; // reverse the direction of the fading at the ends of the fade: if ( brightness <= minBrightness || brightness >= maxBrightness ) { fadeAmount = - fadeAmount ; } // wait for 3 milliseconds to see the dimming effect delay ( 1 ); } Piccolo Approfondimento - Frequenza PWM Come gi\u00e0 detto, Arduino imposta un valore di frequenza per il segnale PWM ma quale? Per Arduino UNO il valore \u00e8 490.20 Hz per i pin D3,D9, D10, D11 e il valore 976.56 Hz per i pin D5 & D6 . Cosa cambia al variare della frequenza? Provo a darti una spiegazione molto qualitativa.. IL PWM agisce sul'inerzia elettromeccanica dei componenti. Puoi intuire che abbassando la frequenza il componente possa diventare meno fluido. Se si parla di un LED, a una frequenza molto bassa vedrai lampeggiare il LED. Allo stesso tempo puoi intuire che alzando troppo la frequenza sia difficile per il componente leggere valori di duty cicle troppo piccoli. Nel caso del LED, lo vedrai sempre spento. Per determinare i valori minimi e massimi di frequenza PWM \u00e8 necessario eseguire un'analisi dei componenti capacitivi/indutti parassiti e studiare la caratteristica al variare della frequenza. Per adesso comunque ti basta sapere che in linea generale, le frequenze possono andare nei casi pi\u00f9 comuni tra [100Hz - 100Khz] . Avrai frequenze piuttosto basse se il componente ha una capacit\u00e0 di reazione lenta e frequenze pi\u00f9 alte per componenti che hanno una capacit\u00e0 di reazione alta Lezione 06 Documentazione Linguaggio Arduino Arduino utilizza il linguaggio C++ ma esporta una serie di funzioni molto semplici per il controllo dell'Hardware. Qui puoi trovare la documentazione ufficiale del linguaggio di Arduino. Qua sotto riporto comunque qualche costrutto fondamentale del linguaggio C++ e qualche funzione esportata da Arduino. Le variabili Tipo di Dato Dimensione Descrizione char 1 Byte Contenitore per caratteri e valori alfanumerici (e.g., \u2018a\u2019, \u2018b\u2019, \u20181\u2019, etc) bool 1 Byte Contenitore per valori booleani (e.g., true, false) int 2 Byte Contenitore per numeri interi nel range numerico, da -32768 a 32767. unsigned int 2 Byte Contenitore per numeri interi senza segno nel range numerico, da 0 a 65535. long 4 Byte Contenitore per numeri interi nel range numerico, da -2147483648 a 2147483647 unsigned long 4 Byte Contenitore per numeri interi nel range numerico, da 0 to 4,294,967,295 (2^32 \u2013 1) float 4 Byte Contenitore per numeri interi nel range numerico, da 0 to 4,294,967,295 (2^32 \u2013 1) double 4 Byte Contenitore per numeri interi nel range numerico, da 0 to 4,294,967,295 (2^32 \u2013 1) String - Contenitore per testo (e.g., \u201cResistenza\u201d) Binary Clock Per questo orologio binario ho utilizzato la libreria simple_matrix per la gestione della matrice di LED e la libreria RTClib per la gestione del tempo. Ho modificato la libreria simple_matrix creando una nuova versione, simple_matrix_v2 che in pi\u00f9 contiene i metodi: writeSquare(order, x, y, value) writePixel(x, y, value) Collegamenti Hardware LED Matrix Pins Arduino Pins VCC VCC GND GND DIN D11 CLK D13 CS D4 RTC Arduino Pins VCC VCC (+5V) GND GND SDA A4 (SDA) SCL A5 (SCL) Il codice L'orologio binario consiste nel codificare ore, minuti e secondi con la relativa sequenza binaria. Ho deciso di codificare ogni cifra in una sequenza binaria rappresentando quindi separatamente decine e unit\u00e0 per ore, minuti e secondi. Ad esempio: 12 //decine //unit\u00e0 0001 0010 Inoltre la rappresentazione del tempo all'interno della matrice di LED va dall'alto verso il basso a partire dalle ore. In conclusione, per rappresentare la seguente ora: 21:34:46 vedrai: 21 : 34 : 46 //d //u 0010 0001 0011 0100 0100 0110 Ecco quindi il codice completo.. #include \"simple_matrix_v2.h\" //Import the library #include \"RTClib.h\" #define NUMBER_OF_DISPLAYS 2 //Sets the number of display (4 for this example) /* Initialize the library. The 4 means that the CS pin is connected to pin D4. You can change this to whatever you want, just make sure to connect the CS pin to the pin number. The disp means that any future function calls to the library uses \"disp\" as the library's object name. For example, the library has a function called \"setIntensity\", you need to write \"disp.setIntensity\" to call that function. If you notice that the display is upside-down per display, change simpleMatrix disp(4, false, NUMBER_OF_DISPLAYS); to simpleMatrix disp(4, true, NUMBER_OF_DISPLAYS); */ /* WARNING!! There are several problems with the coding of (x, y) coordinates. I advise you to change the library for the LED matrix and switch to MD_MAX72XX which is much more complete and configurable. */ simpleMatrix disp ( 4 , true , NUMBER_OF_DISPLAYS ); RTC_DS1307 rtc ; #define ORDER 2 #define START_X 0 #define START_Y 8 #define ADJUST_HOUR true int seconds = 0 ; int minutes = 0 ; int hours = 0 ; void seconds_unit ( int i ){ //If you don't understand, see WARNINGS int x = 0 ; int y = 0 ; int value = 0 ; for ( int bitNumber = 0 ; bitNumber < 4 ; bitNumber ++ ){ x = START_Y - 1 * ORDER ; y = START_X + bitNumber * ORDER ; value = ( i >> bitNumber ) & 1 ; disp . writeSquare ( ORDER , x , y , value ); } } void seconds_dozens ( int i ){ //If you don't understand, see WARNINGS int x = 0 ; int y = 0 ; int value = 0 ; for ( int bitNumber = 0 ; bitNumber < 4 ; bitNumber ++ ){ x = START_Y - 1 * ORDER ; y = START_X + 8 + bitNumber * ORDER ; value = ( i >> bitNumber ) & 1 ; disp . writeSquare ( ORDER , x , y , value ); } } void minutes_unit ( int i ){ //If you don't understand, see WARNINGS int x = 0 ; int y = 0 ; int value = 0 ; for ( int bitNumber = 0 ; bitNumber < 4 ; bitNumber ++ ){ x = START_Y - 2 * ORDER -1 ; y = START_X + bitNumber * ORDER ; value = ( i >> bitNumber ) & 1 ; disp . writeSquare ( ORDER , x , y , value ); } } void minutes_dozens ( int i ){ //If you don't understand, see WARNINGS int x = 0 ; int y = 0 ; int value = 0 ; for ( int bitNumber = 0 ; bitNumber < 4 ; bitNumber ++ ){ x = START_Y - 2 * ORDER -1 ; y = START_X + 8 + bitNumber * ORDER ; value = ( i >> bitNumber ) & 1 ; disp . writeSquare ( ORDER , x , y , value ); } } void hours_unit ( int i ){ //If you don't understand, see WARNINGS int x = 0 ; int y = 0 ; int value = 0 ; for ( int bitNumber = 0 ; bitNumber < 4 ; bitNumber ++ ){ x = START_Y - 3 * ORDER -2 ; y = START_X + bitNumber * ORDER ; value = ( i >> bitNumber ) & 1 ; disp . writeSquare ( ORDER , x , y , value ); } } void hours_dozens ( int i ){ //If you don't understand, see WARNINGS int x = 0 ; int y = 0 ; int value = 0 ; for ( int bitNumber = 0 ; bitNumber < 4 ; bitNumber ++ ){ x = START_Y - 3 * ORDER -2 ; y = START_X + 8 + bitNumber * ORDER ; value = ( i >> bitNumber ) & 1 ; disp . writeSquare ( ORDER , x , y , value ); } } //This code will run only once when the Arduino is turned on. void setup (){ rtc . begin (); //Starts the library disp . begin (); //Set the LED's intensity. This value can be anywhere between 0 and 15. disp . setIntensity ( 0x01 ); if ( ADJUST_HOUR ){ rtc . adjust ( DateTime ( F ( __DATE__ ), F ( __TIME__ ))); } } //After void setup(), this code will run and loop forever. void loop (){ DateTime adesso = rtc . now (); seconds = adesso . second (); minutes = adesso . minute (); hours = adesso . hour (); seconds_unit ( seconds % 10 ); seconds_dozens ( seconds / 10 ); minutes_unit ( minutes % 10 ); minutes_dozens ( minutes / 10 ); hours_unit ( hours % 10 ); hours_dozens ( hours / 10 ); delay ( 1000 ); } RTC e display 7 segmenti 7 SEG Pins Arduino Pins VCC VCC GND GND DIN D11 CLK D13 CS D10 tutorial //We always have to include the library #include \"LedControl.h\" /* Now we need a LedControl to work with. ***** These pin numbers will probably not work with your hardware ***** pin 12 is connected to the DataIn pin 11 is connected to the CLK pin 10 is connected to LOAD We have only a single MAX72XX. */ LedControl lc = LedControl ( 12 , 11 , 10 , 1 ); /* we always wait a bit between updates of the display */ unsigned long delaytime = 500 ; void setup () { /* The MAX72XX is in power-saving mode on startup, we have to do a wakeup call */ lc . shutdown ( 0 , false ); /* Set the brightness to a medium values */ lc . setIntensity ( 0 , 8 ); /* and clear the display */ lc . clearDisplay ( 0 ); } int ore = 22 ; int minuti = 30 ; int secondi = 0 ; int centesimi = 0 ; void loop () { lc . setDigit ( 0 , 7 , ore / 10 , false ); lc . setDigit ( 0 , 6 , ore % 10 , true ); lc . setDigit ( 0 , 5 , minuti / 10 , false ); lc . setDigit ( 0 , 4 , minuti % 10 , true ); lc . setDigit ( 0 , 3 , secondi / 10 , false ); lc . setDigit ( 0 , 2 , secondi % 10 , true ); lc . setDigit ( 0 , 1 , centesimi / 10 , false ); lc . setDigit ( 0 , 0 , centesimi % 10 , false ); delay ( 10 ); centesimi ++ ; if ( centesimi == 100 ){ centesimi = 0 ; secondi ++ ; } if ( secondi == 60 ){ minuti ++ ; secondi = 0 ; } if ( minuti == 60 ){ ore ++ ; minuti = 0 ; } if ( ore == 24 ){ ore = 0 ; } } EEPROM #include <EEPROM.h> int nByte = 0 ; int value = 50 ; void setup () { Serial . begin ( 9600 ); if ( EEPROM . read ( nByte ) == 255 ){ Serial . println ( String ( String ( nByte ) + \"vuoto\" )); EEPROM . write ( nByte , value ); } else { int tempvalue = EEPROM . read ( nByte ); String toprint = String ( String ( nByte ) + \":\" + String ( tempvalue )); Serial . println ( toprint ); } } void loop () { } SLEEP MODE /** * Author:Ab Kurk * version: 1.0 * date: 24/01/2018 * Description: * This sketch is part of the beginners guide to putting your Arduino to sleep * tutorial. It is to demonstrate how to put your arduino into deep sleep and * how to wake it up. * Link To Tutorial http://www.thearduinomakerman.info/blog/2018/1/24/guide-to-arduino-sleep-mode */ #include <avr/sleep.h> //this AVR library contains the methods that controls the sleep modes #define interruptPin 2 //Pin we are going to use to wake up the Arduino void setup () { Serial . begin ( 9600 ); //Start Serial Comunication pinMode ( LED_BUILTIN , OUTPUT ); //We use the led on pin 13 to indecate when Arduino is A sleep pinMode ( interruptPin , INPUT ); //Set pin d2 to input using the buildin pullup resistor attachInterrupt ( digitalPinToInterrupt ( interruptPin ), wakeUp , RISING ); //attaching a interrupt to pin d2 digitalWrite ( LED_BUILTIN , HIGH ); //turning LED on } void loop () { delay ( 5000 ); //wait 5 seconds before going to sleep digitalWrite ( LED_BUILTIN , LOW ); //turning LED off Going_To_Sleep (); } void Going_To_Sleep (){ sleep_enable (); //Enabling sleep mode set_sleep_mode ( SLEEP_MODE_PWR_DOWN ); //Setting the sleep mode, in our case full sleep sleep_cpu (); //activating sleep mode } void wakeUp (){ Serial . println ( \"Interrrupt Fired\" ); //Print message to serial monitor sleep_disable (); //Disable sleep mode Serial . println ( \"just woke up!\" ); //next line of code executed after the interrupt digitalWrite ( LED_BUILTIN , HIGH ); //turning LED on } Contatto magnetico void setup () { pinMode ( 2 , INPUT_PULLUP ); pinMode ( LED_BUILTIN , OUTPUT ); Serial . begin ( 9600 ); } void loop () { bool v = digitalRead ( 2 ); digitalWrite ( LED_BUILTIN , ! v ); delay ( 100 ); } RTC e Display I2C In questo esempio vedremo come realizzare un orologio utilizzando il modulo RTC , un display LCD con interfaccia I2C e un tasto touch . L'orologio sar\u00e0 alimentato da una pila a 9V quindi, per evitare che si scarichi nel giro di poche ore, faremo in modo che arduino vada in sleep mode disabilitando tutte le periferiche ad esso connesso. Il tasto touch servi\u00e0 a risvegliare la arduino, il display e il modulo RTC per 10 secondi. RTC Arduino Pins VCC VCC (+5V) GND GND SDA A4 (SDA) SCL A5 (SCL) LCD Arduino Pins VCC VCC (+5V) GND GND SDA A4 (SDA) SCL A5 (SCL) #include <Wire.h> #include <avr/sleep.h> #include <LiquidCrystal_I2C.h> #include \"RTClib.h\" #define WAKEUP_PIN 2 #define RTC_LDC_PIN_POWER_SUPPLY 7 #define timeBeforeWakeUp 10000 #define refreshTime 1000 #define ON true #define OFF false enum Mesi { Jan = 1 , Feb , Mar , Apr , May , Jun , Jul , Aug , Sept , Oct , Nov , Dec }; enum Giorni { Sunday = 0 , Monday , Tuesday , Wednesay , Thursday , Friday , Saturday }; //You shall flash the sketch two time. //The first for adjust the time //The second for run arduino stand alone #define ADJUST_HOUR false DateTime dateNow = DateTime ( 2021 , May , 19 , 19 , 9 , 10 ); LiquidCrystal_I2C lcd ( 0x27 , 20 , 2 ); // set the LCD address to 0x27 for a 16 chars and 2 line display RTC_DS1307 rtc ; //add 0 if number is < 9 and return a string String fillZeros ( int n ) { return ( n < 10 ? String ( '0' + String ( n )) : String ( n )); } //receive h, m, s and return hh:mm:ss String standardTime ( int h , int m , int s ){ return ( String ( fillZeros ( h ) + ':' + fillZeros ( m ) + ':' + fillZeros ( s ))); } void setup () { pinMode ( RTC_LDC_PIN_POWER_SUPPLY , OUTPUT ); pinMode ( WAKEUP_PIN , INPUT_PULLUP ); attachInterrupt ( digitalPinToInterrupt ( WAKEUP_PIN ), mcuWakeUp , FALLING ); //attaching a interrupt to pin rtc_lcd_PowSupply ( ON ); if ( ADJUST_HOUR ){ //to set time at the compilation time //rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); rtc . adjust ( dateNow ); } } void loop () { DateTime now = rtc . now (); int year = now . year (); int month = now . month (); int day = now . day (); int dayOfTheWeek = now . dayOfTheWeek (); int seconds = now . second (); int minutes = now . minute (); int hours = now . hour (); String LCD_firstRow = \"\" ; switch ( dayOfTheWeek ){ case Sunday : LCD_firstRow = LCD_firstRow + \"Dom\" + \" \" ; break ; case Monday : LCD_firstRow = LCD_firstRow + \"Lun\" + \" \" ; break ; case Tuesday : LCD_firstRow = LCD_firstRow + \"Mar\" + \" \" ; break ; case Wednesay : LCD_firstRow = LCD_firstRow + \"Mer\" + \" \" ; break ; case Thursday : LCD_firstRow = LCD_firstRow + \"Gio\" + \" \" ; break ; case Friday : LCD_firstRow = LCD_firstRow + \"Ven\" + \" \" ; break ; case Saturday : LCD_firstRow = LCD_firstRow + \"Sab\" + \" \" ; break ; break ; default : ; } LCD_firstRow = LCD_firstRow + String ( day ) + \" \" ; switch ( month ){ case Jan : LCD_firstRow = LCD_firstRow + \"gen\" + \" \" ; break ; case Feb : LCD_firstRow = LCD_firstRow + \"gen\" + \" \" ; break ; case Mar : LCD_firstRow = LCD_firstRow + \"mar\" + \" \" ; break ; case Apr : LCD_firstRow = LCD_firstRow + \"apr\" + \" \" ; break ; case May : LCD_firstRow = LCD_firstRow + \"mag\" + \" \" ; break ; case Jun : LCD_firstRow = LCD_firstRow + \"giu\" + \" \" ; break ; case Jul : LCD_firstRow = LCD_firstRow + \"lug\" + \" \" ; break ; case Aug : LCD_firstRow = LCD_firstRow + \"ago\" + \" \" ; break ; case Sept : LCD_firstRow = LCD_firstRow + \"set\" + \" \" ; break ; case Oct : LCD_firstRow = LCD_firstRow + \"ott\" + \" \" ; break ; case Nov : LCD_firstRow = LCD_firstRow + \"nov\" + \" \" ; break ; case Dec : LCD_firstRow = LCD_firstRow + \"dic\" + \" \" ; break ; break ; default : ; } LCD_firstRow = LCD_firstRow + String ( year ); lcd . setCursor ( 0 , 0 ); lcd . print ( LCD_firstRow ); lcd . setCursor ( 0 , 1 ); lcd . print ( standardTime ( hours , minutes , seconds )); delay ( refreshTime ); static int counter = 0 ; if ( counter < timeBeforeWakeUp ){ counter += refreshTime ; } //go to sleep else { counter = 0 ; rtc_lcd_PowSupply ( OFF ); mcuGoToSleep (); //after wake up rtc_lcd_PowSupply ( ON ); } } void rtc_lcd_PowSupply ( bool isOn ){ if ( isOn ){ digitalWrite ( RTC_LDC_PIN_POWER_SUPPLY , HIGH ); lcd . init (); lcd . backlight (); lcd . setCursor ( 0 , 0 ); delay ( 100 ); rtc . begin (); } else { digitalWrite ( RTC_LDC_PIN_POWER_SUPPLY , LOW ); } } void mcuGoToSleep (){ sleep_enable (); set_sleep_mode ( SLEEP_MODE_PWR_DOWN ); sleep_cpu (); } void mcuWakeUp (){ sleep_disable (); //Disable sleep mode }","title":"Arduino"},{"location":"arduino/#arduino","text":"Arduino Lezione 01 Lezione 02 Alimentare arduino Lezione 03 Pin I/O Lezione 04 Sketch Primo sketch - LED Blink Lezione 05 PWM Lezione 06 Documentazione Linguaggio Arduino Binary Clock Collegamenti Hardware Il codice RTC e display 7 segmenti EEPROM SLEEP MODE Contatto magnetico RTC e Display I2C","title":"Arduino"},{"location":"arduino/#lezione-01","text":"Arduino \u00e8 una scheda elettronica per realizzare prototipi. Il cuore di arduino \u00e8 il microcontrollore . Il modello Arduino UNO R3 utilizza il microcontrollore Atmega328P . Un microcontrollore (in inglese microcontroller in acronimo MCU ovvero MicroController Unit), in elettronica digitale, \u00e8 un dispositivo elettronico integrato su singolo circuito elettronico, nato come evoluzione alternativa al microprocessore e utilizzato generalmente in sistemi embedded ovvero per applicazioni specifiche di controllo digitale. La scehda di Arduino, attraverso il microcontrollore, comunica con il mondo esterno attraverso i suoi PIN. Un microcontrollore in genere svolge un compito molto specifico come leggere il valore di certi sensori collegati in ingresso o settare le uscite collegate a qualche attuatore. Ci sono molti componenti elettronici interfacciabili direttamente con Arduino","title":"Lezione 01"},{"location":"arduino/#lezione-02","text":"","title":"Lezione 02"},{"location":"arduino/#alimentare-arduino","text":"Puoi alimentare Arduino con il connettore DC con una tensione nel range 6-20V Puoi inoltre utilizzare il cavo usb collegato a PC o un a un caricatore per smartphone. Il cavo USB \u00e8 inoltre indispensabile per il caricamento del programma da PC alla memoria interna del microcontrollore Puoi alimentare Arduino manualmente attraverso il pin Vin con una tensione esatta di 5V . Una volta alimentato Arduino puoi prelevare le tensioni di 5v , 3.3v e il riferimento GND dagli omonimi pin. Esiste inoltre un tasto RESET che consente il riavvio di Arduino. E' possibile inoltre riavviare Arduino attraverso il pin RESET con un apposito segnale di reset .","title":"Alimentare arduino"},{"location":"arduino/#lezione-03","text":"","title":"Lezione 03"},{"location":"arduino/#pin-io","text":"Pin Digitali Ci sono 14 PIN digitali numerati da 0 - 13 per l'interfacciamento digitale con il mondo esterno. Possono essere utili per collegare LED, tasti, display LCD, matrici di LED e molto altro. In generale \u00e8 possibile collegare ogni dispositivo digitale ovvero componenti che ricevono o trasmettono solo due possibili valori di tensione 5V , 0V . Alucuni pin sono marcati con una ~ . Sono dedicati al modulo PWM che studieremo pi\u00f9 avanti. Pin Analogici Ci sono inoltre 5 PIN numerati da 14 - 19 per l'interfacciamento con segnali analogici in ingresso come sensori di temperatura, microfoni o in generale qualsiasi segnale elettrico che varia in modo continuo nel range [0v - 5v] .","title":"Pin I/O"},{"location":"arduino/#lezione-04","text":"","title":"Lezione 04"},{"location":"arduino/#sketch","text":"Lo Sketch \u00e8 il programma, la logica. Arduino utilizza come linguaggio di programmazione il C++ ma fornisce anche delle funzioni di interfacciamento o meglio delle classi e dei metodi per l'accesso in modo semplificato all'Hardware. Per far ci\u00f2, all'accensione del microcontrollore, Arduino configura i registri interni dei moduli del microcontrollore con un settaggio standard e \"maschera\" queste operazioni all'utente finale mostrando solo due macroblocchi: setup loop In linea generale possiamo affermare che: setup: i comandi scritti all'interno di questo blocco vengono eseguiti una sola volta all'avvio di Arduino. loop i comandi scritti all'interno di questo blocco vengono eseguiti ciclicamente dopo l'avvio di Arduino fino al riavvio o spegnimento della board.","title":"Sketch"},{"location":"arduino/#driver-necessari","text":"Normalmente, installando l'IDE Arduino ti troverai installati anche tutti i driver necessari per comunicare con la scheda. Se acquisti un Arduino clone tuttavia potresti aver bisogno dei driver (per Windows) poich\u00e8 spesso i componenti hardware non sono proprio gli stessi. Da questa pagina \u00e8 possibile scaricare i driver necessari. Trovi un file eseguibile anche all'interno di questa repository al percorso files/CH341SER.EXE","title":"Driver necessari"},{"location":"arduino/#primo-sketch-led-blink","text":"Come primo Sketch vedremo come far lampeggiare un LED. Useremo il LED connesso direttamente ad arduino al pin 13 . Per far ci\u00f2 dovremo: in void setup {} : - Impostare il pin 13 come output in void loop(){} : - Scrivere il valore logico HIGH sul pin 13 per fornire 5v ed accendere il led tramite l'istruzione digitalWrite() - Inserire un ritardo che esprime il tempo in cui il pin star\u00e0 acceso con l'istruzione delay() - Scrivere il valore logico LOW sul pin 13 per togliere l'alimentazione e spegnere il led tramite l'istruzione digitalWrite() - Inserire un ritardo che esprime il tempo in cui il pin star\u00e0 spento con l'istruzione delay() Poich\u00e8 il void loop(){} esegue in loop le istruzioni, realizzerai un lampeggio del LED infinito. Il codice completo: void setup () { // initialize digital pin LED_BUILTIN as an output. pinMode ( 13 , OUTPUT ); } // the loop function runs over and over again forever void loop () { digitalWrite ( 13 , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( 13 , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } Adesso \u00e8 sufficiente: - Premere il tasto Verifica che controller\u00e0 la sintassi e ti avviser\u00e0 se hai inserito qualche comando non valido nella finestra nera in basso - Premere il tasto Esegui che andr\u00e0 a inserire il codice all'interno della memoria di Arduino e a procedere con l'esecuzione dello sketch E' possibile trovare questo sketch esempio su File/Esempi/01.Basics/Blink Apparir\u00e0 come: /* Blink Turns an LED on for one second, then off for one second, repeatedly. Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to the correct LED pin independent of which board is used. If you want to know what pin the on-board LED is connected to on your Arduino model, check the Technical Specs of your board at: https://www.arduino.cc/en/Main/Products modified 8 May 2014 by Scott Fitzgerald modified 2 Sep 2016 by Arturo Guadalupi modified 8 Sep 2016 by Colby Newman This example code is in the public domain. http://www.arduino.cc/en/Tutorial/Blink */ // the setup function runs once when you press reset or power the board void setup () { // initialize digital pin LED_BUILTIN as an output. pinMode ( LED_BUILTIN , OUTPUT ); } // the loop function runs over and over again forever void loop () { digitalWrite ( LED_BUILTIN , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( LED_BUILTIN , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } L'unica differenza che trovi \u00e8 LED_BUILTIN . E' una costante il cui valore \u00e8 pari a 13 . Il valore di tutte le costanti di Arduino le puoi trovare sulla documentazione ufficiale: Arduino - constants","title":"Primo sketch - LED Blink"},{"location":"arduino/#lezione-05","text":"","title":"Lezione 05"},{"location":"arduino/#pwm","text":"In elettronica e telecomunicazioni la modulazione di larghezza di impulso (o PWM, acronimo del corrispettivo inglese pulse-width modulation) \u00e8 un tipo di modulazione digitale che permette di ottenere una tensione media variabile dipendente dal rapporto tra la durata dell'impulso positivo e dell'intero periodo (duty cycle). Allo stesso modo, \u00e8 fondamentalmente utilizzato per protocolli di comunicazione in cui l'informazione \u00e8 codificata sotto forma di durata nel tempo di ciascun impulso. Grazie ai moderni microcontrollori, \u00e8 possibile attivare o disattivare un interruttore ad alta frequenza e allo stesso modo rilevare lo stato e il periodo di un impulso. Poich\u00e8 arduino \u00e8 alimentato a 5V se volessi ottenere un valore medio pari a 2.5V in uscita da un pin digitale dovrei generare un segnale PWM con le seguenti caratteristiche: Frequenza: fissa. Valori standard di frequenza per i segnali PWM vanno da qualche centinaia di Hz a qualche Khz . Il valore di frequenza \u00e8 stabilito internamente da Arduino quindi per adesso non dovrai preoccupartene. Duty cicle: 50% . Per impostare il duty cicle si imposta un valore nel range 0-255 all'interno della funzione analogWrite() . Attraverso la proporzione: dutyCicle% : 100% = value: 255 Poich\u00e8 vogliamo dutyCicle% = 50% , allora value = 127 Nel prossimo esempio generer\u00f2 un segnale PWM con duty cicle = 50% per controllare la luminosit\u00e0 di un LED. Per far ci\u00f2 \u00e8 necessario: - collegare un LED a un PIN qualsiasi con uscita PWM. Sono quelli identificati dal simbolo ~ . Utilizzer\u00f2 il pin 9 - chiamare il comando analogWrite() specificando come primo parametro il pin sul quale si desidera generare il segnale PWM , quindi il pin 9 e come secondo parametro il duty cicle espresso con un numero da [0 - 255] . Per ottenere un duty cicle del 50% scriver\u00f2 127 Lo sketch completo \u00e8: void setup () { } void loop () { analogWrite ( 9 , 127 ); } Arduino fornisce un esepio pi\u00f9 compelto all'interno della cartella degli esempi File/Esempi/01.Basics/Fade /* Fade This example shows how to fade an LED on pin 9 using the analogWrite() function. The analogWrite() function uses PWM, so if you want to change the pin you're using, be sure to use another PWM capable pin. On most Arduino, the PWM pins are identified with a \"~\" sign, like ~3, ~5, ~6, ~9, ~10 and ~11. This example code is in the public domain. http://www.arduino.cc/en/Tutorial/Fade */ int led = 9 ; // the PWM pin the LED is attached to int brightness = 0 ; // how bright the LED is int fadeAmount = 5 ; // how many points to fade the LED by // the setup routine runs once when you press reset: void setup () { // declare pin 9 to be an output: pinMode ( led , OUTPUT ); } // the loop routine runs over and over again forever: void loop () { // set the brightness of pin 9: analogWrite ( led , brightness ); // change the brightness for next time through the loop: brightness = brightness + fadeAmount ; // reverse the direction of the fading at the ends of the fade: if ( brightness <= 0 || brightness >= 255 ) { fadeAmount = - fadeAmount ; } // wait for 30 milliseconds to see the dimming effect delay ( 30 ); } In questo esempio il LED, connesso al PIN 9 si accender\u00e0 e si spegner\u00e0 in modo graduale. Per ottenere questo effetto si agisce su parametro che regola il duty cicle che in questo programma \u00e8 definito dalla variabile brightness . In pratica il software imposta una brightness pari a 0 aumenta la variabile brightness del valore pari a fadeAmount (impostata a 5 ) secondo l'espressione brightness = brightness + fadeAmount che diventa quindi brightness = brightness + 5 Ripete questa operazione ogni 30 millisecondi . In questo modo il LED aumenter\u00e0 la sua luminosit\u00e0 in modo graduale Una volta che brightness \u00e8 arrivata al valore massimo, brightness >= 255 , inverte il valore di fadeAmount . In questo caso quindi l'espressione diventa brightness = brightness - 5 . Ripete questa operazione ogni 30 millisecondi . Il risultato \u00e8 che il LED diminuir\u00e0 la sua luminosit\u00e0 in modo graduale. Una volta che brightness \u00e8 arrivata al valore minimo, brightness <= 0 , inverte il valore di fadeAmount . In questo caso quindi l'espressione torna a essere brightness = brightness + 5 . Ripete questa operazione ogni 30 millisecondi . E continua fino al reset di Arduino. Domanda: Quanto impiega il ciclo di accensione? vista l'espressione brightness = brightness + fadeAmount e visto il ritardo pari a 30ms , si ha che brightness passa da 0 255 in 51 step ( 255/5 ) e quindi il ciclo di accensione graduale dura 30ms*51 = 1.53 secondi . Poich\u00e8 il ciclo di spegnimento \u00e8 simmetrico, se ne deduce che il ciclo completo (accensione + spegnimento) dura poco pi\u00f9 di 3 secondi Puoi provare: Puoi provare a cambiare il ritardo di 30ms o il fadeAmount per cambiare la velocit\u00e0 di accensione/spegnimento. Puoi anche impostare un valore minimo di brightness e un valore massimo Ecco un esempio: /* Fade This example shows how to fade an LED on pin 9 using the analogWrite() function. The analogWrite() function uses PWM, so if you want to change the pin you're using, be sure to use another PWM capable pin. On most Arduino, the PWM pins are identified with a \"~\" sign, like ~3, ~5, ~6, ~9, ~10 and ~11. This example code is in the public domain. http://www.arduino.cc/en/Tutorial/Fade */ int led = 9 ; // the PWM pin the LED is attached to int brightness = 0 ; // how bright the LED is int fadeAmount = 2 ; // how many points to fade the LED by byte maxBrightness = 200 ; byte minBrightness = 10 ; // the setup routine runs once when you press reset: void setup () { // declare pin 9 to be an output: pinMode ( led , OUTPUT ); } // the loop routine runs over and over again forever: void loop () { // set the brightness of pin 9: analogWrite ( led , brightness ); // change the brightness for next time through the loop: brightness = brightness + fadeAmount ; // reverse the direction of the fading at the ends of the fade: if ( brightness <= minBrightness || brightness >= maxBrightness ) { fadeAmount = - fadeAmount ; } // wait for 3 milliseconds to see the dimming effect delay ( 1 ); } Piccolo Approfondimento - Frequenza PWM Come gi\u00e0 detto, Arduino imposta un valore di frequenza per il segnale PWM ma quale? Per Arduino UNO il valore \u00e8 490.20 Hz per i pin D3,D9, D10, D11 e il valore 976.56 Hz per i pin D5 & D6 . Cosa cambia al variare della frequenza? Provo a darti una spiegazione molto qualitativa.. IL PWM agisce sul'inerzia elettromeccanica dei componenti. Puoi intuire che abbassando la frequenza il componente possa diventare meno fluido. Se si parla di un LED, a una frequenza molto bassa vedrai lampeggiare il LED. Allo stesso tempo puoi intuire che alzando troppo la frequenza sia difficile per il componente leggere valori di duty cicle troppo piccoli. Nel caso del LED, lo vedrai sempre spento. Per determinare i valori minimi e massimi di frequenza PWM \u00e8 necessario eseguire un'analisi dei componenti capacitivi/indutti parassiti e studiare la caratteristica al variare della frequenza. Per adesso comunque ti basta sapere che in linea generale, le frequenze possono andare nei casi pi\u00f9 comuni tra [100Hz - 100Khz] . Avrai frequenze piuttosto basse se il componente ha una capacit\u00e0 di reazione lenta e frequenze pi\u00f9 alte per componenti che hanno una capacit\u00e0 di reazione alta","title":"PWM"},{"location":"arduino/#lezione-06","text":"","title":"Lezione 06"},{"location":"arduino/#documentazione-linguaggio-arduino","text":"Arduino utilizza il linguaggio C++ ma esporta una serie di funzioni molto semplici per il controllo dell'Hardware. Qui puoi trovare la documentazione ufficiale del linguaggio di Arduino. Qua sotto riporto comunque qualche costrutto fondamentale del linguaggio C++ e qualche funzione esportata da Arduino. Le variabili Tipo di Dato Dimensione Descrizione char 1 Byte Contenitore per caratteri e valori alfanumerici (e.g., \u2018a\u2019, \u2018b\u2019, \u20181\u2019, etc) bool 1 Byte Contenitore per valori booleani (e.g., true, false) int 2 Byte Contenitore per numeri interi nel range numerico, da -32768 a 32767. unsigned int 2 Byte Contenitore per numeri interi senza segno nel range numerico, da 0 a 65535. long 4 Byte Contenitore per numeri interi nel range numerico, da -2147483648 a 2147483647 unsigned long 4 Byte Contenitore per numeri interi nel range numerico, da 0 to 4,294,967,295 (2^32 \u2013 1) float 4 Byte Contenitore per numeri interi nel range numerico, da 0 to 4,294,967,295 (2^32 \u2013 1) double 4 Byte Contenitore per numeri interi nel range numerico, da 0 to 4,294,967,295 (2^32 \u2013 1) String - Contenitore per testo (e.g., \u201cResistenza\u201d)","title":"Documentazione Linguaggio Arduino"},{"location":"arduino/#binary-clock","text":"Per questo orologio binario ho utilizzato la libreria simple_matrix per la gestione della matrice di LED e la libreria RTClib per la gestione del tempo. Ho modificato la libreria simple_matrix creando una nuova versione, simple_matrix_v2 che in pi\u00f9 contiene i metodi: writeSquare(order, x, y, value) writePixel(x, y, value)","title":"Binary Clock"},{"location":"arduino/#collegamenti-hardware","text":"LED Matrix Pins Arduino Pins VCC VCC GND GND DIN D11 CLK D13 CS D4 RTC Arduino Pins VCC VCC (+5V) GND GND SDA A4 (SDA) SCL A5 (SCL)","title":"Collegamenti Hardware"},{"location":"arduino/#il-codice","text":"L'orologio binario consiste nel codificare ore, minuti e secondi con la relativa sequenza binaria. Ho deciso di codificare ogni cifra in una sequenza binaria rappresentando quindi separatamente decine e unit\u00e0 per ore, minuti e secondi. Ad esempio: 12 //decine //unit\u00e0 0001 0010 Inoltre la rappresentazione del tempo all'interno della matrice di LED va dall'alto verso il basso a partire dalle ore. In conclusione, per rappresentare la seguente ora: 21:34:46 vedrai: 21 : 34 : 46 //d //u 0010 0001 0011 0100 0100 0110 Ecco quindi il codice completo.. #include \"simple_matrix_v2.h\" //Import the library #include \"RTClib.h\" #define NUMBER_OF_DISPLAYS 2 //Sets the number of display (4 for this example) /* Initialize the library. The 4 means that the CS pin is connected to pin D4. You can change this to whatever you want, just make sure to connect the CS pin to the pin number. The disp means that any future function calls to the library uses \"disp\" as the library's object name. For example, the library has a function called \"setIntensity\", you need to write \"disp.setIntensity\" to call that function. If you notice that the display is upside-down per display, change simpleMatrix disp(4, false, NUMBER_OF_DISPLAYS); to simpleMatrix disp(4, true, NUMBER_OF_DISPLAYS); */ /* WARNING!! There are several problems with the coding of (x, y) coordinates. I advise you to change the library for the LED matrix and switch to MD_MAX72XX which is much more complete and configurable. */ simpleMatrix disp ( 4 , true , NUMBER_OF_DISPLAYS ); RTC_DS1307 rtc ; #define ORDER 2 #define START_X 0 #define START_Y 8 #define ADJUST_HOUR true int seconds = 0 ; int minutes = 0 ; int hours = 0 ; void seconds_unit ( int i ){ //If you don't understand, see WARNINGS int x = 0 ; int y = 0 ; int value = 0 ; for ( int bitNumber = 0 ; bitNumber < 4 ; bitNumber ++ ){ x = START_Y - 1 * ORDER ; y = START_X + bitNumber * ORDER ; value = ( i >> bitNumber ) & 1 ; disp . writeSquare ( ORDER , x , y , value ); } } void seconds_dozens ( int i ){ //If you don't understand, see WARNINGS int x = 0 ; int y = 0 ; int value = 0 ; for ( int bitNumber = 0 ; bitNumber < 4 ; bitNumber ++ ){ x = START_Y - 1 * ORDER ; y = START_X + 8 + bitNumber * ORDER ; value = ( i >> bitNumber ) & 1 ; disp . writeSquare ( ORDER , x , y , value ); } } void minutes_unit ( int i ){ //If you don't understand, see WARNINGS int x = 0 ; int y = 0 ; int value = 0 ; for ( int bitNumber = 0 ; bitNumber < 4 ; bitNumber ++ ){ x = START_Y - 2 * ORDER -1 ; y = START_X + bitNumber * ORDER ; value = ( i >> bitNumber ) & 1 ; disp . writeSquare ( ORDER , x , y , value ); } } void minutes_dozens ( int i ){ //If you don't understand, see WARNINGS int x = 0 ; int y = 0 ; int value = 0 ; for ( int bitNumber = 0 ; bitNumber < 4 ; bitNumber ++ ){ x = START_Y - 2 * ORDER -1 ; y = START_X + 8 + bitNumber * ORDER ; value = ( i >> bitNumber ) & 1 ; disp . writeSquare ( ORDER , x , y , value ); } } void hours_unit ( int i ){ //If you don't understand, see WARNINGS int x = 0 ; int y = 0 ; int value = 0 ; for ( int bitNumber = 0 ; bitNumber < 4 ; bitNumber ++ ){ x = START_Y - 3 * ORDER -2 ; y = START_X + bitNumber * ORDER ; value = ( i >> bitNumber ) & 1 ; disp . writeSquare ( ORDER , x , y , value ); } } void hours_dozens ( int i ){ //If you don't understand, see WARNINGS int x = 0 ; int y = 0 ; int value = 0 ; for ( int bitNumber = 0 ; bitNumber < 4 ; bitNumber ++ ){ x = START_Y - 3 * ORDER -2 ; y = START_X + 8 + bitNumber * ORDER ; value = ( i >> bitNumber ) & 1 ; disp . writeSquare ( ORDER , x , y , value ); } } //This code will run only once when the Arduino is turned on. void setup (){ rtc . begin (); //Starts the library disp . begin (); //Set the LED's intensity. This value can be anywhere between 0 and 15. disp . setIntensity ( 0x01 ); if ( ADJUST_HOUR ){ rtc . adjust ( DateTime ( F ( __DATE__ ), F ( __TIME__ ))); } } //After void setup(), this code will run and loop forever. void loop (){ DateTime adesso = rtc . now (); seconds = adesso . second (); minutes = adesso . minute (); hours = adesso . hour (); seconds_unit ( seconds % 10 ); seconds_dozens ( seconds / 10 ); minutes_unit ( minutes % 10 ); minutes_dozens ( minutes / 10 ); hours_unit ( hours % 10 ); hours_dozens ( hours / 10 ); delay ( 1000 ); }","title":"Il codice"},{"location":"arduino/#rtc-e-display-7-segmenti","text":"7 SEG Pins Arduino Pins VCC VCC GND GND DIN D11 CLK D13 CS D10 tutorial //We always have to include the library #include \"LedControl.h\" /* Now we need a LedControl to work with. ***** These pin numbers will probably not work with your hardware ***** pin 12 is connected to the DataIn pin 11 is connected to the CLK pin 10 is connected to LOAD We have only a single MAX72XX. */ LedControl lc = LedControl ( 12 , 11 , 10 , 1 ); /* we always wait a bit between updates of the display */ unsigned long delaytime = 500 ; void setup () { /* The MAX72XX is in power-saving mode on startup, we have to do a wakeup call */ lc . shutdown ( 0 , false ); /* Set the brightness to a medium values */ lc . setIntensity ( 0 , 8 ); /* and clear the display */ lc . clearDisplay ( 0 ); } int ore = 22 ; int minuti = 30 ; int secondi = 0 ; int centesimi = 0 ; void loop () { lc . setDigit ( 0 , 7 , ore / 10 , false ); lc . setDigit ( 0 , 6 , ore % 10 , true ); lc . setDigit ( 0 , 5 , minuti / 10 , false ); lc . setDigit ( 0 , 4 , minuti % 10 , true ); lc . setDigit ( 0 , 3 , secondi / 10 , false ); lc . setDigit ( 0 , 2 , secondi % 10 , true ); lc . setDigit ( 0 , 1 , centesimi / 10 , false ); lc . setDigit ( 0 , 0 , centesimi % 10 , false ); delay ( 10 ); centesimi ++ ; if ( centesimi == 100 ){ centesimi = 0 ; secondi ++ ; } if ( secondi == 60 ){ minuti ++ ; secondi = 0 ; } if ( minuti == 60 ){ ore ++ ; minuti = 0 ; } if ( ore == 24 ){ ore = 0 ; } }","title":"RTC e display 7 segmenti"},{"location":"arduino/#eeprom","text":"#include <EEPROM.h> int nByte = 0 ; int value = 50 ; void setup () { Serial . begin ( 9600 ); if ( EEPROM . read ( nByte ) == 255 ){ Serial . println ( String ( String ( nByte ) + \"vuoto\" )); EEPROM . write ( nByte , value ); } else { int tempvalue = EEPROM . read ( nByte ); String toprint = String ( String ( nByte ) + \":\" + String ( tempvalue )); Serial . println ( toprint ); } } void loop () { }","title":"EEPROM"},{"location":"arduino/#sleep-mode","text":"/** * Author:Ab Kurk * version: 1.0 * date: 24/01/2018 * Description: * This sketch is part of the beginners guide to putting your Arduino to sleep * tutorial. It is to demonstrate how to put your arduino into deep sleep and * how to wake it up. * Link To Tutorial http://www.thearduinomakerman.info/blog/2018/1/24/guide-to-arduino-sleep-mode */ #include <avr/sleep.h> //this AVR library contains the methods that controls the sleep modes #define interruptPin 2 //Pin we are going to use to wake up the Arduino void setup () { Serial . begin ( 9600 ); //Start Serial Comunication pinMode ( LED_BUILTIN , OUTPUT ); //We use the led on pin 13 to indecate when Arduino is A sleep pinMode ( interruptPin , INPUT ); //Set pin d2 to input using the buildin pullup resistor attachInterrupt ( digitalPinToInterrupt ( interruptPin ), wakeUp , RISING ); //attaching a interrupt to pin d2 digitalWrite ( LED_BUILTIN , HIGH ); //turning LED on } void loop () { delay ( 5000 ); //wait 5 seconds before going to sleep digitalWrite ( LED_BUILTIN , LOW ); //turning LED off Going_To_Sleep (); } void Going_To_Sleep (){ sleep_enable (); //Enabling sleep mode set_sleep_mode ( SLEEP_MODE_PWR_DOWN ); //Setting the sleep mode, in our case full sleep sleep_cpu (); //activating sleep mode } void wakeUp (){ Serial . println ( \"Interrrupt Fired\" ); //Print message to serial monitor sleep_disable (); //Disable sleep mode Serial . println ( \"just woke up!\" ); //next line of code executed after the interrupt digitalWrite ( LED_BUILTIN , HIGH ); //turning LED on }","title":"SLEEP MODE"},{"location":"arduino/#contatto-magnetico","text":"void setup () { pinMode ( 2 , INPUT_PULLUP ); pinMode ( LED_BUILTIN , OUTPUT ); Serial . begin ( 9600 ); } void loop () { bool v = digitalRead ( 2 ); digitalWrite ( LED_BUILTIN , ! v ); delay ( 100 ); }","title":"Contatto magnetico"},{"location":"arduino/#rtc-e-display-i2c","text":"In questo esempio vedremo come realizzare un orologio utilizzando il modulo RTC , un display LCD con interfaccia I2C e un tasto touch . L'orologio sar\u00e0 alimentato da una pila a 9V quindi, per evitare che si scarichi nel giro di poche ore, faremo in modo che arduino vada in sleep mode disabilitando tutte le periferiche ad esso connesso. Il tasto touch servi\u00e0 a risvegliare la arduino, il display e il modulo RTC per 10 secondi. RTC Arduino Pins VCC VCC (+5V) GND GND SDA A4 (SDA) SCL A5 (SCL) LCD Arduino Pins VCC VCC (+5V) GND GND SDA A4 (SDA) SCL A5 (SCL) #include <Wire.h> #include <avr/sleep.h> #include <LiquidCrystal_I2C.h> #include \"RTClib.h\" #define WAKEUP_PIN 2 #define RTC_LDC_PIN_POWER_SUPPLY 7 #define timeBeforeWakeUp 10000 #define refreshTime 1000 #define ON true #define OFF false enum Mesi { Jan = 1 , Feb , Mar , Apr , May , Jun , Jul , Aug , Sept , Oct , Nov , Dec }; enum Giorni { Sunday = 0 , Monday , Tuesday , Wednesay , Thursday , Friday , Saturday }; //You shall flash the sketch two time. //The first for adjust the time //The second for run arduino stand alone #define ADJUST_HOUR false DateTime dateNow = DateTime ( 2021 , May , 19 , 19 , 9 , 10 ); LiquidCrystal_I2C lcd ( 0x27 , 20 , 2 ); // set the LCD address to 0x27 for a 16 chars and 2 line display RTC_DS1307 rtc ; //add 0 if number is < 9 and return a string String fillZeros ( int n ) { return ( n < 10 ? String ( '0' + String ( n )) : String ( n )); } //receive h, m, s and return hh:mm:ss String standardTime ( int h , int m , int s ){ return ( String ( fillZeros ( h ) + ':' + fillZeros ( m ) + ':' + fillZeros ( s ))); } void setup () { pinMode ( RTC_LDC_PIN_POWER_SUPPLY , OUTPUT ); pinMode ( WAKEUP_PIN , INPUT_PULLUP ); attachInterrupt ( digitalPinToInterrupt ( WAKEUP_PIN ), mcuWakeUp , FALLING ); //attaching a interrupt to pin rtc_lcd_PowSupply ( ON ); if ( ADJUST_HOUR ){ //to set time at the compilation time //rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); rtc . adjust ( dateNow ); } } void loop () { DateTime now = rtc . now (); int year = now . year (); int month = now . month (); int day = now . day (); int dayOfTheWeek = now . dayOfTheWeek (); int seconds = now . second (); int minutes = now . minute (); int hours = now . hour (); String LCD_firstRow = \"\" ; switch ( dayOfTheWeek ){ case Sunday : LCD_firstRow = LCD_firstRow + \"Dom\" + \" \" ; break ; case Monday : LCD_firstRow = LCD_firstRow + \"Lun\" + \" \" ; break ; case Tuesday : LCD_firstRow = LCD_firstRow + \"Mar\" + \" \" ; break ; case Wednesay : LCD_firstRow = LCD_firstRow + \"Mer\" + \" \" ; break ; case Thursday : LCD_firstRow = LCD_firstRow + \"Gio\" + \" \" ; break ; case Friday : LCD_firstRow = LCD_firstRow + \"Ven\" + \" \" ; break ; case Saturday : LCD_firstRow = LCD_firstRow + \"Sab\" + \" \" ; break ; break ; default : ; } LCD_firstRow = LCD_firstRow + String ( day ) + \" \" ; switch ( month ){ case Jan : LCD_firstRow = LCD_firstRow + \"gen\" + \" \" ; break ; case Feb : LCD_firstRow = LCD_firstRow + \"gen\" + \" \" ; break ; case Mar : LCD_firstRow = LCD_firstRow + \"mar\" + \" \" ; break ; case Apr : LCD_firstRow = LCD_firstRow + \"apr\" + \" \" ; break ; case May : LCD_firstRow = LCD_firstRow + \"mag\" + \" \" ; break ; case Jun : LCD_firstRow = LCD_firstRow + \"giu\" + \" \" ; break ; case Jul : LCD_firstRow = LCD_firstRow + \"lug\" + \" \" ; break ; case Aug : LCD_firstRow = LCD_firstRow + \"ago\" + \" \" ; break ; case Sept : LCD_firstRow = LCD_firstRow + \"set\" + \" \" ; break ; case Oct : LCD_firstRow = LCD_firstRow + \"ott\" + \" \" ; break ; case Nov : LCD_firstRow = LCD_firstRow + \"nov\" + \" \" ; break ; case Dec : LCD_firstRow = LCD_firstRow + \"dic\" + \" \" ; break ; break ; default : ; } LCD_firstRow = LCD_firstRow + String ( year ); lcd . setCursor ( 0 , 0 ); lcd . print ( LCD_firstRow ); lcd . setCursor ( 0 , 1 ); lcd . print ( standardTime ( hours , minutes , seconds )); delay ( refreshTime ); static int counter = 0 ; if ( counter < timeBeforeWakeUp ){ counter += refreshTime ; } //go to sleep else { counter = 0 ; rtc_lcd_PowSupply ( OFF ); mcuGoToSleep (); //after wake up rtc_lcd_PowSupply ( ON ); } } void rtc_lcd_PowSupply ( bool isOn ){ if ( isOn ){ digitalWrite ( RTC_LDC_PIN_POWER_SUPPLY , HIGH ); lcd . init (); lcd . backlight (); lcd . setCursor ( 0 , 0 ); delay ( 100 ); rtc . begin (); } else { digitalWrite ( RTC_LDC_PIN_POWER_SUPPLY , LOW ); } } void mcuGoToSleep (){ sleep_enable (); set_sleep_mode ( SLEEP_MODE_PWR_DOWN ); sleep_cpu (); } void mcuWakeUp (){ sleep_disable (); //Disable sleep mode }","title":"RTC e Display I2C"},{"location":"cpp/","text":"Raccolta di esempi in C++ ordinati secondo difficolt\u00e0 Area e perimetro di un rettangolo Restituisce area e perimetro di un rettangolo dati base e altezza immessi da tastiera #include <iostream> using namespace std ; int main () { cout << \"Title: Area e perimetro di un rettangolo\" << '\\n' << \"Description: Restituisce area e perimetro di un rettangolo dati base e altezza immessi da tastiera\" << '\\n' ; double base , altezza , perimetro , area ; cout << '\\n' << \"base:\" ; cin >> base ; cout << \"altezza:\" ; cin >> altezza ; perimetro = 2 * ( base + altezza ); //Conversione implicita 2 -> 2.0 area = base * altezza ; cout << '\\n' << \"Perimetro: \" << perimetro << '\\n' << \"Area: \" << area << '\\n' ; } Da intero a decine centinaia e unita' Acquisisce un numero intero positivo minore o uguale a 999 immesso da tastiera e stampa la scomposizione in centinaia, decine, unita'. Modo 1: Uso del costrutto if ... else #include <iostream> using namespace std ; int main () { cout << \"Title: Da intero a decine centinaia e unita'\" << '\\n' << \"Description: Acquisisce un numero intero positivo minore o uguale a 999 immesso da tastiera e stampa la scomposizione in centinaia, decine, unita'\" << '\\n' ; int numero , centinaia , decine , unita ; cout << '\\n' << \"Inserisci un numero positivo minore o uguale a 999.\" << '\\n' << \"Numero:\" ; cin >> numero ; if ( ( numero < 0 ) || ( numero > 999 ) ) cout << '\\n' << \"Numero non valido\" ; else { unita = numero % 10 ; decine = ( numero / 10 ) % 10 ; centinaia = numero / 100 ; cout << '\\n' << \"centinaia:\" << centinaia << '\\n' << \"decine:\" << decine << '\\n' << \"unita':\" << unita << '\\n' ; } } Modo 2 Uso del ternary operator ... ? ... : ... #include <iostream> using namespace std ; int main () { cout << \"Title: Da intero a decine centinaia e unita'\" << '\\n' << \"Description: Acquisisce un numero intero positivo minore o uguale a 999 immesso da tastiera e stampa la scomposizione in centinaia, decine, unita'\" << '\\n' ; int numero , centinaia , decine , unita ; cout << '\\n' << \"Inserisci un numero positivo minore o uguale a 999.\" << '\\n' << \"Numero:\" ; cin >> numero ; //Forzo i numeri maggiori 999 a 999 e i numeri minori di 0 a 0. numero = ( numero > 0 ) ? ( numero < 999 ? numero : 999 ) : 0 ; unita = numero % 10 ; decine = ( numero / 10 ) % 10 ; centinaia = numero / 100 ; cout << '\\n' << \"centinaia:\" << centinaia << '\\n' << \"decine:\" << decine << '\\n' << \"unita':\" << unita ; << '\\n' ; } Negativo, nullo o positivo? Acquisisce un numero intero da tastiera e stampa se \u00e8 negativo, nullo o positivo Modo 1: Uso del costrutto if ... else #include <iostream> using namespace std ; int main () { cout << \"Title: Negativo, nullo o positivo?\" << '\\n' << \"Description: Acquisisce un numero intero da tastiera e stampa se \u00e8 negativo, nullo o positivo\" << '\\n' ; int numero ; cout << '\\n' << \"Inserisci un numero intero.\" << '\\n' << \"Numero:\" ; cin >> numero ; if ( numero < 0 ) cout << '\\n' << \"Negativo.\" ; else if ( numero == 0 ) cout << '\\n' << \"Nullo.\" ; else cout << '\\n' << \"Positivo.\" ; cout << '\\n' ; } Modo 2: Uso del ternary operator ... ? ... : ... #include <iostream> using namespace std ; int main () { cout << \"Title: Negativo, nullo o positivo?\" << '\\n' << \"Description: Acquisisce un numero intero da tastiera e stampa se \u00e8 negativo, nullo o positivo\" << '\\n' ; int numero ; cout << '\\n' << \"Inserisci un numero intero.\" << '\\n' << \"Numero:\" ; cin >> numero ; ( numero == 0 ) ? ( cout << '\\n' << \"Nullo.\" ) : ( ( numero > 0 ) ? ( cout << '\\n' << \"Positivo.\" ) : ( cout << '\\n' << \"Negativo.\" ) ); cout << '\\n' ; } Pari o Dispari? Acquisisce un numero intero da tastiera e stampa se \u00e8 pari o dispari # include <iostream> using namespace std ; int main (){ cout << \"Ttitle: Pari o dispari?\" << '\\n' << \"Description: Acquisisce un numero intero da tastiera e stampa se \u00e8 pari o dispari \\n \" ; int n ; cout << \"Inserisci un numero:\" ; cin >> n ; ( n % 2 ) ? ( cout << \"Dispari.\" ) : ( cout << \"Pari.\" ); cout << '\\n' ; } Uguali ? Acquisisce tre numeri interi da tastiera e stampa se sono uguali #include <iostream> using namespace std ; int main (){ cout << \"Title: Uguali ? \\n \" << \"Acquisisce tre numeri interi da tastiera e stampa se sono uguali \\n \" ; int n1 , n2 , n3 ; cout << \"Inserisci tre numeri interi.\" << '\\n' ; cout << '\\n' << \"n1:\" ; cin >> n1 ; cout << \"n2:\" ; cin >> n2 ; cout << \"n3:\" ; cin >> n3 ; if ( ( n1 == n2 ) && ( n2 == n3 ) ) cout << '\\n' << \"Tutti uguali.\" ; else if ( ( n1 == n2 ) || ( n1 == n3 ) || ( n2 == n3 ) ) cout << '\\n' << \"Due uguali.\" ; else cout << '\\n' << \"Diversi.\" ; cout << '\\n' ; } Da intero a carattere Acquisisce un numero intero da tastiera e lo converte in un carattere stampabile #include <iostream> using namespace std ; int main (){ cout << \"Title: Da intero a carattere \\n \" << \"Description: Acquisisce un numero intero da tastiera e lo converte in un carattere stampabile \\n \" ; int i ; cout << \"insercisci un numero:\" ; cin >> i ; //Se minore di 31 o maggiore di 127 forza a 32. i = ( ( i < 32 ) || ( i > 127 ) ) ? ( i = 32 ) : i ; cout << char ( i ); cout << '\\n' ; } Da carattere a intero Acquisisce un carattere da tastiera e lo converte nel corrispondente codice ASCII #include <iostream> using namespace std ; int main (){ cout << \"Title: Da carattere a intero \\n \" << \"Description: Acquisisce un carattere da tastiera e lo converte nel corrispondente codice ASCII \\n \" ; char c ; cout << \"Inserisci un carattere: \" ; cin >> c ; if ( ( ( c >= 'a' ) && ( c <= 'z' ) ) || ( ( c >= 'A' ) && ( c <= 'Z' ) ) ) cout << \" \\n Codisce ASCII: \" << int ( c ); else cout << \" \\n Non e' una lettera dell'alfabeto.\" ; cout << '\\n' ; } Da minuscolo a maiuscolo Acquisisce un carattere letterale minuscolo da tastiera e lo converte in un carattere letterale maiuscolo #include <iostream> using namespace std ; //0100 0000 -> MAIUSC //0110 0000 -> min //Devo mettere a 0 il quinto bit. Quindi min = (xx1x xxxx) & (1101 1111); // 1101 1111 --> = ~(1<<5) // ATT: // 1<<5 = 0010 0000 // ~(1<<5) = 1101 1111 int main () { cout << \"Title: Da minuscolo a maiuscolo \\n \" << \"Description: Acquisisce un carattere letterale minuscolo da tastiera e lo converte in un carattere letterale maiuscolo \\n \" ; char c ; cout << \"Inserisci un carattere minuscolo: \" ; cin >> c ; c &= ~ ( 1 << 5 ); cout << \"Il carattere maiuscolo e': \" << c ; cout << '\\n' ; } Da maiuscolo a minuscolo Acquisisce un carattere letterale maiuscolo da tastiera e lo converte in un carattere letterale minuscolo #include <iostream> using namespace std ; //0100 0000 -> MAIUSC //0110 0000 -> min //Devo mettere a 1 il quinto bit. Quindi min = (xx1x xxxx) | (0010 0000); // 0010 0000 --> = (1<<5) int main () { cout << \"Title: Da maiuscolo a minuscolo \\n \" << \"Description: Acquisisce un carattere letterale maiuscolo da tastiera e lo converte in un carattere letterale minuscolo \\n \" ; char c ; cout << \"Inserisci un carattere MAIUSCOLO: \" ; cin >> c ; c |= ( 1 << 5 ); cout << \"Il carattere minuscolo e': \" << c ; cout << '\\n' ; } Da minuscolo a maiuscolo e viceversa Acquisisce un carattere letterale da tastiera e: - Lo converte in maiuscolo se \u00e8 minuscolo - Lo converte in minuscolo se \u00e8 maiuscolo - Restituisce il carattere se non \u00e8 una lettera #include <iostream> using namespace std ; //010x xxxx -> MAIUSC //011x xxxx -> minusc //La lettera 'k' differisce di 2^5 rispetto alla lettera 'K' //Calcolo 'a' - 'A' int main (){ cout << \"Title: Da minuscolo a maiuscolo e viceversa \\n \" << \"Description: Acquisisce un carattere letterale da tastiera e: \\n \" << \"- Lo converte in maiuscolo se \u00e8 minuscolo \\n \" << \"- Lo converte in minuscolo se \u00e8 maiuscolo \\n \" << \"- Restituisce il carattere se non \u00e8 una lettera \\n \" ; char c ; cout << \"Inserisci un carattere: \" ; cin >> c ; const int t = 'a' - 'A' ; //Costante di conversione min<->MAIUSC if ( c >= 'a' && c <= 'z' ){ c -= t ; //Trasformo min->MAIUSC cout << \"Il carattere maiuscolo e': \" << c ; } else if ( c >= 'A' && c <= 'Z' ){ c += t ; //Trasformo MAIUSC-min cout << \"Il carattere minuscolo e': \" << c ; } else cout << \"Il carattere inserito e': \" << c ; cout << '\\n' ; } Risolvi equazioni di II grado Calcola i risultati di un equazione di secondo grado del tipo: ax^2 + bx + c = 0 Inserendo da tastiera i valori dei coefficienti a , b , c #include <iostream> #include <cmath> using namespace std ; int main (){ cout << \"Ttile: Risolvi equazioni di II grado \\n \" << \"Description: Calcola i risultati di un equazione di secondo grado del tipo: \\n \" << \"ax^2 + bx +c = 0 \\n \" << \"Inserendo da tastiera i valori dei coefficienti a, b, c \\n \" ; double a , b , c , x1 , x2 , delta ; cout << \" \\n Inserisci i coefficienti a, b, c. \\n\\n \" ; cout << \"a:\" ; cin >> a ; cout << \"b:\" ; cin >> b ; cout << \"c:\" ; cin >> c ; if ( ( a == 0 ) && ( b == 0 ) && ( c == 0 ) ) cout << \" \\n Equazione DEGENERE.\" ; else if ( ( a == 0 ) && ( b == 0 ) ) cout << \" \\n Equazione IMPOSSIBILE.\" ; else if ( a == 0 ) { cout << \" \\n Equazione di PRIMO grado.\" ; x1 = - b / c ; cout << \" \\n x=\" << x1 ; } else { delta = b * b - 4 * a * c ; if ( delta < 0 ) cout << \" \\n x1, x2, soluzioni immaginarie. \\n \" ; else if ( delta == 0 ) { x1 = - b / ( 2 * a ); cout << \" \\n x1=x2=\" << x1 ; } else { cout << \" \\n Soluzioni reali e distinte. \\n \" ; x1 = ( - b + sqrt ( delta ) ) / ( 2 * a ); x2 = ( - b - sqrt ( delta ) ) / ( 2 * a ); cout << \" \\n x1:\" << x1 << \" \\n x2:\" << x2 ; } } cout << '\\n' ; } Conta dispari da sequenza illimitata Conta i numeri dispari inseriti da tastiera. Termina al primo negativo o nullo Modo 1: Uso del ciclo while() #include <iostream> using namespace std ; /* NOTA: - Lo statemeant: conta += n%2; - Equivake a: conta = conta + n%2; - Equivale a: if ( n%2 ) conta++; */ int main (){ cout << \"Title: Conta dispari\" << \"Description: Conta i numeri dispari inseriti da tastiera. Termina al primo negativo o nullo. \\n \" ; int n , conta = 0 ; cout << \"n: \" ; cin >> n ; while ( n > 0 ){ conta += n % 2 ; cout << \"n: \" ; cin >> n ; } cout << conta ; cout << '\\n' ; } Modo 2: Uso del ciclo for(;;) #include <iostream> using namespace std ; /* NOTA: - Lo statemeant: conta += n%2; - Equivake a: conta = conta + n%2; - Equivale a: if ( n%2 ) conta++; */ int main (){ cout << \"Title: Conta dispari \\n \" << \"Description: Conta i numeri dispari inseriti da tastiera. Termina al primo negativo o nullo. \\n \" ; int n , conta = 0 ; cout << \"n: \" ; cin >> n ; for (;;) { if ( n > 0 ) { conta += n % 2 ; cout << \"n: \" ; cin >> n ; } else break ; } cout << conta ; cout << '\\n' ; } Stampa cifre Stampa le cifre di un numero intero inserito da tastiera a partire da quella meno significativa. #include <iostream> using namespace std ; int main (){ cout << \"Title: Stampa cifre \\n \" << \"Description: Stampa le cifre di un numero intero inserito da tastiera a partire da quella meno significativa. \\n \" ; int n ; cout << \"Inserisci un numero intero \\n \" ; cin >> n ; n = ( n > 0 ) ? n : - n ; cout << \"Cifre: \\n \" ; do { cout << '>' << n % 10 << '\\n' ; n /= 10 ; } while ( n > 0 ); cout << '\\n' ; } Tavola pitagorica Costruisce la tavola pitagorica dato l'ordine \"n\" immesso da tastiera. #include <iostream> using namespace std ; int main (){ cout << \"Title: Tavola pitagorica\" << \"Description: Costruisce la tavola pitagorica dato l'ordine 'n' immesso da tastiera. \\n \" ; int n ; cout << \"Inserisci l'ordine 'n' della tavola pitagorica:\" ; cin >> n ; cout << '\\n' ; n = n < 1 ? 1 : n ; for ( int i = 1 ; i <= n ; i ++ ){ for ( int j = 1 ; j <= n ; j ++ ) cout << i * j << '\\t' ; cout << \" \\n\\n\\n \" ; } cout << '\\n' ; } Conta dispari da sequenza limitata Riceve una sequenza di numeri da tastiera e conta i dispari. Termina anche se un numero inserito \u00e8 nullo o negativo #include <iostream> using namespace std ; int main (){ cout << \"Title: Conta dispari da sequenza limitata\" << \"Description: Riceve una sequenza di numeri da tastiera e conta i dispari. Termina anche se un numero inserito \u00e8 nullo o negativo \\n \" ; int M , n , conta = 0 ; cout << \"Inserisci il numero di elementi della sequenza:\" ; cin >> M ; cout << \" \\n Inserisci la sequenza: \\n \" ; cin >> n ; conta += n % 2 ; for ( int i = 1 ; ( i < M ) && ( n > 0 ); i ++ ){ cin >> n ; conta += n % 2 ; } cout << \" \\n I numeri dispari della sequenza sono:\" << conta ; cout << '\\n' ; } Sequenza crescente, decrescente o non ordinata? Riceve da tastiera una sequenza di numeri interi e calcola se la sequenza \u00e8 ordinata in modo crescente, decrescente o non ordinata #include <iostream> using namespace std ; int main (){ cout << \"Title: Sequenza crescente, decrescente o non ordinata? \\n \" << \"Description: Riceve da tastiera una sequenza di numeri interi e calcola se la sequenza \u00e8 ordinata in modo crescente, decrescente o non ordinata \\n \" ; int n , n1 , n2 , crescente = 0 , decrescente = 0 , uguale = 0 ; cout << \"Immetti la Lunghezza della sequenza numerica:\" ; cin >> n ; cout << \" \\n Immetti la sequenza: \\n \" ; cin >> n1 ; for ( int i = 1 ; ( i < n ) ; i ++ ){ cin >> n2 ; crescente += n2 > n1 ; decrescente += n2 < n1 ; uguale += n2 == n1 ; n1 = n2 ; } if ( crescente == n -1 ) cout << \"CRESCENTE\" ; else if ( decrescente == n -1 ) cout << \"DECRESCENTE\" ; else if ( uguale == n -1 ) cout << \"UGUALE.\" ; else cout << \"NON ORDINATA.\" ; cout << '\\n' ; } Vettore palindromo Calcola se il vettore immesso da tastiera \u00e8 palindromo #include <iostream> using namespace std ; void riempi ( int * , int ); void stampa ( int * , int ); int palindromo ( int * , int ); int main (){ cout << \"Title: Vettore palindromo\" << \"Description: Calcola se il vettore immesso da tastiera \u00e8 palindromo \\n \" ; int nElem ; cout << \"Dimensione del vettore: \" ; cin >> nElem ; nElem = ( nElem < 1 ) ? 1 : nElem ; int * vett = new int [ nElem ]; riempi ( vett , nElem ); stampa ( vett , nElem ); if ( palindromo ( vett , nElem ) ) cout << \"Vettore palindromo.\" ; else cout << \"Vettore non palindromo.\" ; cout << '\\n' ; } void riempi ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ){ cout << \"Elemento \" << i + 1 << \": \" ; cin >> v [ i ]; //v[i] = *(v+i) } } void stampa ( int * v , int n ){ cout << \" \\n [\" << n << \"] <\" << v [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) cout << \", \" << v [ i ]; //v[i] = *(v+i) cout << \"> \\n \" ; } int palindromo ( int * v , int n ){ for ( int i = 0 , j = n -1 ; i < j ; i ++ , j -- ){ if ( v [ i ] != v [ j ] ) //v[i] != v[j] -> *(v+i) != *(v+j) return 0 ; } return 1 ; } Conta ricorrenza numerica Conta la ricorrenza delle cifre 0-9 presenti nella sequenza inserita da tastiera #include <iostream> using namespace std ; void azzera ( int * , int ); void conta ( int * , int ); void stampa ( int * , int ); int main (){ cout << \"Title: Conta ricorrenza numerica \\n \" << \"Description: Conta la ricorrenza delle cifre 0-9 presenti nella sequenza inserita da tastiera. \\n \" ; int LunghSeq , nElem = 10 ; int vettConta [ nElem ]; //Vettore conteggio cifre. azzera ( vettConta , nElem ); cout << \"Lunghezza sequenza: \" ; cin >> LunghSeq ; cout << \"Inserisci la sequenza: \\n \" ; conta ( vettConta , LunghSeq ); stampa ( vettConta , nElem ); cout << '\\n' ; } void azzera ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ) v [ i ] = 0 ; } void conta ( int * v , int l ){ int num ; for ( int i = 0 ; i < l ; i ++ ){ cin >> num ; num = ( num >= 0 ) ? num : - num ; //Controllo sul segno. do { v [ num % 10 ] ++ ; num = num / 10 ; } while ( num > 0 ); } } void stampa ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ) cout << '\\n' << i << ':' << v [ i ]; cout << '\\n' ; } Conta ricorrenza letterale Conta la ricorrenza delle lettere contenute in una stringa - I caratteri non alfabetici vengono ignorati - Le maiuscole sono considerate muinuscole #include <iostream> using namespace std ; void azzera ( int * , int ); void contaLettere ( char * , int * ); void stampaLettere ( int * , int ); int main (){ cout << \"Title: Conta ricorrenza letterale \\n \" cout << \"Description Conta la ricorrenza delle lettere contenute in una stringa \\n \" << \"- I caratteri non alfabetici vengono ignorati \\n \" << \"- Le maiuscole sono considerate muinuscole \\n \" ; char stringa [ 100 ]; const int lettere = 26 ; int vettConta [ lettere ]; cout << \"Inserisci la stringa:\" ; cin >> stringa ; azzera ( vettConta , lettere ); contaLettere ( stringa , vettConta ); stampaLettere ( vettConta , lettere ); cout << '\\n' ; } void azzera ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ) v [ i ] = 0 ; } void contaLettere ( char * str , int * c ){ for ( int i = 0 ; str [ i ] != '\\0' ; i ++ ){ if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) c [ str [ i ] - 'a' ] ++ ; else if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) c [ str [ i ] - 'A' ] ++ ; } } void stampaLettere ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ) cout << '\\n' << char ( 'a' + i ) << ':' << v [ i ]; } Segno elementi di un vettore Stampa il segno degli elementi di un vettore. #include <iostream> using namespace std ; int main (){ cout << \"Title: Segno elementi di un vettore \\n \" << \"Description: Stampa il segno degli elementi di un vettore \\n \" ; int nElem , pos = 0 , null = 0 , neg = 0 ; cout << \"Inserisci nElem: \" ; cin >> nElem ; nElem = ( nElem > 0 ) ? nElem : 1 ; int * vett = new int [ nElem ]; for ( int i = 0 ; i < nElem ; i ++ ){ cout << \"Elemento \" << i + 1 << ':' ; cin >> vett [ i ]; } for ( int i = 0 ; i < nElem ; i ++ ){ if ( vett [ i ] > 0 ) pos ++ ; else if ( vett [ i ] == 0 ) null ++ ; else neg ++ ; } cout << \" \\n Pos: \" << pos << \" \\n Null: \" << null << \" \\n Neg: \" << neg ; cout << '\\n' ; } Vettore - elementi dispari, nulli o pari? Acquisisce un vettore da tastiera e restituisce il numero degli elementi dispari, nulli e pari in un vettore #include <iostream> using namespace std ; void leggi ( int * , int ); int dzp ( int , int * , int ); int main (){ cout << \"Title: Vettore - elementi dispari, nulli o pari? \\n \" << \"Description: Acquisisce un vettore da tastiera Stampa il numero degli elementi dispari, nulli e pari in un vettore \\n \" ; int nElem , selettore ; cout << \"Inserisci il numero di elementi del vettore, nElem: \" ; cin >> nElem ; nElem = nElem > 1 ? nElem : 1 ; //Riempi vettore cout << '\\n' ; int * vett = new int [ nElem ]; leggi ( vett , nElem ); //Stampa il numero di elementi dispari selettore = -1 ; cout << \" \\n Dispari: \" << dzp ( selettore , vett , nElem ); //Stampa il numero di elementi nulli selettore = 0 ; cout << \" \\n Nulli: \" << dzp ( selettore , vett , nElem ); //Stampa il numero di elementi pari selettore = 1 ; cout << \" \\n Pari: \" << dzp ( selettore , vett , nElem ); char c ; cout << '\\n' << \"Comando?: (d = dispari, n = nulli, p = pari)\" ; cin >> c ; switch ( c ){ case 'd' : cout << \" \\n Dispari: \" << dzp ( -1 , vett , nElem ); break ; case 'n' : cout << \" \\n Nulli: \" << dzp ( 0 , vett , nElem ); break ; case 'p' : cout << \" \\n Dispari: \" << dzp ( 1 , vett , nElem ); break ; default : cout << \"!!!\" ; } cout << '\\n' ; } void leggi ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ){ cout << \"Elemento \" << i + 1 << ':' ; cin >> v [ i ]; } } int dzp ( int sel , int * v , int n ){ int conta = 0 ; switch ( sel ){ case -1 : for ( int i = 0 ; i < n ; i ++ ){ v [ i ] = v [ i ] < 0 ? - v [ i ] : v [ i ]; //NECESSARIO!! conta += v [ i ] % 2 ; } break ; case 0 : for ( int i = 0 ; i < n ; i ++ ){ v [ i ] = v [ i ] < 0 ? - v [ i ] : v [ i ]; //NECESSARIO!! conta += ( v [ i ] == 0 ); } break ; case 1 : for ( int i = 0 ; i < n ; i ++ ){ v [ i ] = v [ i ] < 0 ? - v [ i ] : v [ i ]; //NECESSARIO!! conta += ! ( v [ i ] % 2 || v [ i ] == 0 ); } break ; } return conta ; } Vettore - elementi ordinati? Acquisisce un vettore da tastiera e restitusice se gli elementi sono in ordine crescente, descrescente o non ordinati #include <iostream> using namespace std ; void leggi ( int * , int ); int ordinato ( int * , int ); void stampa ( int ); int main (){ cout << \"Title: Vettore - elementi ordinati? \\n \" << \"Description: Acquisisce un vettore da tastiera e restitusice se gli elementi sono in ordine crescente, descrescente o non ordinati \\n \" ; int nElem ; cout << \"nElem: \" ; cin >> nElem ; int * vett = new int [ nElem ]; leggi ( vett , nElem ); stampa ( ordinato ( vett , nElem ) ); cout << '\\n' ; } void leggi ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ){ cout << \"El \" << i + 1 << ':' ; cin >> v [ i ]; } } int ordinato ( int * v , int n ){ int decrescente = 1 ; int crescente = 1 ; int uguale = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ){ decrescente &= v [ i ] > v [ i + 1 ]; crescente &= v [ i ] < v [ i + 1 ]; uguale &= v [ i ] == v [ i + 1 ]; } if ( decrescente ) return -1 ; if ( uguale ) return 0 ; if ( crescente ) return + 1 ; return + 2 ; } void stampa ( int ord ){ switch ( ord ){ case -1 : cout << \" \\n Vettore ordinato in senso decrescente.\" ; break ; case 0 : cout << \" \\n Elementi del vettore uguali.\" ; break ; case + 1 : cout << \" \\n Vettore ordinato in senso crescente.\" ; break ; case + 2 : cout << \" \\n Elementi del vettore non ordinati.\" ; } } Buffer circolare Inizializza un buffer circolare di una dimensione impostata da tastiera. Sono disponibili i comandi: - i : inserisci, inscerisce un elemento nel buffer - e : estrai, estrai il primo elemento dal buffer in modoalit\u00e0 LIFO (last input, first output) - < : termina #include <iostream> using namespace std ; // 'in' e 'out' devono essere inizialmente sovrapposti. // 'in' e 'out' sono INDICI. // COMANDO : // i = inserisci // e = estrai struct buffer { int dimensione ; int in ; int out ; int nElem ; int * pHEAP ; }; void inizializza ( buffer & buf , int dim ); int inserisci ( buffer & buf , int val ); int estrai ( buffer & buf , int & val ); int main () { cout << \"Title: Buffer circolare \\n \" << \"Description: Inizializza un buffer circolare di una dimensione impostata da tastiera. \\n \" << \"Sono disponibili i comandi: \\n \" << \"- 'i': inserisci, inscerisce un elemento nel buffer \\n \" << \"- 'e': estrai, estrai il primo elemento dal buffer in modoalit\u00e0 LIFO (last input, first output) \\n \" << \"- '<': termina \\n \" buffer b1 ; int dim , val ; char c ; cout << \"Inizializza il buffer. \\n \" << \"Dimensione:\" ; cin >> dim ; inizializza ( b1 , dim ); cout << \" \\n Inserisci un comando. \\n \" << \"i -> inserisci. \\n \" << \"e -> estrai. \\n \" << \"< -> termina. \\n \" ; for (;;){ cout << \" \\n\\n Comando?? \" ; cin >> c ; if ( c == '<' ) break ; switch ( c ){ case 'i' : { int i ; cout << \" \\n Immetti un valore:\" ; cin >> val ; i = inserisci ( b1 , val ); if ( ! i ) cout << \" \\n\\n BUFFER PIENO. \\n \" ; break ; } case 'e' : { int i ; i = estrai ( b1 , val ); if ( ! i ){ cout << \" \\n\\n BUFFER VUOTO. \\n \" ; break ; } else { cout << \" \\n L'elemento vale: \" << val ; break ; } } default : break ; } } cout << '\\n' ; } void inizializza ( buffer & buf , int dim ){ buf . in = 0 ; buf . out = 0 ; buf . nElem = 0 ; buf . dimensione = dim > 0 ? dim : 1 ; buf . pHEAP = new int [ buf . dimensione ]; } int inserisci ( buffer & buf , int val ){ // Controllo se e' pieno. if ( buf . nElem >= buf . dimensione ){ return 0 ; } // Inserisco l'elemento nel primo posto vuoto. buf . pHEAP [ buf . in ++ ] = val ; buf . in = buf . in == buf . dimensione ? 0 : buf . in ; buf . nElem ++ ; return 1 ; } int estrai ( buffer & buf , int & val ){ if ( buf . nElem <= 0 ) return 0 ; val = buf . pHEAP [ buf . out ++ ]; buf . out = buf . out == buf . dimensione ? 0 : buf . out ; buf . nElem -- ; return 1 ; } Contenitore Inizializza due contenitori di una dimensione impostata da tastiera contenenti lettere. Sono disponibili i seguenti comandi: i : inizializza, inizializza un contenitore > : inserisci, iscerisce un elemento immesso da tastiera nel contenitore < : estrai, estrae un elmento da un contenitore u : Ritorna un contenitore con gli elementi a comune d : Ritorna un contenitore con gli elementi diversi #include <iostream> using namespace std ; struct contenitore { int nElem ; int cap ; int ee [ 26 ]; }; void inizializza ( contenitore & c , int N ){ N = N > 1 ? N : 1 ; c . cap = N ; for ( int i = 0 ; i < 26 ; i ++ ) c . ee [ i ] = 0 ; c . nElem = 0 ; } void inserisci ( contenitore & c , char p ){ if ( c . nElem >= c . cap || p < 'a' || p > 'z' ) return ; c . ee [ p - 'a' ] ++ ; c . nElem ++ ; } void estrai ( contenitore & c , char p ){ if ( p < 'a' || p > 'z' ) return ; c . nElem -= c . ee [ p - 'a' ]; c . ee [ p - 'a' ] = 0 ; } void scrivi ( contenitore & c ){ cout << '<' ; if ( c . ee [ 0 ] > 0 ) cout << 'a' << \": \" << c . ee [ 0 ]; for ( int i = 1 ; i < 25 ; i ++ ){ if ( c . ee [ i ] == 0 ) continue ; cout << \", \" << char ( 'a' + i ) << \": \" << c . ee [ i ]; } cout << '>' ; } contenitore cambiaCapienza ( const contenitore & c , int N ){ if ( N < c . nElem ) return c ; contenitore t ; t = c ; t . cap = N ; return t ; } contenitore diversiE ( const contenitore & c1 , const contenitore & c2 ){ contenitore c3 ; int N ; N = ( c1 . cap <= c2 . cap ) ? c1 . cap : c2 . cap ; inizializza ( c3 , N ); for ( int i = 0 ; i < 26 ; i ++ ){ if ( c1 . ee [ i ] == 0 || c2 . ee [ i ] == 0 ) continue ; c3 . ee [ i ] = 1 ; c3 . nElem ++ ; } } contenitore diversiN ( const contenitore & c1 , const contenitore & c2 ){ contenitore c3 ; int N ; inizializza ( c3 , c1 . cap ); for ( int i = 0 ; i < 26 ; i ++ ){ if ( c1 . ee [ i ] > 0 || c2 . ee [ i ] == 0 ){ c3 . ee [ i ] = 1 ; c3 . nElem ++ ; } } return c3 ; } int capienza ( const contenitore c ){ return c . cap ; } int quanti ( const contenitore c ) { return c . nElem ; } int main (){ cout << \"Title: Buffer \\n \" << \"Description: Inizializza due contenitori di una dimensione impostata da tastiera contenenti lettere. \\n \" << \"Sono disponibili i seguenti comandi: \\n \" << \"- `i`: inizializza, inizializza un contenitore \\n \" << \"- `>`: inserisci, iscerisce un elemento immesso da tastiera nel contenitore \\n \" << \"- `<`: estrai, estrae un elmento da un contenitore \\n \" << \"- `u`: Ritorna un contenitore con gli elementi a comune \\n \" << \"- `d`: Ritorna un contenitore con gli elementi diversi \\n \" /* contenitore c1, c2; cout << \"\\n\\n\" << \"i: inizializza.\\n\" << \">: inserisci.\\n\" << \"<: estrai.\\n\" << \"c: cambia capienaza.\\n\" << \"u: Ritorna un contenitore con gli elementi a comune.\\n\" << \"d: Ritorna un contenitore con elementi diversi\" << \"q:\" int capienza; int c; cout << \"Inserisci capienza: \"; cin >> capienza; */ contenitore c1 ; inizializza ( c1 , 5 ); inserisci ( c1 , 'a' ); inserisci ( c1 , 'b' ); inserisci ( c1 , 'a' ); inserisci ( c1 , 'a' ); inserisci ( c1 , 'd' ); scrivi ( c1 ); cout << '\\n' ; }","title":"C++ per esempi"},{"location":"cpp/#area-e-perimetro-di-un-rettangolo","text":"Restituisce area e perimetro di un rettangolo dati base e altezza immessi da tastiera #include <iostream> using namespace std ; int main () { cout << \"Title: Area e perimetro di un rettangolo\" << '\\n' << \"Description: Restituisce area e perimetro di un rettangolo dati base e altezza immessi da tastiera\" << '\\n' ; double base , altezza , perimetro , area ; cout << '\\n' << \"base:\" ; cin >> base ; cout << \"altezza:\" ; cin >> altezza ; perimetro = 2 * ( base + altezza ); //Conversione implicita 2 -> 2.0 area = base * altezza ; cout << '\\n' << \"Perimetro: \" << perimetro << '\\n' << \"Area: \" << area << '\\n' ; }","title":"Area e perimetro di un rettangolo"},{"location":"cpp/#da-intero-a-decine-centinaia-e-unita","text":"Acquisisce un numero intero positivo minore o uguale a 999 immesso da tastiera e stampa la scomposizione in centinaia, decine, unita'. Modo 1: Uso del costrutto if ... else #include <iostream> using namespace std ; int main () { cout << \"Title: Da intero a decine centinaia e unita'\" << '\\n' << \"Description: Acquisisce un numero intero positivo minore o uguale a 999 immesso da tastiera e stampa la scomposizione in centinaia, decine, unita'\" << '\\n' ; int numero , centinaia , decine , unita ; cout << '\\n' << \"Inserisci un numero positivo minore o uguale a 999.\" << '\\n' << \"Numero:\" ; cin >> numero ; if ( ( numero < 0 ) || ( numero > 999 ) ) cout << '\\n' << \"Numero non valido\" ; else { unita = numero % 10 ; decine = ( numero / 10 ) % 10 ; centinaia = numero / 100 ; cout << '\\n' << \"centinaia:\" << centinaia << '\\n' << \"decine:\" << decine << '\\n' << \"unita':\" << unita << '\\n' ; } } Modo 2 Uso del ternary operator ... ? ... : ... #include <iostream> using namespace std ; int main () { cout << \"Title: Da intero a decine centinaia e unita'\" << '\\n' << \"Description: Acquisisce un numero intero positivo minore o uguale a 999 immesso da tastiera e stampa la scomposizione in centinaia, decine, unita'\" << '\\n' ; int numero , centinaia , decine , unita ; cout << '\\n' << \"Inserisci un numero positivo minore o uguale a 999.\" << '\\n' << \"Numero:\" ; cin >> numero ; //Forzo i numeri maggiori 999 a 999 e i numeri minori di 0 a 0. numero = ( numero > 0 ) ? ( numero < 999 ? numero : 999 ) : 0 ; unita = numero % 10 ; decine = ( numero / 10 ) % 10 ; centinaia = numero / 100 ; cout << '\\n' << \"centinaia:\" << centinaia << '\\n' << \"decine:\" << decine << '\\n' << \"unita':\" << unita ; << '\\n' ; }","title":"Da intero a decine centinaia e unita'"},{"location":"cpp/#negativo-nullo-o-positivo","text":"Acquisisce un numero intero da tastiera e stampa se \u00e8 negativo, nullo o positivo Modo 1: Uso del costrutto if ... else #include <iostream> using namespace std ; int main () { cout << \"Title: Negativo, nullo o positivo?\" << '\\n' << \"Description: Acquisisce un numero intero da tastiera e stampa se \u00e8 negativo, nullo o positivo\" << '\\n' ; int numero ; cout << '\\n' << \"Inserisci un numero intero.\" << '\\n' << \"Numero:\" ; cin >> numero ; if ( numero < 0 ) cout << '\\n' << \"Negativo.\" ; else if ( numero == 0 ) cout << '\\n' << \"Nullo.\" ; else cout << '\\n' << \"Positivo.\" ; cout << '\\n' ; } Modo 2: Uso del ternary operator ... ? ... : ... #include <iostream> using namespace std ; int main () { cout << \"Title: Negativo, nullo o positivo?\" << '\\n' << \"Description: Acquisisce un numero intero da tastiera e stampa se \u00e8 negativo, nullo o positivo\" << '\\n' ; int numero ; cout << '\\n' << \"Inserisci un numero intero.\" << '\\n' << \"Numero:\" ; cin >> numero ; ( numero == 0 ) ? ( cout << '\\n' << \"Nullo.\" ) : ( ( numero > 0 ) ? ( cout << '\\n' << \"Positivo.\" ) : ( cout << '\\n' << \"Negativo.\" ) ); cout << '\\n' ; }","title":"Negativo, nullo o positivo?"},{"location":"cpp/#pari-o-dispari","text":"Acquisisce un numero intero da tastiera e stampa se \u00e8 pari o dispari # include <iostream> using namespace std ; int main (){ cout << \"Ttitle: Pari o dispari?\" << '\\n' << \"Description: Acquisisce un numero intero da tastiera e stampa se \u00e8 pari o dispari \\n \" ; int n ; cout << \"Inserisci un numero:\" ; cin >> n ; ( n % 2 ) ? ( cout << \"Dispari.\" ) : ( cout << \"Pari.\" ); cout << '\\n' ; }","title":"Pari o Dispari?"},{"location":"cpp/#uguali","text":"Acquisisce tre numeri interi da tastiera e stampa se sono uguali #include <iostream> using namespace std ; int main (){ cout << \"Title: Uguali ? \\n \" << \"Acquisisce tre numeri interi da tastiera e stampa se sono uguali \\n \" ; int n1 , n2 , n3 ; cout << \"Inserisci tre numeri interi.\" << '\\n' ; cout << '\\n' << \"n1:\" ; cin >> n1 ; cout << \"n2:\" ; cin >> n2 ; cout << \"n3:\" ; cin >> n3 ; if ( ( n1 == n2 ) && ( n2 == n3 ) ) cout << '\\n' << \"Tutti uguali.\" ; else if ( ( n1 == n2 ) || ( n1 == n3 ) || ( n2 == n3 ) ) cout << '\\n' << \"Due uguali.\" ; else cout << '\\n' << \"Diversi.\" ; cout << '\\n' ; }","title":"Uguali ?"},{"location":"cpp/#da-intero-a-carattere","text":"Acquisisce un numero intero da tastiera e lo converte in un carattere stampabile #include <iostream> using namespace std ; int main (){ cout << \"Title: Da intero a carattere \\n \" << \"Description: Acquisisce un numero intero da tastiera e lo converte in un carattere stampabile \\n \" ; int i ; cout << \"insercisci un numero:\" ; cin >> i ; //Se minore di 31 o maggiore di 127 forza a 32. i = ( ( i < 32 ) || ( i > 127 ) ) ? ( i = 32 ) : i ; cout << char ( i ); cout << '\\n' ; }","title":"Da intero a carattere"},{"location":"cpp/#da-carattere-a-intero","text":"Acquisisce un carattere da tastiera e lo converte nel corrispondente codice ASCII #include <iostream> using namespace std ; int main (){ cout << \"Title: Da carattere a intero \\n \" << \"Description: Acquisisce un carattere da tastiera e lo converte nel corrispondente codice ASCII \\n \" ; char c ; cout << \"Inserisci un carattere: \" ; cin >> c ; if ( ( ( c >= 'a' ) && ( c <= 'z' ) ) || ( ( c >= 'A' ) && ( c <= 'Z' ) ) ) cout << \" \\n Codisce ASCII: \" << int ( c ); else cout << \" \\n Non e' una lettera dell'alfabeto.\" ; cout << '\\n' ; }","title":"Da carattere a intero"},{"location":"cpp/#da-minuscolo-a-maiuscolo","text":"Acquisisce un carattere letterale minuscolo da tastiera e lo converte in un carattere letterale maiuscolo #include <iostream> using namespace std ; //0100 0000 -> MAIUSC //0110 0000 -> min //Devo mettere a 0 il quinto bit. Quindi min = (xx1x xxxx) & (1101 1111); // 1101 1111 --> = ~(1<<5) // ATT: // 1<<5 = 0010 0000 // ~(1<<5) = 1101 1111 int main () { cout << \"Title: Da minuscolo a maiuscolo \\n \" << \"Description: Acquisisce un carattere letterale minuscolo da tastiera e lo converte in un carattere letterale maiuscolo \\n \" ; char c ; cout << \"Inserisci un carattere minuscolo: \" ; cin >> c ; c &= ~ ( 1 << 5 ); cout << \"Il carattere maiuscolo e': \" << c ; cout << '\\n' ; }","title":"Da minuscolo a maiuscolo"},{"location":"cpp/#da-maiuscolo-a-minuscolo","text":"Acquisisce un carattere letterale maiuscolo da tastiera e lo converte in un carattere letterale minuscolo #include <iostream> using namespace std ; //0100 0000 -> MAIUSC //0110 0000 -> min //Devo mettere a 1 il quinto bit. Quindi min = (xx1x xxxx) | (0010 0000); // 0010 0000 --> = (1<<5) int main () { cout << \"Title: Da maiuscolo a minuscolo \\n \" << \"Description: Acquisisce un carattere letterale maiuscolo da tastiera e lo converte in un carattere letterale minuscolo \\n \" ; char c ; cout << \"Inserisci un carattere MAIUSCOLO: \" ; cin >> c ; c |= ( 1 << 5 ); cout << \"Il carattere minuscolo e': \" << c ; cout << '\\n' ; }","title":"Da maiuscolo a minuscolo"},{"location":"cpp/#da-minuscolo-a-maiuscolo-e-viceversa","text":"Acquisisce un carattere letterale da tastiera e: - Lo converte in maiuscolo se \u00e8 minuscolo - Lo converte in minuscolo se \u00e8 maiuscolo - Restituisce il carattere se non \u00e8 una lettera #include <iostream> using namespace std ; //010x xxxx -> MAIUSC //011x xxxx -> minusc //La lettera 'k' differisce di 2^5 rispetto alla lettera 'K' //Calcolo 'a' - 'A' int main (){ cout << \"Title: Da minuscolo a maiuscolo e viceversa \\n \" << \"Description: Acquisisce un carattere letterale da tastiera e: \\n \" << \"- Lo converte in maiuscolo se \u00e8 minuscolo \\n \" << \"- Lo converte in minuscolo se \u00e8 maiuscolo \\n \" << \"- Restituisce il carattere se non \u00e8 una lettera \\n \" ; char c ; cout << \"Inserisci un carattere: \" ; cin >> c ; const int t = 'a' - 'A' ; //Costante di conversione min<->MAIUSC if ( c >= 'a' && c <= 'z' ){ c -= t ; //Trasformo min->MAIUSC cout << \"Il carattere maiuscolo e': \" << c ; } else if ( c >= 'A' && c <= 'Z' ){ c += t ; //Trasformo MAIUSC-min cout << \"Il carattere minuscolo e': \" << c ; } else cout << \"Il carattere inserito e': \" << c ; cout << '\\n' ; }","title":"Da minuscolo a maiuscolo e viceversa"},{"location":"cpp/#risolvi-equazioni-di-ii-grado","text":"Calcola i risultati di un equazione di secondo grado del tipo: ax^2 + bx + c = 0 Inserendo da tastiera i valori dei coefficienti a , b , c #include <iostream> #include <cmath> using namespace std ; int main (){ cout << \"Ttile: Risolvi equazioni di II grado \\n \" << \"Description: Calcola i risultati di un equazione di secondo grado del tipo: \\n \" << \"ax^2 + bx +c = 0 \\n \" << \"Inserendo da tastiera i valori dei coefficienti a, b, c \\n \" ; double a , b , c , x1 , x2 , delta ; cout << \" \\n Inserisci i coefficienti a, b, c. \\n\\n \" ; cout << \"a:\" ; cin >> a ; cout << \"b:\" ; cin >> b ; cout << \"c:\" ; cin >> c ; if ( ( a == 0 ) && ( b == 0 ) && ( c == 0 ) ) cout << \" \\n Equazione DEGENERE.\" ; else if ( ( a == 0 ) && ( b == 0 ) ) cout << \" \\n Equazione IMPOSSIBILE.\" ; else if ( a == 0 ) { cout << \" \\n Equazione di PRIMO grado.\" ; x1 = - b / c ; cout << \" \\n x=\" << x1 ; } else { delta = b * b - 4 * a * c ; if ( delta < 0 ) cout << \" \\n x1, x2, soluzioni immaginarie. \\n \" ; else if ( delta == 0 ) { x1 = - b / ( 2 * a ); cout << \" \\n x1=x2=\" << x1 ; } else { cout << \" \\n Soluzioni reali e distinte. \\n \" ; x1 = ( - b + sqrt ( delta ) ) / ( 2 * a ); x2 = ( - b - sqrt ( delta ) ) / ( 2 * a ); cout << \" \\n x1:\" << x1 << \" \\n x2:\" << x2 ; } } cout << '\\n' ; }","title":"Risolvi equazioni di II grado"},{"location":"cpp/#conta-dispari-da-sequenza-illimitata","text":"Conta i numeri dispari inseriti da tastiera. Termina al primo negativo o nullo Modo 1: Uso del ciclo while() #include <iostream> using namespace std ; /* NOTA: - Lo statemeant: conta += n%2; - Equivake a: conta = conta + n%2; - Equivale a: if ( n%2 ) conta++; */ int main (){ cout << \"Title: Conta dispari\" << \"Description: Conta i numeri dispari inseriti da tastiera. Termina al primo negativo o nullo. \\n \" ; int n , conta = 0 ; cout << \"n: \" ; cin >> n ; while ( n > 0 ){ conta += n % 2 ; cout << \"n: \" ; cin >> n ; } cout << conta ; cout << '\\n' ; } Modo 2: Uso del ciclo for(;;) #include <iostream> using namespace std ; /* NOTA: - Lo statemeant: conta += n%2; - Equivake a: conta = conta + n%2; - Equivale a: if ( n%2 ) conta++; */ int main (){ cout << \"Title: Conta dispari \\n \" << \"Description: Conta i numeri dispari inseriti da tastiera. Termina al primo negativo o nullo. \\n \" ; int n , conta = 0 ; cout << \"n: \" ; cin >> n ; for (;;) { if ( n > 0 ) { conta += n % 2 ; cout << \"n: \" ; cin >> n ; } else break ; } cout << conta ; cout << '\\n' ; }","title":"Conta dispari da sequenza illimitata"},{"location":"cpp/#stampa-cifre","text":"Stampa le cifre di un numero intero inserito da tastiera a partire da quella meno significativa. #include <iostream> using namespace std ; int main (){ cout << \"Title: Stampa cifre \\n \" << \"Description: Stampa le cifre di un numero intero inserito da tastiera a partire da quella meno significativa. \\n \" ; int n ; cout << \"Inserisci un numero intero \\n \" ; cin >> n ; n = ( n > 0 ) ? n : - n ; cout << \"Cifre: \\n \" ; do { cout << '>' << n % 10 << '\\n' ; n /= 10 ; } while ( n > 0 ); cout << '\\n' ; }","title":"Stampa cifre"},{"location":"cpp/#tavola-pitagorica","text":"Costruisce la tavola pitagorica dato l'ordine \"n\" immesso da tastiera. #include <iostream> using namespace std ; int main (){ cout << \"Title: Tavola pitagorica\" << \"Description: Costruisce la tavola pitagorica dato l'ordine 'n' immesso da tastiera. \\n \" ; int n ; cout << \"Inserisci l'ordine 'n' della tavola pitagorica:\" ; cin >> n ; cout << '\\n' ; n = n < 1 ? 1 : n ; for ( int i = 1 ; i <= n ; i ++ ){ for ( int j = 1 ; j <= n ; j ++ ) cout << i * j << '\\t' ; cout << \" \\n\\n\\n \" ; } cout << '\\n' ; }","title":"Tavola pitagorica"},{"location":"cpp/#conta-dispari-da-sequenza-limitata","text":"Riceve una sequenza di numeri da tastiera e conta i dispari. Termina anche se un numero inserito \u00e8 nullo o negativo #include <iostream> using namespace std ; int main (){ cout << \"Title: Conta dispari da sequenza limitata\" << \"Description: Riceve una sequenza di numeri da tastiera e conta i dispari. Termina anche se un numero inserito \u00e8 nullo o negativo \\n \" ; int M , n , conta = 0 ; cout << \"Inserisci il numero di elementi della sequenza:\" ; cin >> M ; cout << \" \\n Inserisci la sequenza: \\n \" ; cin >> n ; conta += n % 2 ; for ( int i = 1 ; ( i < M ) && ( n > 0 ); i ++ ){ cin >> n ; conta += n % 2 ; } cout << \" \\n I numeri dispari della sequenza sono:\" << conta ; cout << '\\n' ; }","title":"Conta dispari da sequenza limitata"},{"location":"cpp/#sequenza-crescente-decrescente-o-non-ordinata","text":"Riceve da tastiera una sequenza di numeri interi e calcola se la sequenza \u00e8 ordinata in modo crescente, decrescente o non ordinata #include <iostream> using namespace std ; int main (){ cout << \"Title: Sequenza crescente, decrescente o non ordinata? \\n \" << \"Description: Riceve da tastiera una sequenza di numeri interi e calcola se la sequenza \u00e8 ordinata in modo crescente, decrescente o non ordinata \\n \" ; int n , n1 , n2 , crescente = 0 , decrescente = 0 , uguale = 0 ; cout << \"Immetti la Lunghezza della sequenza numerica:\" ; cin >> n ; cout << \" \\n Immetti la sequenza: \\n \" ; cin >> n1 ; for ( int i = 1 ; ( i < n ) ; i ++ ){ cin >> n2 ; crescente += n2 > n1 ; decrescente += n2 < n1 ; uguale += n2 == n1 ; n1 = n2 ; } if ( crescente == n -1 ) cout << \"CRESCENTE\" ; else if ( decrescente == n -1 ) cout << \"DECRESCENTE\" ; else if ( uguale == n -1 ) cout << \"UGUALE.\" ; else cout << \"NON ORDINATA.\" ; cout << '\\n' ; }","title":"Sequenza crescente, decrescente o non ordinata?"},{"location":"cpp/#vettore-palindromo","text":"Calcola se il vettore immesso da tastiera \u00e8 palindromo #include <iostream> using namespace std ; void riempi ( int * , int ); void stampa ( int * , int ); int palindromo ( int * , int ); int main (){ cout << \"Title: Vettore palindromo\" << \"Description: Calcola se il vettore immesso da tastiera \u00e8 palindromo \\n \" ; int nElem ; cout << \"Dimensione del vettore: \" ; cin >> nElem ; nElem = ( nElem < 1 ) ? 1 : nElem ; int * vett = new int [ nElem ]; riempi ( vett , nElem ); stampa ( vett , nElem ); if ( palindromo ( vett , nElem ) ) cout << \"Vettore palindromo.\" ; else cout << \"Vettore non palindromo.\" ; cout << '\\n' ; } void riempi ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ){ cout << \"Elemento \" << i + 1 << \": \" ; cin >> v [ i ]; //v[i] = *(v+i) } } void stampa ( int * v , int n ){ cout << \" \\n [\" << n << \"] <\" << v [ 0 ]; for ( int i = 1 ; i < n ; i ++ ) cout << \", \" << v [ i ]; //v[i] = *(v+i) cout << \"> \\n \" ; } int palindromo ( int * v , int n ){ for ( int i = 0 , j = n -1 ; i < j ; i ++ , j -- ){ if ( v [ i ] != v [ j ] ) //v[i] != v[j] -> *(v+i) != *(v+j) return 0 ; } return 1 ; }","title":"Vettore palindromo"},{"location":"cpp/#conta-ricorrenza-numerica","text":"Conta la ricorrenza delle cifre 0-9 presenti nella sequenza inserita da tastiera #include <iostream> using namespace std ; void azzera ( int * , int ); void conta ( int * , int ); void stampa ( int * , int ); int main (){ cout << \"Title: Conta ricorrenza numerica \\n \" << \"Description: Conta la ricorrenza delle cifre 0-9 presenti nella sequenza inserita da tastiera. \\n \" ; int LunghSeq , nElem = 10 ; int vettConta [ nElem ]; //Vettore conteggio cifre. azzera ( vettConta , nElem ); cout << \"Lunghezza sequenza: \" ; cin >> LunghSeq ; cout << \"Inserisci la sequenza: \\n \" ; conta ( vettConta , LunghSeq ); stampa ( vettConta , nElem ); cout << '\\n' ; } void azzera ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ) v [ i ] = 0 ; } void conta ( int * v , int l ){ int num ; for ( int i = 0 ; i < l ; i ++ ){ cin >> num ; num = ( num >= 0 ) ? num : - num ; //Controllo sul segno. do { v [ num % 10 ] ++ ; num = num / 10 ; } while ( num > 0 ); } } void stampa ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ) cout << '\\n' << i << ':' << v [ i ]; cout << '\\n' ; }","title":"Conta ricorrenza numerica"},{"location":"cpp/#conta-ricorrenza-letterale","text":"Conta la ricorrenza delle lettere contenute in una stringa - I caratteri non alfabetici vengono ignorati - Le maiuscole sono considerate muinuscole #include <iostream> using namespace std ; void azzera ( int * , int ); void contaLettere ( char * , int * ); void stampaLettere ( int * , int ); int main (){ cout << \"Title: Conta ricorrenza letterale \\n \" cout << \"Description Conta la ricorrenza delle lettere contenute in una stringa \\n \" << \"- I caratteri non alfabetici vengono ignorati \\n \" << \"- Le maiuscole sono considerate muinuscole \\n \" ; char stringa [ 100 ]; const int lettere = 26 ; int vettConta [ lettere ]; cout << \"Inserisci la stringa:\" ; cin >> stringa ; azzera ( vettConta , lettere ); contaLettere ( stringa , vettConta ); stampaLettere ( vettConta , lettere ); cout << '\\n' ; } void azzera ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ) v [ i ] = 0 ; } void contaLettere ( char * str , int * c ){ for ( int i = 0 ; str [ i ] != '\\0' ; i ++ ){ if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) c [ str [ i ] - 'a' ] ++ ; else if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) c [ str [ i ] - 'A' ] ++ ; } } void stampaLettere ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ) cout << '\\n' << char ( 'a' + i ) << ':' << v [ i ]; }","title":"Conta ricorrenza letterale"},{"location":"cpp/#segno-elementi-di-un-vettore","text":"Stampa il segno degli elementi di un vettore. #include <iostream> using namespace std ; int main (){ cout << \"Title: Segno elementi di un vettore \\n \" << \"Description: Stampa il segno degli elementi di un vettore \\n \" ; int nElem , pos = 0 , null = 0 , neg = 0 ; cout << \"Inserisci nElem: \" ; cin >> nElem ; nElem = ( nElem > 0 ) ? nElem : 1 ; int * vett = new int [ nElem ]; for ( int i = 0 ; i < nElem ; i ++ ){ cout << \"Elemento \" << i + 1 << ':' ; cin >> vett [ i ]; } for ( int i = 0 ; i < nElem ; i ++ ){ if ( vett [ i ] > 0 ) pos ++ ; else if ( vett [ i ] == 0 ) null ++ ; else neg ++ ; } cout << \" \\n Pos: \" << pos << \" \\n Null: \" << null << \" \\n Neg: \" << neg ; cout << '\\n' ; }","title":"Segno elementi di un vettore"},{"location":"cpp/#vettore-elementi-dispari-nulli-o-pari","text":"Acquisisce un vettore da tastiera e restituisce il numero degli elementi dispari, nulli e pari in un vettore #include <iostream> using namespace std ; void leggi ( int * , int ); int dzp ( int , int * , int ); int main (){ cout << \"Title: Vettore - elementi dispari, nulli o pari? \\n \" << \"Description: Acquisisce un vettore da tastiera Stampa il numero degli elementi dispari, nulli e pari in un vettore \\n \" ; int nElem , selettore ; cout << \"Inserisci il numero di elementi del vettore, nElem: \" ; cin >> nElem ; nElem = nElem > 1 ? nElem : 1 ; //Riempi vettore cout << '\\n' ; int * vett = new int [ nElem ]; leggi ( vett , nElem ); //Stampa il numero di elementi dispari selettore = -1 ; cout << \" \\n Dispari: \" << dzp ( selettore , vett , nElem ); //Stampa il numero di elementi nulli selettore = 0 ; cout << \" \\n Nulli: \" << dzp ( selettore , vett , nElem ); //Stampa il numero di elementi pari selettore = 1 ; cout << \" \\n Pari: \" << dzp ( selettore , vett , nElem ); char c ; cout << '\\n' << \"Comando?: (d = dispari, n = nulli, p = pari)\" ; cin >> c ; switch ( c ){ case 'd' : cout << \" \\n Dispari: \" << dzp ( -1 , vett , nElem ); break ; case 'n' : cout << \" \\n Nulli: \" << dzp ( 0 , vett , nElem ); break ; case 'p' : cout << \" \\n Dispari: \" << dzp ( 1 , vett , nElem ); break ; default : cout << \"!!!\" ; } cout << '\\n' ; } void leggi ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ){ cout << \"Elemento \" << i + 1 << ':' ; cin >> v [ i ]; } } int dzp ( int sel , int * v , int n ){ int conta = 0 ; switch ( sel ){ case -1 : for ( int i = 0 ; i < n ; i ++ ){ v [ i ] = v [ i ] < 0 ? - v [ i ] : v [ i ]; //NECESSARIO!! conta += v [ i ] % 2 ; } break ; case 0 : for ( int i = 0 ; i < n ; i ++ ){ v [ i ] = v [ i ] < 0 ? - v [ i ] : v [ i ]; //NECESSARIO!! conta += ( v [ i ] == 0 ); } break ; case 1 : for ( int i = 0 ; i < n ; i ++ ){ v [ i ] = v [ i ] < 0 ? - v [ i ] : v [ i ]; //NECESSARIO!! conta += ! ( v [ i ] % 2 || v [ i ] == 0 ); } break ; } return conta ; }","title":"Vettore - elementi dispari, nulli o pari?"},{"location":"cpp/#vettore-elementi-ordinati","text":"Acquisisce un vettore da tastiera e restitusice se gli elementi sono in ordine crescente, descrescente o non ordinati #include <iostream> using namespace std ; void leggi ( int * , int ); int ordinato ( int * , int ); void stampa ( int ); int main (){ cout << \"Title: Vettore - elementi ordinati? \\n \" << \"Description: Acquisisce un vettore da tastiera e restitusice se gli elementi sono in ordine crescente, descrescente o non ordinati \\n \" ; int nElem ; cout << \"nElem: \" ; cin >> nElem ; int * vett = new int [ nElem ]; leggi ( vett , nElem ); stampa ( ordinato ( vett , nElem ) ); cout << '\\n' ; } void leggi ( int * v , int n ){ for ( int i = 0 ; i < n ; i ++ ){ cout << \"El \" << i + 1 << ':' ; cin >> v [ i ]; } } int ordinato ( int * v , int n ){ int decrescente = 1 ; int crescente = 1 ; int uguale = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ){ decrescente &= v [ i ] > v [ i + 1 ]; crescente &= v [ i ] < v [ i + 1 ]; uguale &= v [ i ] == v [ i + 1 ]; } if ( decrescente ) return -1 ; if ( uguale ) return 0 ; if ( crescente ) return + 1 ; return + 2 ; } void stampa ( int ord ){ switch ( ord ){ case -1 : cout << \" \\n Vettore ordinato in senso decrescente.\" ; break ; case 0 : cout << \" \\n Elementi del vettore uguali.\" ; break ; case + 1 : cout << \" \\n Vettore ordinato in senso crescente.\" ; break ; case + 2 : cout << \" \\n Elementi del vettore non ordinati.\" ; } }","title":"Vettore - elementi ordinati?"},{"location":"cpp/#buffer-circolare","text":"Inizializza un buffer circolare di una dimensione impostata da tastiera. Sono disponibili i comandi: - i : inserisci, inscerisce un elemento nel buffer - e : estrai, estrai il primo elemento dal buffer in modoalit\u00e0 LIFO (last input, first output) - < : termina #include <iostream> using namespace std ; // 'in' e 'out' devono essere inizialmente sovrapposti. // 'in' e 'out' sono INDICI. // COMANDO : // i = inserisci // e = estrai struct buffer { int dimensione ; int in ; int out ; int nElem ; int * pHEAP ; }; void inizializza ( buffer & buf , int dim ); int inserisci ( buffer & buf , int val ); int estrai ( buffer & buf , int & val ); int main () { cout << \"Title: Buffer circolare \\n \" << \"Description: Inizializza un buffer circolare di una dimensione impostata da tastiera. \\n \" << \"Sono disponibili i comandi: \\n \" << \"- 'i': inserisci, inscerisce un elemento nel buffer \\n \" << \"- 'e': estrai, estrai il primo elemento dal buffer in modoalit\u00e0 LIFO (last input, first output) \\n \" << \"- '<': termina \\n \" buffer b1 ; int dim , val ; char c ; cout << \"Inizializza il buffer. \\n \" << \"Dimensione:\" ; cin >> dim ; inizializza ( b1 , dim ); cout << \" \\n Inserisci un comando. \\n \" << \"i -> inserisci. \\n \" << \"e -> estrai. \\n \" << \"< -> termina. \\n \" ; for (;;){ cout << \" \\n\\n Comando?? \" ; cin >> c ; if ( c == '<' ) break ; switch ( c ){ case 'i' : { int i ; cout << \" \\n Immetti un valore:\" ; cin >> val ; i = inserisci ( b1 , val ); if ( ! i ) cout << \" \\n\\n BUFFER PIENO. \\n \" ; break ; } case 'e' : { int i ; i = estrai ( b1 , val ); if ( ! i ){ cout << \" \\n\\n BUFFER VUOTO. \\n \" ; break ; } else { cout << \" \\n L'elemento vale: \" << val ; break ; } } default : break ; } } cout << '\\n' ; } void inizializza ( buffer & buf , int dim ){ buf . in = 0 ; buf . out = 0 ; buf . nElem = 0 ; buf . dimensione = dim > 0 ? dim : 1 ; buf . pHEAP = new int [ buf . dimensione ]; } int inserisci ( buffer & buf , int val ){ // Controllo se e' pieno. if ( buf . nElem >= buf . dimensione ){ return 0 ; } // Inserisco l'elemento nel primo posto vuoto. buf . pHEAP [ buf . in ++ ] = val ; buf . in = buf . in == buf . dimensione ? 0 : buf . in ; buf . nElem ++ ; return 1 ; } int estrai ( buffer & buf , int & val ){ if ( buf . nElem <= 0 ) return 0 ; val = buf . pHEAP [ buf . out ++ ]; buf . out = buf . out == buf . dimensione ? 0 : buf . out ; buf . nElem -- ; return 1 ; }","title":"Buffer circolare"},{"location":"cpp/#contenitore","text":"Inizializza due contenitori di una dimensione impostata da tastiera contenenti lettere. Sono disponibili i seguenti comandi: i : inizializza, inizializza un contenitore > : inserisci, iscerisce un elemento immesso da tastiera nel contenitore < : estrai, estrae un elmento da un contenitore u : Ritorna un contenitore con gli elementi a comune d : Ritorna un contenitore con gli elementi diversi #include <iostream> using namespace std ; struct contenitore { int nElem ; int cap ; int ee [ 26 ]; }; void inizializza ( contenitore & c , int N ){ N = N > 1 ? N : 1 ; c . cap = N ; for ( int i = 0 ; i < 26 ; i ++ ) c . ee [ i ] = 0 ; c . nElem = 0 ; } void inserisci ( contenitore & c , char p ){ if ( c . nElem >= c . cap || p < 'a' || p > 'z' ) return ; c . ee [ p - 'a' ] ++ ; c . nElem ++ ; } void estrai ( contenitore & c , char p ){ if ( p < 'a' || p > 'z' ) return ; c . nElem -= c . ee [ p - 'a' ]; c . ee [ p - 'a' ] = 0 ; } void scrivi ( contenitore & c ){ cout << '<' ; if ( c . ee [ 0 ] > 0 ) cout << 'a' << \": \" << c . ee [ 0 ]; for ( int i = 1 ; i < 25 ; i ++ ){ if ( c . ee [ i ] == 0 ) continue ; cout << \", \" << char ( 'a' + i ) << \": \" << c . ee [ i ]; } cout << '>' ; } contenitore cambiaCapienza ( const contenitore & c , int N ){ if ( N < c . nElem ) return c ; contenitore t ; t = c ; t . cap = N ; return t ; } contenitore diversiE ( const contenitore & c1 , const contenitore & c2 ){ contenitore c3 ; int N ; N = ( c1 . cap <= c2 . cap ) ? c1 . cap : c2 . cap ; inizializza ( c3 , N ); for ( int i = 0 ; i < 26 ; i ++ ){ if ( c1 . ee [ i ] == 0 || c2 . ee [ i ] == 0 ) continue ; c3 . ee [ i ] = 1 ; c3 . nElem ++ ; } } contenitore diversiN ( const contenitore & c1 , const contenitore & c2 ){ contenitore c3 ; int N ; inizializza ( c3 , c1 . cap ); for ( int i = 0 ; i < 26 ; i ++ ){ if ( c1 . ee [ i ] > 0 || c2 . ee [ i ] == 0 ){ c3 . ee [ i ] = 1 ; c3 . nElem ++ ; } } return c3 ; } int capienza ( const contenitore c ){ return c . cap ; } int quanti ( const contenitore c ) { return c . nElem ; } int main (){ cout << \"Title: Buffer \\n \" << \"Description: Inizializza due contenitori di una dimensione impostata da tastiera contenenti lettere. \\n \" << \"Sono disponibili i seguenti comandi: \\n \" << \"- `i`: inizializza, inizializza un contenitore \\n \" << \"- `>`: inserisci, iscerisce un elemento immesso da tastiera nel contenitore \\n \" << \"- `<`: estrai, estrae un elmento da un contenitore \\n \" << \"- `u`: Ritorna un contenitore con gli elementi a comune \\n \" << \"- `d`: Ritorna un contenitore con gli elementi diversi \\n \" /* contenitore c1, c2; cout << \"\\n\\n\" << \"i: inizializza.\\n\" << \">: inserisci.\\n\" << \"<: estrai.\\n\" << \"c: cambia capienaza.\\n\" << \"u: Ritorna un contenitore con gli elementi a comune.\\n\" << \"d: Ritorna un contenitore con elementi diversi\" << \"q:\" int capienza; int c; cout << \"Inserisci capienza: \"; cin >> capienza; */ contenitore c1 ; inizializza ( c1 , 5 ); inserisci ( c1 , 'a' ); inserisci ( c1 , 'b' ); inserisci ( c1 , 'a' ); inserisci ( c1 , 'a' ); inserisci ( c1 , 'd' ); scrivi ( c1 ); cout << '\\n' ; }","title":"Contenitore"},{"location":"css/","text":"CSS CSS Lezione 01 Dove inserire il codice CSS? Inserire CSS all'interno della pagina HTML Inserire CSS in un file esterno all'HTML Lezione 02 Alcune propriet\u00e0 CSS Colori in CSS Colore CSS Esadecimale Perch\u00e8 \u00e8 utile questo metodo? Colore CSS RGB/RGBA Lezione 03 Background CSS background-repeat: no-repeat; background-size: cover; Bordi CSS Quindi Lezione 04 Se volessi stilizzare in modo diverso un elemento appartenente alla stessa categoria? Si pu\u00f2 fare attraverso l'id Si pu\u00f2 fare anche attraverso l'uso di una classe ## Lezione 05 Altri selettori CSS * Selector Descendant Selector. Attribute selector. ## Lezione 06 Google developer tool Eredit\u00e0 e Specificit\u00e0 in CSS Eredit\u00e0 Specificit\u00e0 ## Lezione 07 CSS Fonts Google fonts ## Lezione 08 CSS Box Model Alcune Estensioni per VSCode Block element Responsive Deign Em / Rem VH/VW FLEXBOX WEB HOSTING Shared Hosting VPS (Virtual Private Server) Dedicated Server Cloud Hosting Static Hosting Lezione 01 Come abbiamo gi\u00e0 detto, CSS sta per Cascading Style Sheet e serve quindi per \"abbellire\" lo stile nativo della pagina HTML. Vediamo la struttura del codice CSS: selettore { propriet\u00e01 : valore ; propriet\u00e02 : valore ; } Esempi: Nell'esempio seguente attribuir\u00f2 al selettore h1 il colore \"blue\" e un font di \"30 pixel\". h1 { color : blue ; font-size : 30 px ; } In questo esempio invece all'attributo immagine associer\u00f2 un bordo giallo di grandezza di 3 pixel. img { border-color : yellow ; border-width : 3 px ; } Dove inserire il codice CSS? E' possibile aggiungere il codice CSS sia all'interno del file HTML, sia in un file esterno. Inserire CSS all'interno della pagina HTML Per questo metodo ci sono due modi: Inserire la stilizzazione CSS all'interno della riga da stilizzare con l'attributo style . Questo metodo \u00e8 sconsigliato, si faceva una volta quando il CSS non esisteva ma oggi \u00e8 ancora valido. < p style = \"color: red;\" > sono un paragrafo rosso </ p > sono un paragrafo rosso Inserire la stilizzazione CSS con il tag <style></style> messo all'interno del tag <head></head> del boilerplate html. Questo \u00e8 consigliato poich\u00e8 in questo modo avremo tutto ci\u00f2 che riguarda lo stile all'interno di questo tag. <!DOCTYPE html> < html > < head > < style type = \"text/css\" > h1 { color : blue ; } </ style > </ head > < body > < h1 > Ciao, sono un h1 </ h1 > </ body > </ html > Inserire CSS in un file esterno all'HTML Questa \u00e8 sicuramente la soluzione migliore , \u00e8 la pi\u00f9 pulita e ordinata poich\u00e8 separa il contenuto HTML che stabilisce la struttura della pagina dallo stile della stessa tramite CSS. Una volta creato poi sar\u00e0 necessario creare un collegamento tra i due file usando il <link> tag. Ecco un esempio: File CSS (06_HTML_CSS_Style.css) h1 { color : black ; background : yellow ; } li { color : forestgreen ; } File HTML (06_HTML_CSS_ElementiBaseCSSEsterniAdHTML.html) <!DOCTYPE html> < html lang = \"en\" > < head > < title > HTML - CSS Elementi Base </ title > < link rel = \"stylesheet\" href = \"06_HTML_CSS_Style.css\" > </ head > < body > < h1 > HTML - CSS Elementi Base </ h1 > < ul > < li > Primo ELemento </ li > < li > Secondo Elemento </ li > </ ul > </ body > </ html > HTML - CSS Elementi Base #h1_0 { color: black; background: yellow; } #ul_0 li{ color: green; } HTML - CSS Elementi Base Primo ELemento Secondo Elemento Notare il <link> tag con <href> che linka il file CSS. Questa \u00e8 sicuramente la soluzione migliore. Lezione 02 Alcune propriet\u00e0 CSS In questo esempio riporter\u00f2 alcune propriet\u00e0 come l'inserimento di colori, bordi, immagini di background. Alcune propriet\u00e0 sono rappresentate in modo diverso ma equivalenti. Colori in CSS Vediamo come \u00e8 possibile esprimere i colori in CSS. Il metodo che abbiamo visto per adesso \u00e8 un metodo \"amatoriale\" ma non \u00e8 il metodo che i programmatori utilizzano. Un altro metodo \u00e8 utilizzare il valore corrispondente esadecimale del colore . Colore CSS Esadecimale Ogni colore pu\u00f2 essere espresso tramite una terna di valori esadecimali: RED-GREEN-BLUE a1 - f6 - 18 Ad ogni elemento della terna sono associati due numeri esadecimali in modo tale che il numero vada da 0 a 255. Cio' esprime l'intensit\u00e0 del colore appartenente alla terna. Con tale terna \u00e8 possibile rappresentare ogni tipo di colore. Per rappresentare in CSS il colore in esadecimale \u00e8 necessario anteporre al numero di sei cifre che rappresenta il colore il simbolo # Es: red = #ff0000 (ovviamente) Perch\u00e8 \u00e8 utile questo metodo? Supponiamo di voler un colore specifico da creare utilizzando un qualsiasi color picker Scegliendo tramite il color picker il colore desiderato e prelevando il valore esadecimale \u00e8 possibile ottenere esattamente il valore creato. Molto utile e versatile rispetto a una serie di colori preimpostati. Colore CSS RGB/RGBA Un altro metodo \u00e8 utilizzare la terna rgb() . Funziona in modo molto simile ai colori in esadecimale, solo che in questo caso inseriremo una terna decimale nel range 0 -255 . Esempio: rgb(173, 255, 47) . La funzione rgba() invece introduce l'elemento trasparenza (alpha). L'ultimo elemento infatti va da 0.0 - 1.0 e rappresenta la trasparenza dell'elemento. Esempio: rgba(34, 139, 34, 0.2) , in questo caso la trasparenza sar\u00e0 al 20%. Lezione 03 Background CSS Con la propriet\u00e0 background \u00e8 possibile specificare il colore del background dell'elemento. Utile la propriet\u00e0 background per impostare un colore della pagina. Per far ci\u00f2 \u00e8 possibile impostare la propriet\u00e0 background per l'elemento body : E' possibile impostare anche un'immagine. Per far ci\u00f2 si usa la funzione url() . All'interno della funzione url inseriamo il link dell'immagine che vogliamo rappresentare come sfondo background della pagina. E' possibile impostare anche alcune propriet\u00e0 aggiuntiva come la background-reapeat o la background-size . background-repeat: no-repeat; Con questa propriet\u00e0 \u00e8 possibile specificare se ripetere o meno l'immagine. Infatti di default, se l'immagine \u00e8 piccola viene ripetuta, se \u00e8 grande viene adattata alla pagina. Con questa propriet\u00e0 quindi possibile specificare se ripetere o meno l'immagine. background-size: cover; Con questa propriet\u00e0 l'immagine selezionata andr\u00e0 a riempire tutto lo schermo e se \u00e8 piu' piccola la adatter\u00e0. Bordi CSS Per inserire il bordo all'elemento html \u00e8 necessario introdurre la proprit\u00e0 border . Sar\u00e0 necessario impostare almeno border-color per inserire il colore del bordo, border-width per la grandezza del bordo e border-style per scegliere lo stile del bordo. Oppure \u00e8 possibile inserire la proprit\u00e0 bordo tramite una terna di valori che comprendono la grandezza, lo stile e il colore direttamente con la propriet\u00e0 border Quindi Abbiamo imparato a stilizzare modificando propriet\u00e0 come la grandezza del font, il colore, inserendo un bordo, un'immagine di propriet\u00e0 e abbiamo visto che ci\u00f2 si applica ad ogni elemento appartenente alla stessa categoria (detta anche classe), ad esempio l'elemento <li> . Questo significa che se assegner\u00f2 certe propriet\u00e0 all'elemento <li> queste verranno applicate a tutti gli elementi <li> File style.css h1 { color : darkslategray ; border : 2 px rgb ( 173 , 255 , 47 ) solid ; background : grey ; } li { color : rgba ( 34 , 139 , 34 , 0.5 ); border-color : #000000 ; border-width : 2 px ; border-style : groove ; } body { background : url ( https://i.pinimg.com/originals/60/19/89/601989ff441ddc92bc0fa2e05040f9e7.jpg ); background-repeat : no-repeat ; background-size : cover ; } File index.html <!DOCTYPE html> < html lang = \"en\" > < head > < title > HTML - CSS Elementi Base </ title > < link rel = \"stylesheet\" href = \"style.css\" > </ head > < body > < h1 > HTML - CSS Elementi Base </ h1 > < ul > < li > Primo ELemento </ li > < li > Secondo Elemento </ li > </ ul > </ body > </ html > HTML - CSS Elementi Base #h1_01 { color: darkslategray; border: 2px rgb(173, 255, 47) solid; background: grey; } #ul li{ color: rgba(34, 139, 34, 0.5); border-color: #000000; border-width: 2px; border-style: groove; } #body_01{ background: url(https://i.pinimg.com/originals/60/19/89/601989ff441ddc92bc0fa2e05040f9e7.jpg); background-repeat: no-repeat; background-size: cover; height: 400px; } HTML - CSS Elementi Base Primo ELemento Secondo Elemento Lezione 04 Se volessi stilizzare in modo diverso un elemento appartenente alla stessa categoria? Supponiamo quindi ad esempio di scegliere uno stile di default per l'elemento <li> ma di voler cambiare lo stile di un particolare elemento. Come si fa? Si pu\u00f2 fare attraverso l'id Ecco un esempio: File HTML ```HTML Primo ELemento Secondo Elemento speciale `File CSS` CSS speciale { color: red; } `` In questo modo, solo cio' che avr\u00e0 l'id speciale` avr\u00e0 quella classe di propriet\u00e0. Nota che l'id deve essere unico nel codice! Il nome simbolico che fornisco deve essere unico per tutto il codice Si pu\u00f2 fare anche attraverso l'uso di una classe Questo \u00e8 un metodo migliore. In questo caso attribuendo un elemento a una classe con un certo nome \u00e8 possibile impostare lo stile solo agli elementi di quella data classe. File HTML ```HTML Primo ELemento non appartenente a nessuna classe Secondo Elemento appartenente alla classe \"bluColor\" Terzo Elemento appartenente alla classe \"bluColor\" `File CSS` CSS .bluColor { color: blue; } ``` In questo caso verrano colorati di colore \"indigo\" solo gli elementi appartenenti alla classe \"bluColor\". Nota In CSS gli id si identificano inserendo # + il nome dell' id mentre le classi si identidicano tramite . seguito dal nome della classe. File CSS # speciale { color : red ; } . bluColor { color : blue ; } File HTML < head > < title > HTML - CSS Elementi Base </ title > < link href = \"https://fonts.googleapis.com/css2?family=Staatliches&display=swap\" rel = \"stylesheet\" > < link rel = \"stylesheet\" href = \"style.css\" > </ head > < body > < h1 > HTML - CSS Elementi Base </ h1 > < ul > < li > Primo ELemento </ li > < li > Secondo Elemento </ li > </ ul > < ul > < li > Primo ELemento </ li > < li id = \"speciale\" > Secondo Elemento speciale </ li > </ ul > < ul > < li > Primo ELemento non appartenente a nessuna classe </ li > < li class = \"bluColor\" > Secondo Elemento appartenente alla classe \"bluColor\" </ li > < li class = \"bluColor\" > Terzo Elemento appartenente alla classe \"bluColor\" </ li > </ ul > </ body > HTML - CSS Elementi Base #speciale { color: red; } .bluColor { color: blue; } HTML - CSS Elementi Base Primo ELemento Secondo Elemento Primo ELemento Secondo Elemento speciale Primo ELemento non appartenente a nessuna classe Secondo Elemento appartenente alla classe \"bluColor\" Terzo Elemento appartenente alla classe \"bluColor\" Lezione 05 Altri selettori CSS Ricordiamo che il selettore permette appunto di selezionare l'elemento ch vogliamo stilizzare. Per adesso abbiamo visto i selettori generici per ogni elemento html, i selettori definiti da una classe e da un id ma ne esistono altri. * Selector Con questo selettore \u00e8 possibile selezionare ogni elemento della pagina HTML. Descendant Selector. Con questo selettore \u00e8 possibile selezionare elementi complessi ovvero elementi contenuti in altri elementi, elementi discentendi da altri appunto. Immaginiamo di creare una lista di elementi e immaginiamo che ogni elemento \u00e8 un anchor tag. Con questo selettore \u00e8 possibile selezionare solo gli anchor tag all'interno del list item. Sono possibili diverse combinazioni. Attribute selector. Con questo selettore \u00e8 poissibile scegliere un elemento tramite un attributo ed avere quindi anche in questo caso una selezione pi\u00f9 specifica. /* \"*\" Selector */ * { border : 1 px rgb ( 25 , 25 , 112 ) solid ; } /*Descendant selector*/ li a { color : lavenderblush ; } /*Attribute selector*/ a [ href = \"https://git-scm.com/\" ] { color : lightskyblue ; border : 2 px khaki outset ; } input [ type = \"email\" ] { border : 4 px #f5f5dc dotted ; } input [ type = \"password\" ] { border : 4 px gold dotted ; } Ci sono moltissimi altri selettori in CSS espressi in questo formato: a : visited { color : green ; } l'operatore : ci permette di accedere alla classe a per l'anchor tag e di selezionare l'elemento visited . In poche parole questo selettore colorer\u00e0 di verde soltanto i siti gi\u00e0 visitati. Vedremo che con l'operatore : o l'operatore :: \u00e8 possibile entrare in elementi e funzioni specifiche della classe. Molte di queste verranno suggerite dallo stesso editor di testo. Vediamo un esempio piuttosto completo di questi tipi di selettori File CSS a [ href = \"https://git-scm.com/\" ] { color : lightskyblue ; } a [ href = \"https://git-scm.com/\" ] : hover { color : red ; } input [ type = \"email\" ] { border : 4 px #f5f5dc dotted ; } input [ type = \"password\" ] { border : 4 px gold dotted ; } File HTML < form > < label for = \"email\" ></ label > < input id = \"email\" type = \"email\" placeholder = \"email\" required > < label for = \"password\" ></ label > < input id = \"email\" type = \"password\" placeholder = \"password\" required > </ form > < a href = \"https://git-scm.com/\" > git </ a > a[href=\"https://git-scm.com/\"] { color: lightskyblue; } a[href=\"https://git-scm.com/\"]:hover { color: red; } input[type=\"email\"]{ border: 4px #f5f5dc dotted; } input[type=\"password\"]{ border: 4px gold dotted; } git Lezione 06 Google developer tool Un importante strumento di debug e studio di codice html \u00e8 il tasto \"Ispeziona elemento\" presente su browser google chrome. Con questo tasto \u00e8 possibile vedere e modificare il codice html come il testo, il font, il colore, la formattazione e tutto quello che riguarda html/css. Nota: Tutte le modifiche che vengono fatte con questo strumento rimangono temporanee. Una volta aperto lo strumento si aprir\u00e0 una finestra con cui \u00e8 possibile visualizzare il codice. Premendo sul tasto \"select an element to inspect.. \" Lo strumento diventa ancora piu' interattivo. cliccando sugli elementi della pagina verranno evidenziati nel codice e viceversa. Eredit\u00e0 e Specificit\u00e0 in CSS Eredit\u00e0 Spiega le regole con cui, in CSS, vengono ereditate le propriet\u00e0. Ad esempio, se assegno come propriet\u00e0 il colore rosso all'elemento ul ogni elemento della ul avr\u00e0 il colore rosso poich\u00e8 la propriet\u00e0 \u00e8 ereditata dalla classe ul visto che \u00e8 di livello superiore. Un esempio simile pu\u00f2 essere fatto applicando questo concetto al body . Se assegno una certa propriet\u00e0 al body verr\u00e0 applicata a tutti gli elementi all'interno del body , cio\u00e8 tutta la pagina html. Questo \u00e8 per dire che certe propriet\u00e0 non importa specificarle perch\u00e8 verranno ereditate da altre. Specificit\u00e0 Spiega le regole con cui, in CSS, vengono applicate le propriet\u00e0 in base alla priorit\u00e0. Meglio far riferimento ad un esempio. body { color : gold ; } ul { color : grey ; } Consideriamo l'esempio di sopra. In questo esempio lo stile degli elementi ul \u00e8 in conflitto con lo stile del body che ricordiamo raggruppa tutti gli elementi della pagina html. Allora quale colore \"vince\"? Vince il colore dell'elemento ul poich\u00e8 \u00e8 pi\u00f9 specifico. Quindi la regola dice che pi\u00f9 l'elemento \u00e8 specifico pi\u00f9 ha priorit\u00e0 per la stilizzazione. Elementi di specificit\u00e0 sono anche le classi e gli id. Nota : Gli id sono quelli a priorit\u00e0 piu' alta in termini di specificit\u00e0. Lezione 07 CSS Fonts Vediamo alcune propriet\u00e0 per i font CSS. font-family font-weight font-size line-height text-align text-decoration Con queste propriet\u00e0 \u00e8 possibile impostare il font, lo spessore, la distanza tra le linee testuali, la grandezza del font, la formattazone testuale e alcune elementi decorativi testuali come ad esempio la sottolineatura. E' possibile trovare qualche esempio nelle esercitazioni. File CSS . par1 { font-family : Impact , Haettenschweiler , 'Arial Narrow Bold' , sans-serif ; } /*line-height seleziona la distanza, lo spazio che ci deve essere sia sopra che sotto dell'elemento, in questo caso della linea del paragrafo*/ . par2 { line-height : 60 px ; } /*font-weight seleziona lo spessore del font, range 100-900*/ . par3 { font-weight : 900 ; } /*font-size invece va a impostare la grandezza del font*/ . par4 { font-size : 100 px ; } /*text-align imposta la formattazione del testo: a destra, a sinistra, centrale..*/ . par5 { text-align : right ; } /*text-decoration pu\u00f2 essere utile per inserire testo sottolineato o altre decorazioni..*/ . par6 { text-decoration : underline ; } File HTML < p class = \"par1\" > sono un paragrafo della classe par1 </ p > < p class = \"par2\" > sono un paragrafo della classe par2 </ p > < p class = \"par3\" > sono un paragrafo della classe par3 </ p > < p class = \"par3\" > Anch'io sono un paragrafo della classe par3 </ p > < p class = \"par4\" > Io invece sono un paragrafo della classe par4 </ p > < p class = \"par5\" > Io invece sono un paragrafo della classe par5 </ p > < p class = \"par6\" > Io invece dovrei essere del testo sottolineato </ p > .par1{ font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif; } /*line-height seleziona la distanza, lo spazio che ci deve essere sia sopra che sotto dell'elemento, in questo caso della linea del paragrafo*/ .par2{ line-height: 100px; } /*font-weight seleziona lo spessore del font, range 100-900*/ .par3{ font-weight: 900; } /*font-size invece va a impostare la grandezza del font*/ .par4{ font-size: 10px; } /*text-align imposta la formattazione del testo: a destra, a sinistra, centrale..*/ .par5{ text-align: right; } /*text-decoration pu\u00f2 essere utile per inserire testo sottolineato o altre decorazioni..*/ .par6{ text-decoration: underline; } sono un paragrafo della classe par1 sono un paragrafo della classe par2 sono un paragrafo della classe par3 Io invece sono un paragrafo della classe par4 Io invece sono un paragrafo della classe par5 Io invece dovrei essere del testo sottolineato Google fonts I font forniti di default sono pochi e poco interessanti. Vediamo un modo per linkare fonts esterni come nel caso di \"google fonts\". Da https://fonts.google.com/ \u00e8 possibile per prima cosa scegliere un font che ci piace. E' possibile filtrare in base alle propriet\u00e0 del font che stiamo cercando. Una volta scelto un font \u00e8 possibile scaricarlo, verr\u00e0 scaricata una cartella zip oppure linkarlo. Un volta entrati all'interno del font desiderato, in alto a destra \u00e8 possibile selezionare \"Download Family\" oppure, accanto si aprir\u00e0 un quadratino con le istruzioni per linkarlo. In pratica si tratta di aggiungere un link nell <head> del codice html e di inserire il font nella sezione CSS che adesso lo riconoscer\u00e0. File CSS . par7 { background : brown ; color : whitesmoke ; font-family : 'Staatliches' , cursive ; } File HTML < head > < link href = \"https://fonts.googleapis.com/css2?family=Staatliches&display=swap\" rel = \"stylesheet\" > </ head > < p class = \"par7\" > Io invece dovrei essere un font diverso, preso da google fonts </ p > .par7{ background: brown; color: whitesmoke; font-family: 'Staatliches', cursive; } Io invece dovrei essere un font diverso, preso da google fonts Lezione 08 CSS Box Model Ogni elemento in html presenta questa struttura: C'\u00e8 quindi un contenuto ( content ), un bordo ( border ), uno spazio tra contenuto e bordo ( Padding ) e uno spazio tra il bordo e gli altri elementi ( Margin ). Questo box-model pu\u00f2 essere modificando andando a impostare queste propriet\u00e0: File CSS . par8 { background : brown ; color : white ; /*Box model*/ border : 4 px yellow solid ; padding : 40 px ; margin : 60 px ; } File HTML < p class = \"par8\" > Con questo paragrafo mi piacerebbe giocare con il box model. </ p > .par8 { background: brown; color: white; /*Box model*/ border: 4px yellow solid; padding: 40px; margin: 60px; } Con questo paragrafo mi piacerebbe giocare con il box model. Inoltre \u00e8 possibile impostare la grandezza del box tramite width , grandezza che pu\u00f2 essere espressa in modo relativo o percentuale e l'altezza del box attraverso height . E' possibile avere una granularit\u00e0 superiore andando a impostare anche, per ogni elemento del box, la dimensione di ogni lato del box. E' infatti possibile avere propriet\u00e0 come border-right o margin-bottom che andranno a impostare rispettivamente il bordo destro e il margine basso del box. Con questo si presenta infatti un altro modo per la formattazione del testo tramite il suo box. Usare margin-top , margin-right , margin-bottom , margin-left \u00e8 utile per selezionare spazi e formattare il contenuto dell'elemento da stilizzare. Esiste un modo per inserirli tutti e 4 insieme. Scrivendo direttamente margin \u00e8 possibile infatti inserire ogni grandezza del margin a partire dal margin-top e terminando con margin-left cio\u00e8 seguendo il bordo box in senso orario. p { margin : 10 px , 2 px , 4 px , 1 px ; } Equivale a: p { margin-top : 10 px ; margin-right : 2 px ; margin-bottom : 4 px ; margin-left : 1 px ; } Oppure se vogliamo il margin-top / margin-bottom uguali e margin-right / margin-left uguali \u00e8 possibile utilizzare sempre la propriet\u00e0 margin con due parametri. In questo caso, il primo parametro verr\u00e0 interpretato come il margin-top / margin-bottom mentre il secondo parametro verr\u00e0 interpretato come il margin-right / margin-left p { margin : 10 px , 2 px ; } Equivale a: p { margin-top : 10 px ; margin-bottom : 10 px ; margin-right : 2 px ; margin-left : 2 px ; } Un ulteriore importante attributo del margin \u00e8 l'attributo auto . Con auto \u00e8 possibile centrare l'elemento. Nell'esempio sotto, visto che margin-top / margin-bottom \u00e8 pari a 0px e visto che margin-right / margin-left \u00e8 impostato su auto , il paragrafo verr\u00e0 centrato in alto. p { margin : 0 px auto ; width : 50 % ; } E' importante tuttavia impostare la grandezza del box tramite la propriet\u00e0 width per dar modo di centrare rispetto alle dimensioni del box. E' chiaro che se il box ha una dimensione del 100% e quindi occupa tutta la pagina l'effetto di centratura non si ha perch\u00e8 di fatto il box \u00e8 gi\u00e0 centrato. Alcune Estensioni per VSCode Live Server: Permette di aprire la pagina HTML e aggiornare automaticamente le modifiche salvando il file Prettier: Permette di formattare il testo Block element Gli elementi html hanno degli attributi di default che dipendono dal tipo di elemento. Si distinguono in: Block-level Elements: Elementi che partono sempre su una nuova riga. Alcuni tra questi che conosciamo sono <div> , <li> , <h1> - <h6> , <p> , <form> , <ol> , <table> . Inline Elements: Sono elementi che non partono in una nuova riga. Tra questi troviamo ad esempio <bottom> , <select> Responsive Deign Come faccio ad ottenere una pagina che a seconda del dispositivo in uso ha una render diverso? Le pagine internet fatte come si deve hanno stili diversi che si tratti di uno smartphone, un PC o un tablet. Vediamo come si fa. Questo problema si risolve con le \"media queries\". Con \"@media\" \u00e8 possibile inserire delle propriet\u00e0 come \"max-width\" o \"min-width che definiscono lo stile solo per particolari dimensioni della pagina. E' quindi possibile creare dei range e definire diversi stili a seconda della pagina. @media (max-width: 500px){ /*inserisco lo stile che preferisco*/ } Dove e come si mettono le media queries? Possomo metterle all'interno della pagina HTML dove sta lo stile, quindi nell' <head> < head > < style > @ media ( min-width : 501px ) and ( max-width : 768px ) { /*stile per tablet (ad esempio)*/ } </ style > </ head > Oppure posso inserirle in un file \".css\" esterno metodo consigliato . Nel file \".css\" dovr\u00f2 solo specificare lo stile mentre nella pagina HTML dovr\u00f2 specificare la regola secondo questa sintassi. < head > < style > ... </ style > < link rel = \"stylesheet\" media = \"screen and (max-width:500px)\" href = \"style.css\" > </ head > Em / Rem Em/ Rem sono strumenti utili per regolare a piacimento il font senza dover per forza inserire dei valori assoluti. Ci aiutano quindi a mantenere le proporzioni partendo da un font assoluto e regolando tutti gli altri in modo \"relativo\". Esmprimendo la grandezza del font in \"em\" anzich\u00e8 in \"px\" si avr\u00e0 una misura relativa rispetto al valore di default < head > < style > # box-1 { font-size : 20 px ; } # box-1 p { font-size : 1.5 em ; } </ style > </ head > Nell'esempio di sopra avremo quindi che poich\u00e8 l'elemento con id \"box-1\" ha un font-size di 20px e il paragrafo all'interno dell'elemento con id \"box-1\" ha un font-size di 1.5em il risultato \u00e8 che il testo del paragrafo risulter\u00e0 di 30px cio\u00e8 1 volta e mezzo il suo valore di default. Nota Tutte le grandezze (margin, padding) del box dell'elemento <p> all'interno del \"box-1\" subiranno il fattore di 1,5. Di default gli elementi HTML hanno determinati valori di \"em\". Principalmente valgono 1em ma a volte troviamo valori strani come ad esempio per h1, h2, h3. Ad esempio per h3 troviamo 1.17em. Osservare come i valori assoluti cambino al variare del font-size mentre i valori relativi (em) rimangano tali. E' possibile inoltre analizzare e capire in dettaglio \"em\" con l'aiuto dell'elemento \"Inspect\" di google chrome. Con l'elemento rem invece si introduce un moltiplicatore rispetto al font-size root html. Il font-size root html \u00e8 il font che di default ha l'html e vale 16px. E' possibile cambiarlo in questo modo: < head > < style > html { font-size : 10 px ; } </ style > </ head > Di fatto quando in google chrome cambiamo il font della pagina, non viene fatto altro che cambiare il font-size. Esprimendo quindi una grandezza nell'unit\u00e0 di misura rem \u00e8 possibile cambiarne il font a partire da tale elemento. < head > < style > html { font-size : 10 px ; } # box-1 h3 { font-size : 2 rem ; } </ style > </ head > l'elemento h3 con id \"box-1\" avr\u00e0 quindi font-size pari a 20px. Considerazione finale em/rem: Le misure espressse in rem dipendono soltanto dal font-size root. Le misure espresse in em dipendono dal font-size stabilito per quel box. Se per quel box non \u00e8 stato stabilito nessuno font-size, anch'esse dipendono dal font size root html. VH/VW < head > < style > . header { background : burlywood ; height : 100 vh ; width : 50 vw ; } </ style > </ head > Una pagina html \u00e8 divisa in 100 parti in altezza e 100 parti in larghezza. Nell'esempio \u00e8 stato impostata una height di 100vh. Questo significa che lo stile prender\u00e0 tutta la pagina: Se mettessi una height di 90vh andrebbe a prendere 9 parti su 10 in altezza e cos\u00ec via Per cosa pu\u00f2 essere utile?In certi siti troviamo questo pattern molto frequentemente. Un header con una height di 100vh e.. tutto il resto. Quello che succede \u00e8 che mettendo elementi dopo l'header che ha una height di 100vh compariranno solo dopu uno scrolling Nota che impostanto 100vh lo stile coprir\u00e0 l'intera pagina a prescindere dalle dimensioni quindi \u00e8 responsive. Se provi a mettere una 50vh vedi che la classe si prender\u00e0 50 parti su 100 in altezza, quindi met\u00e0 pagina a prescidere dalle dimensioni Stessa cosa vale impostando width con un valore epresso con vw. In questo caso ovviamente va a selezionare le parti in orizzontale. E' un po' meno frequente ma a volte pu\u00f2 far comodo FLEXBOX E' per creare un layout. Ordina gli elementi in orizzontale e in verticale. E' utile per responsive design, \u00e8 molto moderno. Supponiamo di prendere un elemento \"div\". Consideriamo il flexbox come tutto il contenitore contenente il Div, per far ci\u00f2 dobbiamo impostare la propriet\u00e0 display a flex. Gli elementi all'interno del div sono i flex item WEB HOSTING Il web hosting \u00e8 uno spazio, un cloud online dove poter ospitare il nostro sito web. Per poter pubblicare online il nostro sito c'\u00e8 bisogno di un server, cio\u00e8 un computer costantemente connesso alla rete che permette a un browser di trovare il proprio sito grazie all'indirizzo. Ecco le alternative possibili: Shared Hosting VPS Hosting Dedicated Server Cloud Hosting Static Hosting Shared Hosting Il pi\u00f9 economico: dai 3 ai 15 euro al mese. Ospita diversi account sullo stesso server Pu\u00f2 essere usato per piccoli siti web Ricco di features: Puoi caricare file tramite FTP (FIle transfer protocol) VPS (Virtual Private Server) COsto: 15 - 100 euro al mese Ci sono meno persone sullo stesso server in cui ognuno \u00e8 nel proprio ambiente. E' piu' sicuro per questo e ci sono meno problemi. Ci sono pi\u00f9 privilegi (SSH) Ha le stesse features dello shared hosting Dedicated Server Costo: 100 - 400 euro al mese E' un server personale, non ospita nessun altro, si affitta proprio una macchina fisica Si ha pieno accesso e privilegi perch\u00e8 \u00e8 di fatto una macchina personale E' usato per grandi siti web e grandi applicazioni E' molto potente ma anche molto difficile da usare Cloud Hosting Costo: paghi a seconda del bisogno cio\u00e8 a seconda della quantit\u00e0 di dati che usi Usato per web apps Scalabile e adatto anche per grandi applicazioni Piu' difficile da usare rispetto a shared hosting Static Hosting COsto: Gratis ma paghi gli extra Pochi strumenti disponibili SI carica il sito web con GIT Adatto per siti web statici","title":"CSS"},{"location":"css/#css","text":"CSS Lezione 01 Dove inserire il codice CSS? Inserire CSS all'interno della pagina HTML Inserire CSS in un file esterno all'HTML Lezione 02 Alcune propriet\u00e0 CSS Colori in CSS Colore CSS Esadecimale Perch\u00e8 \u00e8 utile questo metodo? Colore CSS RGB/RGBA Lezione 03 Background CSS background-repeat: no-repeat; background-size: cover; Bordi CSS Quindi Lezione 04 Se volessi stilizzare in modo diverso un elemento appartenente alla stessa categoria? Si pu\u00f2 fare attraverso l'id Si pu\u00f2 fare anche attraverso l'uso di una classe ## Lezione 05 Altri selettori CSS * Selector Descendant Selector. Attribute selector. ## Lezione 06 Google developer tool Eredit\u00e0 e Specificit\u00e0 in CSS Eredit\u00e0 Specificit\u00e0 ## Lezione 07 CSS Fonts Google fonts ## Lezione 08 CSS Box Model Alcune Estensioni per VSCode Block element Responsive Deign Em / Rem VH/VW FLEXBOX WEB HOSTING Shared Hosting VPS (Virtual Private Server) Dedicated Server Cloud Hosting Static Hosting","title":"CSS"},{"location":"css/#lezione-01","text":"Come abbiamo gi\u00e0 detto, CSS sta per Cascading Style Sheet e serve quindi per \"abbellire\" lo stile nativo della pagina HTML. Vediamo la struttura del codice CSS: selettore { propriet\u00e01 : valore ; propriet\u00e02 : valore ; } Esempi: Nell'esempio seguente attribuir\u00f2 al selettore h1 il colore \"blue\" e un font di \"30 pixel\". h1 { color : blue ; font-size : 30 px ; } In questo esempio invece all'attributo immagine associer\u00f2 un bordo giallo di grandezza di 3 pixel. img { border-color : yellow ; border-width : 3 px ; }","title":"Lezione 01"},{"location":"css/#dove-inserire-il-codice-css","text":"E' possibile aggiungere il codice CSS sia all'interno del file HTML, sia in un file esterno.","title":"Dove inserire il codice CSS?"},{"location":"css/#inserire-css-allinterno-della-pagina-html","text":"Per questo metodo ci sono due modi: Inserire la stilizzazione CSS all'interno della riga da stilizzare con l'attributo style . Questo metodo \u00e8 sconsigliato, si faceva una volta quando il CSS non esisteva ma oggi \u00e8 ancora valido. < p style = \"color: red;\" > sono un paragrafo rosso </ p > sono un paragrafo rosso Inserire la stilizzazione CSS con il tag <style></style> messo all'interno del tag <head></head> del boilerplate html. Questo \u00e8 consigliato poich\u00e8 in questo modo avremo tutto ci\u00f2 che riguarda lo stile all'interno di questo tag. <!DOCTYPE html> < html > < head > < style type = \"text/css\" > h1 { color : blue ; } </ style > </ head > < body > < h1 > Ciao, sono un h1 </ h1 > </ body > </ html >","title":"Inserire CSS all'interno della pagina HTML"},{"location":"css/#inserire-css-in-un-file-esterno-allhtml","text":"Questa \u00e8 sicuramente la soluzione migliore , \u00e8 la pi\u00f9 pulita e ordinata poich\u00e8 separa il contenuto HTML che stabilisce la struttura della pagina dallo stile della stessa tramite CSS. Una volta creato poi sar\u00e0 necessario creare un collegamento tra i due file usando il <link> tag. Ecco un esempio: File CSS (06_HTML_CSS_Style.css) h1 { color : black ; background : yellow ; } li { color : forestgreen ; } File HTML (06_HTML_CSS_ElementiBaseCSSEsterniAdHTML.html) <!DOCTYPE html> < html lang = \"en\" > < head > < title > HTML - CSS Elementi Base </ title > < link rel = \"stylesheet\" href = \"06_HTML_CSS_Style.css\" > </ head > < body > < h1 > HTML - CSS Elementi Base </ h1 > < ul > < li > Primo ELemento </ li > < li > Secondo Elemento </ li > </ ul > </ body > </ html > HTML - CSS Elementi Base #h1_0 { color: black; background: yellow; } #ul_0 li{ color: green; }","title":"Inserire CSS in un file esterno all'HTML"},{"location":"css/#lezione-02","text":"","title":"Lezione 02"},{"location":"css/#alcune-proprieta-css","text":"In questo esempio riporter\u00f2 alcune propriet\u00e0 come l'inserimento di colori, bordi, immagini di background. Alcune propriet\u00e0 sono rappresentate in modo diverso ma equivalenti.","title":"Alcune propriet\u00e0 CSS"},{"location":"css/#colori-in-css","text":"Vediamo come \u00e8 possibile esprimere i colori in CSS. Il metodo che abbiamo visto per adesso \u00e8 un metodo \"amatoriale\" ma non \u00e8 il metodo che i programmatori utilizzano. Un altro metodo \u00e8 utilizzare il valore corrispondente esadecimale del colore .","title":"Colori in CSS"},{"location":"css/#colore-css-esadecimale","text":"Ogni colore pu\u00f2 essere espresso tramite una terna di valori esadecimali: RED-GREEN-BLUE a1 - f6 - 18 Ad ogni elemento della terna sono associati due numeri esadecimali in modo tale che il numero vada da 0 a 255. Cio' esprime l'intensit\u00e0 del colore appartenente alla terna. Con tale terna \u00e8 possibile rappresentare ogni tipo di colore. Per rappresentare in CSS il colore in esadecimale \u00e8 necessario anteporre al numero di sei cifre che rappresenta il colore il simbolo # Es: red = #ff0000 (ovviamente)","title":"Colore CSS Esadecimale"},{"location":"css/#perche-e-utile-questo-metodo","text":"Supponiamo di voler un colore specifico da creare utilizzando un qualsiasi color picker Scegliendo tramite il color picker il colore desiderato e prelevando il valore esadecimale \u00e8 possibile ottenere esattamente il valore creato. Molto utile e versatile rispetto a una serie di colori preimpostati.","title":"Perch\u00e8 \u00e8 utile questo metodo?"},{"location":"css/#colore-css-rgbrgba","text":"Un altro metodo \u00e8 utilizzare la terna rgb() . Funziona in modo molto simile ai colori in esadecimale, solo che in questo caso inseriremo una terna decimale nel range 0 -255 . Esempio: rgb(173, 255, 47) . La funzione rgba() invece introduce l'elemento trasparenza (alpha). L'ultimo elemento infatti va da 0.0 - 1.0 e rappresenta la trasparenza dell'elemento. Esempio: rgba(34, 139, 34, 0.2) , in questo caso la trasparenza sar\u00e0 al 20%.","title":"Colore CSS RGB/RGBA"},{"location":"css/#lezione-03","text":"","title":"Lezione 03"},{"location":"css/#background-css","text":"Con la propriet\u00e0 background \u00e8 possibile specificare il colore del background dell'elemento. Utile la propriet\u00e0 background per impostare un colore della pagina. Per far ci\u00f2 \u00e8 possibile impostare la propriet\u00e0 background per l'elemento body : E' possibile impostare anche un'immagine. Per far ci\u00f2 si usa la funzione url() . All'interno della funzione url inseriamo il link dell'immagine che vogliamo rappresentare come sfondo background della pagina. E' possibile impostare anche alcune propriet\u00e0 aggiuntiva come la background-reapeat o la background-size .","title":"Background CSS"},{"location":"css/#background-repeat-no-repeat","text":"Con questa propriet\u00e0 \u00e8 possibile specificare se ripetere o meno l'immagine. Infatti di default, se l'immagine \u00e8 piccola viene ripetuta, se \u00e8 grande viene adattata alla pagina. Con questa propriet\u00e0 quindi possibile specificare se ripetere o meno l'immagine.","title":"background-repeat: no-repeat;"},{"location":"css/#background-size-cover","text":"Con questa propriet\u00e0 l'immagine selezionata andr\u00e0 a riempire tutto lo schermo e se \u00e8 piu' piccola la adatter\u00e0.","title":"background-size: cover;"},{"location":"css/#bordi-css","text":"Per inserire il bordo all'elemento html \u00e8 necessario introdurre la proprit\u00e0 border . Sar\u00e0 necessario impostare almeno border-color per inserire il colore del bordo, border-width per la grandezza del bordo e border-style per scegliere lo stile del bordo. Oppure \u00e8 possibile inserire la proprit\u00e0 bordo tramite una terna di valori che comprendono la grandezza, lo stile e il colore direttamente con la propriet\u00e0 border","title":"Bordi CSS"},{"location":"css/#quindi","text":"Abbiamo imparato a stilizzare modificando propriet\u00e0 come la grandezza del font, il colore, inserendo un bordo, un'immagine di propriet\u00e0 e abbiamo visto che ci\u00f2 si applica ad ogni elemento appartenente alla stessa categoria (detta anche classe), ad esempio l'elemento <li> . Questo significa che se assegner\u00f2 certe propriet\u00e0 all'elemento <li> queste verranno applicate a tutti gli elementi <li> File style.css h1 { color : darkslategray ; border : 2 px rgb ( 173 , 255 , 47 ) solid ; background : grey ; } li { color : rgba ( 34 , 139 , 34 , 0.5 ); border-color : #000000 ; border-width : 2 px ; border-style : groove ; } body { background : url ( https://i.pinimg.com/originals/60/19/89/601989ff441ddc92bc0fa2e05040f9e7.jpg ); background-repeat : no-repeat ; background-size : cover ; } File index.html <!DOCTYPE html> < html lang = \"en\" > < head > < title > HTML - CSS Elementi Base </ title > < link rel = \"stylesheet\" href = \"style.css\" > </ head > < body > < h1 > HTML - CSS Elementi Base </ h1 > < ul > < li > Primo ELemento </ li > < li > Secondo Elemento </ li > </ ul > </ body > </ html > HTML - CSS Elementi Base #h1_01 { color: darkslategray; border: 2px rgb(173, 255, 47) solid; background: grey; } #ul li{ color: rgba(34, 139, 34, 0.5); border-color: #000000; border-width: 2px; border-style: groove; } #body_01{ background: url(https://i.pinimg.com/originals/60/19/89/601989ff441ddc92bc0fa2e05040f9e7.jpg); background-repeat: no-repeat; background-size: cover; height: 400px; }","title":"Quindi"},{"location":"css/#lezione-04","text":"","title":"Lezione 04"},{"location":"css/#se-volessi-stilizzare-in-modo-diverso-un-elemento-appartenente-alla-stessa-categoria","text":"Supponiamo quindi ad esempio di scegliere uno stile di default per l'elemento <li> ma di voler cambiare lo stile di un particolare elemento. Come si fa?","title":"Se volessi stilizzare in modo diverso un elemento appartenente alla stessa categoria?"},{"location":"css/#si-puo-fare-attraverso-lid","text":"Ecco un esempio: File HTML ```HTML Primo ELemento Secondo Elemento speciale `File CSS` CSS","title":"Si pu\u00f2 fare attraverso l'id"},{"location":"css/#speciale","text":"color: red; } `` In questo modo, solo cio' che avr\u00e0 l'id speciale` avr\u00e0 quella classe di propriet\u00e0. Nota che l'id deve essere unico nel codice! Il nome simbolico che fornisco deve essere unico per tutto il codice","title":"speciale {"},{"location":"css/#si-puo-fare-anche-attraverso-luso-di-una-classe","text":"Questo \u00e8 un metodo migliore. In questo caso attribuendo un elemento a una classe con un certo nome \u00e8 possibile impostare lo stile solo agli elementi di quella data classe. File HTML ```HTML Primo ELemento non appartenente a nessuna classe Secondo Elemento appartenente alla classe \"bluColor\" Terzo Elemento appartenente alla classe \"bluColor\" `File CSS` CSS .bluColor { color: blue; } ``` In questo caso verrano colorati di colore \"indigo\" solo gli elementi appartenenti alla classe \"bluColor\". Nota In CSS gli id si identificano inserendo # + il nome dell' id mentre le classi si identidicano tramite . seguito dal nome della classe. File CSS # speciale { color : red ; } . bluColor { color : blue ; } File HTML < head > < title > HTML - CSS Elementi Base </ title > < link href = \"https://fonts.googleapis.com/css2?family=Staatliches&display=swap\" rel = \"stylesheet\" > < link rel = \"stylesheet\" href = \"style.css\" > </ head > < body > < h1 > HTML - CSS Elementi Base </ h1 > < ul > < li > Primo ELemento </ li > < li > Secondo Elemento </ li > </ ul > < ul > < li > Primo ELemento </ li > < li id = \"speciale\" > Secondo Elemento speciale </ li > </ ul > < ul > < li > Primo ELemento non appartenente a nessuna classe </ li > < li class = \"bluColor\" > Secondo Elemento appartenente alla classe \"bluColor\" </ li > < li class = \"bluColor\" > Terzo Elemento appartenente alla classe \"bluColor\" </ li > </ ul > </ body > HTML - CSS Elementi Base #speciale { color: red; } .bluColor { color: blue; }","title":"Si pu\u00f2 fare anche attraverso l'uso di una classe"},{"location":"css/#lezione-05","text":"","title":"Lezione 05"},{"location":"css/#altri-selettori-css","text":"Ricordiamo che il selettore permette appunto di selezionare l'elemento ch vogliamo stilizzare. Per adesso abbiamo visto i selettori generici per ogni elemento html, i selettori definiti da una classe e da un id ma ne esistono altri.","title":"Altri selettori CSS"},{"location":"css/#selector","text":"Con questo selettore \u00e8 possibile selezionare ogni elemento della pagina HTML.","title":"* Selector"},{"location":"css/#descendant-selector","text":"Con questo selettore \u00e8 possibile selezionare elementi complessi ovvero elementi contenuti in altri elementi, elementi discentendi da altri appunto. Immaginiamo di creare una lista di elementi e immaginiamo che ogni elemento \u00e8 un anchor tag. Con questo selettore \u00e8 possibile selezionare solo gli anchor tag all'interno del list item. Sono possibili diverse combinazioni.","title":"Descendant Selector."},{"location":"css/#attribute-selector","text":"Con questo selettore \u00e8 poissibile scegliere un elemento tramite un attributo ed avere quindi anche in questo caso una selezione pi\u00f9 specifica. /* \"*\" Selector */ * { border : 1 px rgb ( 25 , 25 , 112 ) solid ; } /*Descendant selector*/ li a { color : lavenderblush ; } /*Attribute selector*/ a [ href = \"https://git-scm.com/\" ] { color : lightskyblue ; border : 2 px khaki outset ; } input [ type = \"email\" ] { border : 4 px #f5f5dc dotted ; } input [ type = \"password\" ] { border : 4 px gold dotted ; } Ci sono moltissimi altri selettori in CSS espressi in questo formato: a : visited { color : green ; } l'operatore : ci permette di accedere alla classe a per l'anchor tag e di selezionare l'elemento visited . In poche parole questo selettore colorer\u00e0 di verde soltanto i siti gi\u00e0 visitati. Vedremo che con l'operatore : o l'operatore :: \u00e8 possibile entrare in elementi e funzioni specifiche della classe. Molte di queste verranno suggerite dallo stesso editor di testo. Vediamo un esempio piuttosto completo di questi tipi di selettori File CSS a [ href = \"https://git-scm.com/\" ] { color : lightskyblue ; } a [ href = \"https://git-scm.com/\" ] : hover { color : red ; } input [ type = \"email\" ] { border : 4 px #f5f5dc dotted ; } input [ type = \"password\" ] { border : 4 px gold dotted ; } File HTML < form > < label for = \"email\" ></ label > < input id = \"email\" type = \"email\" placeholder = \"email\" required > < label for = \"password\" ></ label > < input id = \"email\" type = \"password\" placeholder = \"password\" required > </ form > < a href = \"https://git-scm.com/\" > git </ a > a[href=\"https://git-scm.com/\"] { color: lightskyblue; } a[href=\"https://git-scm.com/\"]:hover { color: red; } input[type=\"email\"]{ border: 4px #f5f5dc dotted; } input[type=\"password\"]{ border: 4px gold dotted; } git","title":"Attribute selector."},{"location":"css/#lezione-06","text":"","title":"Lezione 06"},{"location":"css/#google-developer-tool","text":"Un importante strumento di debug e studio di codice html \u00e8 il tasto \"Ispeziona elemento\" presente su browser google chrome. Con questo tasto \u00e8 possibile vedere e modificare il codice html come il testo, il font, il colore, la formattazione e tutto quello che riguarda html/css. Nota: Tutte le modifiche che vengono fatte con questo strumento rimangono temporanee. Una volta aperto lo strumento si aprir\u00e0 una finestra con cui \u00e8 possibile visualizzare il codice. Premendo sul tasto \"select an element to inspect.. \" Lo strumento diventa ancora piu' interattivo. cliccando sugli elementi della pagina verranno evidenziati nel codice e viceversa.","title":"Google developer tool"},{"location":"css/#eredita-e-specificita-in-css","text":"","title":"Eredit\u00e0 e Specificit\u00e0 in CSS"},{"location":"css/#eredita","text":"Spiega le regole con cui, in CSS, vengono ereditate le propriet\u00e0. Ad esempio, se assegno come propriet\u00e0 il colore rosso all'elemento ul ogni elemento della ul avr\u00e0 il colore rosso poich\u00e8 la propriet\u00e0 \u00e8 ereditata dalla classe ul visto che \u00e8 di livello superiore. Un esempio simile pu\u00f2 essere fatto applicando questo concetto al body . Se assegno una certa propriet\u00e0 al body verr\u00e0 applicata a tutti gli elementi all'interno del body , cio\u00e8 tutta la pagina html. Questo \u00e8 per dire che certe propriet\u00e0 non importa specificarle perch\u00e8 verranno ereditate da altre.","title":"Eredit\u00e0"},{"location":"css/#specificita","text":"Spiega le regole con cui, in CSS, vengono applicate le propriet\u00e0 in base alla priorit\u00e0. Meglio far riferimento ad un esempio. body { color : gold ; } ul { color : grey ; } Consideriamo l'esempio di sopra. In questo esempio lo stile degli elementi ul \u00e8 in conflitto con lo stile del body che ricordiamo raggruppa tutti gli elementi della pagina html. Allora quale colore \"vince\"? Vince il colore dell'elemento ul poich\u00e8 \u00e8 pi\u00f9 specifico. Quindi la regola dice che pi\u00f9 l'elemento \u00e8 specifico pi\u00f9 ha priorit\u00e0 per la stilizzazione. Elementi di specificit\u00e0 sono anche le classi e gli id. Nota : Gli id sono quelli a priorit\u00e0 piu' alta in termini di specificit\u00e0.","title":"Specificit\u00e0"},{"location":"css/#lezione-07","text":"","title":"Lezione 07"},{"location":"css/#css-fonts","text":"Vediamo alcune propriet\u00e0 per i font CSS. font-family font-weight font-size line-height text-align text-decoration Con queste propriet\u00e0 \u00e8 possibile impostare il font, lo spessore, la distanza tra le linee testuali, la grandezza del font, la formattazone testuale e alcune elementi decorativi testuali come ad esempio la sottolineatura. E' possibile trovare qualche esempio nelle esercitazioni. File CSS . par1 { font-family : Impact , Haettenschweiler , 'Arial Narrow Bold' , sans-serif ; } /*line-height seleziona la distanza, lo spazio che ci deve essere sia sopra che sotto dell'elemento, in questo caso della linea del paragrafo*/ . par2 { line-height : 60 px ; } /*font-weight seleziona lo spessore del font, range 100-900*/ . par3 { font-weight : 900 ; } /*font-size invece va a impostare la grandezza del font*/ . par4 { font-size : 100 px ; } /*text-align imposta la formattazione del testo: a destra, a sinistra, centrale..*/ . par5 { text-align : right ; } /*text-decoration pu\u00f2 essere utile per inserire testo sottolineato o altre decorazioni..*/ . par6 { text-decoration : underline ; } File HTML < p class = \"par1\" > sono un paragrafo della classe par1 </ p > < p class = \"par2\" > sono un paragrafo della classe par2 </ p > < p class = \"par3\" > sono un paragrafo della classe par3 </ p > < p class = \"par3\" > Anch'io sono un paragrafo della classe par3 </ p > < p class = \"par4\" > Io invece sono un paragrafo della classe par4 </ p > < p class = \"par5\" > Io invece sono un paragrafo della classe par5 </ p > < p class = \"par6\" > Io invece dovrei essere del testo sottolineato </ p > .par1{ font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif; } /*line-height seleziona la distanza, lo spazio che ci deve essere sia sopra che sotto dell'elemento, in questo caso della linea del paragrafo*/ .par2{ line-height: 100px; } /*font-weight seleziona lo spessore del font, range 100-900*/ .par3{ font-weight: 900; } /*font-size invece va a impostare la grandezza del font*/ .par4{ font-size: 10px; } /*text-align imposta la formattazione del testo: a destra, a sinistra, centrale..*/ .par5{ text-align: right; } /*text-decoration pu\u00f2 essere utile per inserire testo sottolineato o altre decorazioni..*/ .par6{ text-decoration: underline; } sono un paragrafo della classe par1 sono un paragrafo della classe par2 sono un paragrafo della classe par3 Io invece sono un paragrafo della classe par4 Io invece sono un paragrafo della classe par5 Io invece dovrei essere del testo sottolineato","title":"CSS Fonts"},{"location":"css/#google-fonts","text":"I font forniti di default sono pochi e poco interessanti. Vediamo un modo per linkare fonts esterni come nel caso di \"google fonts\". Da https://fonts.google.com/ \u00e8 possibile per prima cosa scegliere un font che ci piace. E' possibile filtrare in base alle propriet\u00e0 del font che stiamo cercando. Una volta scelto un font \u00e8 possibile scaricarlo, verr\u00e0 scaricata una cartella zip oppure linkarlo. Un volta entrati all'interno del font desiderato, in alto a destra \u00e8 possibile selezionare \"Download Family\" oppure, accanto si aprir\u00e0 un quadratino con le istruzioni per linkarlo. In pratica si tratta di aggiungere un link nell <head> del codice html e di inserire il font nella sezione CSS che adesso lo riconoscer\u00e0. File CSS . par7 { background : brown ; color : whitesmoke ; font-family : 'Staatliches' , cursive ; } File HTML < head > < link href = \"https://fonts.googleapis.com/css2?family=Staatliches&display=swap\" rel = \"stylesheet\" > </ head > < p class = \"par7\" > Io invece dovrei essere un font diverso, preso da google fonts </ p > .par7{ background: brown; color: whitesmoke; font-family: 'Staatliches', cursive; } Io invece dovrei essere un font diverso, preso da google fonts","title":"Google fonts"},{"location":"css/#lezione-08","text":"","title":"Lezione 08"},{"location":"css/#css-box-model","text":"Ogni elemento in html presenta questa struttura: C'\u00e8 quindi un contenuto ( content ), un bordo ( border ), uno spazio tra contenuto e bordo ( Padding ) e uno spazio tra il bordo e gli altri elementi ( Margin ). Questo box-model pu\u00f2 essere modificando andando a impostare queste propriet\u00e0: File CSS . par8 { background : brown ; color : white ; /*Box model*/ border : 4 px yellow solid ; padding : 40 px ; margin : 60 px ; } File HTML < p class = \"par8\" > Con questo paragrafo mi piacerebbe giocare con il box model. </ p > .par8 { background: brown; color: white; /*Box model*/ border: 4px yellow solid; padding: 40px; margin: 60px; } Con questo paragrafo mi piacerebbe giocare con il box model. Inoltre \u00e8 possibile impostare la grandezza del box tramite width , grandezza che pu\u00f2 essere espressa in modo relativo o percentuale e l'altezza del box attraverso height . E' possibile avere una granularit\u00e0 superiore andando a impostare anche, per ogni elemento del box, la dimensione di ogni lato del box. E' infatti possibile avere propriet\u00e0 come border-right o margin-bottom che andranno a impostare rispettivamente il bordo destro e il margine basso del box. Con questo si presenta infatti un altro modo per la formattazione del testo tramite il suo box. Usare margin-top , margin-right , margin-bottom , margin-left \u00e8 utile per selezionare spazi e formattare il contenuto dell'elemento da stilizzare. Esiste un modo per inserirli tutti e 4 insieme. Scrivendo direttamente margin \u00e8 possibile infatti inserire ogni grandezza del margin a partire dal margin-top e terminando con margin-left cio\u00e8 seguendo il bordo box in senso orario. p { margin : 10 px , 2 px , 4 px , 1 px ; } Equivale a: p { margin-top : 10 px ; margin-right : 2 px ; margin-bottom : 4 px ; margin-left : 1 px ; } Oppure se vogliamo il margin-top / margin-bottom uguali e margin-right / margin-left uguali \u00e8 possibile utilizzare sempre la propriet\u00e0 margin con due parametri. In questo caso, il primo parametro verr\u00e0 interpretato come il margin-top / margin-bottom mentre il secondo parametro verr\u00e0 interpretato come il margin-right / margin-left p { margin : 10 px , 2 px ; } Equivale a: p { margin-top : 10 px ; margin-bottom : 10 px ; margin-right : 2 px ; margin-left : 2 px ; } Un ulteriore importante attributo del margin \u00e8 l'attributo auto . Con auto \u00e8 possibile centrare l'elemento. Nell'esempio sotto, visto che margin-top / margin-bottom \u00e8 pari a 0px e visto che margin-right / margin-left \u00e8 impostato su auto , il paragrafo verr\u00e0 centrato in alto. p { margin : 0 px auto ; width : 50 % ; } E' importante tuttavia impostare la grandezza del box tramite la propriet\u00e0 width per dar modo di centrare rispetto alle dimensioni del box. E' chiaro che se il box ha una dimensione del 100% e quindi occupa tutta la pagina l'effetto di centratura non si ha perch\u00e8 di fatto il box \u00e8 gi\u00e0 centrato.","title":"CSS Box Model"},{"location":"css/#alcune-estensioni-per-vscode","text":"Live Server: Permette di aprire la pagina HTML e aggiornare automaticamente le modifiche salvando il file Prettier: Permette di formattare il testo","title":"Alcune Estensioni per VSCode"},{"location":"css/#block-element","text":"Gli elementi html hanno degli attributi di default che dipendono dal tipo di elemento. Si distinguono in: Block-level Elements: Elementi che partono sempre su una nuova riga. Alcuni tra questi che conosciamo sono <div> , <li> , <h1> - <h6> , <p> , <form> , <ol> , <table> . Inline Elements: Sono elementi che non partono in una nuova riga. Tra questi troviamo ad esempio <bottom> , <select>","title":"Block element"},{"location":"css/#responsive-deign","text":"Come faccio ad ottenere una pagina che a seconda del dispositivo in uso ha una render diverso? Le pagine internet fatte come si deve hanno stili diversi che si tratti di uno smartphone, un PC o un tablet. Vediamo come si fa. Questo problema si risolve con le \"media queries\". Con \"@media\" \u00e8 possibile inserire delle propriet\u00e0 come \"max-width\" o \"min-width che definiscono lo stile solo per particolari dimensioni della pagina. E' quindi possibile creare dei range e definire diversi stili a seconda della pagina. @media (max-width: 500px){ /*inserisco lo stile che preferisco*/ } Dove e come si mettono le media queries? Possomo metterle all'interno della pagina HTML dove sta lo stile, quindi nell' <head> < head > < style > @ media ( min-width : 501px ) and ( max-width : 768px ) { /*stile per tablet (ad esempio)*/ } </ style > </ head > Oppure posso inserirle in un file \".css\" esterno metodo consigliato . Nel file \".css\" dovr\u00f2 solo specificare lo stile mentre nella pagina HTML dovr\u00f2 specificare la regola secondo questa sintassi. < head > < style > ... </ style > < link rel = \"stylesheet\" media = \"screen and (max-width:500px)\" href = \"style.css\" > </ head >","title":"Responsive Deign"},{"location":"css/#em-rem","text":"Em/ Rem sono strumenti utili per regolare a piacimento il font senza dover per forza inserire dei valori assoluti. Ci aiutano quindi a mantenere le proporzioni partendo da un font assoluto e regolando tutti gli altri in modo \"relativo\". Esmprimendo la grandezza del font in \"em\" anzich\u00e8 in \"px\" si avr\u00e0 una misura relativa rispetto al valore di default < head > < style > # box-1 { font-size : 20 px ; } # box-1 p { font-size : 1.5 em ; } </ style > </ head > Nell'esempio di sopra avremo quindi che poich\u00e8 l'elemento con id \"box-1\" ha un font-size di 20px e il paragrafo all'interno dell'elemento con id \"box-1\" ha un font-size di 1.5em il risultato \u00e8 che il testo del paragrafo risulter\u00e0 di 30px cio\u00e8 1 volta e mezzo il suo valore di default. Nota Tutte le grandezze (margin, padding) del box dell'elemento <p> all'interno del \"box-1\" subiranno il fattore di 1,5. Di default gli elementi HTML hanno determinati valori di \"em\". Principalmente valgono 1em ma a volte troviamo valori strani come ad esempio per h1, h2, h3. Ad esempio per h3 troviamo 1.17em. Osservare come i valori assoluti cambino al variare del font-size mentre i valori relativi (em) rimangano tali. E' possibile inoltre analizzare e capire in dettaglio \"em\" con l'aiuto dell'elemento \"Inspect\" di google chrome. Con l'elemento rem invece si introduce un moltiplicatore rispetto al font-size root html. Il font-size root html \u00e8 il font che di default ha l'html e vale 16px. E' possibile cambiarlo in questo modo: < head > < style > html { font-size : 10 px ; } </ style > </ head > Di fatto quando in google chrome cambiamo il font della pagina, non viene fatto altro che cambiare il font-size. Esprimendo quindi una grandezza nell'unit\u00e0 di misura rem \u00e8 possibile cambiarne il font a partire da tale elemento. < head > < style > html { font-size : 10 px ; } # box-1 h3 { font-size : 2 rem ; } </ style > </ head > l'elemento h3 con id \"box-1\" avr\u00e0 quindi font-size pari a 20px. Considerazione finale em/rem: Le misure espressse in rem dipendono soltanto dal font-size root. Le misure espresse in em dipendono dal font-size stabilito per quel box. Se per quel box non \u00e8 stato stabilito nessuno font-size, anch'esse dipendono dal font size root html.","title":"Em / Rem"},{"location":"css/#vhvw","text":"< head > < style > . header { background : burlywood ; height : 100 vh ; width : 50 vw ; } </ style > </ head > Una pagina html \u00e8 divisa in 100 parti in altezza e 100 parti in larghezza. Nell'esempio \u00e8 stato impostata una height di 100vh. Questo significa che lo stile prender\u00e0 tutta la pagina: Se mettessi una height di 90vh andrebbe a prendere 9 parti su 10 in altezza e cos\u00ec via Per cosa pu\u00f2 essere utile?In certi siti troviamo questo pattern molto frequentemente. Un header con una height di 100vh e.. tutto il resto. Quello che succede \u00e8 che mettendo elementi dopo l'header che ha una height di 100vh compariranno solo dopu uno scrolling Nota che impostanto 100vh lo stile coprir\u00e0 l'intera pagina a prescindere dalle dimensioni quindi \u00e8 responsive. Se provi a mettere una 50vh vedi che la classe si prender\u00e0 50 parti su 100 in altezza, quindi met\u00e0 pagina a prescidere dalle dimensioni Stessa cosa vale impostando width con un valore epresso con vw. In questo caso ovviamente va a selezionare le parti in orizzontale. E' un po' meno frequente ma a volte pu\u00f2 far comodo","title":"VH/VW"},{"location":"css/#flexbox","text":"E' per creare un layout. Ordina gli elementi in orizzontale e in verticale. E' utile per responsive design, \u00e8 molto moderno. Supponiamo di prendere un elemento \"div\". Consideriamo il flexbox come tutto il contenitore contenente il Div, per far ci\u00f2 dobbiamo impostare la propriet\u00e0 display a flex. Gli elementi all'interno del div sono i flex item","title":"FLEXBOX"},{"location":"css/#web-hosting","text":"Il web hosting \u00e8 uno spazio, un cloud online dove poter ospitare il nostro sito web. Per poter pubblicare online il nostro sito c'\u00e8 bisogno di un server, cio\u00e8 un computer costantemente connesso alla rete che permette a un browser di trovare il proprio sito grazie all'indirizzo. Ecco le alternative possibili: Shared Hosting VPS Hosting Dedicated Server Cloud Hosting Static Hosting","title":"WEB HOSTING"},{"location":"css/#shared-hosting","text":"Il pi\u00f9 economico: dai 3 ai 15 euro al mese. Ospita diversi account sullo stesso server Pu\u00f2 essere usato per piccoli siti web Ricco di features: Puoi caricare file tramite FTP (FIle transfer protocol)","title":"Shared Hosting"},{"location":"css/#vps-virtual-private-server","text":"COsto: 15 - 100 euro al mese Ci sono meno persone sullo stesso server in cui ognuno \u00e8 nel proprio ambiente. E' piu' sicuro per questo e ci sono meno problemi. Ci sono pi\u00f9 privilegi (SSH) Ha le stesse features dello shared hosting","title":"VPS (Virtual Private Server)"},{"location":"css/#dedicated-server","text":"Costo: 100 - 400 euro al mese E' un server personale, non ospita nessun altro, si affitta proprio una macchina fisica Si ha pieno accesso e privilegi perch\u00e8 \u00e8 di fatto una macchina personale E' usato per grandi siti web e grandi applicazioni E' molto potente ma anche molto difficile da usare","title":"Dedicated Server"},{"location":"css/#cloud-hosting","text":"Costo: paghi a seconda del bisogno cio\u00e8 a seconda della quantit\u00e0 di dati che usi Usato per web apps Scalabile e adatto anche per grandi applicazioni Piu' difficile da usare rispetto a shared hosting","title":"Cloud Hosting"},{"location":"css/#static-hosting","text":"COsto: Gratis ma paghi gli extra Pochi strumenti disponibili SI carica il sito web con GIT Adatto per siti web statici","title":"Static Hosting"},{"location":"espruino/","text":"Espruino Espruino \u00e8 un interprete JavaScript open source per microcontrollori. Le board ufficialmente sviluppate da espruino le puoi trovare su Espruino - shop . ESP8266 In questa guida vedremo come installare il firmware espruino sul microcontrollore ESP8266 . L'ESP8266 \u00e8 un chip con Wi-Fi integrato a basso costo, con supporto completo al protocollo TCP/IP e funzionalit\u00e0 da microcontrollore prodotto dall'azienda cinese di Shanghai Espressif Systems. Il chip \u00e8 spesso utilizzato in molti prodotti IOT Installazione del firmware espruino su ESP8266 Strumenti necessari: python , necessario per lanciare lo script esptool . esptool , uno script python in grado di eseguire il flash del firmware espruino su ESP8266. firmware , l'interprete javascript da installa su ESP8266 per permettere l'esecuzione di file js Procedura. Installa python per il tuo sistema operativo. Puoi verificare che sia stato installato attraverso il comando python3 --version >>> python3 --version Python 3.8.6 Installa il gestore dei pacchetti python pip . Puoi verificare che sia stato installato attraverso il comando pip --version >>> pip --version pip 20 .1.1 from /usr/lib/python3/dist-packages/pip ( python 3 .8 ) Nota Su linux puoi installare python e pip lanciando i comandi: sudo apt-get install python3 sudo apt-get install python3-pip Installa il pacchetto esptool tramite il comando: pip install esptool Per verificare che sia stato installato correttamente digita python3 -m esptool version >>> python3 -m esptool version esptool.py v3.0 3.0 Digitando python3 -m esptool puoi accedere a tutti i comandi forniti da esptool esptool.py v3.0 usage: esptool [ -h ] [ --chip { auto,esp8266,esp32,esp32s2,esp32s3beta2,esp32c3 }] [ --port PORT ] [ --baud BAUD ] [ --before { default_reset,no_reset,no_reset_no_sync }] [ --after { hard_reset,soft_reset,no_reset }] [ --no-stub ] [ --trace ] [ --override-vddsdio [{ 1 .8V,1.9V,OFF }]] [ --connect-attempts CONNECT_ATTEMPTS ] { load_ram,dump_mem,read_mem,write_mem,write_flash,run,image_info,make_image,elf2image,read_mac,chip_id,flash_id,read_flash_status,write_flash_status,read_flash,verify_flash,erase_flash,erase_region,version,get_security_info } ... esptool.py v3.0 - ESP8266 ROM Bootloader Utility positional arguments: { load_ram,dump_mem,read_mem,write_mem,write_flash,run,image_info,make_image,elf2image,read_mac,chip_id,flash_id,read_flash_status,write_flash_status,read_flash,verify_flash,erase_flash,erase_region,version,get_security_info } Run esptool { command } -h for additional help load_ram Download an image to RAM and execute dump_mem Dump arbitrary memory to disk read_mem Read arbitrary memory location write_mem Read-modify-write to arbitrary memory location write_flash Write a binary blob to flash run Run application code in flash image_info Dump headers from an application image make_image Create an application image from binary files elf2image Create an application image from ELF file read_mac Read MAC address from OTP ROM chip_id Read Chip ID from OTP ROM flash_id Read SPI flash manufacturer and device ID read_flash_status Read SPI flash status register write_flash_status Write SPI flash status register read_flash Read SPI flash content verify_flash Verify a binary blob against flash erase_flash Perform Chip Erase on SPI flash erase_region Erase a region of the flash version Print esptool version get_security_info Get some security-related data optional arguments: -h, --help show this help message and exit --chip { auto,esp8266,esp32,esp32s2,esp32s3beta2,esp32c3 } , -c { auto,esp8266,esp32,esp32s2,esp32s3beta2,esp32c3 } Target chip type --port PORT, -p PORT Serial port device --baud BAUD, -b BAUD Serial port baud rate used when flashing/reading --before { default_reset,no_reset,no_reset_no_sync } What to do before connecting to the chip --after { hard_reset,soft_reset,no_reset } , -a { hard_reset,soft_reset,no_reset } What to do after esptool.py is finished --no-stub Disable launching the flasher stub, only talk to ROM bootloader. Some features will not be available. --trace, -t Enable trace-level output of esptool.py interactions. --override-vddsdio [{ 1 .8V,1.9V,OFF }] Override ESP32 VDDSDIO internal voltage regulator ( use with care ) --connect-attempts CONNECT_ATTEMPTS Number of attempts to connect, negative or 0 for infinite. Default: 7 . Connetti ESP8266 al PC e digita python3 -m esptool flash_id . Dovrebber risponderti con alcune informazioni riguardo il tipo del chip. python3 -m esptool flash_id esptool.py v3.0 Found 1 serial ports Serial port /dev/ttyUSB0 Connecting..... Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi Crystal is 26MHz MAC: ec:fa:bc:32:cd:a6 Uploading stub... Running stub... Stub running... Manufacturer: ef Device: 4016 Detected flash size: 4MB Hard resetting via RTS pin... Di queste informazioni, memorizza Serial port che indica la porta seriale a cui \u00e8 connesso ESP8266 , in questo caso \u00e8 /dev/ttyUSB0 , Device che identifica il nome del dispositivo che in questo caso \u00e8 il 4016 e Detected flash size che rappresenta la memoria flash, che in questo caso vale 4MB . Scarica il firmware dal sito ufficiale di espruino . Puoi scegliere tra: Cutting Edge build: espruino_2v08.191_esp8266.tgz Cutting Edge build: espruino_2v08.191_esp8266_4mb.tgz La differenza tra i due firmware la puoi trovare qua . content *) espruino_2v00_esp8266 espruino_2v00_esp8266_4mb Modules NET, TELNET, CRYPTO, only SHA1, NEOPIXEL, Storage NET, TELNET, GRAPHICS, CRYPTO only SHA1, NEOPIXEL,Storage JS variables 1700 1600 save pages 4 x 4096 byte 48 x 4096 byte getState() {\"sdkVersion\": \"2.2.1(6ab97e9), \"cpuFrequency\": 160, \"freeHeap\": 10672, \"maxCon\": 10, \"flashMap\": \"512KB:256/256\",\"flashKB\": 512,\"flashChip\": \"0xXX 0x4013\"} {\"sdkVersion\": \"2.2.1(6ab97e9)\", \"cpuFrequency\": 160, \"freeHeap\": 12416, \"maxCon\": 10, \"flashMap\": \"4MB:1024/1024\", \"flashKB\": 4096,\"flashChip\": \"0xXX 0x4016\"} getFreeFlash() use 'Storage' module to save data [{ \"addr\": 2097152, \"length\": 1048576 }, { \"addr\": 3145728, \"length\": 262144 }, { \"addr\": 3407872, \"length\": 262144}, { \"addr\": 3670016, \"length\": 262144 }, { \"addr\": 3932160, \"length\": 262144 }] chip_id and flash_size 4013-4015 use --flash_size 512KB 4016-4018 use --flash_size 4MB-c1 max image size 468 KB 812 KB In breve il firmware espruino_2v00_esp8266_4mb contiene la libreria GRAPHICS rispetto al firmware espruino_2v00_esp8266 . Da notare tuttavia che a seconda del chip_id \u00e8 necessario installare un firmware piuttosto di un altro. In particolare dal momento che il mio ESP8266 \u00e8 un 4016 posso installare il firmware espruino_2v00_esp8266_4mb Una volta scelto il firmware giusto scompatta il file scaricato. Nel mio caso, installer\u00f2 il firmware espruino_2v00_esp8266_4mb . Cancella la flash. Il seguente comando canceller\u00e0 il contenuto della flash. Assicurati di riportere il nome della porta corretto, nel mio caso \u00e8 /dev/ttyUSB0 (Ricorda che puoi ricevere informazioni sul tuo ESP8266 connesso digitando python3 -m esptool flash_id ). > python3 -m esptool --port /dev/ttyUSB0 --baud 115200 erase_flash esptool.py v3.0 Serial port /dev/ttyUSB0 Connecting.... Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi Crystal is 26MHz MAC: ec:fa:bc:32:cd:a6 Uploading stub... Running stub... Stub running... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 6 .0s Hard resetting via RTS pin... Esegui il flash del firmware. Posizionati all'interno della cartella appena scaricata e scampattata del firmware espruino per ESP8266, nel mio caso espruino_2v08.191_esp8266_4mb . Per flashare questo firmware digita: python3 -m esptool --port /dev/ttyUSB0 --baud 115200 write_flash --flash_freq 80m --flash_mode qio --flash_size 4MB 0x0000 \"boot_v1.6.bin\" 0x1000 espruino_esp8266_user1.bin 0x3FC000 esp_init_data_default.bin 0x3FE000 blank.bin Ricordati di controllare il nome della porta seriale. python3 -m esptool --port /dev/ttyUSB0 --baud 115200 write_flash --flash_freq 80m --flash_mode qio --flash_size 4MB 0x0000 \"boot_v1.6.bin\" 0x1000 espruino_esp8266_user1.bin 0x3FC000 esp_init_data_default.bin 0x3FE000 blank.bin esptool.py v3.0 Serial port /dev/ttyUSB0 Connecting.... Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi Crystal is 26MHz MAC: ec:fa:bc:32:cd:a6 Uploading stub... Running stub... Stub running... Configuring flash size... Flash params set to 0x004f Compressed 3856 bytes to 2763 ... Wrote 3856 bytes ( 2763 compressed ) at 0x00000000 in 0 .2 seconds ( effective 124 .8 kbit/s ) ... Hash of data verified. Compressed 533716 bytes to 350945 ... Wrote 533716 bytes ( 350945 compressed ) at 0x00001000 in 30 .9 seconds ( effective 138 .0 kbit/s ) ... Hash of data verified. Compressed 128 bytes to 75 ... Wrote 128 bytes ( 75 compressed ) at 0x003fc000 in 0 .0 seconds ( effective 92 .7 kbit/s ) ... Hash of data verified. Compressed 4096 bytes to 26 ... Wrote 4096 bytes ( 26 compressed ) at 0x003fe000 in 0 .0 seconds ( effective 4906 .3 kbit/s ) ... Hash of data verified. Leaving... Hard resetting via RTS pin... Nota Se vuoi flashare il firmare espruino_2v08.191_esp8266 devi digitare: python3 -m esptool --port /dev/ttyUSB0 --baud 115200 write_flash --flash_freq 40m --flash_mode qio --flash_size 4m 0x0000 \"boot_v1.6.bin\" 0x1000 espruino_esp8266_user1.bin 0x7C000 esp_init_data_default.bin 0x7E000 blank.bin Una guida completa su questi comandi la puoi trovare su ESP8266 - Flashing Vedi anche Quick start USB Come flashare un file js su un microcontrollore espruino Per vedere tutte le opzioni di programmazione di espruino ti consiglio di dare un'occhiata alla sezione di programmazione sul sito ufficiale . Puoi usare: Espuino IDE , ma solo con google chrome. Con chromium non funziona. [] Primi passi con javascript ed espruino Puoi dare un'occhiata al tutorial Comandi basilari 1 + 2 //set D16 pin to high digitalWrite ( D16 , 1 ) //read D16 pin digitalRead ( D16 ); //Set D16 to high //after 200ms Set D16 to low function flash () { digitalWrite ( D16 , 1 ); setTimeout ( function () { digitalWrite ( D16 , 0 ); }, 200 ); } flash (); function flash () { digitalWrite ( D16 , 1 ); setTimeout ( function () { digitalWrite ( D16 , 0 ); }, 200 ); } if ( digitalRead ( D15 )) flash (); //When press D15, flash will be executed function flash () { digitalWrite ( D16 , 1 ); setTimeout ( function () { digitalWrite ( D16 , 0 ); }, 200 ); } setInterval ( function () { if ( digitalRead ( D15 )) flash (); }, 500 ); var Hh , Mm , Ss , mm ; function initOLED (){ oled . setFont8x12 (); oled . drawString ( \"init OLDED 789\" ); oled . flip (); } require ( \"Font8x12\" ). add ( Graphics ); I2C1 . setup ({ scl : D5 , sda : D4 }); var oled = require ( \"SSD1306\" ). connect ( I2C1 , initOLED , { rst : D16 , height : 32 , width : 128 }); function orario (){ var data = new Date (); Hh = data . getHours () + \":\" ; Mm = data . getMinutes () + \":\" ; Ss = data . getSeconds (); oled . clear (); oled . drawString ( \"Ora:\" ); oled . drawString ( Hh + Mm + Ss , 0 , 16 ); oled . flip (); } setInterval ( orario , 1000 ); Led blink var on = false ; var pin = D16 ; setInterval ( function () { on = ! on ; digitalWrite ( pin , on ); }, 500 ); function start (){ g . setFont8x12 (); g . drawString ( \"Ciao mondo\" ); g . flip (); console . log ( g . getFonts ()); } require ( \"Font4x4Numeric\" ). add ( Graphics ); require ( \"Font8x12\" ). add ( Graphics ); I2C1 . setup ({ scl : D5 , sda : D4 }); var g = require ( \"SSD1306\" ). connect ( I2C1 , start , { rst : D16 , height : 32 , width : 128 }); Orologio con display NOKIA 5110 Puoi trovare il progetto qua . Riporto comunque il codice completo che comprende l'adattamento NodeMCU. /* GND GND GND LIGHT Any GND (backlight on) VCC 3.3v 3.3 CLK SPI SCK D3 DIN SPI MOSI D5 DC Any D6 CE Any D7 RST Any D8 */ var g ; var MONTHS = [ \"Jan\" , \"Feb\" , \"Mar\" , \"Apr\" , \"May\" , \"Jun\" , \"Jul\" , \"Aug\" , \"Sep\" , \"Oct\" , \"Nov\" , \"Dec\" ]; function draw () { g . clear (); var t = new Date (); var date = t . getDate () + \" \" + MONTHS [ t . getMonth ()] + \" \" + t . getFullYear (); var time = t . getHours () + \":\" + ( \"0\" + t . getMinutes ()). substr ( - 2 ); var secs = ( \"0\" + t . getSeconds ()). substr ( - 2 ); // top left date g . setFontBitmap (); g . drawString ( date , 0 , 0 ); // middle time g . setFontVector ( 20 ); var timeWidth = g . stringWidth ( time ); g . drawString ( time ,( g . getWidth () - timeWidth - 12 ) / 2 , 10 ); // seconds over to the right g . setFontBitmap (); g . drawString ( secs ,( g . getWidth () + timeWidth - 8 ) / 2 , 26 ); // send to LCD g . flip (); } function onInit () { clearInterval (); // Setup SPI var spi = new SPI (); spi . setup ({ sck : NodeMCU . D3 , mosi : NodeMCU . D5 }); // Initialise the LCD g = require ( \"PCD8544\" ). connect ( spi , NodeMCU . D6 , NodeMCU . D7 , NodeMCU . D8 , function () { // When it's initialised, set up an animation at 20fps (50ms per frame) setInterval ( draw , 1000 ); }); } onInit (); Snake // Setup SPI var spi = new SPI (); // Graphics var g ; // Current score var score = 0 ; // Snake position and direction var pos , dir ; // previous snake positions var history = []; //initial snake lenght var snakeLength = 5 ; // a list of apple locations (that the snake can eat) var apples = []; //initial speed var speed = 120 ; var idOnFrame = 0 ; function beep ( state ){ digitalWrite ( NodeMCU . D4 , state ); } function updateSnake () { // remove old score... beep ( 1 ); g . setColor ( 0 ); g . fillRect ( 0 , 0 , g . getWidth (), 5 ); g . setColor ( 1 ); g . drawString ( score ); beep ( 0 ); clearInterval (); speed = ( speed <= 20 ) ? 20 : speed - 5 ; idOnFrame = setInterval ( onFrame , speed ); } function newApple () { var p ; // keep coming up with random locations until there // is nothing drawn where we want to put the apple do { p = { x : Math . round ( Math . random () * g . getWidth ()), y : 6 + Math . round ( Math . random () * ( g . getHeight () - 6 )) }; } while ( g . getPixel ( p . x , p . y )); // draw the apple, and save it inthe array g . setPixel ( p . x , p . y ); apples . push ( p ); } function start () { // clear screen g . clear (); g . drawRect ( 0 , 6 , g . getWidth () - 1 , g . getHeight () - 1 ); speed = 150 ; // Setup snake position pos = { x : g . getWidth () / 2 , y : g . getHeight () / 2 }; // centre of the screen history = [[ pos . x , pos . y ]]; // reset the 'history' list g . setPixel ( pos . x , pos . y ); dir = { x : 1 , y : 0 }; // the direction of the snake // Now add randomly positioned apples apples = []; for ( var i = 0 ; i < 10 ; i ++ ) newApple (); // update the screen g . flip (); // reset score score = 0 ; updateSnake (); // When a button is pressed, rotate the snake setWatch ( function ( e ) { rotate ( - 1 ); }, NodeMCU . D1 , { repeat : true , edge : \"rising\" , debounce : 10 }); setWatch ( function ( e ) { rotate ( 1 ); }, NodeMCU . D2 , { repeat : true , edge : \"rising\" , debounce : 10 }); } // When Espruino starts up... function onInit () { clearInterval (); clearWatch (); // Setup SPI spi . setup ({ sck : NodeMCU . D3 , mosi : NodeMCU . D5 }); // Initialise the LCD g = require ( \"PCD8544\" ). connect ( spi , NodeMCU . D6 , NodeMCU . D7 , NodeMCU . D8 , function (){ // When it's initialised, clear it and write some text g . clear (); g . drawString ( \"Hello\" , 0 , 0 ); // send the graphics to the display g . flip (); start (); }); } function gameOver () { // stop the game beep ( 1 ); clearWatch (); clearInterval (); // write 'game over' on the screen g . clear (); var s = \"Game Over!\" ; g . drawString ( s , ( g . getWidth () - g . stringWidth ( s )) / 2 , g . getHeight () / 2 - 4 ); g . flip (); beep ( 0 ); // when the button is pressed, restart setWatch ( function ( e ) { start (); }, NodeMCU . D2 , { edge : \"rising\" , debounce : 20 }); } // called every 'frame' of the game function onFrame () { pos . x += dir . x ; pos . y += dir . y ; // remove tail while ( history . length >= snakeLength ) { var p = history . shift (); // remove first item from list g . setPixel ( p [ 0 ], p [ 1 ], 0 ); // clear that pixel } // add current position onto the end history . push ([ pos . x , pos . y ]); if ( g . getPixel ( pos . x , pos . y )) { // check for apples var wasApple = false ; for ( var i in apples ) if ( apples [ i ]. x == pos . x && apples [ i ]. y == pos . y ) { wasApple = true ; // delete this apple apples . splice ( i , 1 ); // add a new apple newApple (); // change score and increase snake length snakeLength += 1 ; score += 10 ; updateSnake (); // break out so we don't check any more apples break ; } if ( ! wasApple ) gameOver (); } else { g . setPixel ( pos . x , pos . y ); g . flip (); } } function rotate ( d ) { if ( dir . x ) { dir = { x : 0 , y : d * dir . x }; } else { dir = { x :- d * dir . y , y : 0 }; } } onInit ();","title":"Espruino"},{"location":"espruino/#espruino","text":"Espruino \u00e8 un interprete JavaScript open source per microcontrollori. Le board ufficialmente sviluppate da espruino le puoi trovare su Espruino - shop .","title":"Espruino"},{"location":"espruino/#esp8266","text":"In questa guida vedremo come installare il firmware espruino sul microcontrollore ESP8266 . L'ESP8266 \u00e8 un chip con Wi-Fi integrato a basso costo, con supporto completo al protocollo TCP/IP e funzionalit\u00e0 da microcontrollore prodotto dall'azienda cinese di Shanghai Espressif Systems. Il chip \u00e8 spesso utilizzato in molti prodotti IOT","title":"ESP8266"},{"location":"espruino/#installazione-del-firmware-espruino-su-esp8266","text":"Strumenti necessari: python , necessario per lanciare lo script esptool . esptool , uno script python in grado di eseguire il flash del firmware espruino su ESP8266. firmware , l'interprete javascript da installa su ESP8266 per permettere l'esecuzione di file js Procedura. Installa python per il tuo sistema operativo. Puoi verificare che sia stato installato attraverso il comando python3 --version >>> python3 --version Python 3.8.6 Installa il gestore dei pacchetti python pip . Puoi verificare che sia stato installato attraverso il comando pip --version >>> pip --version pip 20 .1.1 from /usr/lib/python3/dist-packages/pip ( python 3 .8 ) Nota Su linux puoi installare python e pip lanciando i comandi: sudo apt-get install python3 sudo apt-get install python3-pip Installa il pacchetto esptool tramite il comando: pip install esptool Per verificare che sia stato installato correttamente digita python3 -m esptool version >>> python3 -m esptool version esptool.py v3.0 3.0 Digitando python3 -m esptool puoi accedere a tutti i comandi forniti da esptool esptool.py v3.0 usage: esptool [ -h ] [ --chip { auto,esp8266,esp32,esp32s2,esp32s3beta2,esp32c3 }] [ --port PORT ] [ --baud BAUD ] [ --before { default_reset,no_reset,no_reset_no_sync }] [ --after { hard_reset,soft_reset,no_reset }] [ --no-stub ] [ --trace ] [ --override-vddsdio [{ 1 .8V,1.9V,OFF }]] [ --connect-attempts CONNECT_ATTEMPTS ] { load_ram,dump_mem,read_mem,write_mem,write_flash,run,image_info,make_image,elf2image,read_mac,chip_id,flash_id,read_flash_status,write_flash_status,read_flash,verify_flash,erase_flash,erase_region,version,get_security_info } ... esptool.py v3.0 - ESP8266 ROM Bootloader Utility positional arguments: { load_ram,dump_mem,read_mem,write_mem,write_flash,run,image_info,make_image,elf2image,read_mac,chip_id,flash_id,read_flash_status,write_flash_status,read_flash,verify_flash,erase_flash,erase_region,version,get_security_info } Run esptool { command } -h for additional help load_ram Download an image to RAM and execute dump_mem Dump arbitrary memory to disk read_mem Read arbitrary memory location write_mem Read-modify-write to arbitrary memory location write_flash Write a binary blob to flash run Run application code in flash image_info Dump headers from an application image make_image Create an application image from binary files elf2image Create an application image from ELF file read_mac Read MAC address from OTP ROM chip_id Read Chip ID from OTP ROM flash_id Read SPI flash manufacturer and device ID read_flash_status Read SPI flash status register write_flash_status Write SPI flash status register read_flash Read SPI flash content verify_flash Verify a binary blob against flash erase_flash Perform Chip Erase on SPI flash erase_region Erase a region of the flash version Print esptool version get_security_info Get some security-related data optional arguments: -h, --help show this help message and exit --chip { auto,esp8266,esp32,esp32s2,esp32s3beta2,esp32c3 } , -c { auto,esp8266,esp32,esp32s2,esp32s3beta2,esp32c3 } Target chip type --port PORT, -p PORT Serial port device --baud BAUD, -b BAUD Serial port baud rate used when flashing/reading --before { default_reset,no_reset,no_reset_no_sync } What to do before connecting to the chip --after { hard_reset,soft_reset,no_reset } , -a { hard_reset,soft_reset,no_reset } What to do after esptool.py is finished --no-stub Disable launching the flasher stub, only talk to ROM bootloader. Some features will not be available. --trace, -t Enable trace-level output of esptool.py interactions. --override-vddsdio [{ 1 .8V,1.9V,OFF }] Override ESP32 VDDSDIO internal voltage regulator ( use with care ) --connect-attempts CONNECT_ATTEMPTS Number of attempts to connect, negative or 0 for infinite. Default: 7 . Connetti ESP8266 al PC e digita python3 -m esptool flash_id . Dovrebber risponderti con alcune informazioni riguardo il tipo del chip. python3 -m esptool flash_id esptool.py v3.0 Found 1 serial ports Serial port /dev/ttyUSB0 Connecting..... Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi Crystal is 26MHz MAC: ec:fa:bc:32:cd:a6 Uploading stub... Running stub... Stub running... Manufacturer: ef Device: 4016 Detected flash size: 4MB Hard resetting via RTS pin... Di queste informazioni, memorizza Serial port che indica la porta seriale a cui \u00e8 connesso ESP8266 , in questo caso \u00e8 /dev/ttyUSB0 , Device che identifica il nome del dispositivo che in questo caso \u00e8 il 4016 e Detected flash size che rappresenta la memoria flash, che in questo caso vale 4MB . Scarica il firmware dal sito ufficiale di espruino . Puoi scegliere tra: Cutting Edge build: espruino_2v08.191_esp8266.tgz Cutting Edge build: espruino_2v08.191_esp8266_4mb.tgz La differenza tra i due firmware la puoi trovare qua . content *) espruino_2v00_esp8266 espruino_2v00_esp8266_4mb Modules NET, TELNET, CRYPTO, only SHA1, NEOPIXEL, Storage NET, TELNET, GRAPHICS, CRYPTO only SHA1, NEOPIXEL,Storage JS variables 1700 1600 save pages 4 x 4096 byte 48 x 4096 byte getState() {\"sdkVersion\": \"2.2.1(6ab97e9), \"cpuFrequency\": 160, \"freeHeap\": 10672, \"maxCon\": 10, \"flashMap\": \"512KB:256/256\",\"flashKB\": 512,\"flashChip\": \"0xXX 0x4013\"} {\"sdkVersion\": \"2.2.1(6ab97e9)\", \"cpuFrequency\": 160, \"freeHeap\": 12416, \"maxCon\": 10, \"flashMap\": \"4MB:1024/1024\", \"flashKB\": 4096,\"flashChip\": \"0xXX 0x4016\"} getFreeFlash() use 'Storage' module to save data [{ \"addr\": 2097152, \"length\": 1048576 }, { \"addr\": 3145728, \"length\": 262144 }, { \"addr\": 3407872, \"length\": 262144}, { \"addr\": 3670016, \"length\": 262144 }, { \"addr\": 3932160, \"length\": 262144 }] chip_id and flash_size 4013-4015 use --flash_size 512KB 4016-4018 use --flash_size 4MB-c1 max image size 468 KB 812 KB In breve il firmware espruino_2v00_esp8266_4mb contiene la libreria GRAPHICS rispetto al firmware espruino_2v00_esp8266 . Da notare tuttavia che a seconda del chip_id \u00e8 necessario installare un firmware piuttosto di un altro. In particolare dal momento che il mio ESP8266 \u00e8 un 4016 posso installare il firmware espruino_2v00_esp8266_4mb Una volta scelto il firmware giusto scompatta il file scaricato. Nel mio caso, installer\u00f2 il firmware espruino_2v00_esp8266_4mb . Cancella la flash. Il seguente comando canceller\u00e0 il contenuto della flash. Assicurati di riportere il nome della porta corretto, nel mio caso \u00e8 /dev/ttyUSB0 (Ricorda che puoi ricevere informazioni sul tuo ESP8266 connesso digitando python3 -m esptool flash_id ). > python3 -m esptool --port /dev/ttyUSB0 --baud 115200 erase_flash esptool.py v3.0 Serial port /dev/ttyUSB0 Connecting.... Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi Crystal is 26MHz MAC: ec:fa:bc:32:cd:a6 Uploading stub... Running stub... Stub running... Erasing flash ( this may take a while ) ... Chip erase completed successfully in 6 .0s Hard resetting via RTS pin... Esegui il flash del firmware. Posizionati all'interno della cartella appena scaricata e scampattata del firmware espruino per ESP8266, nel mio caso espruino_2v08.191_esp8266_4mb . Per flashare questo firmware digita: python3 -m esptool --port /dev/ttyUSB0 --baud 115200 write_flash --flash_freq 80m --flash_mode qio --flash_size 4MB 0x0000 \"boot_v1.6.bin\" 0x1000 espruino_esp8266_user1.bin 0x3FC000 esp_init_data_default.bin 0x3FE000 blank.bin Ricordati di controllare il nome della porta seriale. python3 -m esptool --port /dev/ttyUSB0 --baud 115200 write_flash --flash_freq 80m --flash_mode qio --flash_size 4MB 0x0000 \"boot_v1.6.bin\" 0x1000 espruino_esp8266_user1.bin 0x3FC000 esp_init_data_default.bin 0x3FE000 blank.bin esptool.py v3.0 Serial port /dev/ttyUSB0 Connecting.... Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi Crystal is 26MHz MAC: ec:fa:bc:32:cd:a6 Uploading stub... Running stub... Stub running... Configuring flash size... Flash params set to 0x004f Compressed 3856 bytes to 2763 ... Wrote 3856 bytes ( 2763 compressed ) at 0x00000000 in 0 .2 seconds ( effective 124 .8 kbit/s ) ... Hash of data verified. Compressed 533716 bytes to 350945 ... Wrote 533716 bytes ( 350945 compressed ) at 0x00001000 in 30 .9 seconds ( effective 138 .0 kbit/s ) ... Hash of data verified. Compressed 128 bytes to 75 ... Wrote 128 bytes ( 75 compressed ) at 0x003fc000 in 0 .0 seconds ( effective 92 .7 kbit/s ) ... Hash of data verified. Compressed 4096 bytes to 26 ... Wrote 4096 bytes ( 26 compressed ) at 0x003fe000 in 0 .0 seconds ( effective 4906 .3 kbit/s ) ... Hash of data verified. Leaving... Hard resetting via RTS pin... Nota Se vuoi flashare il firmare espruino_2v08.191_esp8266 devi digitare: python3 -m esptool --port /dev/ttyUSB0 --baud 115200 write_flash --flash_freq 40m --flash_mode qio --flash_size 4m 0x0000 \"boot_v1.6.bin\" 0x1000 espruino_esp8266_user1.bin 0x7C000 esp_init_data_default.bin 0x7E000 blank.bin Una guida completa su questi comandi la puoi trovare su ESP8266 - Flashing Vedi anche Quick start USB","title":"Installazione del firmware espruino su ESP8266"},{"location":"espruino/#come-flashare-un-file-js-su-un-microcontrollore-espruino","text":"Per vedere tutte le opzioni di programmazione di espruino ti consiglio di dare un'occhiata alla sezione di programmazione sul sito ufficiale . Puoi usare: Espuino IDE , ma solo con google chrome. Con chromium non funziona. []","title":"Come flashare un file js su un microcontrollore espruino"},{"location":"espruino/#primi-passi-con-javascript-ed-espruino","text":"Puoi dare un'occhiata al tutorial","title":"Primi passi con javascript ed espruino"},{"location":"espruino/#comandi-basilari","text":"1 + 2 //set D16 pin to high digitalWrite ( D16 , 1 ) //read D16 pin digitalRead ( D16 ); //Set D16 to high //after 200ms Set D16 to low function flash () { digitalWrite ( D16 , 1 ); setTimeout ( function () { digitalWrite ( D16 , 0 ); }, 200 ); } flash (); function flash () { digitalWrite ( D16 , 1 ); setTimeout ( function () { digitalWrite ( D16 , 0 ); }, 200 ); } if ( digitalRead ( D15 )) flash (); //When press D15, flash will be executed function flash () { digitalWrite ( D16 , 1 ); setTimeout ( function () { digitalWrite ( D16 , 0 ); }, 200 ); } setInterval ( function () { if ( digitalRead ( D15 )) flash (); }, 500 ); var Hh , Mm , Ss , mm ; function initOLED (){ oled . setFont8x12 (); oled . drawString ( \"init OLDED 789\" ); oled . flip (); } require ( \"Font8x12\" ). add ( Graphics ); I2C1 . setup ({ scl : D5 , sda : D4 }); var oled = require ( \"SSD1306\" ). connect ( I2C1 , initOLED , { rst : D16 , height : 32 , width : 128 }); function orario (){ var data = new Date (); Hh = data . getHours () + \":\" ; Mm = data . getMinutes () + \":\" ; Ss = data . getSeconds (); oled . clear (); oled . drawString ( \"Ora:\" ); oled . drawString ( Hh + Mm + Ss , 0 , 16 ); oled . flip (); } setInterval ( orario , 1000 );","title":"Comandi basilari"},{"location":"espruino/#led-blink","text":"var on = false ; var pin = D16 ; setInterval ( function () { on = ! on ; digitalWrite ( pin , on ); }, 500 ); function start (){ g . setFont8x12 (); g . drawString ( \"Ciao mondo\" ); g . flip (); console . log ( g . getFonts ()); } require ( \"Font4x4Numeric\" ). add ( Graphics ); require ( \"Font8x12\" ). add ( Graphics ); I2C1 . setup ({ scl : D5 , sda : D4 }); var g = require ( \"SSD1306\" ). connect ( I2C1 , start , { rst : D16 , height : 32 , width : 128 });","title":"Led blink"},{"location":"espruino/#orologio-con-display-nokia-5110","text":"Puoi trovare il progetto qua . Riporto comunque il codice completo che comprende l'adattamento NodeMCU. /* GND GND GND LIGHT Any GND (backlight on) VCC 3.3v 3.3 CLK SPI SCK D3 DIN SPI MOSI D5 DC Any D6 CE Any D7 RST Any D8 */ var g ; var MONTHS = [ \"Jan\" , \"Feb\" , \"Mar\" , \"Apr\" , \"May\" , \"Jun\" , \"Jul\" , \"Aug\" , \"Sep\" , \"Oct\" , \"Nov\" , \"Dec\" ]; function draw () { g . clear (); var t = new Date (); var date = t . getDate () + \" \" + MONTHS [ t . getMonth ()] + \" \" + t . getFullYear (); var time = t . getHours () + \":\" + ( \"0\" + t . getMinutes ()). substr ( - 2 ); var secs = ( \"0\" + t . getSeconds ()). substr ( - 2 ); // top left date g . setFontBitmap (); g . drawString ( date , 0 , 0 ); // middle time g . setFontVector ( 20 ); var timeWidth = g . stringWidth ( time ); g . drawString ( time ,( g . getWidth () - timeWidth - 12 ) / 2 , 10 ); // seconds over to the right g . setFontBitmap (); g . drawString ( secs ,( g . getWidth () + timeWidth - 8 ) / 2 , 26 ); // send to LCD g . flip (); } function onInit () { clearInterval (); // Setup SPI var spi = new SPI (); spi . setup ({ sck : NodeMCU . D3 , mosi : NodeMCU . D5 }); // Initialise the LCD g = require ( \"PCD8544\" ). connect ( spi , NodeMCU . D6 , NodeMCU . D7 , NodeMCU . D8 , function () { // When it's initialised, set up an animation at 20fps (50ms per frame) setInterval ( draw , 1000 ); }); } onInit ();","title":"Orologio con display NOKIA 5110"},{"location":"espruino/#snake","text":"// Setup SPI var spi = new SPI (); // Graphics var g ; // Current score var score = 0 ; // Snake position and direction var pos , dir ; // previous snake positions var history = []; //initial snake lenght var snakeLength = 5 ; // a list of apple locations (that the snake can eat) var apples = []; //initial speed var speed = 120 ; var idOnFrame = 0 ; function beep ( state ){ digitalWrite ( NodeMCU . D4 , state ); } function updateSnake () { // remove old score... beep ( 1 ); g . setColor ( 0 ); g . fillRect ( 0 , 0 , g . getWidth (), 5 ); g . setColor ( 1 ); g . drawString ( score ); beep ( 0 ); clearInterval (); speed = ( speed <= 20 ) ? 20 : speed - 5 ; idOnFrame = setInterval ( onFrame , speed ); } function newApple () { var p ; // keep coming up with random locations until there // is nothing drawn where we want to put the apple do { p = { x : Math . round ( Math . random () * g . getWidth ()), y : 6 + Math . round ( Math . random () * ( g . getHeight () - 6 )) }; } while ( g . getPixel ( p . x , p . y )); // draw the apple, and save it inthe array g . setPixel ( p . x , p . y ); apples . push ( p ); } function start () { // clear screen g . clear (); g . drawRect ( 0 , 6 , g . getWidth () - 1 , g . getHeight () - 1 ); speed = 150 ; // Setup snake position pos = { x : g . getWidth () / 2 , y : g . getHeight () / 2 }; // centre of the screen history = [[ pos . x , pos . y ]]; // reset the 'history' list g . setPixel ( pos . x , pos . y ); dir = { x : 1 , y : 0 }; // the direction of the snake // Now add randomly positioned apples apples = []; for ( var i = 0 ; i < 10 ; i ++ ) newApple (); // update the screen g . flip (); // reset score score = 0 ; updateSnake (); // When a button is pressed, rotate the snake setWatch ( function ( e ) { rotate ( - 1 ); }, NodeMCU . D1 , { repeat : true , edge : \"rising\" , debounce : 10 }); setWatch ( function ( e ) { rotate ( 1 ); }, NodeMCU . D2 , { repeat : true , edge : \"rising\" , debounce : 10 }); } // When Espruino starts up... function onInit () { clearInterval (); clearWatch (); // Setup SPI spi . setup ({ sck : NodeMCU . D3 , mosi : NodeMCU . D5 }); // Initialise the LCD g = require ( \"PCD8544\" ). connect ( spi , NodeMCU . D6 , NodeMCU . D7 , NodeMCU . D8 , function (){ // When it's initialised, clear it and write some text g . clear (); g . drawString ( \"Hello\" , 0 , 0 ); // send the graphics to the display g . flip (); start (); }); } function gameOver () { // stop the game beep ( 1 ); clearWatch (); clearInterval (); // write 'game over' on the screen g . clear (); var s = \"Game Over!\" ; g . drawString ( s , ( g . getWidth () - g . stringWidth ( s )) / 2 , g . getHeight () / 2 - 4 ); g . flip (); beep ( 0 ); // when the button is pressed, restart setWatch ( function ( e ) { start (); }, NodeMCU . D2 , { edge : \"rising\" , debounce : 20 }); } // called every 'frame' of the game function onFrame () { pos . x += dir . x ; pos . y += dir . y ; // remove tail while ( history . length >= snakeLength ) { var p = history . shift (); // remove first item from list g . setPixel ( p [ 0 ], p [ 1 ], 0 ); // clear that pixel } // add current position onto the end history . push ([ pos . x , pos . y ]); if ( g . getPixel ( pos . x , pos . y )) { // check for apples var wasApple = false ; for ( var i in apples ) if ( apples [ i ]. x == pos . x && apples [ i ]. y == pos . y ) { wasApple = true ; // delete this apple apples . splice ( i , 1 ); // add a new apple newApple (); // change score and increase snake length snakeLength += 1 ; score += 10 ; updateSnake (); // break out so we don't check any more apples break ; } if ( ! wasApple ) gameOver (); } else { g . setPixel ( pos . x , pos . y ); g . flip (); } } function rotate ( d ) { if ( dir . x ) { dir = { x : 0 , y : d * dir . x }; } else { dir = { x :- d * dir . y , y : 0 }; } } onInit ();","title":"Snake"},{"location":"github-pages-jekyll/","text":"Crea il tuo sito tramite GitHub Pages e jekyll Jekyll \u00e8 un semplice generatore di siti statici, compatibile con i blog, per siti personali, di progetto o di organizzazione. Scritto in Ruby da Tom Preston-Werner, co-fondatore di GitHub, \u00e8 distribuito con licenza open source MIT. Consente di creare un sito statico grazie alla sola conoscenza del linguaggio markdown supportato nativamente da GitHub. Non \u00e8 quindi richiesta una conoscenza dei linguaggi html e css . Dispone di una enorme quantit\u00e0 di temi gratuiti i quali consentono personalizzazioni pi\u00f9 o meno avanzate. Per chi conosce i linguaggi html e css sar\u00e0 possibile aggiungere elementi o modificare lo stile a piacimento. Prerequisiti e installazione Come ho gi\u00e0 detto, non \u00e8 richiesta una conoscenza dei linguaggi html e css a patto che tu conosca il linguaggio markdown . Jekyll si occuper\u00e0 di convertire, tra le altre cose, la tue pagine markdown in pagine html . Per chi avesse la necessit\u00e0 di modificare il layout standard aggiungendo elementi o modificando lo stile nativo del tema al di fuori delle possibilit\u00e0 offerte dal creatore del tema sar\u00e0 tuttavia richiesta una conoscenza intermedia dei linguaggi html e css . E' inoltre necessaria la conoscenza di git per la comunicazione con GitHUb Sei pronto? Per prima cosa devi installare jekyll e git per il tuo sistema operativo. Installazione di jekyll su Ubuntu Devi installare tutte le dipendenze: - ruby - rubygems - gcc - make Il seguente comando installa tutte le dipendenze necessarie: sudo apt-get install ruby-full build-essential zlib1g-dev Evita di installare i pacchetti RubyGems (chiamati gems) come utente root. Invece, imposta una directory di installazione gem per il tuo account utente. I seguenti comandi aggiungeranno variabili d'ambiente al tuo file ~ / .bashrc per configurare il percorso di installazione di gem: echo '# Install Ruby Gems to ~/gems' >> ~/.bashrc echo 'export GEM_HOME=\"$HOME/gems\"' >> ~/.bashrc echo 'export PATH=\"$HOME/gems/bin:$PATH\"' >> ~/.bashrc source ~/.bashrc Installa jekyll e bundler gem install jekyll bundler Jekyll on Ubuntu Con questa procedura installerai l'ultima versione di jekyll. Per verificare la versione installata digita: jekyll -v In generale la versione di jekyll appena installata differisce da quella utilizzata da GitHub Pages per il deploy (pubblicazione) di una pagina web. Per verificare la versione utilizzata da GitHub Pages, visita GitHub pages - Dependency versions . Per evitare problemi consiglio di allinearsi alla versione di jekyll utilizzata da GitHub Pages ma solo in fase di creazione di un nuovo sito, quindi con un'installazione locale alla directory contente il progetto. Nei prossimi passaggi vedremo come fare.. Crea il tuo primo sito Crea una nuova directory con un nome a piacere, ad esempio myWebPage . Apri il terminale all'interno della repository appena creata e digita il comando per creare una nuova base per il sito. jekyll new . Adesso, lanciando il comando: jekyll serve Dovrebbe rispondere con qualcosa del genere: Configuration file: /home/s/Repository/myWebPage/_config.yml Source: /home/s/Repository/myWebPage Destination: /home/s/Repository/myWebPage/_site Incremental build: disabled. Enable with --incremental Generating... Jekyll Feed: Generating feed for posts done in 0 .211 seconds. Auto-regeneration: enabled for '/home/s/Repository/myWebPage' Server address: http://127.0.0.1:4000/ Server running... press ctrl-c to stop. Raggiungi l'indirizzo indicato dal campo Server address , nel mio caso http://127.0.0.1:4000/ , da terminale \u00e8 sufficiente un Ctrl + click o semplicemente copiando l'indirizzo su browser web. A questo punto dovresti vedere l'anteprima del tuo sito. Di default verr\u00e0 impostato un tema dal nome minima Non ti preoccupare adesso dei contenuti, avrai modo di configurarli con calma una volta finito il setup. Come dicevo, adesso ti consiglio di allinearti alla versione di jekyll utilizzata da GitHub Pages. Apri la directory del progetto, nel mio caso myWebPage . Troverai una serie di file: La nostra concentrazione per adesso va ai file Gemfile , Gemfile.lock e _config.yml . Apri il file Gemfile , troverai questo contenuto scritto nel linguaggio Ruby : source \"https://rubygems.org\" # Hello! This is where you manage which Jekyll version is used to run. # When you want to use a different version, change it below, save the # file and run `bundle install`. Run Jekyll with `bundle exec`, like so: # # bundle exec jekyll serve # # This will help ensure the proper Jekyll version is running. # Happy Jekylling! gem \"jekyll\" , \"~> 4.1.1\" # This is the default theme for new Jekyll sites. You may change this to anything you like. gem \"minima\" , \"~> 2.5\" # If you want to use GitHub Pages, remove the \"gem \"jekyll\"\" above and # uncomment the line below. To upgrade, run `bundle update github-pages`. # gem \"github-pages\", group: :jekyll_plugins # If you have any plugins, put them here! group :jekyll_plugins do gem \"jekyll-feed\" , \"~> 0.12\" end # Windows and JRuby does not include zoneinfo files, so bundle the tzinfo-data gem # and associated library. platforms :mingw , :x64_mingw , :mswin , :jruby do gem \"tzinfo\" , \"~> 1.2\" gem \"tzinfo-data\" end # Performance-booster for watching directories on Windows gem \"wdm\" , \"~> 0.1.1\" , :platforms => [ :mingw , :x64_mingw , :mswin ] Tra i commenti del file troviamo diverse indicazioni su come procedere per utilizzare GitHub Pages. In particolare devi impostare la versione di jekyll utilizzata da GitHub, nel mio caso 3.9.0 , consultabile da GitHub pages - Dependency versions . gem \"jekyll\" , \"~> 3.9.0\" e devi inserire anche la direttiva giusta per github-pages con l'attuale versione di GitHub Pages consultabile sempre da GitHub pages - Dependency versions . Nel mio caso la versione \u00e8 la 209 gem \"github-pages\" , \"~> 209\" , group : :jekyll_plugins Il file completo sar\u00e0: source \"https://rubygems.org\" # Hello! This is where you manage which Jekyll version is used to run. # When you want to use a different version, change it below, save the # file and run `bundle install`. Run Jekyll with `bundle exec`, like so: # # bundle exec jekyll serve # # This will help ensure the proper Jekyll version is running. # Happy Jekylling! gem \"jekyll\" , \"~> 3.9.0\" # This is the default theme for new Jekyll sites. You may change this to anything you like. gem \"minima\" #gem \"minima\", \"~> 2.5\" # If you want to use GitHub Pages, remove the \"gem \"jekyll\"\" above and # uncomment the line below. To upgrade, run `bundle update github-pages`. gem \"github-pages\" , \"~> 209\" , group : :jekyll_plugins # If you have any plugins, put them here! group :jekyll_plugins do gem \"jekyll-feed\" , \"~> 0.12\" end # Windows and JRuby does not include zoneinfo files, so bundle the tzinfo-data gem # and associated library. platforms :mingw , :x64_mingw , :mswin , :jruby do gem \"tzinfo\" , \"~> 1.2\" gem \"tzinfo-data\" end # Performance-booster for watching directories on Windows gem \"wdm\" , \"~> 0.1.1\" , :platforms => [ :mingw , :x64_mingw , :mswin ] A questo punto puoi salvare ed eliminare il file Gemfile.lock . Questo file infatti contiene tutte le dipendenze ed \u00e8 generato a partire dal file Gemfile . Ne dovrai generare uno nuovo. Da terminale, all'interno della directory del progetto digita: bundle install Verr\u00e0 generato un nuovo Gemfile.lock con tutte le dipendenze necessarie per GitHub Pages. Adesso, per lanciare l'anteprima della pagina, non puoi pi\u00f9 utilizzare il comando jekyll serve poich\u00e8 tale comando invocher\u00e0 la versione di jekyll installata globalmente sul tuo PC e quindi risulteresti non allineato. Dovrai lanciare il comando bundle exec jekyll serve come suggerito dal file Gemfile in modo da garantire che venga eseguita la versione di jekyll indicata dal file Gemfile e non quella installata su PC. Digita quindi: bundle exec jekyll serve A questo punto sei quasi pronto per pubblicare il tuo sito tramite GitHub Pages. Pubblica il sito su GitHub Pages Crea una repository vuota e pubblica su GitHub. Ti consiglio di dare lo stesso nome della directory utilizzata nel progetto, nel mio caso myWebPage . Il nome appena creato coincider\u00e0 con la subdirectory dell'indirizzo della propria pagina web che nel mio caso sar\u00e0: https://sidiri-8bit.github.io/myWebPage/ . Adesso torna alla directory del progetto e aggiungiamo quindi il subpath myWebPage all'interno del file _config.yml , baseurl: \"/myWebPage\" # the subpath of your site, e.g. /blog Il file completo sar\u00e0 una cosa del genere: # Welcome to Jekyll! title: Your awesome title email: your-email@example.com description: >- # this means to ignore newlines until \"baseurl:\" Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description. baseurl: \"/myWebPage\" # the subpath of your site, e.g. /blog url: \"\" # the base hostname & protocol for your site, e.g. http://example.com twitter_username: jekyllrb github_username: jekyll # Build settings theme: minima plugins: - jekyll-feed A questo punto lancia nuovamente il comando: bundle exec jekyll serve Bene, sei pronto a trasformare la directory nella repository GitHub che ospiter\u00e0 la tua pagina web. Tramite git digita: git init git add . git commit -m \"initial\" git branch -M master git remote add origin git@github.com:sidiri-8bit/myWebPage.git git push -u origin master e search results) and in your feed.xml site description. baseurl: \"\" # the subpath of your site, e.g. /blog url: \"\" # the base hostname & protocol for your site, e.g. http://example.com twitter_username: jekyllrb github_username: jekyll ina web. Apri la Repository e vai su Settings , sezione GitHub Pages . Seleziona il branch master , premi il tasto Save , una volta aggiornata la pagina, se torni alla sezione GitHub Pages dovresti trovare: Your site is published at https://sidiri-8bit.github.io/myWebPage/ Cliccando sul link dovresti visualizzare la tua pagina. Sei online! Attenzione al branch! Fintanto che farai le modifiche al sito ed eseguirai push sul branch master , GitHub effettuer\u00e0 il deploy in automatico della tua pagina. Per evitare il deploy puoi utilizzare un altro branch, un branch di lavoro qualsiasi ad esempio changes ma ricorda che affinch\u00e8 la pagina possa essere caricata dovrai effettuare il merge del tuo branch changes con il branch master Non importa specificare un subpath per il tuo sito! Se non vuoi specificare un subpath e pubblicare il sito come \"https://[username].github.io/\" la procedura \u00e8 semplificata. Crea una repository con il nome [username].github.io . Nel mio caso sar\u00e0 sidiri-8bit.github.io . La repository [username].github.io \u00e8 speciale , infatti GitHub la identifica gi\u00e0 come una repository pronta ad ospitare una pagina web e ad effettuare il deploy in automatico sul branch master . L'unica cosa che dovrai fare \u00e8 caricare il contenuto del tuo sito su questa repository togliendo dal file _config.yml il subpath indicato attraverso parametro baseurl . Riporto il file _config.yml completo: # Welcome to Jekyll! title: Your awesome title email: your-email@example.com description: >- # this means to ignore newlines until \"baseurl:\" Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description. baseurl: \"\" # the subpath of your site, e.g. /blog #url: \"\" # the base hostname & protocol for your site, e.g. http://example.com twitter_username: jekyllrb github_username: jekyll # Build settings theme: minima# Exclude from processing. plugins: - jekyll-feed Temi jekyll Adesso vedrai come impostare il tema just-the-docs . Questo tema, non essendo tra quelli ufficialmente supportati da GitHub va aggiunto in un atro modo. Ovviamente questa guida vale anche per altri temi. Modifica il Gemfile inserendo al posto di: gem \"minima\" Il tema just-the-docs : gem \"just-the-docs\" Modifica file _config.yml inserendo al posto di: theme: minima remote_theme: pmarsceill/just-the-docs Adesso cancella il file Gemfile.lock e lancia nuovamente: bundle install Per vedere l'anteprima lancia nuovamente il comando: bundle exec jekyll serve A questo punto esegui il commit e il push delle modifiche. git add . git commit -m \"add other theme\" git push Verr\u00e0 eseguito il deploy in automatico. L'anteprima di questo tema \u00e8 una cosa del genere: Come personalizzare un tema jekyll Stai utilizzando un tema ma vorresti personalizzarlo a tuo piacimento aggiungendo stile css o elelmenti html ? Normalmente ogni tema dispone di una documentazione per la personalizzazione della propria pagina. Si tratta in generale di impostare certi parametri di alto livello nel file _config.yml o definire alcune variabili in qualche file ad un path particolare. Ad esempio per il tema just-the-docs \u00e8 possibile creare un file con un nome a piacimento ad esempio my_schema.scss ad un percorso specifico, _sass/color_schemes/my_schema.scss e settare certe variabili (definite dal tema) come: $link-color : $purple-100 ; $sidebar-color : $grey-lt-100 ; $content-width : 1000 px ; consentendo di cambiare certi colori o ridefinire alcuni margini o proporzioni. Questo file deve essere aggiunto come build settings inserendo la seguente riga nel file _config.yml : color_scheme: my_schema Ovviamente queste modifiche sono limitate alle possibilit\u00e0 definite dal creatore del tema. Aggiunta css Per aver accesso ad una personalizzazione pi\u00f9 profonda in genere viene data la possibilit\u00e0 di ridefinire completamente lo stile css sovraiscrivendo solo gli attributi che ci interessano. Nel caso del tema just-the-docs viene data la possibilit\u00e0 di creare un file con il nome specifico custom.scss al path _sass/custom/custom.scss . In questo modo utilizzando le regole css \u00e8 possibile cambiare lo stile di ogni elemento della pagina. Purtroppo, essendo un'operazione di basso livello richiede una conoscenza approfondita del linguaggio css e di comprendere la logica di layout con cui \u00e8 stata progettata la pagina. Ti dovrai armare di pazienza e dello strumento Ispeziona del browser per risalire al selettore giusto per ottenere la modifica che ti serve. Potrete trovare inoltre lo stile completo css all'interno della cartella _site , nel mio caso si trova al path _site/assets/css/just-the-docs-default.css . Personalmente ho modificato abbondantemente lo stile css Aggiunta html Se non ti basta modificare lo stile css e vuoi aggiungere anche elementi html si pu\u00f2 fare come sempre con una procedura di basso livello cio\u00e8 sovraiscrivendo la pagina html che dovrebbe occuparsi di aggiungere questi elementi. Da terminale, all'interno della root del tuo progetto digita bundle info [nome-tema] . In questo caso utilizzando il tema just-the-docs sar\u00e0: bundle info just-the-docs Risponder\u00e0 con il path di installazione del tema * just-the-docs ( 0 .3.3 ) Summary: A modern, highly customizable, and responsive Jekyll theme for documention with built-in search. Homepage: https://github.com/pmarsceill/just-the-docs Path: /home/s/gems/gems/just-the-docs-0.3.3 Raggiungi questa posizione e naviga tra le directory. Troverai le pagine html che generano il tuo sito. Devi copiare la pagina che ti interessa all'interno del tuo progetto allo stesso path. Personalmente, per il tema just-the-docs , ho copiato la pagina default.html all'interno della directory _layouts e le pagine footer.html , head.html , nav.html all'interno della directory _includes . Dopo averle incollate localmente rispettando i path ho iniziato ad apportre delle modifiche, aggiungendo social-link o un logo, modificando il footer di default o la nav-bar. Per caricare le nuove modifiche \u00e8 sufficiente lanciare il comando: bundle exec jekyll serve Personalizzazioni avanzate Nel file yml come abbiamo gi\u00e0 visto, sono definite delle variabili come title , description , github_username richiamate dalle pagine html attraverso la sintassi: Ho dovuto usare un'immagine perch\u00e8 jekyll cercherebbe di applicare la valorizzazione # Welcome to Jekyll! title: Your awesome title email: your-email@example.com description: >- # this means to ignore newlines until \"baseurl:\" Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description. baseurl: \"\" # the subpath of your site, e.g. /blog #url: \"\" # the base hostname & protocol for your site, e.g. http://example.com twitter_username: jekyllrb github_username: jekyll # Build settings theme: minima plugins: - jekyll-feed Io ad esempio ho utilizzato la variabile github_username per aggiungere un icona che punti al mio account github:","title":"Crea il tuo sito tramite GitHub Pages e jekyll"},{"location":"github-pages-jekyll/#crea-il-tuo-sito-tramite-github-pages-e-jekyll","text":"Jekyll \u00e8 un semplice generatore di siti statici, compatibile con i blog, per siti personali, di progetto o di organizzazione. Scritto in Ruby da Tom Preston-Werner, co-fondatore di GitHub, \u00e8 distribuito con licenza open source MIT. Consente di creare un sito statico grazie alla sola conoscenza del linguaggio markdown supportato nativamente da GitHub. Non \u00e8 quindi richiesta una conoscenza dei linguaggi html e css . Dispone di una enorme quantit\u00e0 di temi gratuiti i quali consentono personalizzazioni pi\u00f9 o meno avanzate. Per chi conosce i linguaggi html e css sar\u00e0 possibile aggiungere elementi o modificare lo stile a piacimento.","title":"Crea il tuo sito tramite GitHub Pages e jekyll"},{"location":"github-pages-jekyll/#prerequisiti-e-installazione","text":"Come ho gi\u00e0 detto, non \u00e8 richiesta una conoscenza dei linguaggi html e css a patto che tu conosca il linguaggio markdown . Jekyll si occuper\u00e0 di convertire, tra le altre cose, la tue pagine markdown in pagine html . Per chi avesse la necessit\u00e0 di modificare il layout standard aggiungendo elementi o modificando lo stile nativo del tema al di fuori delle possibilit\u00e0 offerte dal creatore del tema sar\u00e0 tuttavia richiesta una conoscenza intermedia dei linguaggi html e css . E' inoltre necessaria la conoscenza di git per la comunicazione con GitHUb Sei pronto? Per prima cosa devi installare jekyll e git per il tuo sistema operativo.","title":"Prerequisiti e installazione"},{"location":"github-pages-jekyll/#installazione-di-jekyll-su-ubuntu","text":"Devi installare tutte le dipendenze: - ruby - rubygems - gcc - make Il seguente comando installa tutte le dipendenze necessarie: sudo apt-get install ruby-full build-essential zlib1g-dev Evita di installare i pacchetti RubyGems (chiamati gems) come utente root. Invece, imposta una directory di installazione gem per il tuo account utente. I seguenti comandi aggiungeranno variabili d'ambiente al tuo file ~ / .bashrc per configurare il percorso di installazione di gem: echo '# Install Ruby Gems to ~/gems' >> ~/.bashrc echo 'export GEM_HOME=\"$HOME/gems\"' >> ~/.bashrc echo 'export PATH=\"$HOME/gems/bin:$PATH\"' >> ~/.bashrc source ~/.bashrc Installa jekyll e bundler gem install jekyll bundler Jekyll on Ubuntu Con questa procedura installerai l'ultima versione di jekyll. Per verificare la versione installata digita: jekyll -v In generale la versione di jekyll appena installata differisce da quella utilizzata da GitHub Pages per il deploy (pubblicazione) di una pagina web. Per verificare la versione utilizzata da GitHub Pages, visita GitHub pages - Dependency versions . Per evitare problemi consiglio di allinearsi alla versione di jekyll utilizzata da GitHub Pages ma solo in fase di creazione di un nuovo sito, quindi con un'installazione locale alla directory contente il progetto. Nei prossimi passaggi vedremo come fare..","title":"Installazione di jekyll su Ubuntu"},{"location":"github-pages-jekyll/#crea-il-tuo-primo-sito","text":"Crea una nuova directory con un nome a piacere, ad esempio myWebPage . Apri il terminale all'interno della repository appena creata e digita il comando per creare una nuova base per il sito. jekyll new . Adesso, lanciando il comando: jekyll serve Dovrebbe rispondere con qualcosa del genere: Configuration file: /home/s/Repository/myWebPage/_config.yml Source: /home/s/Repository/myWebPage Destination: /home/s/Repository/myWebPage/_site Incremental build: disabled. Enable with --incremental Generating... Jekyll Feed: Generating feed for posts done in 0 .211 seconds. Auto-regeneration: enabled for '/home/s/Repository/myWebPage' Server address: http://127.0.0.1:4000/ Server running... press ctrl-c to stop. Raggiungi l'indirizzo indicato dal campo Server address , nel mio caso http://127.0.0.1:4000/ , da terminale \u00e8 sufficiente un Ctrl + click o semplicemente copiando l'indirizzo su browser web. A questo punto dovresti vedere l'anteprima del tuo sito. Di default verr\u00e0 impostato un tema dal nome minima Non ti preoccupare adesso dei contenuti, avrai modo di configurarli con calma una volta finito il setup. Come dicevo, adesso ti consiglio di allinearti alla versione di jekyll utilizzata da GitHub Pages. Apri la directory del progetto, nel mio caso myWebPage . Troverai una serie di file: La nostra concentrazione per adesso va ai file Gemfile , Gemfile.lock e _config.yml . Apri il file Gemfile , troverai questo contenuto scritto nel linguaggio Ruby : source \"https://rubygems.org\" # Hello! This is where you manage which Jekyll version is used to run. # When you want to use a different version, change it below, save the # file and run `bundle install`. Run Jekyll with `bundle exec`, like so: # # bundle exec jekyll serve # # This will help ensure the proper Jekyll version is running. # Happy Jekylling! gem \"jekyll\" , \"~> 4.1.1\" # This is the default theme for new Jekyll sites. You may change this to anything you like. gem \"minima\" , \"~> 2.5\" # If you want to use GitHub Pages, remove the \"gem \"jekyll\"\" above and # uncomment the line below. To upgrade, run `bundle update github-pages`. # gem \"github-pages\", group: :jekyll_plugins # If you have any plugins, put them here! group :jekyll_plugins do gem \"jekyll-feed\" , \"~> 0.12\" end # Windows and JRuby does not include zoneinfo files, so bundle the tzinfo-data gem # and associated library. platforms :mingw , :x64_mingw , :mswin , :jruby do gem \"tzinfo\" , \"~> 1.2\" gem \"tzinfo-data\" end # Performance-booster for watching directories on Windows gem \"wdm\" , \"~> 0.1.1\" , :platforms => [ :mingw , :x64_mingw , :mswin ] Tra i commenti del file troviamo diverse indicazioni su come procedere per utilizzare GitHub Pages. In particolare devi impostare la versione di jekyll utilizzata da GitHub, nel mio caso 3.9.0 , consultabile da GitHub pages - Dependency versions . gem \"jekyll\" , \"~> 3.9.0\" e devi inserire anche la direttiva giusta per github-pages con l'attuale versione di GitHub Pages consultabile sempre da GitHub pages - Dependency versions . Nel mio caso la versione \u00e8 la 209 gem \"github-pages\" , \"~> 209\" , group : :jekyll_plugins Il file completo sar\u00e0: source \"https://rubygems.org\" # Hello! This is where you manage which Jekyll version is used to run. # When you want to use a different version, change it below, save the # file and run `bundle install`. Run Jekyll with `bundle exec`, like so: # # bundle exec jekyll serve # # This will help ensure the proper Jekyll version is running. # Happy Jekylling! gem \"jekyll\" , \"~> 3.9.0\" # This is the default theme for new Jekyll sites. You may change this to anything you like. gem \"minima\" #gem \"minima\", \"~> 2.5\" # If you want to use GitHub Pages, remove the \"gem \"jekyll\"\" above and # uncomment the line below. To upgrade, run `bundle update github-pages`. gem \"github-pages\" , \"~> 209\" , group : :jekyll_plugins # If you have any plugins, put them here! group :jekyll_plugins do gem \"jekyll-feed\" , \"~> 0.12\" end # Windows and JRuby does not include zoneinfo files, so bundle the tzinfo-data gem # and associated library. platforms :mingw , :x64_mingw , :mswin , :jruby do gem \"tzinfo\" , \"~> 1.2\" gem \"tzinfo-data\" end # Performance-booster for watching directories on Windows gem \"wdm\" , \"~> 0.1.1\" , :platforms => [ :mingw , :x64_mingw , :mswin ] A questo punto puoi salvare ed eliminare il file Gemfile.lock . Questo file infatti contiene tutte le dipendenze ed \u00e8 generato a partire dal file Gemfile . Ne dovrai generare uno nuovo. Da terminale, all'interno della directory del progetto digita: bundle install Verr\u00e0 generato un nuovo Gemfile.lock con tutte le dipendenze necessarie per GitHub Pages. Adesso, per lanciare l'anteprima della pagina, non puoi pi\u00f9 utilizzare il comando jekyll serve poich\u00e8 tale comando invocher\u00e0 la versione di jekyll installata globalmente sul tuo PC e quindi risulteresti non allineato. Dovrai lanciare il comando bundle exec jekyll serve come suggerito dal file Gemfile in modo da garantire che venga eseguita la versione di jekyll indicata dal file Gemfile e non quella installata su PC. Digita quindi: bundle exec jekyll serve A questo punto sei quasi pronto per pubblicare il tuo sito tramite GitHub Pages.","title":"Crea il tuo primo sito"},{"location":"github-pages-jekyll/#pubblica-il-sito-su-github-pages","text":"Crea una repository vuota e pubblica su GitHub. Ti consiglio di dare lo stesso nome della directory utilizzata nel progetto, nel mio caso myWebPage . Il nome appena creato coincider\u00e0 con la subdirectory dell'indirizzo della propria pagina web che nel mio caso sar\u00e0: https://sidiri-8bit.github.io/myWebPage/ . Adesso torna alla directory del progetto e aggiungiamo quindi il subpath myWebPage all'interno del file _config.yml , baseurl: \"/myWebPage\" # the subpath of your site, e.g. /blog Il file completo sar\u00e0 una cosa del genere: # Welcome to Jekyll! title: Your awesome title email: your-email@example.com description: >- # this means to ignore newlines until \"baseurl:\" Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description. baseurl: \"/myWebPage\" # the subpath of your site, e.g. /blog url: \"\" # the base hostname & protocol for your site, e.g. http://example.com twitter_username: jekyllrb github_username: jekyll # Build settings theme: minima plugins: - jekyll-feed A questo punto lancia nuovamente il comando: bundle exec jekyll serve Bene, sei pronto a trasformare la directory nella repository GitHub che ospiter\u00e0 la tua pagina web. Tramite git digita: git init git add . git commit -m \"initial\" git branch -M master git remote add origin git@github.com:sidiri-8bit/myWebPage.git git push -u origin master e search results) and in your feed.xml site description. baseurl: \"\" # the subpath of your site, e.g. /blog","title":"Pubblica il sito su GitHub Pages"},{"location":"github-pages-jekyll/#url-the-base-hostname-protocol-for-your-site-eg-httpexamplecom","text":"twitter_username: jekyllrb github_username: jekyll ina web. Apri la Repository e vai su Settings , sezione GitHub Pages . Seleziona il branch master , premi il tasto Save , una volta aggiornata la pagina, se torni alla sezione GitHub Pages dovresti trovare: Your site is published at https://sidiri-8bit.github.io/myWebPage/ Cliccando sul link dovresti visualizzare la tua pagina. Sei online! Attenzione al branch! Fintanto che farai le modifiche al sito ed eseguirai push sul branch master , GitHub effettuer\u00e0 il deploy in automatico della tua pagina. Per evitare il deploy puoi utilizzare un altro branch, un branch di lavoro qualsiasi ad esempio changes ma ricorda che affinch\u00e8 la pagina possa essere caricata dovrai effettuare il merge del tuo branch changes con il branch master Non importa specificare un subpath per il tuo sito! Se non vuoi specificare un subpath e pubblicare il sito come \"https://[username].github.io/\" la procedura \u00e8 semplificata. Crea una repository con il nome [username].github.io . Nel mio caso sar\u00e0 sidiri-8bit.github.io . La repository [username].github.io \u00e8 speciale , infatti GitHub la identifica gi\u00e0 come una repository pronta ad ospitare una pagina web e ad effettuare il deploy in automatico sul branch master . L'unica cosa che dovrai fare \u00e8 caricare il contenuto del tuo sito su questa repository togliendo dal file _config.yml il subpath indicato attraverso parametro baseurl . Riporto il file _config.yml completo: # Welcome to Jekyll! title: Your awesome title email: your-email@example.com description: >- # this means to ignore newlines until \"baseurl:\" Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description. baseurl: \"\" # the subpath of your site, e.g. /blog #url: \"\" # the base hostname & protocol for your site, e.g. http://example.com twitter_username: jekyllrb github_username: jekyll # Build settings theme: minima# Exclude from processing. plugins: - jekyll-feed","title":"url: \"\" # the base hostname &amp; protocol for your site, e.g. http://example.com"},{"location":"github-pages-jekyll/#temi-jekyll","text":"Adesso vedrai come impostare il tema just-the-docs . Questo tema, non essendo tra quelli ufficialmente supportati da GitHub va aggiunto in un atro modo. Ovviamente questa guida vale anche per altri temi. Modifica il Gemfile inserendo al posto di: gem \"minima\" Il tema just-the-docs : gem \"just-the-docs\" Modifica file _config.yml inserendo al posto di: theme: minima remote_theme: pmarsceill/just-the-docs Adesso cancella il file Gemfile.lock e lancia nuovamente: bundle install Per vedere l'anteprima lancia nuovamente il comando: bundle exec jekyll serve A questo punto esegui il commit e il push delle modifiche. git add . git commit -m \"add other theme\" git push Verr\u00e0 eseguito il deploy in automatico. L'anteprima di questo tema \u00e8 una cosa del genere:","title":"Temi jekyll"},{"location":"github-pages-jekyll/#come-personalizzare-un-tema-jekyll","text":"Stai utilizzando un tema ma vorresti personalizzarlo a tuo piacimento aggiungendo stile css o elelmenti html ? Normalmente ogni tema dispone di una documentazione per la personalizzazione della propria pagina. Si tratta in generale di impostare certi parametri di alto livello nel file _config.yml o definire alcune variabili in qualche file ad un path particolare. Ad esempio per il tema just-the-docs \u00e8 possibile creare un file con un nome a piacimento ad esempio my_schema.scss ad un percorso specifico, _sass/color_schemes/my_schema.scss e settare certe variabili (definite dal tema) come: $link-color : $purple-100 ; $sidebar-color : $grey-lt-100 ; $content-width : 1000 px ; consentendo di cambiare certi colori o ridefinire alcuni margini o proporzioni. Questo file deve essere aggiunto come build settings inserendo la seguente riga nel file _config.yml : color_scheme: my_schema Ovviamente queste modifiche sono limitate alle possibilit\u00e0 definite dal creatore del tema.","title":"Come personalizzare un tema jekyll"},{"location":"github-pages-jekyll/#aggiunta-css","text":"Per aver accesso ad una personalizzazione pi\u00f9 profonda in genere viene data la possibilit\u00e0 di ridefinire completamente lo stile css sovraiscrivendo solo gli attributi che ci interessano. Nel caso del tema just-the-docs viene data la possibilit\u00e0 di creare un file con il nome specifico custom.scss al path _sass/custom/custom.scss . In questo modo utilizzando le regole css \u00e8 possibile cambiare lo stile di ogni elemento della pagina. Purtroppo, essendo un'operazione di basso livello richiede una conoscenza approfondita del linguaggio css e di comprendere la logica di layout con cui \u00e8 stata progettata la pagina. Ti dovrai armare di pazienza e dello strumento Ispeziona del browser per risalire al selettore giusto per ottenere la modifica che ti serve. Potrete trovare inoltre lo stile completo css all'interno della cartella _site , nel mio caso si trova al path _site/assets/css/just-the-docs-default.css . Personalmente ho modificato abbondantemente lo stile css","title":"Aggiunta css"},{"location":"github-pages-jekyll/#aggiunta-html","text":"Se non ti basta modificare lo stile css e vuoi aggiungere anche elementi html si pu\u00f2 fare come sempre con una procedura di basso livello cio\u00e8 sovraiscrivendo la pagina html che dovrebbe occuparsi di aggiungere questi elementi. Da terminale, all'interno della root del tuo progetto digita bundle info [nome-tema] . In questo caso utilizzando il tema just-the-docs sar\u00e0: bundle info just-the-docs Risponder\u00e0 con il path di installazione del tema * just-the-docs ( 0 .3.3 ) Summary: A modern, highly customizable, and responsive Jekyll theme for documention with built-in search. Homepage: https://github.com/pmarsceill/just-the-docs Path: /home/s/gems/gems/just-the-docs-0.3.3 Raggiungi questa posizione e naviga tra le directory. Troverai le pagine html che generano il tuo sito. Devi copiare la pagina che ti interessa all'interno del tuo progetto allo stesso path. Personalmente, per il tema just-the-docs , ho copiato la pagina default.html all'interno della directory _layouts e le pagine footer.html , head.html , nav.html all'interno della directory _includes . Dopo averle incollate localmente rispettando i path ho iniziato ad apportre delle modifiche, aggiungendo social-link o un logo, modificando il footer di default o la nav-bar. Per caricare le nuove modifiche \u00e8 sufficiente lanciare il comando: bundle exec jekyll serve","title":"Aggiunta html"},{"location":"github-pages-jekyll/#personalizzazioni-avanzate","text":"Nel file yml come abbiamo gi\u00e0 visto, sono definite delle variabili come title , description , github_username richiamate dalle pagine html attraverso la sintassi: Ho dovuto usare un'immagine perch\u00e8 jekyll cercherebbe di applicare la valorizzazione # Welcome to Jekyll! title: Your awesome title email: your-email@example.com description: >- # this means to ignore newlines until \"baseurl:\" Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description. baseurl: \"\" # the subpath of your site, e.g. /blog #url: \"\" # the base hostname & protocol for your site, e.g. http://example.com twitter_username: jekyllrb github_username: jekyll # Build settings theme: minima plugins: - jekyll-feed Io ad esempio ho utilizzato la variabile github_username per aggiungere un icona che punti al mio account github:","title":"Personalizzazioni avanzate"},{"location":"html/Progetti/myPersonalWebPage/","text":"My personal Webpage","title":"Index"},{"location":"html/Progetti/myPersonalWebPage/#my-personal-webpage","text":"","title":"My personal Webpage"},{"location":"java/","text":"Java Java - Modulo Base Java - OOP","title":"Java"},{"location":"java/#java","text":"Java - Modulo Base Java - OOP","title":"Java"},{"location":"java/java-basic-module/","text":"Java - write once, run anywhere Java - write once, run anywhere Lezione 01 Descrizione Principi JVM: Java Virtual Machine JRE: Java Runtime Environment JDK: Java Development Kit Lezione 02 Processo di compilazione Java Setup di Java Lezione 03 Primo programma - compilazione manuale Lezione 04 Installazione e setup di Eclipse Primo progetto con Eclipse Lezione 05 Introduzione alla OOP Classi, oggetti, metodi Lezione 06 Metodo Main Metodo print Qualche stampa Commenti Lezione 07 Qualche espressione aritmetica Lezione 08 Variabili Lezione 09 Esercizio - Calcolo dell'interesse annuo Lezione 10 Approfondimento sui tipi primitivi Lezione 11 Ancora sui numeri Lezione 12 Il tipo char Lezione 13 Il tipo boolean Lezione 14 Introduzione a String Lezione 15 Operatori Precedenza degli operatori Operatori Unari Operatori binari Lezione 16 Tra stringhe e caratteri. Lezione 17 E i boolean? Lezione 18 Numeri decimali Lezione 19 Espressioni miste Lezione 20 Numeri Esadecimali, ottali Costanti numeriche Sequenze di escape Lezione 21 Operatori di Assegnamento Lezione 22 Operatori Relazionali Lezione 23 Operatori Logici Lezione 24 Costrutto Condizionali If ... Else Lezione 25 Costrutto Switch Lezione 26 Leggere dati da tastiera Lezione 27 Costrutti Iterativi Ciclo while Lezione 28 Qualche esercizio Stampa somma esercizio base stampa somma esercizio avanzato Aggiunta di un controllo Lezione 28 Ciclo do ... while Lezione 29 - For loop Lezione 30 break e continue Lezione 31 Sottoprogrammi, Funzioni, Metodi Definizione di un metodo: Chiamata di un metodo: Lezione 32 due parole sui parametri Lezione 33 Return Lezione 34 Qualche approfondimento sui parametri Lezione 35 Array Lezione 36 Errori con gli array Lezione 37 Approfondimento Input tastiera Lezione 38 Costrutto try catch Lezione 39 Esercizio calcolo interesse con input da tastiera parte 1 Lezione 40 Buffered reader Vs Scanner Lezione 41 Regular expression Lezione 42 Esercizio calcolo interesse con input da tastiera parte 2 Lezione 01 documentazione oracle In informatica Java \u00e8 un linguaggio di programmazione ad alto livello, orientato agli oggetti e a tipizzazione statica, che si appoggia sull'omonima piattaforma software di esecuzione, specificamente progettato per essere il pi\u00f9 possibile indipendente dalla piattaforma hardware di esecuzione (tramite compilazione in bytecode prima e interpretazione poi da parte di una JVM) (sebbene questa caratteristica comporti prestazioni in termini di computazione inferiori a quelle di linguaggi direttamente compilati come C e C++ ovvero dunque perfettamente adattati alla piattaforma hardware). Java - Wikipedia Descrizione Uno dei principi fondamentali del linguaggio \u00e8 espresso dal motto WORA (write once, run anywhere, ossia \"scrivi una volta, esegui ovunque\"): il codice compilato che viene eseguito su una piattaforma non deve essere ricompilato per essere eseguito su una piattaforma diversa; infatti il prodotto della compilazione \u00e8 in un formato chiamato bytecode che pu\u00f2 essere eseguito da una qualunque implementazione di un processore virtuale detto Java Virtual Machine; al 2014 Java risulta essere uno dei linguaggi di programmazione pi\u00f9 usati al mondo, specialmente per applicazioni client-server, con un numero di sviluppatori stimato intorno ai 9 milioni; un buon punto di partenza per imparare Java \u00e8 il tutorial ufficiale. Java - Wikipedia Principi Java venne creato per soddisfare cinque obiettivi primari: 1. essere \"semplice, orientato agli oggetti e familiare\"; 2. essere \"robusto e sicuro\"; 3. essere indipendente dalla piattaforma; 4. contenere strumenti e librerie per il networking; 5. essere progettato per eseguire codice da sorgenti remote in modo sicuro. Java - Wikipedia JVM: Java Virtual Machine In informatica la macchina virtuale Java (detta anche Java Virtual Machine o JVM) \u00e8 il componente software della piattaforma Java che esegue i programmi tradotti in bytecode dopo la prima fase di compilazione in bytecode (tra i linguaggi di programmazione che possono essere tradotti in bytecode troviamo Java, Groovy, Clojure, Scala ed Eta). I passi che devono essere fatti per eseguire un programma scritto in linguaggio Java sono i seguenti: Un programmatore usa un editor di testo o un integrated development environment come Eclipse, NetBeans o IntelliJ IDEA per scrivere una o pi\u00f9 classi Java Un software di compilazione trasforma il programma in bytecode, che \u00e8 una leggera astrazione del codice macchina Il bytecode viene fornito ad una macchina virtuale Java che lo esegue Il bytecode \u00e8 generalmente prodotto dalla compilazione di codici sorgenti (o file sorgenti) scritti in linguaggio Java, anche se \u00e8 possibile produrre bytecode partendo da altri linguaggi come Scala, Clojure o Groovy. La JVM \u00e8 definita da una specifica, mantenuta da Oracle. Qualsiasi sistema che si comporti in modo coerente con tale specifica viene considerato come una particolare implementazione della JVM. Esistono implementazioni software per praticamente tutti i sistemi operativi moderni, sia gratuite che commerciali. Inoltre, esistono implementazioni speciali per particolari ambienti hardware/software, come telefoni cellulari e palmari), e persino implementazioni hardware come Jazelle. La disponibilit\u00e0 di implementazioni della macchina virtuale Java per diversi ambienti operativi \u00e8 la chiave della portabilit\u00e0 di Java, proclamata nello slogan write once, run everywhere (\"scrivi una volta, esegui dappertutto\"). La macchina virtuale realizza infatti un ambiente di esecuzione omogeneo, che nasconde al software Java (e quindi al programmatore) qualsiasi specificit\u00e0 del sistema operativo sottostante JVM - Wikipedia JRE: Java Runtime Environment In quanto tale contiene la Java Virtual Machine, le librerie standard (API Java) e un launcher per le applicazioni Java, necessario per avviare i programmi scritti in linguaggio Java e gi\u00e0 compilati in bytecode; \u00e8 dunque necessario quando si hanno programmi scritti in Java forniti gi\u00e0 compilati in bytecode. Materialmente JRE \u00e8 un plugin per browser in quanto \u00e8 impiegato per applicazioni web che contengono componenti scritte in Java. Esso non costituisce un ambiente di sviluppo software e non contiene strumenti di sviluppo (compilatori e/o debugger): per poter sviluppare in Java a monte, a partire dal codice sorgente, \u00e8 necessario infatti il Java Development Kit (che tipicamente contiene anche il JRE), anch'esso distribuito gratuitamente dalla Sun. Molti IDE offrono inoltre la possibilit\u00e0 di agganciare (linkare) la JRE e poter cos\u00ec sviluppare i propri programmi coadiuvati dell'editor. Rilasciato in versione 32 bit e 64 bit, ad oggi, l'ultima versione della Java 2 Platform, Standard Edition Runtime Environment \u00e8 la versione 8: ogni versione ha molti aggiornamenti (detti anche build) che vengono rilasciati durante il periodo di sviluppo (ad es. JRE 6 \u00e8 arrivato sino all'aggiornamento 45, mentre JRE 7 all'aggiornamento 51; a maggio 2019 JRE versione 8 \u00e8 in aggiornamento 211 (rilasciata il 16 aprile 2019). JRE - Wikipedia JDK: Java Development Kit In informatica il JDK (java development kit) \u00e8 l'insieme degli strumenti per sviluppare programmi da parte dei programmatori Java. \u00c8 un prodotto della Oracle Corporation, e fin dall'introduzione di Java \u00e8 sempre stato l'ambiente di sviluppo pi\u00f9 utilizzato dai programmatori Java soprattutto per applicazioni desktop. Per applicazioni pi\u00f9 complesse (es. applicazioni web) oggi sempre pi\u00f9 spesso si utilizzano per lo sviluppo ed esecuzione programmi IDE a cui \u00e8 possibile agganciare la JRE. JDK - Wikipedia Lezione 02 Processo di compilazione Java Il codice sorgente java .java per poter essere eseguito deve essere: 1. Tradotto in Bytecode , formato .class tramite il compilatore JavaC 2. Assemblato insieme alle librerie Java utilizzate (anch'esse in Bytecode) attraverso un Loader producendo un file Bytecode molto efficiente 3. Interpretato dall'interprete Java situato all'interno della Java Virtual Machine Setup di Java Scarica la JDK per il tuo sistema operativo: Fai riferimento alla Java SE cio\u00e8 alla piattaforma Standard Edition . La Java EE \u00e8 la versione Enterprise \u00e8 pensata soprattutto per applicativi server. Installazione Ubuntu Per il sistema operativo Ubuntu dovrebbe gi\u00e0 essere installata una versione del java development kit. Da terminale digitando: java --version Puoi verificare la versione installata. Nel mio caso: openjdk 11 .0.9.1 2020 -11-04 OpenJDK Runtime Environment ( build 11 .0.9.1+1-Ubuntu-0ubuntu1.20.10 ) OpenJDK 64 -Bit Server VM ( build 11 .0.9.1+1-Ubuntu-0ubuntu1.20.10, mixed mode, sharing ) Puoi inoltre verificare la versione di javac il compilatore Java digitando da terminale: javac --version A questo punto la bash potrebbe non riconoscere il comando perch\u00e8 l'installazione del pacchetto JDK non \u00e8 globale. Comando \u00abjavac\u00bb non trovato, ma pu\u00f2 essere installato con: sudo apt install default-jdk # version 2:1.11-72, or sudo apt install openjdk-11-jdk-headless # version 11.0.9.1+1-0ubuntu1~20.10 sudo apt install ecj # version 3.16.0-1 sudo apt install openjdk-13-jdk-headless # version 13.0.4+8-1 sudo apt install openjdk-14-jdk-headless # version 14.0.2+12-1 sudo apt install openjdk-15-jdk-headless # version 15+36-1 sudo apt install openjdk-8-jdk-headless # version 8u275-b01-0ubuntu1~20.10 Puoi installare una versione globale e aggiornata del JDK seguendo la procedura descritta dal sito ufficiale scaricando il pacchetto .rpm oppure puoi digitare il comando per l'installazione della versione 15: sudo apt install openjdk-15-jdk-headless # version 15+36-1 A questo punto \u00e8 possibile verificare che sia stata installata la versione giusta con il comando: javac --version Che dovr\u00e0 rispondere con: 15 Inoltre, digitando nuovamente: java --version Troverete aggiornato anche il pacchetto JDK : openjdk 15 2020 -09-15 OpenJDK Runtime Environment ( build 15 +36-Ubuntu-1 ) OpenJDK 64 -Bit Server VM ( build 15 +36-Ubuntu-1, mixed mode, sharing ) Se ti sei confuso durante l'installazione delle versioni di java o ti sei reso contoc che hai bisogno di un'altra versione puoi eliminare tutto con il comando: sudo apt-get remove openjdk* A questo punto, i comandi java e javac non saranno riconosciuti da terminale e potrai procedere ad una nuova installazione Installazione Windows Scarica l'installer per windows Esegui la procedura di installazione guidata. Una volta installato il pacchetto JDK apri il prompt dei comandi cmd e digita: java -version Dovrebbe rispondere con la versione di Java del pacchetto JDK appena scaricata: java version \"15.0.1\" 2020-10-20 Java(TM) SE Runtime Environment (build 15.0.1+9-18) Java HotSpot(TM) 64-Bit Server VM (build 15.0.1+9-18, mixed mode, sharing) Verifica che sia raggiungibile da prompt dei comandi anche il compilatore Java, digitando: javac -version Se risponder\u00e0 con un output del tipo: javac 15.0.1 vuol dire che il setup \u00e8 terminato, altrimenti sar\u00e0 sufficiente aggiungere come variabile d'ambiente la directory bin all'interno della cartella di installazione di Java. Nel mio caso e probabilmente anche nel tuo (se hai installato la versione a 64 bit) si trova al percorso: C:\\Program Files\\Java\\jdk-15.0.1\\bin Lezione 03 Primo programma - compilazione manuale Scrivi il seguente pezzo di codice in un file utilizzando un editor di testo come blocco note (windows) o gedit (linux) public class MioCalcolo { public static void main ( String [] args ){ System . out . print ( 5 + 3 ); } } Salva il file con nome MioCalcolo.java all'interno di una directory specifica, raggiungi la posizione da terminale e compila il file java digitando: javac MioCalcolo.java Il compilatore java compiler\u00e0 il sorgente MioCalcolo.java producendo un file MioCalcolo.class ovvero la traduzione del sorgente in bytecode. A questo punto digitando il comando: java MioCalcolo Verr\u00e0 eseguito il codice che produrr\u00e0 come risultato la stampa: 8 Lezione 04 Installazione e setup di Eclipse Per questo corso utilizzeremo Eclipse come IDE. Installazione Ubuntu Per installare Eclipse digita da terminale: sudo snap install --classic eclipse Poich\u00e8 abbiamo gi\u00e0 installato tutti i pacchetti necessari con la procedura descritta sopra, Eclipse li riconoscer\u00e0 e li utilizzer\u00e0. Installazione Windows Scarica Eclipse ed esegui l'installer. Una volta terminato il processo di installazione avrai gli strumenti necessari alla compilazione e debug del codice Java Primo progetto con Eclipse Aprendo Eclipse, ti chieder\u00e0 di scegliere una workspace: Scegli una directory di lavoro e premi su Launch . Comparir\u00e0 adesso la finestra di selezione di un progetto. Clicca su Create a new Java Project Attenzione!! Su windows consiglio di spuntare Use default JRE 'jre' and workspace compiler preferences perch\u00e8 potrebbe andare in conflitto con le versioni di JRE installate globalmente su PC Scegli un nome del progetto ad esempio mioTest e premi su Finish Ti chieder\u00e0 infine se vuoi creare il file module-info.java , Per adesso premi su Don't Create Comparir\u00e0 finalmente la finestra principale di lavoro. A sinistra troverai il file explore del tuo ambiente di lavoro. Per creare un nuovo progetto clicca con il destro su src e scegli new/class Dai un nome al file, ad esempio prova01 e seleziona i flags come in figura. In particolare presta attenzione a selezionare public static void main(Strings[] args) . Premi su Finish . A questo punto sarai pronto per scrivere codice con un template impostato da Eclipse Per replicare il programmino precedente, compilato ed eseguito manualmente inserisci la linea di codice: System.out.print ( 5 + 3 ) ; All'interno del blocco pi\u00f9 interno delimitato dalle parentesi graffe. Il risultato finale sar\u00e0: package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . print ( 5 + 3 ); } } Compila ed esegui il codice con il tasto indicato dal simbolo PLAY Troverai il risultato stampato nella finestra della console: Lezione 05 Introduzione alla OOP Il codice gi\u00e0 compilato, sia con Eclipse che in modo manuale: package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . print ( 5 + 3 ); } } E' stato il nostro primo programma scritto in Java ma di fatto non comprendiamo granch\u00e8 di cio' che c'\u00e8 scritto. Intuiamo probabilmente che il codice stamper\u00e0 il risultato dell'operazione 5+3 poich\u00e8 riconosciamo il comando print il cui termine tecnico \u00e8 realt\u00e0 metodo derivato della programmazione OOP di Java (di cui parleremo approfonditamente alla fine del corso). Classi, oggetti, metodi Puoi pensare alla classe come a una grande famiglia un contenitore di oggetti omogenei tra loro e metodi . Tonando al codice, print non fa parte del nucleo delle istruzioni base di Java ma di una libreria esterna, una libreria di input output, situata all'interno della JRE System Library . Quindi in fase di compilazione, il compilatore fa uso anche di questa libreria per linkare tutti simboli che trova nel codice sorgente. La JRE System Library come per qualsiasi liberia pu\u00f2 essere considerata come un pachetto estensione estensione del linguaggio base Java chiamato package e contiente metodi, oggetti, classi. In generale ogni package deve essere incluso nel codice sorgente con il comando: import packageName Nel caso dell'importazione del comando ( classe ) System anch'esso non presente nel nucleo base delle istruzioni Java scriveremo: import java.lang.System ; In questo modo importeremo solo la classe System del package lang situato all'interno del package java Nota: il nome del package \u00e8 sempre in minuscolo, es: java , lang .. il nome della classe \u00e8 sempre maiuscolo, es: System .. nel caso della JRE System Library l'importazione \u00e8 automatica quindi non \u00e8 necessario specificare il comando di import . Nel caso di uso di una libreria esterna, invece dovremo inserire il comando di import specifico per quella libreria Se vuoi includere tutto il contenuto (tutte le classi, tutti gli oggetti e tutti i metodi) di un package puoi farlo utilizzando il carattere * al posto della specifica classe import java.lang.* ; //importa tutte le classi all'interno del package java.lang Tornando al codice, abbiamo capito che System \u00e8 una classe della libreria JRE System Library in particolare del package java.lang . Cosa sono quindi out e print ? package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . print ( 5 + 3 ); } } out \u00e8 un' oggetto contenuto all'interno della classe System cio\u00e8 un blocco di codice autoconsistente che forma, insieme agli altri oggetti la classe System . Considerazione Non badare troppo alla terminologia per adesso. Evita di soffermarti troppo sui concetti di classe , oggetto , metodo , li capirai pi\u00f9 avanti quando inizierai la OOP , la programmazione ad oggetti di Java. Per adesso \u00e8 sufficiente che tu ne abbia colto le differenze \u00e8 che tu sappia identificare una classe, da un oggetto o da un metodo. La classe si riconosce perch\u00e8 \u00e8 sempre sicritta con la prima lettera in maiuscolo. Un oggetto si riconosce perch\u00e8 \u00e8 sempre situato all'interno di una classe e un metodo si riconosce perch\u00e8 \u00e8 l'ultimo pezzo, cio\u00e8 il comando da eseguire e fa riferimento al contesto dell'oggetto Infine.. Il metodo pu\u00f2 ricevere, come nel caso di print , dei parametri. Posso passare delle stringhe testuali, dei calcoli e una quantit\u00e0 di dati prevista dal metodo.\u00f9 Lezione 06 Metodo Main Partendo sempre dal codice: package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . print ( 5 + 3 ); } } Analizziamo adesso il metodo main public static void main ( String [] args ) { System . out . print ( 5 + 3 ); } main \u00e8 il metodo principale che cerca e richiama Java quando manda in esecuzione un codice sorgente java. In sostanza Java eseguir\u00e0 tutto il codice contenuto all'interno di public static void main ( String [] args ) { //code } Metodo print Come abbiamo gi\u00e0 detto, il metodo print pu\u00f2 ricevere in ingresso una quantit\u00e0 pi\u00f9 o meno vasta di dati. Possiamo aiutarci con l'autocompletamento di Eclipse, Ctrl + space Vedremo in dettaglio tutti i tipi di dato pi\u00f9 avanti Qualche stampa Il seguente esempio mostra la differenza tra il metodo print() e il metodo println . Stamperemo inoltre stringhe, espressioni numeriche ed espressioni miste. Alcune regole: print() stampa inline println() stampa e va a capo Se il metodo print() riceve un'espressione numerica, questa viene prima valutata poi convertita in una stringa per la stampa. operatore + : funge da concatenatore di stringhe se gli operandi sono delle stringhe e da operatore somma se gli operandi sono dei numeri. In caso di espressioni miste \u00e8 possibile utilizzare le parentesi tonde ( ) per forzare la precedenza dell'operatore + package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . print ( 1 + 1 ); //stampa inline del risultato dell'espressione System . out . println ( \"ciao\" ); //stampa \"ciao\" e va a capo System . out . println ( \"a tutti\" ); //stampa \"a tuti\" e va a capo /* System.out.println(\"Il risultato \u00e8: \" + (1+1)); - valuta prima il risultato dell'espressione 1+1, - lo converte in stringa e quindi diventa \"2\" - lo concatena a \"Il risultato \u00e8: \" - produce: \"Il risultato \u00e8: 2\" */ System . out . println ( \"Il risultato \u00e8: \" + ( 1 + 1 )); } } /* output 2ciao a tutti Il risultato \u00e8: 2 */ Commenti I commenti sono linee testuali ignorate dal compilatore e possono essere utili al programmatore per documentare alcune linee di codice. In java ci suo due tipi di commenti gi\u00e0 visti negli esempi precedenti: // text : per commenti inline /* text */ : per commenti multiline package mioTest ; public class prova01 { public static void main ( String [] args ) { /* commento multiline System.out.println(\"Ciao\"); */ System . out . println ( \"Ciao\" ); //commento inline } } Lezione 07 Qualche espressione aritmetica Riporto i principali operatori matematici e il calcolo qualche espressione aritmetica. Alcune considerazioni: Posso valutare espressioni con operandi misti, numeri interi e numeri decimali. In questo caso i numeri interi vengono convertiti in decimali e valutata l'espressione restituendo sempre un numero decimale. L'operatore / rappresenta la divisione ma: calcola il modulo della divisione intera quando gli operandi sono interi la divisione decimale quando almeno un operando \u00e8 decimale effettuando prima una conversione implicita di tutti gli operandi interi in decimale L'operatore % restituisce il resto della divisione intera e ha senso quando gli operandi sono interi Le parentesi ( ) possono essere utilizzate per forzare la precedenza tra le operazioni, come in matematica package mioTest ; public class prova01 { public static void main ( String [] args ) { //Somme e sottrazioni di numeri interi e decimali System . out . println ( 1 - 1.41 ); //-0.4099999999999999 //Moltiplicazione System . out . println ( 3 * 6.5 ); //19.5 //Divisione //Se gli operandi sono numeri interi //viene calcolato il modulo della divisione intera System . out . println ( 12 / 3 ); //4 System . out . println ( 12 / 5 ); //2 //Se almeno un operando \u00e8 decimale //vengono convertiti tutti gli operandi in decimale ed effettuata la divisione decimale System . out . println ( 12 / 5.0 ); //2.4 System . out . println ( 12 / 3.0 ); //4.0 //Resto della divisione intera System . out . println ( 12 % 3 ); //0 System . out . println ( 12 % 7 ); //5 //Le parentesi (), come in matematica, possono essere utilizzate per forzare la precedenza. System . out . println ( (( 5 + 4 ) * 9 ) + 7 ); //88 } } Lezione 08 Variabili Le variabili sono contenitori utilizzati per la memorizzazione dei dati. In java, ad ogni contenitore (quindi ad ogni variabile) deve essere associato il tipo cio\u00e8 deve essere dichiarato a priori quale tipo di dato potr\u00e0 contenere il contenitore I tipi nativi o predefiniti del linguaggio Java sono: Tipo Dimensione Descrizione char 2 byte Utilizzato per la memorizzazione di singoli caratteri come a , B int 4 byte Utilizzato per la memorizzazione di numeri interi come 12 -4 nel range [-2,147,483,648 to 2,147,483,647] short 2 byte Utilizzato per la memorizzazione di numeri interi come 12 -4 nel range [-32,768 to 32,767] long 8 byte Utilizzato per la memorizzazione di numeri interi come 12124L -49825L nel range [-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807]. E' buona norma associare il simbolo L alla fine del valore per forzare la rappresentazione su 8 byte float 4 bytes Utilizzato per la memorizzazione di numeri decimali come 12.6f fino a 7 digits dopo la virgola cio\u00e8 7 cifre considerabili esatte dopo la virgola. E' buona norma associare il simbolo f o F al termine del valore float double 8 byte Utilizzato per la memorizzazione di numeri decimali come 12.9876d fino a 15 digits dopo la virgola cio\u00e8 15 cifre considerabili esatte dopo la virgola. E' buona norma associare il simbolo d al termine del valore double per forzare la rappresentazione con un'accuratezza di 15 digits dopo la virgola byte 8 byte Utilizzato per la memorizzazione di numeri nel range [-128 to 127] boolean 1 bit Utilizzato per la memorizzazione di dati booleani, un tipo di dato particolare e molto importante nella programmazione che pu\u00f2 assumere solo due stati, true o false Per un approfondimento visita w3schools.com - Java Variables e w3schools.com - Java Data Types Una variabile, per poter essre utilizzata, deve essere prima dichiarata , dopodich\u00e8 l' identificatore cio\u00e8 il nome della variabile potr\u00e0 essere utilizzato nel codice come sostitutivo del suo valore. Non confondere le variabili, o meglio gli identificatori di variabili, con le costanti letterali che invece sono espressioni numeriche o letterali appunto costanti. Dichiarazione di una variabile Sintassi: type identificatore = value package mioTest ; public class prova01 { public static void main ( String [] args ) { //dichiarazione double piGreco = 3.14 ; //uso System . out . println ( \"pi greco vale: \" + piGreco ); } } /* outout --- pi greco vale: 3.14 */ Nell'esempio, double \u00e8 il tipo, piGreco \u00e8 l'identificatore della variabile mentre 3.14 \u00e8 il suo valore espresso come costante letterale numerica. Allo stesso modo \"pi greco vale: \" \u00e8 una costante letterale. Puoi dichiarare pi\u00f9 variabili dello stesso tipo utilizzando separando gli identificatori con la virgola , che in programamzione rappresenta sempre un operatore di separazione. int a = 1 , b = 12 , c ; Nell'esempio ho dichiarato tre variabili intere a , b , c . Il valore della variabile c non \u00e8 ancora espresso, si dice in questo caso che la variabile \u00e8 dichiarata ma non inizializzata Nota : E' sempre bene inizializzare sempre ogni variabile dichiarata poich\u00e8 l'utilizzo di tale variabile nel codice produce un errore di compilazione package mioTest ; public class prova01 { public static void main ( String [] args ) { //dichiarazione double piGreco = 3.14 , area , circonferenza , raggio ; area = piGreco * ( raggio * raggio ); System . out . println ( area ); } } /* output ------ Exception in thread \"main\" java.lang.Error: Unresolved compilation problems: The local variable raggio may not have been initialized The local variable raggio may not have been initialized at mioTest.prova01.main(prova01.java:9) */ Il messaggio \u00e8 chiaro The local variable raggio may not have been initialized . La variabile raggio non \u00e8 stata inizializzata. Attenzione!! Il solo problema \u00e8 la variabile raggio poich\u00e8 \u00e8 in lettura . Infatti, sebbene sia circonferenza che area siano variabili non inizializzate, circonferenza non \u00e8 di fatto mai utilizzata quindi non pu\u00f2 generare nessun tipo di errore mentre area \u00e8 utilizzata in scrittura ed \u00e8 logicamente previsto non inizializzare delle variabili per assegnar loro un valore successivo. A dimostrazione di quanto detto riporto l'esempio di prima assegnando un valore solo alla variabile raggio package mioTest ; public class prova01 { public static void main ( String [] args ) { //dichiarazione double piGreco = 3.14 , area , circonferenza , raggio = 2 ; area = piGreco * ( raggio * raggio ); System . out . println ( area ); //12.56 } } In generale comunque, per evitare confusione, conviene sempre inizializzare tutte le variabili al momento della dichiarazione Naming conventions Per la dichiarazione di una variabile puoi usare lettere maiuscole o minuscole seguite da caratteri numerici o il carattere underline, _ Lezione 09 Esercizio - Calcolo dell'interesse annuo Il seguente esercizio, in base ad un valore di somma depositata in euro e un tasso percentuale annuo, restituisce il valore della somma depositata dopo un anno in base al tasso di interesse stabilito package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Percentuale di interesse: 2.5%\" ); System . out . println ( \"Somma depositata: 1000 euro\" ); System . out . println ( \"---\" ); double percentualeInteresse = 2.5 ; //percentuale di interesse annuo\u00f9 double sommaDepositata = 1000 ; //in euro //dopo un anno sommaDepositata = sommaDepositata * ( 1 + percentualeInteresse / 100 ); System . out . println ( \"Dopo un anno avrai: \" + sommaDepositata + \"euro\" ); } } /* output --- Percentuale di interesse: 2.5% Somma depositata: 1000 euro --- Dopo un anno avrai: 1025.0euro */ Lezione 10 Approfondimento sui tipi primitivi Questa \u00e8 una sezione di approfondimento per i tipi primitivi di Java. Riporto la tabella gi\u00e0 vista qualche lezione precedente Tipo Dimensione Descrizione char 2 byte Utilizzato per la memorizzazione di singoli caratteri come a , B int 4 byte Utilizzato per la memorizzazione di numeri interi come 12 -4 nel range [-2,147,483,648 to 2,147,483,647] short 2 byte Utilizzato per la memorizzazione di numeri interi come 12 -4 nel range [-32,768 to 32,767] long 8 byte Utilizzato per la memorizzazione di numeri interi come 12124L -49825L nel range [-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807]. E' buona norma associare il simbolo L alla fine del valore per forzare la rappresentazione su 8 byte float 4 bytes Utilizzato per la memorizzazione di numeri decimali come 12.6f fino a 7 digits dopo la virgola. E' buona norma associare il simbolo f o F al termine del valore float double 8 byte Utilizzato per la memorizzazione di numeri decimali come 12.9876d fino a 15 digits dopo la virgola. E' buona norma associare il simbolo d al termine del valore double per forzare la rappresentazione con un'accuratezza di 15 digits dopo la virgola byte 8 byte Utilizzato per la memorizzazione di numeri nel range [-128 to 127] boolean 1 bit Utilizzato per la memorizzazione di dati booleani, un tipo di dato particolare e molto importante nella programmazione che pu\u00f2 assumere solo due stati, true o false Alcune considerazione: Di default le costanti numeriche intere sono considerate di tipo int quindi sono rappresentate su 4 byte. Per rappresentare una costante numerica intera pi\u00f9 piccola del tipo int come short o byte \u00e8 possibile forzare una conversione esplicita tramite l'operatore cast (short) o (byte) . Per rappresentare una costante numerica intera pi\u00f9 grande del tipo int come long \u00e8 possibile aggiungere il suffisso L o forzare una conversione esplicita con l'operatore cast (long) Di default le costanti numeriche decimali sono rappresentate con il tipo double quindi con un'accuratezza di 15 digits dopo la virgola. Per rappresentare una costante decimale pi\u00f9 piccola con il tipo float \u00e8 sufficiente inserire il suffisso f o F oppure forzare una conversione esplicita con l'operatore cast Vediamo un esempio concreto: package mioTest ; public class prova01 { public static void main ( String [] args ) { //dichiarazione //interi int valueInt1 = 217437 ; short valueInt2 = 2341 ; long valueInt3 = 23414246L ; byte valueInt4 = 67 ; //decimali float valueDec1 = 12.4F ; double valueDec2 = 3425.876 ; //cast //conversione implicita da \"byte\" >>> \"long\" long ris1 = valueInt3 + valueInt4 ; System . out . println ( ris1 ); //23414313 //conversione esplicita in \"short\" necessaria poich\u00e8 la conversione implicita //convertirebbe automaticamente valueInt2 da \"short\" a \"int\" //producendo un risultato con un estensione maggiore //di quella in grado di contenere la variabile ris2 anch'essa \"short\" short ris2 = ( short )( valueInt2 - valueInt1 ); System . out . println ( ris2 ); //-18488 //conversione esplicita in \"float\" necessaria poich\u00e8 la conversione implicita //convertirebbe automaticamente valueDec1 da \"float\" a \"double\" //producendo un risultato con un estensione maggiore //di quella in grado di contenere la variabile ris3 anch'essa \"float\" float ris3 = ( float )( valueDec2 / valueDec1 ); System . out . println ( ris3 ); //276.28033 } } Vediamo un controesempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //dichiarazione long valueInt3 = 23414246L ; byte valueInt4 = 67 ; //Attenzione!!! byte ris1 = valueInt3 + valueInt4 ; System . out . println ( ris1 ); // } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: Type mismatch: cannot convert from long to byte at mioTest.prova01.main(prova01.java:18) */ L'errore \u00e8, anche in questo caso, chiaro: Type mismatch: cannot convert from long to byte cio\u00e8 non \u00e8 possibile convertire un long in byte . Forzando la conversione esplicita del tipo long in tipo byte tutto funzioner\u00e0 ma che risultato oterrai? package mioTest ; public class prova01 { public static void main ( String [] args ) { //dichiarazione //interi int valueInt1 = 217437 ; short valueInt2 = 2341 ; long valueInt3 = 23414246L ; byte valueInt4 = 67 ; //Attenzione!!! byte ris1 = ( byte )( valueInt3 + valueInt4 ); System . out . println ( ris1 ); //41 } } Attenzione: Quando utilizzi i cast, hai la responsabilit\u00e0 di garantire, durante il troncamento, che non si perda l'informazione. Dovrai quindi effettuare i cast consapevolmente sempre. Lezione 11 Ancora sui numeri I tipi sopra citati int , double , float .. sono tipi predefiniti del linguaggio. Esiste tuttavia, per ogni tipo, una classe Java associata di cui \u00e8 possibile, come ad ogni classe ricavarne propriet\u00e0 , instanziare oggetti ed applicare metodi . Non approfondir\u00f2 l'argomento qua ma vorrei riportarti come sia facile ricavare il range numerico possibile per ogni tipo. Eclipse ti aiuta con l'autocompletamento Ctrl + space . Nel caso della classe Float , suggerisce varie opzioni: Nel seguente esempio mander\u00f2 in stampa il range numerico di alcuni tipi di dato facendo uso di alcune propriet\u00e0 delle classi Integer , Long , Byte , Double . package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //Integer int maxValueInteger = Integer . MAX_VALUE ; int minValueInteger = Integer . MIN_VALUE ; System . out . println ( \"Max Value Integer: \" + maxValueInteger ); System . out . println ( \"Min Value Integer: \" + minValueInteger ); System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //Byte byte maxValueByte = Byte . MAX_VALUE ; byte minValueByte = Byte . MIN_VALUE ; System . out . println ( \"Max Value Byte: \" + maxValueByte ); System . out . println ( \"Min Value Byte: \" + minValueByte ); System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //Long long maxValueLong = Long . MAX_VALUE ; long minValueLong = Long . MIN_VALUE ; System . out . println ( \"Max Value Long: \" + maxValueLong ); System . out . println ( \"Min Value Long: \" + minValueLong ); System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //Per la classe Double e Float, la proprier\u00e0 MIN_VALUE corrisponde al valore pi\u00f9 vicino a 0 double maxValuePositivoDouble = Double . MAX_VALUE ; double maxValueNegativoDouble = - Double . MAX_VALUE ; double minValueDouble = Double . MIN_VALUE ; System . out . println ( \"Max Value Positivo Double: \" + maxValuePositivoDouble ); System . out . println ( \"Max Value Negativo Double: \" + maxValueNegativoDouble ); System . out . println ( \"Min Value Double: \" + minValueDouble ); } } /* output --- --- --- --- --- --- --- --- --- --- --- Max Value Integer: 2147483647 Min Value Integer: -2147483648 --- --- --- --- --- --- --- --- --- --- --- Max Value Byte: 127 Min Value Byte: -128 --- --- --- --- --- --- --- --- --- --- --- Max Value Long: 9223372036854775807 Min Value Long: -9223372036854775808 --- --- --- --- --- --- --- --- --- --- --- Max Value Positivo Double: 1.7976931348623157E308 Max Value Negativo Double: -1.7976931348623157E308 Min Value Double: 4.9E-324 */ Osservazione: Ti faccio notare come le propriet\u00e0 delle classi siano scritte in maiuscolo e senza le parentesi tonde () finali tipiche di un metodo Lezione 12 Il tipo char Il tipo char \u00e8 un tipo nativo Java che si estende su 1 byte. La rappresentazione di un carattere in memoria segue la tabella ASCII estesa. Ogni carattere \u00e8 rappresentato da una sequenza di bit, identificata da un intero su 8 bit. Vista la dualit\u00e0 tra numeri interi e caratteri \u00e8 possibile: usare numeri interi su 8bit [0 - 255] per rappresentare un carattere secondo la codifica ASCII estesa usare un carattere per rappresentare un intero usare gli operatori di somma e sottrazione package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //char char c1 = 'a' ; char c2 = '#' ; System . out . println ( c1 ); System . out . println ( c2 ); System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //carattere relativo al codice della tabella ASCII: 65 >>> 'A' char c3 = 65 ; System . out . println ( c3 ); System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //anche gli interi possono usare i caratteri come costanti numeriche int i = 100 + 'A' ; System . out . println ( i ); System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); } } /* output --- --- --- --- --- --- --- --- --- --- --- a # --- --- --- --- --- --- --- --- --- --- --- A --- --- --- --- --- --- --- --- --- --- --- 165 --- --- --- --- --- --- --- --- --- --- --- */ Lezione 13 Il tipo boolean Il concetto di valore booleano o logica booleana sta alla base di ogni linguaggio di programmazione. Il controllo del flusso di operazioni e di istruzioni \u00e8 dettato proprio da questo tipo di logica. Se gi\u00e0 conosci vagamente almeno un linguaggio di programmazione sai di cosa sto parlando, se non \u00e8 cos\u00ec sappi che capirai a fondo questo concetto a breve quando parleremo di costrutti condizionali e iterativi. Un variabile booleano pu\u00f2 assumere solo due valori: true / false . Posso utilizzare anche delle espressioni contenenti una condizione da verificare, le quali verranno sempre tradotte in true / false , qualche esempio: 3 == 3 : true 'A' == 'a' : false (4 - 1) < 4 : true package mioTest ; public class prova01 { public static void main ( String [] args ) { //boolean - George Boole boolean myBool = true ; //valuta l'espressione logica restituendo true/false boolean myBool2 = 5 < 3 ; System . out . println ( myBool ); System . out . println ( myBool2 ); } } /* output true false */ Lezione 14 Introduzione a String String non \u00e8 un tipo primitivo ma \u00e8 una classe. Approfondiremo meglio questa particolare classe pi\u00f9 avanti, per adesso ti basta sapere che in quanto classe posso creare delle istanze ovvero degli elementi che hanno come modello la classe String ed applicar loro dei metodi o ricavarne propriet\u00e0 . Un metodo \u00e8 una funzione che svolge un compito ben preciso solo una determinata classe, una propriet\u00e0 \u00e8 solo un valore caratteristico di quella classe. Nell'esempio seguente instanzio un oggetto di tipo String di nome cognome ed applico i metodi : endsWith(param) : Ritorna un boolean: true se l'oggetto stringa a cui si applica questo metodo termina con la stringa indicata come parametro param lenght() : Ritorna un valore intero corrsipondente alla lunghezza dell'oggetto stringa a cui si applica questo metodo package mioTest ; public class prova01 { public static void main ( String [] args ) { //String String cognome = \"Di Ricco\" ; System . out . println ( cognome ); //Metodo \"endsWith()\" System . out . println ( cognome . endsWith ( \"co\" )); //Metodo \"lenght()\" System . out . println ( cognome . length ()); //Attenzione String lettera = \"a\" ; } } /* Di Ricco true 8 */ Lezione 15 Operatori Gli operatori si possono classificare per numero di operandi e si parla quindi di operatori: Unari : Operano con un solo operando Binari : Operano con due operandi Ternari : Operano con tre operandi Inoltre, possono essere classificati in base alla posizione dell'operatore rispetto gli operandi e quindi si parla di operatori: post-fissi : Se l'operatore \u00e8 posto dopo l'operando in-fisso : Se l'operatore \u00e8 posto tra gli operandi pre-fisso : Se l'operatore \u00e8 posto prima l'operando Qualche esempio: / , + , - , * , % : qualche semplice operatore aritmetico ++ , -- : operatori di incremento/decremento. Si applicano SOLO a variabili e non a costanti letterali. Si distinguono ulteriormente in: Post-incremento/decremento : L'operatore \u00e8 post-fisso . Prima assegna il valore poi incrementa Pre-incremento/decremento : L'operatore \u00e8 pre-fisso . Prima incrementa poi assegna Vediamo qualche esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //L' operatore \"-\" nel seguente caso \u00e8 un operatore unario, prefisso int a = - 5 ; //L' operatore \"-\" nel seguente caso \u00e8 un operatore binario, infisso int b = 12 - 5 ; //Pre-Incremento: Prima incrementa poi assegna System . out . println ( ++ a ); // -4 //Post-Incremento: Prima assegna poi incrementa System . out . println ( a -- ); // -4 System . out . println ( a ); // -5 //Dualit\u00e0 tra i caratteri / interi char c1 = 'A' ; char c2 = ++ c1 ; System . out . println ( c2 ); // B } } Precedenza degli operatori In un espressione aritmetica o logica contenete diversi operatori, valgono regole simili alla matematica. In particolare, se \u00e8 vero che in matematica certi operatori hanno la precedenza su altri, sappiamo infatti che le moltiplicazioni e divisioni vengono valutate prima delle somme e sottrazioni, \u00e8 vero anche per la maggior parte dei linguaggi di programmazione. Inoltre rimane vera la propriet\u00e0 che per forzare precedenza \u00e8 possibile usare le parentesi ma sono valide, in informatica, solo quelle tonde () . Qui sotto ti lascio comunque un link che puoi consultare della tabella delle precedenza degli operatori in Java Oracle - Operators Operatori Unari ! : operatore not , negazione logica package mioTest ; public class prova01 { public static void main ( String [] args ) { int eta = 17 ; boolean maggiorenne = ( eta > 18 ); System . out . println ( \"E' maggiorenne: \" + maggiorenne ); System . out . println ( \"Non e' maggiorenne: \" + ! maggiorenne ); } } /* outputf E' maggiorenne: false Non e' maggiorenne: true */ ~ negazione (complemento) bit a bit, negazione bitwise package mioTest ; public class prova01 { public static void main ( String [] args ) { //negazione bit a bit ~ //33 = 0001 0001 int myVar = 33 ; System . out . print ( ~ myVar ); //-34, 1110 1110 } } Operatori binari Qualche operazione aritmetica tra numeri interi. A causa del range limitato dei numeri di tipo Integer , non sempre va come ce lo aspettiamo.. package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari int i1 = 0 , i2 = 0 , i3 = 0 , i4 = 0 ; //Somme semplici a due operandi i1 = 5 + 3 ; i2 = 6 + i1 ; i3 = i1 + i2 ; i2 = 3 + 4 + 9 + 10 ; i2 = ( 12 + 6 ) * 2 * ( i3 - ( i4 / 5 )); //Supera ampiamente la capacit\u00e0 del range [int] //Non viene fatto nesssun controllo a runtime o in fase di compilazione Java //questi controlli deve farli il programmatore! i1 = 1000 * 1000 * 1000 * 1000 ; System . out . print ( i1 ); //-727379968 } } Attenzione: L'operatore / se applicato a operandi interi restituisce sempre il risultato della divisione intera, detto anche modulo o quoziente Lezione 16 Tra stringhe e caratteri. Come sappiamo l'operatore + funge da concatenatore di stringhe, stessa cosa non vale per\u00f2 con i caratteri. package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari String s1 = \"\" , s2 = \"\" , s3 = \"\" ; //Concatenazione tra stringhe s1 = \"Salve a \" ; s2 = \"tutto il mondo!\" ; s3 = s1 + s2 ; System . out . println ( s3 ); //Salve a tutto il mondo! } } E' possibile assegnare a una variabile di tipo char un'espressione somma di caratteri poich\u00e8 verrebbero trattata come un'espressione somma tra interi (rappresentati con il codice ASCII corrispondente) ma non \u00e8 possibile effettuare la somma tra variabili di tipo char . package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari char c1 = ' ' , c2 = ' ' , c3 = ' ' ; //Stessa cosa non vale con i caratteri c3 = 'A' + ' ' ; System . out . println ( c3 ); //a //Nel caso della somma tra due variabili di tipo char Java segnala errore, non \u00e8 previsto c1 = 'A' ; c2 = ' ' ; c3 = c1 + c2 ; } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: Type mismatch: cannot convert from int to char at mioTest.prova01.main(prova01.java:15) */ Eclipse segnala eventuali errori in fase di scrittura del codice per facilitarne la correzione e ne suggerisce anche una possibile soluzione Seguendo il consiglio di Eclipse.. package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari char c1 = ' ' , c2 = ' ' , c3 = ' ' ; c1 = 'A' ; c2 = ' ' ; c3 = ( char ) ( c1 + c2 ); System . out . println ( c3 ); //a } } Inoltre, sebbene l'operatore + sia definito e abbia un senso per le stringhe, l'operatore - non \u00e8 definito con le stringhe package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari String s1 = \"\" , s2 = \"\" , s3 = \"\" ; //L'operatore \"-\" non \u00e8 definito per le stringhe s1 = \"Salve a \" ; s2 = \"tutto il mondo!\" ; s3 = s1 - s2 ; System . out . println ( s3 ); //Salve a tutto il mondo! } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: The operator - is undefined for the argument type(s) java.lang.String, java.lang.String at mioTest.prova01.main(prova01.java:12) */ Per la sottrazione tra char invece valgono le stesse regole viste per l'addizione. Posso quindi assegnare ad un tipo char un'espressione sottrazione di caratteri poich\u00e8 verrebbero trattata come un'espressione sottrazione tra interi (rappresentati con il codice ASCII corrispondente) ma non \u00e8 possibile effettuare la sottrazione tra variabili di tipo char package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari char c1 = ' ' , c2 = ' ' , c3 = ' ' ; //Stessa cosa non vale con i caratteri c3 = 'A' - ' ' ; System . out . println ( c3 ); //! //Nel caso della somma tra due variabili di tipo char Java segnala errore, non \u00e8 previsto c1 = 'A' ; c2 = ' ' ; c3 = c1 - c2 ; } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: Type mismatch: cannot convert from int to char at mioTest.prova01.main(prova01.java:15) */ A questo punto \u00e8 facile intuire la sorte degli operatori / e * i quali non sono definiti per la classe String mentre sono definiti per il tipo char a patto di considerarli in un'espressione tra caratteri costanti o di effettuare un cast in un'espressione tra variabili. In generale: String : E' definito solo l'operatore + che funge da concatenatore di stringhe char : Sono definiti tutti gli operatori + , - , / , * a patto di considerare un'espressione tra caratteri costanti o a patto di effettuare un cast. Lezione 17 E i boolean? Per i boolean somme, sottrazioni, moltiplicazioni e divisioni non sono definiti. Riporto solo l'esempio della sommma package mioTest ; public class prova01 { public static void main ( String [] args ) { //Boolean boolean b1 = true , b2 = true ; //Tra Boolean la somma non \u00e8 pervista boolean b3 = b2 + b3 ; } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: The operator + is undefined for the argument type(s) boolean, boolean at mioTest.prova01.main(prova01.java:8) */ Lezione 18 Numeri decimali Per gli operatori + , - , * valgono le stesse regole viste per i numeri interi. Tuttavia nel caso dell'operatore / viene valutata la divisione decimale, a differenza dei numeri interi che ricordo, valuta la divisione intera composta da quoziente e resto . Riporto qui sotto un esempio trappola . package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari int i1 = 0 ; double d1 = 0 ; //Divisione Intera i1 = 40 / 15 ; System . out . println ( i1 ); //2 //Attenzione!! d1 = 40 / 15 ; System . out . println ( d1 ); //2.0 //Forme equivalenti corrette d1 = 40 d / 15 ; System . out . println ( d1 ); //2.6666666666666665 d1 = 40 / 15.0 ; System . out . println ( d1 ); //2.6666666666666665 d1 = ( double ) 40 / 15 ; System . out . println ( d1 ); //2.6666666666666665 } } Soluzione trappola: Alla riga: //Attenzione!! d1 = 40 / 15 ; System . out . println ( d1 ); //2.0 Probabilmente ti sarai aspettato di veder stampato un risultato decimale.. Ma non \u00e8 cos\u00ec! Questo perch\u00e8 come gi\u00e0 detto, l'operatore / calcola la divisione intera se gli operandi sono interi. Beh, in questo caso gli operandi sono interi , non \u00e8 importante se il contenitore \u00e8 un double , viene quindi calcolata la divisione intera e poi convertita in un numero decimale che tuttavia rimane comunque troncato. Per \"forzare\" la divisione decimale quando gli operandi sono interi \u00e8 necessario convertire un operando qualsiasi da intero a double . In questo caso poi tutti gli operandi verrebbero convertiti automaticamente in double e quindi l'operatore / \u00e8 in grado di calcolare la divisione decimale. Lezione 19 Espressioni miste In caso di espressioni miste, ci\u00f2 con operandi di tipo diversom, vale un'unica grande regola generale: Il compilatore effettuer\u00e0 delle conversioni di tipo implicite solo se durante la conversione non si perde informazione, negli altri casi segnaler\u00e0 un'errore di compilazione indicando l'errore della conversione implicita package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari int i1 = 0 ; double d1 = 0 ; //Il tipo intero \u00e8 convertito in double e poi viene calcolata la somma d1 = 100 + 34.91 ; //Il tipo double non pu\u00f2 essere convertito implicitamente in double poich\u00e8 si perderebbe informazione i1 = 100 + 34.91 ; //Error! cannot convert from double to int } } Ogni volta che si effettuano operazioni tra tipi diversi, il compilatore potrebbe rilevare la perdita di informazione, in questo caso segnala un errore di compilazione. Per \"forzare\" la conversione di tipo \u00e8 necessario utilizzare l'operatore di cast indicando cio\u00e8 tra le parentesi () il tipo di destinazione. package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari int i1 = 0 ; double d1 = 0 ; //Il tipo intero \u00e8 convertito in double e poi viene calcolata la somma d1 = 100 + 34.91 ; i1 = 100 + ( int ) 34.91 ; System . out . print ( i1 ); //134 } } Regola di buona programmazione: In un'espressione mista e' buona norma esplicitare sempre il cast quando i tipi sono diversi Java converte implicitamente anche caratteri, numeri interi o decimali in stringa: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari String s1 = \"\" ; s1 = \"cia\" + 'o' + '!' ; System . out . println ( s1 ); //ciao! s1 = \"pi greco: \" + 3.14 ; System . out . println ( s1 ); //pi greco: 3.14 } } Non \u00e8 vero il contrario. Non posso cio\u00e8 ad esempio convertire un numero decimale espresso come stringa in un double a meno di utilizzare la classe Double con il metodo parseDouble() package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari double d1 = 0d ; d1 = \"3.14\" ; } } /* output Type mismatch: cannot convert from String to double */ Utilizzando il metodo parseDouble() della classe Double sar\u00e0 possibile convertire una stringa in un numero decimale. package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari double d1 = 0d ; d1 = Double . parseDouble ( \"3.14\" ); System . out . print ( d1 ); //3.14 } } Interessante a questo punto vedere anche il metodo parseInt() della classe Integer . parseInt(param1, param2) : Il metodo parseInt() pu\u00f2 ricevere due parametri. Il primo parametro rappresenta la stringa da convertire, il secondo, opzionale, rappresenza invece la base del numero che rappresenta. Di default questo parametro assume che il numero sia decimale, base = 10. Nell'esempio che segue convertiro' in intero tre tipi di numeri, un decimale, un binario e un esadecimale. package mioTest ; public class prova01 { public static void main ( String [] args ) { // String string_temperatura = \"12\" ; String string_bitSequence = \"01011110\" ; String string_hexValue = \"F20B\" ; //Converto in intero una stringa che rappresenta un numero decimale, base = 10, opzione di default int temperatura = Integer . parseInt ( string_temperatura , 10 ); //Converto in intero una stringa che rappresenta un numero binario, base = 2 int bitSequence = Integer . parseInt ( string_bitSequence , 2 ); //Converto in intero una stringa che rappresenta un numero esadecimale, base = 16 int hexValue = Integer . parseInt ( string_hexValue , 16 ); System . out . println ( temperatura ); //12 System . out . println ( bitSequence ); //94 System . out . println ( hexValue ); //61963 } } Lezione 20 Numeri Esadecimali, ottali Posso rappresenare anche numeri eadecimale, ottali e binari specificando rispettivamente i prefissi 0x , 0 , 0b package mioTest ; public class prova01 { public static void main ( String [] args ) { // int esa = 0x45 ; int ott = 0237 ; int bin = 0b010010 ; System . out . println ( esa ); //69 System . out . println ( ott ); //159 System . out . println ( bin ); //18 } } Costanti numeriche Di default le costanti letterali numeriche intere vengono rappresentate con il tipo Integer mentre per i numeri decimali le costanti vengono sempre rappresentate con il tipo double . Per rappresentare quindi costanti letterali appartenenti a un tipo diverso \u00e8 necessario specificarlo esplicitamente. package mioTest ; public class prova01 { public static void main ( String [] args ) { //Necessario specificare il suffisso \"L\" poich\u00e8 verrebbe interpretato come un intero long longNumber = 2427832389L ; //Necessario specificare il suffisso \"F\" poich\u00e8 verrebbe interpretato come un double float floatNumber = 12.8F ; //Necessario specificare il suffisso \"D\" poich\u00e8 verrebbe interpretato come un intero double doubleNumber = 34 D ; } } Sequenze di escape //a capo char c1 = '\\n' ; //backslash char c2 = '\\b' ; Interessante vedere in azione il backslash. Tuttavia \u00e8 necessario eseguire il codice da terminale package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"ciao a tutti\\b\\b\\b\\b\\bnessuno\" ); //ciao a nessuno } } Vediamo tutte le sequenze di escape in java: Escape Sequence Description \\t Insert a tab in the text at this point. \\b Insert a backspace in the text at this point. \\n Insert a newline in the text at this point. \\r Insert a carriage return in the text at this point. \\f Insert a formfeed in the text at this point. \\' Insert a single quote character in the text at this point. \\\" Insert a double quote character in the text at this point. \\ Insert a backslash character in the text at this point. Interessante la sequenza di escape per l'inserimento di caratteri unicode \\u package mioTest ; public class prova01 { public static void main ( String [] args ) { char c = '\\u1241' ; System . out . println ( c ); //\u1241 } } Attenzione!! Il tipo char in questo caso non occupa pi\u00f9 8 bit. Lezione 21 Operatori di Assegnamento Gli operatori di assegnamento, come gi\u00e0 visto, sono utilizzati per assegnare un valore ad una variabile. Non esiste soltanto l'operatore di assegnamento = , esistono forme sintetiche di operatori di assegnamento che oltre che ad assegnare elaborano il valore della variabile di destinazione specificando un operatore aritmetico. Una lista completa degli operatori di assegnamento aritmetici: Operatore Esempio Equivale a = x = 5 x = 5 += x += 5 x = x + 5 -= x -= 5 x = x -5 *= x *= 5 x = x * 5 /= x /= 5 x = x / 5 %= x %= 5 x = x % 5 Un esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori di assegnamento int n = 0 ; //Assegnamento semplice n = 12 ; System . out . println ( n ); //12 //Assegnamento complesso n += 2 ; //n = n + 2 System . out . println ( n ); //14 n += 12 + n * n ; //n = n + (12 + n*n) System . out . println ( n ); //222 n /= 2 ; n -= 40 ; n *= 3 ; System . out . println ( n ); //213 } } Qui sotto riporto per completezza anche una lista degli operatori di assegnamento bit a bit | Operatore | Esempio | Equivale a | | ----------| -----------| ----------- | | &= | x &= 5 | x = x & 5 | | |= | x |= 5 | x = x | 5 | | ^= | x ^= 5 | x = x ^ 5 | | >>= | x >>= 5 | x = x >> 5 | | <<= | x <<= 5 | x = x << 5 | Lezione 22 Operatori Relazionali Gli operatori relazionali ritornano un boolean e sono utilizzati per confrontare due valori o, pi\u00f9 in generale, due espressioni: Operatore Nome Esempio == Uguale a x == y : Ritorna true solo se x \u00e8 uguale a y != Diverso da x != y : Ritorna true solo se x \u00e8 diverso da y > Maggiore di x > y : Ritorna true solo se x \u00e8 maggiore di y < Minore di x < y : Ritorna true solo se x \u00e8 minore di y >= Maggiore o uguale di x >= y : Ritorna true solo se x \u00e8 maggioere o uguale a y <= Minore o uguale di x <= y : Ritorna true solo se x \u00e8 minore o uguale a y Un esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori Relazionali int x = 0 , y = 12 ; System . out . println ( x == y ) ; //false System . out . println ( x != y ) ; //true System . out . println ( x > y ) ; //false System . out . println ( x < y ) ; //true System . out . println ( x >= y ) ; //false System . out . println ( x <= y ) ; //true } } E' possibile applicare tutti gli operatori relazionali anche ai caratteri: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori Relazionali char c1 = 'A' , c2 = 'S' ; System . out . println ( c1 == c2 ) ; //false System . out . println ( c1 != c2 ) ; //true System . out . println ( c1 > c2 ) ; //false System . out . println ( c1 < c2 ) ; //true System . out . println ( c1 >= c2 ) ; //false System . out . println ( c1 <= c2 ) ; //true } } Per le stringhe sono validi solo gli operatori relazionali: == : Ritorna true se due stringhe sono identiche != : Ritorna true se due stringhe differiscono per uno o pi\u00f9 caratteri package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori Relazionali String s1 = \"Giorno\" , s2 = \"Giornata\" ; System . out . println ( s1 == s2 ) ; //false System . out . println ( s1 != s2 ) ; //true } } Per confrontare due stringhe \u00e8 possibile ricorrere a metodi della classe String come ad esempio: compareTo(s2) : confronta la stringa a cui si applica il metodo con la stringa passata per parametro s2 e ritorna un valore intero. Se il valore di ritorno \u00e8 negativo la stringa a cui si applica il metodo \u00e8 minore dal punto lessicografico della stringa passata per parametro Se il valore di ritorno \u00e8 zero la stringa a cui si applica il metodo \u00e8 uguale alla stringa passata per parametro Se il valore di ritorno \u00e8 positivo la stringa a cui si applica il metodo \u00e8 maggiore dal punto lessicografico della stringa passata per parametro package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori Relazionali String s1 = \"Giorno\" , s2 = \"Giornata\" ; System . out . println ( s1 . compareTo ( s2 ) ) ; //14 } } Lezione 23 Operatori Logici Gli operatori logici ritornano un boolean e sono usati per la concatenazione di esepressioni logiche: Operatore Nome Esempio && And Logico expr1 && expr2 : Ritorna true solo se expr1 ed expr2 sono entrambe espressioni vere || Or Logico expr1 || expr2 : Ritorna true se almeno una delle espressioni expr1 e expr2 risulta vera ! Not Logico !expr : Ritorna true se expr \u00e8 false , false se expr \u00e8 true Short evalutation: Nella concatenazione di espressioni logiche il compilatore Java effettua delle ottimizzazioni. expr1 && expr2 : se expr1 \u00e8 false , expr2 non viene valutata e ritorna false expr1 || expr2 : se expr1 \u00e8 true expr2 non viene valutata e ritorna true Esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori Relazionali int x = 0 , y = 12 , c = 4 , d = 3 ; System . out . println ( ( x == y ) || ( c > d ) ); //true System . out . println ( ( x != y ) && ( c >= d ) ); //true //Short evalutation. //Poich\u00e8 la prima espressione (x > y) risulta \"false\" non ha senso valutare le altre espressioni //Ritorner\u00e0 dunque \"false\" System . out . println ( ( x > y ) && ! ( c > d ) ); //false //Attenzione alle precedenze degli operatori!! //nel dubbio metti sempre le parentesi System . out . println ( ( ! ( x > y ) && ! ( c == d )) || ( d > c ) ); //true } } Lezione 24 Costrutto Condizionali If ... Else Puoi Utilizzare Il costrutto if ... else per istruire il programma a prendere scelte Infatti, con il costrutto if ... else , se una determinata condizione risulta true esegue il codice delimitato dal blocco if altrimenti esegue il codice delimitato dal blocco else if ( condition ) { // code A } else { //code B } Esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Costrutto If ... Else String name = \"Marco\" ; int eta = 14 ; int maggioreEta = 18 ; if ( eta >= maggioreEta ) { System . out . print ( name + \" \u00e8 maggiorenne\" ); } if ( eta < maggioreEta ) { System . out . print ( name + \" non \u00e8 maggiorenne\" ); } } } /* output --- Marco non \u00e8 maggiorenne */ E' possibile specificare condizioni multiple con l'istruzione else if : if ( condition1 ) { // code A } else if ( condition2 ) { //code B } } else { //code C } Esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Costrutto If ... Else String name = \"Marco\" ; int eta = 18 ; int maggioreEta = 18 ; if ( eta > maggioreEta ) { System . out . print ( name + \" \u00e8 maggiorenne\" ); } else if ( eta < maggioreEta ) { System . out . print ( name + \" non \u00e8 maggiorenne\" ); } else { System . out . print ( name + \" \u00e8 un diciottenne\" ); } } } /* output --- Marco \u00e8 un diciottenne */ Nell' esempio di sopra, simile al precedente, ho cambiato l'eta' di Marco e la prima condizione del costrutto if da >= a > . In questo modo rimane fuori la condizione in cui eta == maggioreEta che sar\u00e0 rilevata dal blocco else . Il ramo if e' necessario Non pu\u00f2 esistere il ramo else if o il ramo else se non esiste il ramo if . E' un errore sintattico. else if ( condition ){ //code } else { } /* Syntax error on token \"else\" */ Il ramo else non e' necessario Il blocco else non \u00e8 necessario. Se non vengono verificate le condizioni espresse dagli if statemeant semplicemente il programma non fa niente if ( condition ) { // code A } else if ( condition2 ){ //code B } Esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Costrutto If ... Else String name = \"Marco\" ; int eta = 18 ; int maggioreEta = 18 ; if ( eta > maggioreEta ) { System . out . print ( name + \" \u00e8 maggiorenne\" ); } else if ( eta < maggioreEta ) { System . out . print ( name + \" non \u00e8 maggiorenne\" ); } } } /* output --- */ if annidati Posso annidare gli if statemeant per raggiungere condizioni pi\u00f9 specifiche. if ( condition1 ) { //code .. //.. if ( condition1A ){ //code 1A } else { //condition 1B } //.. } else if ( condition2 ) { //code B } } else { //code.. //.. if ( condition_elseA ){ //code else A } else if ( condition_elseB ) { //code else B } else { //condition else C } //code //.. } I costrutti condizionali if pi\u00f9 interni, quelli annidati, sono valutati solo se i costrutti condizionali pi\u00f9 esterni, quelli che li contengono, sono verificati. Un esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Costrutto If ... Else String name = \"Marco\" ; int eta = 23 ; int maggioreEta = 18 ; int trentenne = 30 ; if ( eta > maggioreEta ) { System . out . print ( name + \" \u00e8 maggiorenne\" ); if ( eta > trentenne ) { System . out . print ( name + \" ha anche pi\u00f9 di 30 anni\" ); } else { System . out . print ( \" ma non ha pi\u00f9 di 30 anni\" ); } } else if ( eta < maggioreEta ) { System . out . print ( name + \" non \u00e8 maggiorenne\" ); } } } /* output --- Marco \u00e8 maggiorenne ma non ha pi\u00f9 di 30 anni */ E' possibile tradurre il codice con if annidati con una serie di rami if/else if semplici facendo uso di operatori logici Vediamo lo stesso esempio di prima: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Costrutto If ... Else String name = \"Marco\" ; int eta = 23 ; int maggioreEta = 18 ; int trentenne = 30 ; if ( eta > maggioreEta && eta > trentenne ) { System . out . print ( name + \" \u00e8 maggiorenne\" ); System . out . print ( name + \" ha anche pi\u00f9 di 30 anni\" ); } else if ( eta > maggioreEta && eta < trentenne ) { System . out . print ( name + \" \u00e8 maggiorenne\" ); System . out . print ( \" ma non ha pi\u00f9 di 30 anni\" ); } else { System . out . print ( name + \" non \u00e8 maggiorenne\" ); } } } /* output --- Marco \u00e8 maggiorenne ma non ha pi\u00f9 di 30 anni */ Lezione 25 Costrutto Switch Il costrutto condizionale switch pu\u00f2 essere utilizzato quando la condizione in un costrutto condizionale pu\u00f2 assumere diversi valori e, ad ogni valore della condizione, associare un blocco di codice. switch ( expression ) { case x : // code block break ; case y : // code block break ; default : // code block } Un esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { int mese = 5 ; switch ( mese ) { case 1 :{ System . out . println ( \"Gennaio\" ); break ; } case 2 :{ System . out . println ( \"Febbraio\" ); break ; } case 3 :{ System . out . println ( \"Marzo\" ); break ; } case 4 :{ System . out . println ( \"Aprile\" ); break ; } case 5 :{ System . out . println ( \"Maggio\" ); break ; } case 6 :{ System . out . println ( \"Giugno\" ); break ; } case 7 :{ System . out . println ( \"Luglio\" ); break ; } case 8 :{ System . out . println ( \"Agosto\" ); break ; } case 9 :{ System . out . println ( \"Settembre\" ); break ; } case 10 :{ System . out . println ( \"Ottobre\" ); break ; } case 11 :{ System . out . println ( \"Novembre\" ); break ; } case 12 :{ System . out . println ( \"Dicembre\" ); break ; } default :{ System . out . println ( \"Errore! Mese non valido\" ); break ; } } } } Lo statemeant break rende i rami case mutuamente esclusivi. Solo una condizione \u00e8 verificabile. Lo steatement break tuttavia non \u00e8 obbligatorio. Se manca, i rami case vengono valutati in modo sequenziale. package mioTest ; public class prova01 { public static void main ( String [] args ) { int mese = 4 ; switch ( mese ) { case 1 : case 3 : case 5 : case 7 : case 8 : case 10 : case 12 :{ System . out . println ( \"Mese con 31 giorni\" ); break ; } case 4 : case 6 : case 9 : case 11 :{ System . out . println ( \"Mese con 30 giorni\" ); break ; } case 28 : { System . out . println ( \"Mese con 28 giorni\" ); break ; } default :{ System . out . println ( \"Errore! Mese non valido\" ); break ; } } } } /* output --- Mese con 30 giorni */ Puoi utilizzare qualsiasi tipo o espressione nella condizione da verificare dello switch . Puoi usare ad esempio stringhe, caratteri, boolean o espressioni complesse. package mioTest ; public class prova01 { public static void main ( String [] args ) { String mese = \"Luglio\" ; switch ( mese ) { case \"Gennaio\" : case \"Marzo\" : case \"Maggio\" : case \"Luglio\" : case \"Agosto\" : case \"Ottobre\" : case \"Dicembre\" :{ System . out . println ( \"Mese con 31 giorni\" ); break ; } case \"Aprile\" : case \"Giugno\" : case \"Settembre\" : case \"Novembre\" :{ System . out . println ( \"Mese con 30 giorni\" ); break ; } case \"Febbraio\" : { System . out . println ( \"Mese con 28 giorni\" ); break ; } default :{ System . out . println ( \"Errore! Mese non valido\" ); break ; } } } } /* output --- Mese con 31 giorni */ Attenzione a non giocare troppo in modo incosapevole con il comando break perch\u00e8 il risultato potrebbe non essere quello atteso. package mioTest ; public class prova01 { public static void main ( String [] args ) { int mese = 5 ; switch ( mese ) { case 1 :{ System . out . println ( \"Gennaio\" ); } case 2 :{ System . out . println ( \"Febbraio\" ); } case 3 :{ System . out . println ( \"Marzo\" ); } case 4 :{ System . out . println ( \"Aprile\" ); } case 5 :{ System . out . println ( \"Maggio\" ); } case 6 :{ System . out . println ( \"Giugno\" ); } case 7 :{ System . out . println ( \"Luglio\" ); } case 8 :{ System . out . println ( \"Agosto\" ); } case 9 :{ System . out . println ( \"Settembre\" ); } case 10 :{ System . out . println ( \"Ottobre\" ); } case 11 :{ System . out . println ( \"Novembre\" ); } case 12 :{ System . out . println ( \"Dicembre\" ); } default :{ System . out . println ( \"Errore! Mese non valido\" ); } } } } /* Maggio Giugno Luglio Agosto Settembre Ottobre Novembre Dicembre Errore! Mese non valido */ Non avrei potuto usare il costrutto if..else? Il costrutto if ... else \u00e8 il costrutto pi\u00f9 generico e potente alla base di ogni linguaggio di programmazione e, proprio per la sua genericit\u00e0 \u00e8 preferibile utilizzare in tutti quei casi in cui le condizioni da verificare sono complesse e non facilmente raggruppabili da una famiglia di valori specifici. Nei casi in cui il valore di un'espressione o pi\u00f9 semplicemente di una variabile determina l'esecuzione di un blocco di codice specifico, il costrutto switch si rileva pi\u00f9 lineare e leggibile. Lezione 26 Leggere dati da tastiera Partiamo da un esempio: package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { Scanner tastiera = new Scanner ( System . in ); int eta = tastiera . nextInt (); System . out . print ( \"hai: \" + eta + \" anni\" ); } } Il codice sopra riportato legge un intero da tastiera, lo memorizza nella variabile eta e stampa la variabile. Ma come funziona? Non possiamo pretendere di capire a fondo il meccanismo che sta alla base poich\u00e8 ancora dobbiamo affrontare la OOP ma di fatto, non sappiamo neanche cosa sta dietro il meccanismo della stampa System.out.print() . Ci limiteremo, per adesso ad un apprendimento intuitivo. Riporto i punti fondamentali: Creo un'istanze della classe Scanner chiamato tastiera . Scanner tastiera = .. Assegno a tastiera un nuovo oggetto appartenente alla classe Scanner passando come parametro System.in . La chiamata new Scanner(System.in) invoca il costruttore della claase Scanner , una particolare funzione che si occupa dell'inizializzazione degli oggetti istanziati attraverso classi. Scanner tastiera = new Scanner ( System . in ); A questo punto tastiera \u00e8 un oggetto inizializzato come input della classe Scanner . Posso quindi utilizzare tutti i metodi della classe Scanner applicati a tastiera . Il metodo next.Int() applicato a un oggetto Scanner inizializzato come input si occupa di prelevare da tastiera un intero. int eta = tastiera . nextInt (); Non importa se non hai capito bene tutti i passaggi. Se avrai la pazienza di arrivare in fondo al corso ne capirai il significato. E' tuttavia necessario introdurre qualche concetto sulla OOP visto che Java che \u00e8 un linguaggio costruito proprio sul meccanismo di programmazione orientata agli oggetti. Attenzione! Il metodo nextInt() acquisisce da tastiera solo numeri interi. Verr\u00e0 sollvato un errore (eccezione) a runtime se rileva un valore diverso. Quindi, come acquisisco valori decimale, Stringhe e quantaltro? Semplice, utilizzo un metodo diverso. L'autocompletamento di Eclipse pu\u00f2 aiutarci a capire tutti i metodi disponibili per quella classe Ne riporto giusto alcuni: nextDouble() : Acquisisce da tastiera un numero decimale next() : Acquisisce da tastiera una stringa, termina al primo spazio nextLine() : Acquisce da tastiera una stringa, termina con INVIO . Acquisice dunque l'intera linea immessa da tastiera Lezione 27 Costrutti Iterativi I costrutti iterativi sono costrutti essenziali presenti necessariamente in ogni linguaggio di programmazione. vengono chiamati anche loop o cicli e permettono di eseguire un blocco di codice finch\u00e9 rimane vera, true una condizione specifica. Ciclo while Il ciclo while ripete un blocco di codice finch\u00e8 la condizione specificata rimane vera: while ( condition ) { // code } Esempio: package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { int i = 0 ; while ( i < 5 ) { //i = 0, 0 < 5 //i = 1, 1 < 5 .. System . out . println ( i ); //i = 1 //i = 2 .. i ++ ; } } } /* 0 1 2 3 4 */ Attenzione In una struttura iterativa \u00e8 sempre bene tener presente: - La condizione di verifica del ciclo. Prima o poi la condizione deve risultare false altrimenti si rischia di costruire un ciclo infinito, bloccando l'esecuzione di tutto il programma! - L'istruzione che altera, ad ogni iterazione, la condizione da verificare. Se non esiste nessuna istruzione in grado di modificare la condizione sotto controllo del ciclo, allo stesso modo, si ottiene un ciclo infinito. Da evitare! Il seguente codice stampa il valore 0 infinite volte, bloccando l'utilizzo della CPU . E' chiaramente un errore grave! package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { int i = 0 ; while ( i < 5 ) { System . out . println ( i ); } } } /* 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 . . */ Lezione 28 Qualche esercizio Stampa somma esercizio base Stampa la somma dei primi 100 numeri. package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { int i = 0 ; int ris = 0 ; while ( i <= 100 ) { ris += i ; i ++ ; } System . out . println ( ris ); //5050 } } stampa somma esercizio avanzato Stampa la somma dei numeri interi immessi da tastiera compresi nel range [x, y]. Termina non appena la somma supera il valore 1000 package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); int ris = x ; while ( ( x < y ) && ( ris < 1000 ) ) { x ++ ; ris += x ; } System . out . println ( \"Ultimo valore somato: \" + x ); System . out . println ( \"Risultato: \" + ris ); } } Attenzione! La sequenza delle istruzioni \u00e8 importante soprattutto quando queste sono all'interno di una struttura iterativa! Cambiando l'ordine degli statemeant il risultato cambia eccome.. In particolare, all'interno di una struttura iterativa \u00e8 necessario fare bene i conti poich\u00e8 ad esempio l'istruzione B successiva all'istruzione A \u00e8 tale da influenzare l'istruzione A all'iterazione successiva. Consiglio sempre di fare attenzione ai casi eccezionali ovvero i valori di partenza e i valori finali. Il prossimo esercizio, simile al precedente \u00e8 sintatticamente corretto ma semanticamente sbagliato. L'algoritmo non \u00e8 corretto! package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); int ris = x ; while ( ( x < y ) && ris < 1000 ) { ris += x ; x ++ ; } System . out . println ( \"Ultimo valore somato: \" + x ); System . out . println ( \"Risultato: \" + ris ); } } Ho semplicemente invertito l'ordine della sequenza di istruzioni all'interno del ciclo while . Il risultato prodotto non \u00e8 corretto ma un occhio non attento non sarebbe in grado di scoprirlo. La somma dei numeri compresi tra [2, 5] dovrebbe dare come risultato 2 + 3 + 4 + 5 = 14 e non 11 . Cos'\u00e8 che non va? Il problema \u00e8 al primo passo iterativo. int ris = x ; while ( ( x < y ) && ris < 1000 ) { ris += x ; x ++ ; } Prima di iniziare il ciclo infatti la la variabile ris assume il valore iniziale x , quello di partenza ma alla prima iterazione del ciclo somma nuovamente x a ris , quindi quello che ottengo \u00e8: 2 + 2 + 3 + 4 = 11 . Attento che il numero 5 , l'ultimo numero non viene considerato! Perch\u00e8, al contrario di prima il numero finale non viene incluso nel ciclo? Il motivo \u00e8 sempre lo stesso, perch\u00e8 ho invertito le istruzioni all'interno del while ma in questo caso \u00e8 colpa dell'ultimo passo iterativo. Infatti all'ultimo passo iterativo, quando x=4 , il ciclo \u00e8 ancora valido, 4 viene sommato al risultato ris e solo dopo viene incrementato rendendo falsa la condizione del ciclo al passo successivo e quindi impedendo a ris di incrementarsi. Modo alternativo?? Niente paura, sei stai pensando che sia complicato ti garantisco che \u00e8 cos\u00ec, \u00e8 complicato! Per questo sto perdendo molto tempo sugli esercizi e sulla pratica. Ecco un esempio dello stesso esercizio svolto mantenendo questo ordine delle istruzioni. package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); int ris = 0 ; while ( ( x <= y ) && ris < 1000 ) { ris += x ; x ++ ; } System . out . println ( \"Ultimo valore somato: \" + -- x ); System . out . println ( \"Risultato: \" + ris ); } } Che cosa \u00e8 cambiato? Apparentemente niente ma un occhio esperto potrebbe notare che la variabile ris \u00e8 stata inizializzata con il valore 0 in modo da evitare di sommare due volte il valore iniziale ed \u00e8 stata cambiata la condizione all'interno del while da (x < y) a (x <= y) in modo da includere anche l'ultimo numero del passo iterativo. Infine anche se \u00e8 secondario, ho dovuto cambiare la stampa dell'ultimo valore sommato da x a --x cio\u00e8 decrementando il valore poich\u00e8 in questo caso x , alla fine del cilco, \u00e8 fuori range Non ti fidi? ecco il risultato. Ti ho convinto che in ciclo la sequenza delle operazioni \u00e8 fondamentale? Spero proprio di s\u00ec :) Aggiunta di un controllo Nell'esercizio precedente tutto sembra funzionare alla grande ma non \u00e8 cos\u00ec. Che cosa succede se il numero di partenza x \u00e8 maggiore del numero di fine y ? Un disastro.. Dobbiamo aggiungere un controllo per evitare questo problema, del tipo if ( x > y ){ //fai qualcosa } In questo caso ho intenzione di scambiare il valore di x con y per renderla sempre vera. package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); if ( x > y ) { int temp = x ; x = y ; y = temp ; } int ris = 0 ; while ( ( x <= y ) && ris < 1000 ) { ris += x ; x ++ ; } System . out . println ( \"Ultimo valore somato: \" + -- x ); System . out . println ( \"Risultato: \" + ris ); } } Vediamo subito un esempio che passi dal costrutto if Un po' di esercizi e modi di pensare li hai visti. Ti lascio infine un modo compatto per scrivere quel ciclo. package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); if ( x > y ) { int temp = x ; x = y ; y = temp ; } int ris = 0 ; while ( ( x <= y ) && ris < 1000 ) ris += x ++ ; System . out . println ( \"Ultimo valore somato: \" + -- x ); System . out . println ( \"Risultato: \" + ris ); } } Ancora continua a funzionare: Lezione 28 Ciclo do ... while Il ciclo do ... while \u00e8 una variante del ciclo while. Questo ciclo esegue sempre il blocco di codice almeno una volta prima di verificare se la condizione \u00e8 vera. Ripete il codice finch\u00e9 la condizione rimane vera. La differenza sta dunque alla prima iterazione. Infatti, in un ciclo while non \u00e8 detto che venga eseguito il codice all'interno, se la condizione risulta subito falsa, si esce. In questo caso invece almeno una volta si esegue do { // code block to be executed } while ( condition ); Riporto lo stesso esercizio della somma dei numeri utilizzando il do ... while package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); if ( x > y ) { int temp = x ; x = y ; y = temp ; } int ris = 0 ; do { ris += x ++ ; } while ( ( x <= y ) && ris < 1000 ); System . out . println ( \"Ultimo valore somato: \" + -- x ); System . out . println ( \"Risultato: \" + ris ); } } Lezione 29 For loop Quando sai esattamente quante volte vuoi ripetere un blocco di codice, puoi usare il ciclo for invece di un ciclo while : for ( statement 1 ; statement 2 ; statement 3 ) { // code block to be executed } - statement 1 \u00e8 eseguita una volta prima dell'esecuzione del ciclo - statement 2 definisce la condizione da verificare - statement 3 \u00e8 eseguita ogni volta dopo il blocco di codice un esempio classico: package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( i ); } } } Una considerazione importante La variabile i dichiarata all'interno del ciclo for NON E' VISIBILE ALL'ESTERNO rimane privata al ciclo for . Richiamando la variabile i all'esterno del ciclo for si genera un'errore in fase di compilazione poich\u00e8 di fatto i non esiste pi\u00f9. La variabile i muore appena terminato il ciclo ed \u00e8 come se non fosse mai esistita package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { for ( int i = 0 ; i < 5 ; i ++ ) { //qui nasce i System . out . println ( i ); } //qui muore i System . out . println ( i ); } } /* output Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: i cannot be resolved to a variable at mioTest.prova01.main(prova01.java:11) */ Altre considerazioni - statement 1 , statement 2 , statement 3 sono tutte opzionali opzionali - statement 1 , statement 3 possono essere composti da pi\u00f9 statement ciascuno, separati dalla virgola , Un esempio: package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { for ( int i = 0 , j = 10 ; ( i < 10 ) && ( j > 0 ); i ++ , j -- ) { System . out . println ( i + \" - \" + j ); } } } /* output 0 - 10 1 - 9 2 - 8 3 - 7 4 - 6 5 - 5 6 - 4 7 - 3 8 - 2 9 - 1 */ Vediamo infine il solito esercizio somma realizzato anche con il ciclo for package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); if ( x > y ) { int temp = x ; x = y ; y = temp ; } int ris = 0 ; for ( ris = 0 ; (( x <= y ) && ris < 1000 ); x ++ ) ris += x ; System . out . println ( \"Ultimo valore somato: \" + -- x ); System . out . println ( \"Risultato: \" + ris ); } } Lezione 30 break e continue Hai gi\u00e0 visto l'istruzione break usata in un capitolo precedente di questo tutorial. Era usato per \"saltare fuori\" da un'istruzione switch. L'istruzione break pu\u00f2 essere utilizzata anche per uscire da un ciclo. package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == 4 ) { break ; } System . out . println ( i ); } } } /* output 0 1 2 3 */ L'istruzione continue salta all'iterazione successiva ma non termina il ciclo. package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { int i = 0 ; while ( i < 10 ) { if ( i == 4 ) { i ++ ; continue ; } System . out . println ( i ); i ++ ; } } } /* output 0 1 2 3 5 6 7 8 9 */ Lezione 31 Sottoprogrammi, Funzioni, Metodi Per linguaggi non OOP si parla di funzioni , per linguaggi OOP si parla di metodi. Pi\u00f9 in generale si pu\u00f2 parlare di sottoprogrammi come un raggruppamento di istruzioni atte a svolgere uno scopo preciso. In Java, poich\u00e8 \u00e8 un linguaggio OOP si parla di metodi. Abbiamo gi\u00e0 visto dei metodi sottoforma di black-box come print , println della classe System.out oppure endsWith() , lenght() della classe String o ancora parseDouble() della classe Double . Dal punto di vista dell'utente si presentano sottoforma di comandi ma in realt\u00e0 sono dei pacchetti di codice scritti anch'essi in linguaggio Java e applicabili soltanto a una particolare classe . Infatti il metodo parseDouble() \u00e8 un sottoprogramma applicabile alla classe Double, , endsWith() allo stesso modo \u00e8 applicabile alla classe String . Questi sottoprogrammi non hanno una funzione sintattica specifica, non aggiungono costrutti al linguaggio quindi non lo arricchiscono ma sono indispensabili al fine di poter costruire enormi pezzi di codice poich\u00e8 permettono la scomposizione dell'intero codice in tanti piccoli pezzi fondamentali isolati e quindi studiabili separatamente. Ti ho mentito, in realt\u00e0 hai visto anche l'implementazione di un metodo package mioTest ; public class prova01 { public static void main ( String [] args ) { } } Ebbene s\u00ec, fino ad ora abbiamo scritto all'interno del metodo principale main() quello che Java cerca sempre alla partenza di un programma come entry point. E abbiamo visto che il metodo main() \u00e8 all'interno della classe prova01 quindi \u00e8 un metodo applicabile alla classe prova01 . Bando alle ciance vediamo adesso la sintassi base per la definizione di un metodo: public class prova01 { //Definizione di un metodo static returnType methodName ( type1 paramA , type2 paramB , ....) { //implementazione } public static void main ( String [] args ) { //Chiamata di un metodo methodName ( param1 , param2 , ...); } } Un metodo per funzionare deve essere definito e successivamente chiamato. Per adesso, di tutti i metodi citati sopra abbiamo visto solo la chiamata ma non sappiamo qual \u00e8 la loro definizione anche se di fatto non ci interessa. Adesso andremo a definire un nostro metodo e successivamente a chiamarlo. Definizione di un metodo: static returnType methodName ( type1 paramA , type2 paramB , ....) { //implementazione } - Nella definizione si stabilisce il nome del metodo, un po' come si fa nella dichiarazione delle variabili. Il nome del metodo verr\u00e0 utilizzato in fase di chiamata - Si stabiliscono i parametri formali ovvero gli input che deve ricevere dall'esterno. - Si stabilisce un tipo di ritorno cio\u00e8 l'output che dovr\u00e0 fornire all'esterno. - Si scrive l' implementazione cio\u00e8 come gli input dovranno essere elaborati per produrre gli output. Chiamata di un metodo: methodName ( param1 , param2 , ...); E' possibile chiamare un metodo solo se \u00e8 stato definito. Per la chiamata di un metodo \u00e8 sufficiente digitare il nome del metodo seguito dai parametri racchiusi tra le parentesi (param1, param2) . In questo caso i parametri sono detti attuali . Il loro valore viene trasferito alla funzione per l'elaborazione Vediamo un esempio: package mioTest ; public class prova01 { //parametri formali static void saluta ( String nome ) { System . out . println ( \"Ciao \" + nome + \"!\" ); } public static void main ( String [] args ) { //richiamo del metodo, parametri attuali saluta ( \"Simone\" ); //Ciao Simone! saluta ( \"Matteo\" ); //Ciao Matteo! } } saluta \u00e8 il nome della funzione. void \u00e8 il tipo di ritorno della funzione. Il tipo void si utilizza quando la funzione non ritorna nessun valore. Un solo parametro \u00e8 definito ed \u00e8 un oggetto String Un altro esempio. In questo esempio aggiunger\u00f2 altri parametri per la stampa di una cornice al saluto, stabilendo la lunghezza della cornice: package mioTest ; public class prova01 { //parametri formali static void saluta ( String nome , char simbolo , int lunghezza ) { for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } System . out . print ( '\\n' ); System . out . println ( \"Ciao \" + nome + \"!\" ); for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } System . out . print ( '\\n' ); } public static void main ( String [] args ) { //richiamo del metodo, parametri attuali saluta ( \"Simone\" , '*' , 30 ); saluta ( \"Matteo\" , '-' , 20 ); } } /* output ****************************** Ciao Simone! ****************************** -------------------- Ciao Matteo! -------------------- */ Cambiando solo i parametri formali ottengo gi\u00e0 un risultato molto personalizzato. Lezione 32 due parole sui parametri I parametri formali, cio\u00e8 quelli dichiarati in fase di definizione del metodo, NON SONO VISIBILI ALL'ESTERNO . E' lo stesso concetto che vale anche per le variabili dichiarate nel ciclo for . package mioTest ; public class prova01 { //parametri formali static void saluta ( String nome , char simbolo , int lunghezza ) { for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } System . out . print ( '\\n' ); System . out . println ( \"Ciao \" + nome + \"!\" ); for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } System . out . print ( '\\n' ); } public static void main ( String [] args ) { System . out . print ( simbolo ); } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: simbolo cannot be resolved to a variable at mioTest.prova01.main(prova01.java:19) */ E' un problema? Assolutamente no! Anzi, ai fini di isolare un blocco di codice \u00e8 giusto che ogni variabile o parametro sia privato al metodo. Chi scrive il metodo deve solo preoccuparsi di produrre certi output dati certi input. Allo stesso modo, all'esterno del metodo, non ci dobbiamo assolutamente preoccupare di come sono state scritte le variabili o di come \u00e8 stato implementato il metodo. Ci dobbiamo solo preoccupare di utilizzare il metodo nel modo giusto! Un altro esempio. In queso esempio ottimizzer\u00f2 ancora il metodo dell'esercizio precedente scompattando il codice ulteriormente. Mano a mano che il codice viene frammentato le singole unit\u00e0 diventano pi\u00f9 semplici e facilmente debuggabili. package mioTest ; public class prova01 { static void stampaRiga ( char simbolo , int lunghezza , boolean aCapo ) { for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } if ( aCapo ) System . out . print ( '\\n' ); } //parametri formali static void saluta ( String nome , char simbolo , int lunghezza ) { stampaRiga ( simbolo , lunghezza , true ); System . out . println ( \"Ciao \" + nome + \"!\" ); stampaRiga ( simbolo , lunghezza , true ); } public static void main ( String [] args ) { saluta ( \"Simone\" , '*' , 30 ); saluta ( \"Matteo\" , '#' , 15 ); } } Ho aggiunto inoltre una funzionalit\u00e0 in pi\u00f9. Un parametro boolean che specifica se la stampa deve andare a capo oppure no. Troppi parametri a volte potrebbero essere semplicemente \"troppi\". Un metodo alternativo: package mioTest ; public class prova01 { static void stampaRiga ( char simbolo , int lunghezza ) { for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } } static void stampaRigaLn ( char simbolo , int lunghezza ) { for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } System . out . print ( '\\n' ); } //parametri formali static void saluta ( String nome , char simbolo , int lunghezza ) { stampaRigaLn ( simbolo , lunghezza ); System . out . println ( \"Ciao \" + nome + \"!\" ); stampaRigaLn ( simbolo , lunghezza ); } public static void main ( String [] args ) { saluta ( \"Simone\" , '*' , 30 ); saluta ( \"Matteo\" , '#' , 15 ); } } Questo \u00e8 un metodo che fa uso di un parametro in meno ma di una funzione in pi\u00f9 distinguendo stampaRiga() da stampaRigaLn() . La prima stampa una riga ma non va a capo, la seconda stampa una riga e va a capo. Cosa ci guadagno? In questo caso di semplicit\u00e0 e intuitivit\u00e0. Lezione 33 Ancora un altro esempio. Return Nel prossimo esempio vedremo un tipo di ritorno diverso da void . Vedremo anche la parola chiave return che permette di restituire un volore all'esterno del tipo specificato in fase di dichiarazione. Con la seguente definizione di metodo: static String ripetiSimbolo ( char simbolo , int lunghezza ) { String riga = \"\" ; //.. code return riga ; } Sto assegnando come tipo di ritorno un oggeto di tipo String . la parola chiave return interrompe la funzione restiutendo il valore indiciato Vediamo un esempio: package mioTest ; public class prova01 { static String ripetiSimbolo ( char simbolo , int lunghezza ) { String riga = \"\" ; for ( int i = 0 ; i < lunghezza ; i ++ ) { riga += simbolo ; } return riga ; } //parametri formali static void saluta ( String nome , char simbolo , int lunghezza ) { String riga = ripetiSimbolo ( simbolo , lunghezza ); System . out . println ( riga ); System . out . println ( \"Ciao \" + nome + \"!\" ); System . out . println ( riga ); } public static void main ( String [] args ) { saluta ( \"Simone\" , '*' , 30 ); saluta ( \"Matteo\" , '#' , 15 ); } } Questo \u00e8 il la soluzione migliore (per adesso). Invece di stampare direttamente la riga ritorno una String che possono quindi mandare come argomento al metodo print() o println() . In questo caso non importa neanche la suddivisione tra la stampa della riga con o senza a capo , ci penser\u00e0 il metodo print() o println() . Di gran lunga molto pulito. Inoltre ritornando una String posso usare questa stringa per fare ci\u00f2 che voglio. Con la stamp diretta non ho questa flessibilit\u00e0, una votla stampato \u00e8 stampato e la sua funzionalit\u00e0 \u00e8 terminata. Un esempio ancora pi\u00f9 compatto: package mioTest ; public class prova01 { static String ripetiSimbolo ( char simbolo , int lunghezza ) { String riga = \"\" ; for ( int i = 0 ; i < lunghezza ; i ++ ) { riga += simbolo ; } return riga ; } //parametri formali static void saluta ( String nome , char simbolo , int lunghezza ) { System . out . println ( ripetiSimbolo ( simbolo , lunghezza )); System . out . println ( \"Ciao \" + nome + \"!\" ); System . out . println ( ripetiSimbolo ( simbolo , lunghezza )); } public static void main ( String [] args ) { saluta ( \"Simone\" , '*' , 30 ); saluta ( \"Matteo\" , '#' , 15 ); } } Lezione 34 Qualche approfondimento sui parametri I parametri in java vengono passati per valore . Ogni parametro o variabile creata all'interno della definizione di una funzione rimane privato alla funzione e non c'\u00e8 modo di confondersi. Anche se i parametri attuali coincidono (di nome) con i parametri formali, come spesso accade, deve essere chiaro che fanno riferimento a due variabili diverse. Vediamo un esempio: package mioTest ; public class prova01 { //parametri formali static void quadrato ( int n ) { n *= n ; System . out . println ( n ); } public static void main ( String [] args ) { int n = 10 ; System . out . println ( n ); //10 quadrato ( n ); //100 System . out . println ( n ); //10 } } Lezione 35 Array Un array \u00e8 un contenitore in grado di memorizzare un numero fisso di valori di un singolo tipo. La lunghezza di un array viene stabilita quando viene creato l'array. Dopo la creazione, la sua lunghezza \u00e8 fissata. Ogni elemento in un array \u00e8 chiamato elemento e si accede a ciascun elemento tramite il suo indice numerico. Come mostrato in figura, la numerazione inizia con 0. Il nono elemento, ad esempio, sarebbe quindi accessibile dall'indice 8. Un esempio di dichiarazione di un array //array di interi, la lunghezza \u00e8 4 //indice 0 1 2 3 int [] myNum = { 10 , 20 , 30 , 40 }; //array di String, la lunghezza \u00e8 4 //indice 0 1 2 3 String [] cars = { \"Volvo\" , \"BMW\" , \"Ford\" , \"Mazda\" }; Vediamo adesso come si accede in lettura ad un elemento di un array. package mioTest ; public class prova01 { public static void main ( String [] args ) { //array di interi //indice 0 1 2 3 int [] myNum = { 10 , 20 , 30 , 40 }; //array di String //indice 0 1 2 3 String [] cars = { \"Volvo\" , \"BMW\" , \"Ford\" , \"Mazda\" }; System . out . println ( cars [ 1 ] ); //BMW System . out . println ( myNum [ 3 ] ); //40 } } Vediamo adesso come accedere in scrittura agli elementi di un array. package mioTest ; public class prova01 { public static void main ( String [] args ) { //array di interi // 0 1 2 3 int [] myNum = { 10 , 20 , 30 , 40 }; //array di String // 0 1 2 3 String [] cars = { \"Volvo\" , \"BMW\" , \"Ford\" , \"Mazda\" }; //Accesso in scrittura ad un elemento di un array cars [ 1 ] = \"Mercedes\" ; myNum [ 3 ] = 140 ; System . out . println ( cars [ 1 ] ); //Mercedes System . out . println ( myNum [ 3 ] ); //140 } } Vediamo un esercizio. Nel seguente esercizio riempir\u00f2 un array di 5 numeri decimali casuali che rappresentano l'incasso settimanale di una ipotetica azienda. Per ogni giorno della settimana stamper\u00f2 l'incasso giornaliero e il parziale settimanale. Random r = new Random(); : Genera un oggetto di nome r della classe Random . Il metodo nextDouble() della classe Random genera un numero decimale casuale nel range [0, 1] package mioTest ; import java.util.Random ; public class prova01 { public static void main ( String [] args ) { Random r = new Random (); double totaleIncassi = 0 ; double [] incassiGiornalieri = new double [ 30 ] ; System . out . println ( \"Incassi dell'azienda Super inc\" ); System . out . println ( \"************************************************\" ); for ( int giorno = 0 ; giorno < 5 ; giorno ++ ) { incassiGiornalieri [ giorno ] = r . nextDouble () * 1000 ; System . out . print ( \"Incasso del giorno \" + ( giorno + 1 ) + \" vale: \" + incassiGiornalieri [ giorno ] ); totaleIncassi += incassiGiornalieri [ giorno ] ; System . out . println ( \"\\nTotale incassi al giorno \" + ( giorno + 1 ) + \": \" + totaleIncassi + '\\n' ); } } } /* Incassi dell'azienda Super inc ************************************************ Incasso del giorno 1 vale: 591.9943669250713 Totale incassi al giorno 1: 591.9943669250713 Incasso del giorno 2 vale: 361.53919223504084 Totale incassi al giorno 2: 953.5335591601122 Incasso del giorno 3 vale: 470.24992212457863 Totale incassi al giorno 3: 1423.7834812846909 Incasso del giorno 4 vale: 308.06054288474604 Totale incassi al giorno 4: 1731.844024169437 Incasso del giorno 5 vale: 893.9369612336028 Totale incassi al giorno 5: 2625.7809854030397 */ Nel prossimo esempio incapsuler\u00f2 la generazione di un numero casuale in un metodo aggiungendo la possibilit\u00e0 di esprimere un range. randomDouble(param1, param2) : Genera un numero decimale casuale nel range [param1, param2] package mioTest ; import java.util.Random ; public class prova01 { static double randomDouble ( double minValue , double maxValue ) { double ris = 0d ; Random r = new Random (); ris = r . nextDouble () * ( maxValue - minValue ) + minValue ; return ris ; } public static void main ( String [] args ) { double totaleIncassi = 0 ; double [] incassiGiornalieri = new double [ 5 ] ; System . out . println ( \"Incassi dell'azienda Super inc\" ); System . out . println ( \"************************************************\" ); for ( int giorno = 0 ; giorno < 5 ; giorno ++ ) { incassiGiornalieri [ giorno ] = randomDouble ( 0 , 1000 ); System . out . print ( \"Incasso del giorno \" + ( giorno + 1 ) + \" vale: \" + incassiGiornalieri [ giorno ] ); totaleIncassi += incassiGiornalieri [ giorno ] ; System . out . println ( \"\\nTotale incassi al giorno \" + ( giorno + 1 ) + \": \" + totaleIncassi + '\\n' ); } } } /* Incassi dell'azienda Super inc ************************************************ Incasso del giorno 1 vale: 744.9914581441986 Totale incassi al giorno 1: 744.9914581441986 Incasso del giorno 2 vale: 783.3932124466809 Totale incassi al giorno 2: 1528.3846705908795 Incasso del giorno 3 vale: 769.2791383491912 Totale incassi al giorno 3: 2297.663808940071 Incasso del giorno 4 vale: 493.77024887651777 Totale incassi al giorno 4: 2791.4340578165884 Incasso del giorno 5 vale: 136.12792423533682 Totale incassi al giorno 5: 2927.561982051925 */ Nel prossimo esempio aggiungeremo la possibilit\u00e0 di calcolare la media e i giorni in cui l'incasso \u00e8 sotto la media. package mioTest ; import java.util.Random ; public class prova01 { static double randomDouble ( double minValue , double maxValue ) { double ris = 0d ; Random r = new Random (); ris = r . nextDouble () * ( maxValue - minValue ) + minValue ; return ris ; } public static void main ( String [] args ) { double mediaIncassi = 0 ; double totaleIncassi = 0 ; double [] incassiGiornalieri = new double [ 5 ] ; System . out . println ( \"Incassi dell'azienda Super inc\" ); System . out . println ( \"************************************************\" ); //inserisco gli incassi giornalieri e stampo il parziale for ( int giorno = 0 ; giorno < 5 ; giorno ++ ) { incassiGiornalieri [ giorno ] = randomDouble ( 0 , 1000 ); System . out . print ( \"Incasso del giorno \" + ( giorno + 1 ) + \" vale: \" + incassiGiornalieri [ giorno ] ); totaleIncassi += incassiGiornalieri [ giorno ] ; System . out . println ( \"\\nTotale incassi al giorno \" + ( giorno + 1 ) + \": \" + totaleIncassi + '\\n' ); } //calcolo la media mediaIncassi = totaleIncassi / 5 ; //Stampo i giorni della settimana in cui l'incasso \u00e8 risultato inferiore all media System . out . print ( \"Incasso inferiore alla media nei giorni: \" ); for ( int giorno = 0 ; giorno < 5 ; giorno ++ ) { if ( incassiGiornalieri [ giorno ] < mediaIncassi ) System . out . print ( ( giorno + 1 ) + \", \" ); } } } /* output --- --- --- --- --- --- --- --- --- --- Incassi dell'azienda Super inc ************************************************ Incasso del giorno 1 vale: 267.3356741835512 Totale incassi al giorno 1: 267.3356741835512 Incasso del giorno 2 vale: 686.4601921175105 Totale incassi al giorno 2: 953.7958663010617 Incasso del giorno 3 vale: 610.6233133806691 Totale incassi al giorno 3: 1564.4191796817308 Incasso del giorno 4 vale: 87.57257150511832 Totale incassi al giorno 4: 1651.9917511868491 Incasso del giorno 5 vale: 513.5065433416011 Totale incassi al giorno 5: 2165.49829452845 la media degli incassi vale:433.09965890569003 Incasso inferiore alla media nei giorni: 1, 4, */ Lezione 36 Errori con gli array Una volta definito un array, la dimensione \u00e8 stabilit\u00e0, non si possono aggiungere, togliere elementi o scrivere/leggere elementi al di fuori del range di un array. In particolare: E' un errore di compilazione se tenti di accedere ad un indice negativo package mioTest ; public class prova01 { public static void main ( String [] args ) { int [] myArr = new int [ 5 ] ; myArr [- 1 ] = 12 ; } } /* Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 5 at mioTest.prova01.main(prova01.java:7) */ E' un erroro di compilazione se tenti di accedere ad un elemento pi\u00f9 grande della grandezza dell'array. Attenzione che se la lunghezza di un array \u00e8 pari a 5 gli elementi sono elencati nel range [0 - 4] package mioTest ; public class prova01 { public static void main ( String [] args ) { int [] myArr = new int [ 5 ] ; myArr [ 8 ] = 12 ; } } /* Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 8 out of bounds for length 5 at mioTest.prova01.main(prova01.java:7) */ Per concludere aggiungo l'algoritmo per vedere se ci sono due giorni consecutivi con incasso inferiore alla media Lezione 37 Approfondimento Input tastiera Per la gestione dei dati in input da tastiera \u00e8 necessario importare il modulo java.io.* . Il carattere * \u00e8 necessario per prelevare tutti i package del modulo java.io . La classe InputStreamReader rappresenta una classe per la lettura di un byte (non necessariamente da tastiera, per esempio anche su file). Inizializzando un oggetto della classe InputStreamReader con l'oggetto System.in consento all'oggetto di leggere dati da tastiera tramite il metodo read() . Ma non basta... package mioTest ; import java.io.* ; public class prova01 { public static void main ( String [] args ) { //InputStreamReader = flusso di byte in lettura //La tastiera \u00e8 definita in System.in InputStreamReader tastiera = new InputStreamReader ( System . in ); System . out . println ( \"Inserisci un carattere e premi INVIO\" ); int myInt = tastiera . read (); } } /* output Exception in thread \"main\" java . lang . Error : Unresolved compilation problem : Unhandled exception type IOException at mioTest . prova01 . main ( prova01 . java : 14 ) Il compilatore riporta l'errore Unhandled exception type IOException , ovvero.. Non hai gestito un eventuale errore del tipo IOException . Eclispe suggerisce anche una soluzione Lezione 38 Costrutto try catch Durante l'esecuzione del codice Java, possono verificarsi diversi errori: errori di codifica commessi dal programmatore, errori dovuti a un input errato o altre cose imprevedibili. Quando si verifica un errore, Java normalmente si interrompe e genera un messaggio di errore. Il termine tecnico per questo \u00e8: Java generer\u00e0 un'eccezione (generer\u00e0 un errore). L'istruzione try consente di definire un blocco di codice da verificare durante l'esecuzione. L'istruzione catch consente di definire un blocco di codice da eseguire, se si verifica un errore nel blocco try. try { //codeA -> Da verificare } catch ( Type e ) { //codeB -> solo se codeA ha rilevato un errore del tipo specificato da Type } Vediamolo in azione: package mioTest ; import java.io.* ; public class prova01 { public static void main ( String [] args ) { //InputStreamReader = flusso di byte in lettura //La tastiera \u00e8 definita in System.in InputStreamReader tastiera = new InputStreamReader ( System . in ); int myInt = 0 ; System . out . println ( \"Inserisci un carattere e premi INVIO\" ); //Gestione dell'errore try { myInt = tastiera . read (); } catch ( IOException e ) { // TODO Auto-generated catch block e . printStackTrace (); } System . out . println ( \"Il carattere ASCII corrsipondente \u00e9: \" + myInt ); } } Attenzione Ho dovuto definire fuori dal blocco try la variabile myInt per una questione di visibilit\u00e0 all'esterno. La classe InputStreamReader permette la lettura di un byte alla volta. Nel prossimo esempio vedremo come leggere un'intera riga attraverso l'uso di BufferdReader . La classe BufferedReader prende come parametro di inizializzazione un oggetto della classe InputStreamReader e forma un buffer, cio\u00e8 consente l'acquisizione da tastiera di una serie di caratteri. Termina l'acquisizione premendo INVIO package mioTest ; import java.io.* ; public class prova01 { public static void main ( String [] args ) { //InputStreamReader = flusso di byte in lettura //La tastiera \u00e8 definita in System.in InputStreamReader tastiera = new InputStreamReader ( System . in ); BufferedReader bufferedTastiera = new BufferedReader ( tastiera ); System . out . println ( \"Inserisci una frase e premi INVIO\" ); String myString = \"\" ; try { myString = bufferedTastiera . readLine (); } catch ( IOException e ) { // TODO Auto-generated catch block e . printStackTrace (); } System . out . println ( \"la frase inserita e: \" + myString ); } } /* output Inserisci una frase e premi INVIO ciao a tutti quanti la frase inserita e: ciao a tutti quanti */ Lezione 39 Esercizio calcolo interesse con input da tastiera parte 1 In questa nuova versione ho aggiunto la possibilit\u00e0 di leggere i dati da tastiera esportando il metodo : leggiDouble(String mainMessage , double minValue, double maxValue) che: Chiede un dato da tastiera stampando il messaggio passato come String e come primo parametro ( mainMessage ) rileva un errore di formato attraverso il costrutto try ... catch e stampa \"Formato non corretto! Riprova..\" rileva un errore se il numero inserito non \u00e8 compreso tra minValue , maxValue passati rispettivamente come terzo e quarto parametro e stampa il messaggio d'errore \"Valore non appartenente al range: [\"minValue\" - \"maxValue\"]\" . Ritorna il valore double acquisito da tastiera solo se non ci sono errori altrimenti chiede un nuovo dato da tasiera finch\u00e8 non ci sono errori. package mioTest ; import java.io.* ; public class prova01 { static double leggiDouble ( String mainMessage , double minValue , double maxValue ) { InputStreamReader tastiera = new InputStreamReader ( System . in ); BufferedReader bufferedTastiera = new BufferedReader ( tastiera ); String rigaLetta = \"\" ; String formatErrorMessage = \"Formato non corretto! Riprova..\" ; String rangeErrorMessage = \"Valore non appartenente al range\" ; double doubleLetto = 0 ; double risultato = 0 ; boolean error = false ; do { error = false ; try { System . out . println ( mainMessage ); rigaLetta = bufferedTastiera . readLine (); doubleLetto = Double . parseDouble ( rigaLetta ); } catch ( IOException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } catch ( NumberFormatException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } if ( ( doubleLetto < minValue ) || ( doubleLetto > maxValue ) ) { error = true ; System . out . println ( rangeErrorMessage ); continue ; } else { risultato = doubleLetto ; } } while ( error ); return risultato ; } public static void main ( String [] args ) { double sommaIniziale = 0 ; double sommaFinale = 0 ; double percentualeInteresse = 0 ; int anniDeposito = 0 ; sommaIniziale = leggiDouble ( \"Inserisci la somma iniziale: \" , 100 , 1000 ); percentualeInteresse = leggiDouble ( \"Inserisci la percentuale di interesse: \" , 1 , 5 ); System . out . println ( \"---\" ); System . out . println ( \"Somma Iniziale: \" + sommaIniziale ); System . out . println ( \"Percentuale di interesse: \" + percentualeInteresse ); System . out . println ( \"---\" ); } } Lezione 40 Buffered reader Vs Scanner Sono differenza perlopi\u00f9 dal punto di vista hardware. BufferedReader : - E' una struttura meno sempplice - legge qualsiasi tipo di dato - thread safe Scanner : - \u00e8 una struttura pi\u00f9 semplice - non \u00e8 thread safe Vediamo lo stesso esempio utilizzando la classe Scanner package mioTest ; import java.io.* ; import java.util.InputMismatchException ; import java.util.Scanner ; public class prova01 { static double leggiDouble ( String mainMessage , double minValue , double maxValue ) { Scanner sc = new Scanner ( System . in ); String formatErrorMessage = \"Formato non corretto! Riprova..\" ; String rangeErrorMessage = \"Valore non appartenente al range: \" ; double doubleLetto = 0 ; double risultato = 0 ; boolean error = false ; do { error = false ; try { System . out . println ( mainMessage ); doubleLetto = sc . nextDouble (); } catch ( InputMismatchException e ) { error = true ; System . out . println ( formatErrorMessage ); //Necessario perch\u00e8 il metodo nextDouble() non toglie il dato dalla tatiera //Al ciclo successivo quindi se c'\u00e8 un errore andrebbe a rileggerlo e continuerebbe cos\u00ec all'infinito //nextLine() scarta il dato memorizzato leggendo la prossima linea sc . nextLine (); continue ; } if ( ( doubleLetto < minValue ) || ( doubleLetto > maxValue ) ) { error = true ; System . out . println ( rangeErrorMessage + '[' + minValue + \" - \" + maxValue + ']' ); continue ; } else { risultato = doubleLetto ; } } while ( error ); return risultato ; } public static void main ( String [] args ) { double sommaIniziale = 0 ; double sommaFinale = 0 ; double percentualeInteresse = 0 ; int anniDeposito = 0 ; sommaIniziale = leggiDouble ( \"Inserisci la somma iniziale: \" , 100 , 1000 ); percentualeInteresse = leggiDouble ( \"Inserisci la percentuale di interesse: \" , 1 , 5 ); System . out . println ( \"---\" ); System . out . println ( \"Somma Iniziale: \" + sommaIniziale ); System . out . println ( \"Percentuale di interesse: \" + percentualeInteresse ); System . out . println ( \"---\" ); } } La classe Scanner ha anche altri metodi molto ultili sulla lettura dei dati. Vediamo un esmpio. package mioTest ; import java.io.* ; import java.util.InputMismatchException ; import java.util.Scanner ; public class prova01 { static double leggiDouble ( String mainMessage , double minValue , double maxValue ) { Scanner sc = new Scanner ( System . in ); String formatErrorMessage = \"Formato non corretto! Riprova..\" ; String rangeErrorMessage = \"Valore non appartenente al range: \" ; double doubleLetto = 0 ; double risultato = 0 ; boolean error = false ; do { error = false ; System . out . println ( mainMessage ); if ( sc . hasNextDouble () ) { doubleLetto = sc . nextDouble (); } else { System . out . println ( formatErrorMessage ); error = true ; sc . nextLine (); continue ; } if ( ( doubleLetto < minValue ) || ( doubleLetto > maxValue ) ) { error = true ; System . out . println ( rangeErrorMessage + '[' + minValue + \" - \" + maxValue + ']' ); continue ; } else { risultato = doubleLetto ; } } while ( error ); return risultato ; } public static void main ( String [] args ) { double sommaIniziale = 0 ; double sommaFinale = 0 ; double percentualeInteresse = 0 ; int anniDeposito = 0 ; sommaIniziale = leggiDouble ( \"Inserisci la somma iniziale: \" , 100 , 1000 ); percentualeInteresse = leggiDouble ( \"Inserisci la percentuale di interesse: \" , 1 , 5 ); System . out . println ( \"---\" ); System . out . println ( \"Somma Iniziale: \" + sommaIniziale ); System . out . println ( \"Percentuale di interesse: \" + percentualeInteresse ); System . out . println ( \"---\" ); } } Metodo alternativo: In questo metodo alternativo per\u00f2 c'\u00e8 un bug! Il bug \u00e8 che inserendo parole spezzate dallo spazio genera degli errori..... package mioTest ; import java.io.* ; import java.util.InputMismatchException ; import java.util.Scanner ; public class prova01 { static double leggiDouble ( String mainMessage , double minValue , double maxValue ) { Scanner sc = new Scanner ( System . in ); String formatErrorMessage = \"Formato non corretto! Riprova..\" ; String rangeErrorMessage = \"Valore non appartenente al range: \" ; double doubleLetto = 0 ; double risultato = 0 ; boolean error = false ; do { error = false ; System . out . println ( mainMessage ); //Comtrollo Errore di formato while ( ! sc . hasNextDouble () ) { System . out . println ( formatErrorMessage ); sc . nextLine (); } //Passato il controllo del formato doubleLetto = sc . nextDouble (); //Controllo Range if ( ( doubleLetto < minValue ) || ( doubleLetto > maxValue ) ) { error = true ; System . out . println ( rangeErrorMessage + '[' + minValue + \" - \" + maxValue + ']' ); } else { risultato = doubleLetto ; } } while ( error ); return risultato ; } public static void main ( String [] args ) { double sommaIniziale = 0 ; double sommaFinale = 0 ; double percentualeInteresse = 0 ; int anniDeposito = 0 ; sommaIniziale = leggiDouble ( \"Inserisci la somma iniziale: \" , 100 , 1000 ); percentualeInteresse = leggiDouble ( \"Inserisci la percentuale di interesse: \" , 1 , 5 ); System . out . println ( \"---\" ); System . out . println ( \"Somma Iniziale: \" + sommaIniziale ); System . out . println ( \"Percentuale di interesse: \" + percentualeInteresse ); System . out . println ( \"---\" ); } } Lezione 41 Regular expression Il metodo hasNext() permette l'inserimento di un RegEpr , un'espressione regolare cio\u00e8 un'espressione in grado di effettuare dei controlli sul flusso di dati ricevuti. package mioTest ; import java.util.Scanner ; public class prova01 { public static String leggiNumeroDiTelefono () { try ( Scanner sc = new Scanner ( System . in )) { System . out . print ( \"Inserisci un numero telefonico: \" ); while ( ! sc . hasNext ( \"[0-9]{3,4}\\\\-[0-9]{6,7}\" )) { System . out . println ( \"Formato errato! Riprova ...\" ); sc . hasNext (); } return sc . next (); } } public static void main ( String [] args ) { System . out . println ( leggiNumeroDiTelefono () ); } } L'espressione regolare: [0-9]{3,4}\\\\-[0-9]{6,7} controlla: - il numero deve iniziare con una serie di 3 o 4 cifre comprese nel range 0-9 - deve essere seguito dal simbolo - (il simbolo \\\\ \u00e8 un escape, serve solo per permettere di leggere il trattino - ) successivamente che il numero prosegua con un min - deve concludere con una serie di 6 o 7 cifre comprese nel range 0-9 Lezione 42 Esercizio calcolo interesse con input da tastiera parte 2 Ripartiamo con l'esercizio: package mioTest ; import java.io.* ; public class prova01 { static double leggiDouble ( String mainMessage , double minValue , double maxValue ) { InputStreamReader tastiera = new InputStreamReader ( System . in ); BufferedReader bufferedTastiera = new BufferedReader ( tastiera ); String rigaLetta = \"\" ; String formatErrorMessage = \"Formato non corretto! Riprova..\" ; String rangeErrorMessage = \"Valore non appartenente al range\" ; double doubleLetto = 0 ; double risultato = 0 ; boolean error = false ; do { error = false ; try { System . out . println ( mainMessage ); rigaLetta = bufferedTastiera . readLine (); doubleLetto = Double . parseDouble ( rigaLetta ); } catch ( IOException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } catch ( NumberFormatException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } if ( ( doubleLetto < minValue ) || ( doubleLetto > maxValue ) ) { error = true ; System . out . println ( rangeErrorMessage ); continue ; } else { risultato = doubleLetto ; } } while ( error ); return risultato ; } public static void main ( String [] args ) { double sommaIniziale = 0 ; double sommaFinale = 0 ; double percentualeInteresse = 0 ; int anniDeposito = 0 ; sommaIniziale = leggiDouble ( \"Inserisci la somma iniziale: \" , 100 , 1000 ); percentualeInteresse = leggiDouble ( \"Inserisci la percentuale di interesse: \" , 1 , 5 ); System . out . println ( \"---\" ); System . out . println ( \"Somma Iniziale: \" + sommaIniziale ); System . out . println ( \"Percentuale di interesse: \" + percentualeInteresse ); System . out . println ( \"---\" ); } } Concludo l'esercizio: package mioTest ; import java.io.* ; public class prova01 { static double leggiDouble ( String mainMessage , double minValue , double maxValue ) { InputStreamReader tastiera = new InputStreamReader ( System . in ); BufferedReader bufferedTastiera = new BufferedReader ( tastiera ); String rigaLetta = \"\" ; String formatErrorMessage = \"Formato non corretto! Riprova..\" ; String rangeErrorMessage = \"Valore non appartenente al range\" ; double doubleLetto = 0 ; double risultato = 0 ; boolean error = false ; do { error = false ; try { System . out . println ( mainMessage ); rigaLetta = bufferedTastiera . readLine (); doubleLetto = Double . parseDouble ( rigaLetta ); } catch ( IOException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } catch ( NumberFormatException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } if ( ( doubleLetto < minValue ) || ( doubleLetto > maxValue ) ) { error = true ; System . out . println ( rangeErrorMessage ); continue ; } else { risultato = doubleLetto ; } } while ( error ); return risultato ; } public static int leggiInt ( String mainMessage ) { InputStreamReader tastiera = new InputStreamReader ( System . in ); BufferedReader bufferedTastiera = new BufferedReader ( tastiera ); String rigaLetta = \"\" ; String formatErrorMessage = \"Formato non corretto! Riprova..\" ; int intLetto = 0 ; boolean error = false ; do { error = false ; try { System . out . println ( mainMessage ); rigaLetta = bufferedTastiera . readLine (); intLetto = Integer . parseInt ( rigaLetta ); } catch ( IOException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } catch ( NumberFormatException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } } while ( error ); return intLetto ; } public static void main ( String [] args ) { double sommaIniziale = 0 ; double sommaFinale = 0 ; double percentualeInteresse = 0 ; int anniDeposito = 0 ; sommaIniziale = leggiDouble ( \"Inserisci la somma iniziale: \" , 100 , 1000 ); percentualeInteresse = leggiDouble ( \"Inserisci la percentuale di interesse: \" , 1 , 5 ); anniDeposito = leggiInt ( \"Durata in anni del deposito: \" ); System . out . println ( \"---\" ); System . out . println ( \"Somma Iniziale: \" + sommaIniziale ); System . out . println ( \"Percentuale di interesse: \" + percentualeInteresse ); System . out . println ( \"Durata in anni del deposito: \" + anniDeposito ); System . out . println ( \"---\" ); sommaFinale = sommaIniziale ; while ( anniDeposito > 0 ) { sommaFinale = sommaFinale + sommaFinale / 100 * percentualeInteresse ; anniDeposito = anniDeposito - 1 ; } System . out . println ( \"Hai ora in banca: \" + sommaFinale + \" euro.\" ); System . out . println ( \"fine..\" ); } }","title":"Java - write once, run anywhere"},{"location":"java/java-basic-module/#java-write-once-run-anywhere","text":"Java - write once, run anywhere Lezione 01 Descrizione Principi JVM: Java Virtual Machine JRE: Java Runtime Environment JDK: Java Development Kit Lezione 02 Processo di compilazione Java Setup di Java Lezione 03 Primo programma - compilazione manuale Lezione 04 Installazione e setup di Eclipse Primo progetto con Eclipse Lezione 05 Introduzione alla OOP Classi, oggetti, metodi Lezione 06 Metodo Main Metodo print Qualche stampa Commenti Lezione 07 Qualche espressione aritmetica Lezione 08 Variabili Lezione 09 Esercizio - Calcolo dell'interesse annuo Lezione 10 Approfondimento sui tipi primitivi Lezione 11 Ancora sui numeri Lezione 12 Il tipo char Lezione 13 Il tipo boolean Lezione 14 Introduzione a String Lezione 15 Operatori Precedenza degli operatori Operatori Unari Operatori binari Lezione 16 Tra stringhe e caratteri. Lezione 17 E i boolean? Lezione 18 Numeri decimali Lezione 19 Espressioni miste Lezione 20 Numeri Esadecimali, ottali Costanti numeriche Sequenze di escape Lezione 21 Operatori di Assegnamento Lezione 22 Operatori Relazionali Lezione 23 Operatori Logici Lezione 24 Costrutto Condizionali If ... Else Lezione 25 Costrutto Switch Lezione 26 Leggere dati da tastiera Lezione 27 Costrutti Iterativi Ciclo while Lezione 28 Qualche esercizio Stampa somma esercizio base stampa somma esercizio avanzato Aggiunta di un controllo Lezione 28 Ciclo do ... while Lezione 29 - For loop Lezione 30 break e continue Lezione 31 Sottoprogrammi, Funzioni, Metodi Definizione di un metodo: Chiamata di un metodo: Lezione 32 due parole sui parametri Lezione 33 Return Lezione 34 Qualche approfondimento sui parametri Lezione 35 Array Lezione 36 Errori con gli array Lezione 37 Approfondimento Input tastiera Lezione 38 Costrutto try catch Lezione 39 Esercizio calcolo interesse con input da tastiera parte 1 Lezione 40 Buffered reader Vs Scanner Lezione 41 Regular expression Lezione 42 Esercizio calcolo interesse con input da tastiera parte 2","title":"Java - write once, run anywhere"},{"location":"java/java-basic-module/#lezione-01","text":"documentazione oracle In informatica Java \u00e8 un linguaggio di programmazione ad alto livello, orientato agli oggetti e a tipizzazione statica, che si appoggia sull'omonima piattaforma software di esecuzione, specificamente progettato per essere il pi\u00f9 possibile indipendente dalla piattaforma hardware di esecuzione (tramite compilazione in bytecode prima e interpretazione poi da parte di una JVM) (sebbene questa caratteristica comporti prestazioni in termini di computazione inferiori a quelle di linguaggi direttamente compilati come C e C++ ovvero dunque perfettamente adattati alla piattaforma hardware). Java - Wikipedia","title":"Lezione 01"},{"location":"java/java-basic-module/#descrizione","text":"Uno dei principi fondamentali del linguaggio \u00e8 espresso dal motto WORA (write once, run anywhere, ossia \"scrivi una volta, esegui ovunque\"): il codice compilato che viene eseguito su una piattaforma non deve essere ricompilato per essere eseguito su una piattaforma diversa; infatti il prodotto della compilazione \u00e8 in un formato chiamato bytecode che pu\u00f2 essere eseguito da una qualunque implementazione di un processore virtuale detto Java Virtual Machine; al 2014 Java risulta essere uno dei linguaggi di programmazione pi\u00f9 usati al mondo, specialmente per applicazioni client-server, con un numero di sviluppatori stimato intorno ai 9 milioni; un buon punto di partenza per imparare Java \u00e8 il tutorial ufficiale. Java - Wikipedia","title":"Descrizione"},{"location":"java/java-basic-module/#principi","text":"Java venne creato per soddisfare cinque obiettivi primari: 1. essere \"semplice, orientato agli oggetti e familiare\"; 2. essere \"robusto e sicuro\"; 3. essere indipendente dalla piattaforma; 4. contenere strumenti e librerie per il networking; 5. essere progettato per eseguire codice da sorgenti remote in modo sicuro. Java - Wikipedia","title":"Principi"},{"location":"java/java-basic-module/#jvm-java-virtual-machine","text":"In informatica la macchina virtuale Java (detta anche Java Virtual Machine o JVM) \u00e8 il componente software della piattaforma Java che esegue i programmi tradotti in bytecode dopo la prima fase di compilazione in bytecode (tra i linguaggi di programmazione che possono essere tradotti in bytecode troviamo Java, Groovy, Clojure, Scala ed Eta). I passi che devono essere fatti per eseguire un programma scritto in linguaggio Java sono i seguenti: Un programmatore usa un editor di testo o un integrated development environment come Eclipse, NetBeans o IntelliJ IDEA per scrivere una o pi\u00f9 classi Java Un software di compilazione trasforma il programma in bytecode, che \u00e8 una leggera astrazione del codice macchina Il bytecode viene fornito ad una macchina virtuale Java che lo esegue Il bytecode \u00e8 generalmente prodotto dalla compilazione di codici sorgenti (o file sorgenti) scritti in linguaggio Java, anche se \u00e8 possibile produrre bytecode partendo da altri linguaggi come Scala, Clojure o Groovy. La JVM \u00e8 definita da una specifica, mantenuta da Oracle. Qualsiasi sistema che si comporti in modo coerente con tale specifica viene considerato come una particolare implementazione della JVM. Esistono implementazioni software per praticamente tutti i sistemi operativi moderni, sia gratuite che commerciali. Inoltre, esistono implementazioni speciali per particolari ambienti hardware/software, come telefoni cellulari e palmari), e persino implementazioni hardware come Jazelle. La disponibilit\u00e0 di implementazioni della macchina virtuale Java per diversi ambienti operativi \u00e8 la chiave della portabilit\u00e0 di Java, proclamata nello slogan write once, run everywhere (\"scrivi una volta, esegui dappertutto\"). La macchina virtuale realizza infatti un ambiente di esecuzione omogeneo, che nasconde al software Java (e quindi al programmatore) qualsiasi specificit\u00e0 del sistema operativo sottostante JVM - Wikipedia","title":"JVM: Java Virtual Machine"},{"location":"java/java-basic-module/#jre-java-runtime-environment","text":"In quanto tale contiene la Java Virtual Machine, le librerie standard (API Java) e un launcher per le applicazioni Java, necessario per avviare i programmi scritti in linguaggio Java e gi\u00e0 compilati in bytecode; \u00e8 dunque necessario quando si hanno programmi scritti in Java forniti gi\u00e0 compilati in bytecode. Materialmente JRE \u00e8 un plugin per browser in quanto \u00e8 impiegato per applicazioni web che contengono componenti scritte in Java. Esso non costituisce un ambiente di sviluppo software e non contiene strumenti di sviluppo (compilatori e/o debugger): per poter sviluppare in Java a monte, a partire dal codice sorgente, \u00e8 necessario infatti il Java Development Kit (che tipicamente contiene anche il JRE), anch'esso distribuito gratuitamente dalla Sun. Molti IDE offrono inoltre la possibilit\u00e0 di agganciare (linkare) la JRE e poter cos\u00ec sviluppare i propri programmi coadiuvati dell'editor. Rilasciato in versione 32 bit e 64 bit, ad oggi, l'ultima versione della Java 2 Platform, Standard Edition Runtime Environment \u00e8 la versione 8: ogni versione ha molti aggiornamenti (detti anche build) che vengono rilasciati durante il periodo di sviluppo (ad es. JRE 6 \u00e8 arrivato sino all'aggiornamento 45, mentre JRE 7 all'aggiornamento 51; a maggio 2019 JRE versione 8 \u00e8 in aggiornamento 211 (rilasciata il 16 aprile 2019). JRE - Wikipedia","title":"JRE: Java Runtime Environment"},{"location":"java/java-basic-module/#jdk-java-development-kit","text":"In informatica il JDK (java development kit) \u00e8 l'insieme degli strumenti per sviluppare programmi da parte dei programmatori Java. \u00c8 un prodotto della Oracle Corporation, e fin dall'introduzione di Java \u00e8 sempre stato l'ambiente di sviluppo pi\u00f9 utilizzato dai programmatori Java soprattutto per applicazioni desktop. Per applicazioni pi\u00f9 complesse (es. applicazioni web) oggi sempre pi\u00f9 spesso si utilizzano per lo sviluppo ed esecuzione programmi IDE a cui \u00e8 possibile agganciare la JRE. JDK - Wikipedia","title":"JDK: Java Development Kit"},{"location":"java/java-basic-module/#lezione-02","text":"","title":"Lezione 02"},{"location":"java/java-basic-module/#processo-di-compilazione-java","text":"Il codice sorgente java .java per poter essere eseguito deve essere: 1. Tradotto in Bytecode , formato .class tramite il compilatore JavaC 2. Assemblato insieme alle librerie Java utilizzate (anch'esse in Bytecode) attraverso un Loader producendo un file Bytecode molto efficiente 3. Interpretato dall'interprete Java situato all'interno della Java Virtual Machine","title":"Processo di compilazione Java"},{"location":"java/java-basic-module/#setup-di-java","text":"Scarica la JDK per il tuo sistema operativo: Fai riferimento alla Java SE cio\u00e8 alla piattaforma Standard Edition . La Java EE \u00e8 la versione Enterprise \u00e8 pensata soprattutto per applicativi server. Installazione Ubuntu Per il sistema operativo Ubuntu dovrebbe gi\u00e0 essere installata una versione del java development kit. Da terminale digitando: java --version Puoi verificare la versione installata. Nel mio caso: openjdk 11 .0.9.1 2020 -11-04 OpenJDK Runtime Environment ( build 11 .0.9.1+1-Ubuntu-0ubuntu1.20.10 ) OpenJDK 64 -Bit Server VM ( build 11 .0.9.1+1-Ubuntu-0ubuntu1.20.10, mixed mode, sharing ) Puoi inoltre verificare la versione di javac il compilatore Java digitando da terminale: javac --version A questo punto la bash potrebbe non riconoscere il comando perch\u00e8 l'installazione del pacchetto JDK non \u00e8 globale. Comando \u00abjavac\u00bb non trovato, ma pu\u00f2 essere installato con: sudo apt install default-jdk # version 2:1.11-72, or sudo apt install openjdk-11-jdk-headless # version 11.0.9.1+1-0ubuntu1~20.10 sudo apt install ecj # version 3.16.0-1 sudo apt install openjdk-13-jdk-headless # version 13.0.4+8-1 sudo apt install openjdk-14-jdk-headless # version 14.0.2+12-1 sudo apt install openjdk-15-jdk-headless # version 15+36-1 sudo apt install openjdk-8-jdk-headless # version 8u275-b01-0ubuntu1~20.10 Puoi installare una versione globale e aggiornata del JDK seguendo la procedura descritta dal sito ufficiale scaricando il pacchetto .rpm oppure puoi digitare il comando per l'installazione della versione 15: sudo apt install openjdk-15-jdk-headless # version 15+36-1 A questo punto \u00e8 possibile verificare che sia stata installata la versione giusta con il comando: javac --version Che dovr\u00e0 rispondere con: 15 Inoltre, digitando nuovamente: java --version Troverete aggiornato anche il pacchetto JDK : openjdk 15 2020 -09-15 OpenJDK Runtime Environment ( build 15 +36-Ubuntu-1 ) OpenJDK 64 -Bit Server VM ( build 15 +36-Ubuntu-1, mixed mode, sharing ) Se ti sei confuso durante l'installazione delle versioni di java o ti sei reso contoc che hai bisogno di un'altra versione puoi eliminare tutto con il comando: sudo apt-get remove openjdk* A questo punto, i comandi java e javac non saranno riconosciuti da terminale e potrai procedere ad una nuova installazione Installazione Windows Scarica l'installer per windows Esegui la procedura di installazione guidata. Una volta installato il pacchetto JDK apri il prompt dei comandi cmd e digita: java -version Dovrebbe rispondere con la versione di Java del pacchetto JDK appena scaricata: java version \"15.0.1\" 2020-10-20 Java(TM) SE Runtime Environment (build 15.0.1+9-18) Java HotSpot(TM) 64-Bit Server VM (build 15.0.1+9-18, mixed mode, sharing) Verifica che sia raggiungibile da prompt dei comandi anche il compilatore Java, digitando: javac -version Se risponder\u00e0 con un output del tipo: javac 15.0.1 vuol dire che il setup \u00e8 terminato, altrimenti sar\u00e0 sufficiente aggiungere come variabile d'ambiente la directory bin all'interno della cartella di installazione di Java. Nel mio caso e probabilmente anche nel tuo (se hai installato la versione a 64 bit) si trova al percorso: C:\\Program Files\\Java\\jdk-15.0.1\\bin","title":"Setup di Java"},{"location":"java/java-basic-module/#lezione-03","text":"","title":"Lezione 03"},{"location":"java/java-basic-module/#primo-programma-compilazione-manuale","text":"Scrivi il seguente pezzo di codice in un file utilizzando un editor di testo come blocco note (windows) o gedit (linux) public class MioCalcolo { public static void main ( String [] args ){ System . out . print ( 5 + 3 ); } } Salva il file con nome MioCalcolo.java all'interno di una directory specifica, raggiungi la posizione da terminale e compila il file java digitando: javac MioCalcolo.java Il compilatore java compiler\u00e0 il sorgente MioCalcolo.java producendo un file MioCalcolo.class ovvero la traduzione del sorgente in bytecode. A questo punto digitando il comando: java MioCalcolo Verr\u00e0 eseguito il codice che produrr\u00e0 come risultato la stampa: 8","title":"Primo programma - compilazione manuale"},{"location":"java/java-basic-module/#lezione-04","text":"","title":"Lezione 04"},{"location":"java/java-basic-module/#installazione-e-setup-di-eclipse","text":"Per questo corso utilizzeremo Eclipse come IDE. Installazione Ubuntu Per installare Eclipse digita da terminale: sudo snap install --classic eclipse Poich\u00e8 abbiamo gi\u00e0 installato tutti i pacchetti necessari con la procedura descritta sopra, Eclipse li riconoscer\u00e0 e li utilizzer\u00e0. Installazione Windows Scarica Eclipse ed esegui l'installer. Una volta terminato il processo di installazione avrai gli strumenti necessari alla compilazione e debug del codice Java","title":"Installazione e setup di Eclipse"},{"location":"java/java-basic-module/#primo-progetto-con-eclipse","text":"Aprendo Eclipse, ti chieder\u00e0 di scegliere una workspace: Scegli una directory di lavoro e premi su Launch . Comparir\u00e0 adesso la finestra di selezione di un progetto. Clicca su Create a new Java Project Attenzione!! Su windows consiglio di spuntare Use default JRE 'jre' and workspace compiler preferences perch\u00e8 potrebbe andare in conflitto con le versioni di JRE installate globalmente su PC Scegli un nome del progetto ad esempio mioTest e premi su Finish Ti chieder\u00e0 infine se vuoi creare il file module-info.java , Per adesso premi su Don't Create Comparir\u00e0 finalmente la finestra principale di lavoro. A sinistra troverai il file explore del tuo ambiente di lavoro. Per creare un nuovo progetto clicca con il destro su src e scegli new/class Dai un nome al file, ad esempio prova01 e seleziona i flags come in figura. In particolare presta attenzione a selezionare public static void main(Strings[] args) . Premi su Finish . A questo punto sarai pronto per scrivere codice con un template impostato da Eclipse Per replicare il programmino precedente, compilato ed eseguito manualmente inserisci la linea di codice: System.out.print ( 5 + 3 ) ; All'interno del blocco pi\u00f9 interno delimitato dalle parentesi graffe. Il risultato finale sar\u00e0: package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . print ( 5 + 3 ); } } Compila ed esegui il codice con il tasto indicato dal simbolo PLAY Troverai il risultato stampato nella finestra della console:","title":"Primo progetto con Eclipse"},{"location":"java/java-basic-module/#lezione-05","text":"","title":"Lezione 05"},{"location":"java/java-basic-module/#introduzione-alla-oop","text":"Il codice gi\u00e0 compilato, sia con Eclipse che in modo manuale: package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . print ( 5 + 3 ); } } E' stato il nostro primo programma scritto in Java ma di fatto non comprendiamo granch\u00e8 di cio' che c'\u00e8 scritto. Intuiamo probabilmente che il codice stamper\u00e0 il risultato dell'operazione 5+3 poich\u00e8 riconosciamo il comando print il cui termine tecnico \u00e8 realt\u00e0 metodo derivato della programmazione OOP di Java (di cui parleremo approfonditamente alla fine del corso).","title":"Introduzione alla OOP"},{"location":"java/java-basic-module/#classi-oggetti-metodi","text":"Puoi pensare alla classe come a una grande famiglia un contenitore di oggetti omogenei tra loro e metodi . Tonando al codice, print non fa parte del nucleo delle istruzioni base di Java ma di una libreria esterna, una libreria di input output, situata all'interno della JRE System Library . Quindi in fase di compilazione, il compilatore fa uso anche di questa libreria per linkare tutti simboli che trova nel codice sorgente. La JRE System Library come per qualsiasi liberia pu\u00f2 essere considerata come un pachetto estensione estensione del linguaggio base Java chiamato package e contiente metodi, oggetti, classi. In generale ogni package deve essere incluso nel codice sorgente con il comando: import packageName Nel caso dell'importazione del comando ( classe ) System anch'esso non presente nel nucleo base delle istruzioni Java scriveremo: import java.lang.System ; In questo modo importeremo solo la classe System del package lang situato all'interno del package java Nota: il nome del package \u00e8 sempre in minuscolo, es: java , lang .. il nome della classe \u00e8 sempre maiuscolo, es: System .. nel caso della JRE System Library l'importazione \u00e8 automatica quindi non \u00e8 necessario specificare il comando di import . Nel caso di uso di una libreria esterna, invece dovremo inserire il comando di import specifico per quella libreria Se vuoi includere tutto il contenuto (tutte le classi, tutti gli oggetti e tutti i metodi) di un package puoi farlo utilizzando il carattere * al posto della specifica classe import java.lang.* ; //importa tutte le classi all'interno del package java.lang Tornando al codice, abbiamo capito che System \u00e8 una classe della libreria JRE System Library in particolare del package java.lang . Cosa sono quindi out e print ? package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . print ( 5 + 3 ); } } out \u00e8 un' oggetto contenuto all'interno della classe System cio\u00e8 un blocco di codice autoconsistente che forma, insieme agli altri oggetti la classe System . Considerazione Non badare troppo alla terminologia per adesso. Evita di soffermarti troppo sui concetti di classe , oggetto , metodo , li capirai pi\u00f9 avanti quando inizierai la OOP , la programmazione ad oggetti di Java. Per adesso \u00e8 sufficiente che tu ne abbia colto le differenze \u00e8 che tu sappia identificare una classe, da un oggetto o da un metodo. La classe si riconosce perch\u00e8 \u00e8 sempre sicritta con la prima lettera in maiuscolo. Un oggetto si riconosce perch\u00e8 \u00e8 sempre situato all'interno di una classe e un metodo si riconosce perch\u00e8 \u00e8 l'ultimo pezzo, cio\u00e8 il comando da eseguire e fa riferimento al contesto dell'oggetto Infine.. Il metodo pu\u00f2 ricevere, come nel caso di print , dei parametri. Posso passare delle stringhe testuali, dei calcoli e una quantit\u00e0 di dati prevista dal metodo.\u00f9","title":"Classi, oggetti, metodi"},{"location":"java/java-basic-module/#lezione-06","text":"","title":"Lezione 06"},{"location":"java/java-basic-module/#metodo-main","text":"Partendo sempre dal codice: package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . print ( 5 + 3 ); } } Analizziamo adesso il metodo main public static void main ( String [] args ) { System . out . print ( 5 + 3 ); } main \u00e8 il metodo principale che cerca e richiama Java quando manda in esecuzione un codice sorgente java. In sostanza Java eseguir\u00e0 tutto il codice contenuto all'interno di public static void main ( String [] args ) { //code }","title":"Metodo Main"},{"location":"java/java-basic-module/#metodo-print","text":"Come abbiamo gi\u00e0 detto, il metodo print pu\u00f2 ricevere in ingresso una quantit\u00e0 pi\u00f9 o meno vasta di dati. Possiamo aiutarci con l'autocompletamento di Eclipse, Ctrl + space Vedremo in dettaglio tutti i tipi di dato pi\u00f9 avanti","title":"Metodo print"},{"location":"java/java-basic-module/#qualche-stampa","text":"Il seguente esempio mostra la differenza tra il metodo print() e il metodo println . Stamperemo inoltre stringhe, espressioni numeriche ed espressioni miste. Alcune regole: print() stampa inline println() stampa e va a capo Se il metodo print() riceve un'espressione numerica, questa viene prima valutata poi convertita in una stringa per la stampa. operatore + : funge da concatenatore di stringhe se gli operandi sono delle stringhe e da operatore somma se gli operandi sono dei numeri. In caso di espressioni miste \u00e8 possibile utilizzare le parentesi tonde ( ) per forzare la precedenza dell'operatore + package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . print ( 1 + 1 ); //stampa inline del risultato dell'espressione System . out . println ( \"ciao\" ); //stampa \"ciao\" e va a capo System . out . println ( \"a tutti\" ); //stampa \"a tuti\" e va a capo /* System.out.println(\"Il risultato \u00e8: \" + (1+1)); - valuta prima il risultato dell'espressione 1+1, - lo converte in stringa e quindi diventa \"2\" - lo concatena a \"Il risultato \u00e8: \" - produce: \"Il risultato \u00e8: 2\" */ System . out . println ( \"Il risultato \u00e8: \" + ( 1 + 1 )); } } /* output 2ciao a tutti Il risultato \u00e8: 2 */","title":"Qualche stampa"},{"location":"java/java-basic-module/#commenti","text":"I commenti sono linee testuali ignorate dal compilatore e possono essere utili al programmatore per documentare alcune linee di codice. In java ci suo due tipi di commenti gi\u00e0 visti negli esempi precedenti: // text : per commenti inline /* text */ : per commenti multiline package mioTest ; public class prova01 { public static void main ( String [] args ) { /* commento multiline System.out.println(\"Ciao\"); */ System . out . println ( \"Ciao\" ); //commento inline } }","title":"Commenti"},{"location":"java/java-basic-module/#lezione-07","text":"","title":"Lezione 07"},{"location":"java/java-basic-module/#qualche-espressione-aritmetica","text":"Riporto i principali operatori matematici e il calcolo qualche espressione aritmetica. Alcune considerazioni: Posso valutare espressioni con operandi misti, numeri interi e numeri decimali. In questo caso i numeri interi vengono convertiti in decimali e valutata l'espressione restituendo sempre un numero decimale. L'operatore / rappresenta la divisione ma: calcola il modulo della divisione intera quando gli operandi sono interi la divisione decimale quando almeno un operando \u00e8 decimale effettuando prima una conversione implicita di tutti gli operandi interi in decimale L'operatore % restituisce il resto della divisione intera e ha senso quando gli operandi sono interi Le parentesi ( ) possono essere utilizzate per forzare la precedenza tra le operazioni, come in matematica package mioTest ; public class prova01 { public static void main ( String [] args ) { //Somme e sottrazioni di numeri interi e decimali System . out . println ( 1 - 1.41 ); //-0.4099999999999999 //Moltiplicazione System . out . println ( 3 * 6.5 ); //19.5 //Divisione //Se gli operandi sono numeri interi //viene calcolato il modulo della divisione intera System . out . println ( 12 / 3 ); //4 System . out . println ( 12 / 5 ); //2 //Se almeno un operando \u00e8 decimale //vengono convertiti tutti gli operandi in decimale ed effettuata la divisione decimale System . out . println ( 12 / 5.0 ); //2.4 System . out . println ( 12 / 3.0 ); //4.0 //Resto della divisione intera System . out . println ( 12 % 3 ); //0 System . out . println ( 12 % 7 ); //5 //Le parentesi (), come in matematica, possono essere utilizzate per forzare la precedenza. System . out . println ( (( 5 + 4 ) * 9 ) + 7 ); //88 } }","title":"Qualche espressione aritmetica"},{"location":"java/java-basic-module/#lezione-08","text":"","title":"Lezione 08"},{"location":"java/java-basic-module/#variabili","text":"Le variabili sono contenitori utilizzati per la memorizzazione dei dati. In java, ad ogni contenitore (quindi ad ogni variabile) deve essere associato il tipo cio\u00e8 deve essere dichiarato a priori quale tipo di dato potr\u00e0 contenere il contenitore I tipi nativi o predefiniti del linguaggio Java sono: Tipo Dimensione Descrizione char 2 byte Utilizzato per la memorizzazione di singoli caratteri come a , B int 4 byte Utilizzato per la memorizzazione di numeri interi come 12 -4 nel range [-2,147,483,648 to 2,147,483,647] short 2 byte Utilizzato per la memorizzazione di numeri interi come 12 -4 nel range [-32,768 to 32,767] long 8 byte Utilizzato per la memorizzazione di numeri interi come 12124L -49825L nel range [-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807]. E' buona norma associare il simbolo L alla fine del valore per forzare la rappresentazione su 8 byte float 4 bytes Utilizzato per la memorizzazione di numeri decimali come 12.6f fino a 7 digits dopo la virgola cio\u00e8 7 cifre considerabili esatte dopo la virgola. E' buona norma associare il simbolo f o F al termine del valore float double 8 byte Utilizzato per la memorizzazione di numeri decimali come 12.9876d fino a 15 digits dopo la virgola cio\u00e8 15 cifre considerabili esatte dopo la virgola. E' buona norma associare il simbolo d al termine del valore double per forzare la rappresentazione con un'accuratezza di 15 digits dopo la virgola byte 8 byte Utilizzato per la memorizzazione di numeri nel range [-128 to 127] boolean 1 bit Utilizzato per la memorizzazione di dati booleani, un tipo di dato particolare e molto importante nella programmazione che pu\u00f2 assumere solo due stati, true o false Per un approfondimento visita w3schools.com - Java Variables e w3schools.com - Java Data Types Una variabile, per poter essre utilizzata, deve essere prima dichiarata , dopodich\u00e8 l' identificatore cio\u00e8 il nome della variabile potr\u00e0 essere utilizzato nel codice come sostitutivo del suo valore. Non confondere le variabili, o meglio gli identificatori di variabili, con le costanti letterali che invece sono espressioni numeriche o letterali appunto costanti. Dichiarazione di una variabile Sintassi: type identificatore = value package mioTest ; public class prova01 { public static void main ( String [] args ) { //dichiarazione double piGreco = 3.14 ; //uso System . out . println ( \"pi greco vale: \" + piGreco ); } } /* outout --- pi greco vale: 3.14 */ Nell'esempio, double \u00e8 il tipo, piGreco \u00e8 l'identificatore della variabile mentre 3.14 \u00e8 il suo valore espresso come costante letterale numerica. Allo stesso modo \"pi greco vale: \" \u00e8 una costante letterale. Puoi dichiarare pi\u00f9 variabili dello stesso tipo utilizzando separando gli identificatori con la virgola , che in programamzione rappresenta sempre un operatore di separazione. int a = 1 , b = 12 , c ; Nell'esempio ho dichiarato tre variabili intere a , b , c . Il valore della variabile c non \u00e8 ancora espresso, si dice in questo caso che la variabile \u00e8 dichiarata ma non inizializzata Nota : E' sempre bene inizializzare sempre ogni variabile dichiarata poich\u00e8 l'utilizzo di tale variabile nel codice produce un errore di compilazione package mioTest ; public class prova01 { public static void main ( String [] args ) { //dichiarazione double piGreco = 3.14 , area , circonferenza , raggio ; area = piGreco * ( raggio * raggio ); System . out . println ( area ); } } /* output ------ Exception in thread \"main\" java.lang.Error: Unresolved compilation problems: The local variable raggio may not have been initialized The local variable raggio may not have been initialized at mioTest.prova01.main(prova01.java:9) */ Il messaggio \u00e8 chiaro The local variable raggio may not have been initialized . La variabile raggio non \u00e8 stata inizializzata. Attenzione!! Il solo problema \u00e8 la variabile raggio poich\u00e8 \u00e8 in lettura . Infatti, sebbene sia circonferenza che area siano variabili non inizializzate, circonferenza non \u00e8 di fatto mai utilizzata quindi non pu\u00f2 generare nessun tipo di errore mentre area \u00e8 utilizzata in scrittura ed \u00e8 logicamente previsto non inizializzare delle variabili per assegnar loro un valore successivo. A dimostrazione di quanto detto riporto l'esempio di prima assegnando un valore solo alla variabile raggio package mioTest ; public class prova01 { public static void main ( String [] args ) { //dichiarazione double piGreco = 3.14 , area , circonferenza , raggio = 2 ; area = piGreco * ( raggio * raggio ); System . out . println ( area ); //12.56 } } In generale comunque, per evitare confusione, conviene sempre inizializzare tutte le variabili al momento della dichiarazione Naming conventions Per la dichiarazione di una variabile puoi usare lettere maiuscole o minuscole seguite da caratteri numerici o il carattere underline, _","title":"Variabili"},{"location":"java/java-basic-module/#lezione-09","text":"","title":"Lezione 09"},{"location":"java/java-basic-module/#esercizio-calcolo-dellinteresse-annuo","text":"Il seguente esercizio, in base ad un valore di somma depositata in euro e un tasso percentuale annuo, restituisce il valore della somma depositata dopo un anno in base al tasso di interesse stabilito package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Percentuale di interesse: 2.5%\" ); System . out . println ( \"Somma depositata: 1000 euro\" ); System . out . println ( \"---\" ); double percentualeInteresse = 2.5 ; //percentuale di interesse annuo\u00f9 double sommaDepositata = 1000 ; //in euro //dopo un anno sommaDepositata = sommaDepositata * ( 1 + percentualeInteresse / 100 ); System . out . println ( \"Dopo un anno avrai: \" + sommaDepositata + \"euro\" ); } } /* output --- Percentuale di interesse: 2.5% Somma depositata: 1000 euro --- Dopo un anno avrai: 1025.0euro */","title":"Esercizio - Calcolo dell'interesse annuo"},{"location":"java/java-basic-module/#lezione-10","text":"","title":"Lezione 10"},{"location":"java/java-basic-module/#approfondimento-sui-tipi-primitivi","text":"Questa \u00e8 una sezione di approfondimento per i tipi primitivi di Java. Riporto la tabella gi\u00e0 vista qualche lezione precedente Tipo Dimensione Descrizione char 2 byte Utilizzato per la memorizzazione di singoli caratteri come a , B int 4 byte Utilizzato per la memorizzazione di numeri interi come 12 -4 nel range [-2,147,483,648 to 2,147,483,647] short 2 byte Utilizzato per la memorizzazione di numeri interi come 12 -4 nel range [-32,768 to 32,767] long 8 byte Utilizzato per la memorizzazione di numeri interi come 12124L -49825L nel range [-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807]. E' buona norma associare il simbolo L alla fine del valore per forzare la rappresentazione su 8 byte float 4 bytes Utilizzato per la memorizzazione di numeri decimali come 12.6f fino a 7 digits dopo la virgola. E' buona norma associare il simbolo f o F al termine del valore float double 8 byte Utilizzato per la memorizzazione di numeri decimali come 12.9876d fino a 15 digits dopo la virgola. E' buona norma associare il simbolo d al termine del valore double per forzare la rappresentazione con un'accuratezza di 15 digits dopo la virgola byte 8 byte Utilizzato per la memorizzazione di numeri nel range [-128 to 127] boolean 1 bit Utilizzato per la memorizzazione di dati booleani, un tipo di dato particolare e molto importante nella programmazione che pu\u00f2 assumere solo due stati, true o false Alcune considerazione: Di default le costanti numeriche intere sono considerate di tipo int quindi sono rappresentate su 4 byte. Per rappresentare una costante numerica intera pi\u00f9 piccola del tipo int come short o byte \u00e8 possibile forzare una conversione esplicita tramite l'operatore cast (short) o (byte) . Per rappresentare una costante numerica intera pi\u00f9 grande del tipo int come long \u00e8 possibile aggiungere il suffisso L o forzare una conversione esplicita con l'operatore cast (long) Di default le costanti numeriche decimali sono rappresentate con il tipo double quindi con un'accuratezza di 15 digits dopo la virgola. Per rappresentare una costante decimale pi\u00f9 piccola con il tipo float \u00e8 sufficiente inserire il suffisso f o F oppure forzare una conversione esplicita con l'operatore cast Vediamo un esempio concreto: package mioTest ; public class prova01 { public static void main ( String [] args ) { //dichiarazione //interi int valueInt1 = 217437 ; short valueInt2 = 2341 ; long valueInt3 = 23414246L ; byte valueInt4 = 67 ; //decimali float valueDec1 = 12.4F ; double valueDec2 = 3425.876 ; //cast //conversione implicita da \"byte\" >>> \"long\" long ris1 = valueInt3 + valueInt4 ; System . out . println ( ris1 ); //23414313 //conversione esplicita in \"short\" necessaria poich\u00e8 la conversione implicita //convertirebbe automaticamente valueInt2 da \"short\" a \"int\" //producendo un risultato con un estensione maggiore //di quella in grado di contenere la variabile ris2 anch'essa \"short\" short ris2 = ( short )( valueInt2 - valueInt1 ); System . out . println ( ris2 ); //-18488 //conversione esplicita in \"float\" necessaria poich\u00e8 la conversione implicita //convertirebbe automaticamente valueDec1 da \"float\" a \"double\" //producendo un risultato con un estensione maggiore //di quella in grado di contenere la variabile ris3 anch'essa \"float\" float ris3 = ( float )( valueDec2 / valueDec1 ); System . out . println ( ris3 ); //276.28033 } } Vediamo un controesempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //dichiarazione long valueInt3 = 23414246L ; byte valueInt4 = 67 ; //Attenzione!!! byte ris1 = valueInt3 + valueInt4 ; System . out . println ( ris1 ); // } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: Type mismatch: cannot convert from long to byte at mioTest.prova01.main(prova01.java:18) */ L'errore \u00e8, anche in questo caso, chiaro: Type mismatch: cannot convert from long to byte cio\u00e8 non \u00e8 possibile convertire un long in byte . Forzando la conversione esplicita del tipo long in tipo byte tutto funzioner\u00e0 ma che risultato oterrai? package mioTest ; public class prova01 { public static void main ( String [] args ) { //dichiarazione //interi int valueInt1 = 217437 ; short valueInt2 = 2341 ; long valueInt3 = 23414246L ; byte valueInt4 = 67 ; //Attenzione!!! byte ris1 = ( byte )( valueInt3 + valueInt4 ); System . out . println ( ris1 ); //41 } } Attenzione: Quando utilizzi i cast, hai la responsabilit\u00e0 di garantire, durante il troncamento, che non si perda l'informazione. Dovrai quindi effettuare i cast consapevolmente sempre.","title":"Approfondimento sui tipi primitivi"},{"location":"java/java-basic-module/#lezione-11","text":"","title":"Lezione 11"},{"location":"java/java-basic-module/#ancora-sui-numeri","text":"I tipi sopra citati int , double , float .. sono tipi predefiniti del linguaggio. Esiste tuttavia, per ogni tipo, una classe Java associata di cui \u00e8 possibile, come ad ogni classe ricavarne propriet\u00e0 , instanziare oggetti ed applicare metodi . Non approfondir\u00f2 l'argomento qua ma vorrei riportarti come sia facile ricavare il range numerico possibile per ogni tipo. Eclipse ti aiuta con l'autocompletamento Ctrl + space . Nel caso della classe Float , suggerisce varie opzioni: Nel seguente esempio mander\u00f2 in stampa il range numerico di alcuni tipi di dato facendo uso di alcune propriet\u00e0 delle classi Integer , Long , Byte , Double . package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //Integer int maxValueInteger = Integer . MAX_VALUE ; int minValueInteger = Integer . MIN_VALUE ; System . out . println ( \"Max Value Integer: \" + maxValueInteger ); System . out . println ( \"Min Value Integer: \" + minValueInteger ); System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //Byte byte maxValueByte = Byte . MAX_VALUE ; byte minValueByte = Byte . MIN_VALUE ; System . out . println ( \"Max Value Byte: \" + maxValueByte ); System . out . println ( \"Min Value Byte: \" + minValueByte ); System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //Long long maxValueLong = Long . MAX_VALUE ; long minValueLong = Long . MIN_VALUE ; System . out . println ( \"Max Value Long: \" + maxValueLong ); System . out . println ( \"Min Value Long: \" + minValueLong ); System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //Per la classe Double e Float, la proprier\u00e0 MIN_VALUE corrisponde al valore pi\u00f9 vicino a 0 double maxValuePositivoDouble = Double . MAX_VALUE ; double maxValueNegativoDouble = - Double . MAX_VALUE ; double minValueDouble = Double . MIN_VALUE ; System . out . println ( \"Max Value Positivo Double: \" + maxValuePositivoDouble ); System . out . println ( \"Max Value Negativo Double: \" + maxValueNegativoDouble ); System . out . println ( \"Min Value Double: \" + minValueDouble ); } } /* output --- --- --- --- --- --- --- --- --- --- --- Max Value Integer: 2147483647 Min Value Integer: -2147483648 --- --- --- --- --- --- --- --- --- --- --- Max Value Byte: 127 Min Value Byte: -128 --- --- --- --- --- --- --- --- --- --- --- Max Value Long: 9223372036854775807 Min Value Long: -9223372036854775808 --- --- --- --- --- --- --- --- --- --- --- Max Value Positivo Double: 1.7976931348623157E308 Max Value Negativo Double: -1.7976931348623157E308 Min Value Double: 4.9E-324 */ Osservazione: Ti faccio notare come le propriet\u00e0 delle classi siano scritte in maiuscolo e senza le parentesi tonde () finali tipiche di un metodo","title":"Ancora sui numeri"},{"location":"java/java-basic-module/#lezione-12","text":"","title":"Lezione 12"},{"location":"java/java-basic-module/#il-tipo-char","text":"Il tipo char \u00e8 un tipo nativo Java che si estende su 1 byte. La rappresentazione di un carattere in memoria segue la tabella ASCII estesa. Ogni carattere \u00e8 rappresentato da una sequenza di bit, identificata da un intero su 8 bit. Vista la dualit\u00e0 tra numeri interi e caratteri \u00e8 possibile: usare numeri interi su 8bit [0 - 255] per rappresentare un carattere secondo la codifica ASCII estesa usare un carattere per rappresentare un intero usare gli operatori di somma e sottrazione package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //char char c1 = 'a' ; char c2 = '#' ; System . out . println ( c1 ); System . out . println ( c2 ); System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //carattere relativo al codice della tabella ASCII: 65 >>> 'A' char c3 = 65 ; System . out . println ( c3 ); System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); //anche gli interi possono usare i caratteri come costanti numeriche int i = 100 + 'A' ; System . out . println ( i ); System . out . println ( \"--- --- --- --- --- --- --- --- --- --- ---\" ); } } /* output --- --- --- --- --- --- --- --- --- --- --- a # --- --- --- --- --- --- --- --- --- --- --- A --- --- --- --- --- --- --- --- --- --- --- 165 --- --- --- --- --- --- --- --- --- --- --- */","title":"Il tipo char"},{"location":"java/java-basic-module/#lezione-13","text":"","title":"Lezione 13"},{"location":"java/java-basic-module/#il-tipo-boolean","text":"Il concetto di valore booleano o logica booleana sta alla base di ogni linguaggio di programmazione. Il controllo del flusso di operazioni e di istruzioni \u00e8 dettato proprio da questo tipo di logica. Se gi\u00e0 conosci vagamente almeno un linguaggio di programmazione sai di cosa sto parlando, se non \u00e8 cos\u00ec sappi che capirai a fondo questo concetto a breve quando parleremo di costrutti condizionali e iterativi. Un variabile booleano pu\u00f2 assumere solo due valori: true / false . Posso utilizzare anche delle espressioni contenenti una condizione da verificare, le quali verranno sempre tradotte in true / false , qualche esempio: 3 == 3 : true 'A' == 'a' : false (4 - 1) < 4 : true package mioTest ; public class prova01 { public static void main ( String [] args ) { //boolean - George Boole boolean myBool = true ; //valuta l'espressione logica restituendo true/false boolean myBool2 = 5 < 3 ; System . out . println ( myBool ); System . out . println ( myBool2 ); } } /* output true false */","title":"Il tipo boolean"},{"location":"java/java-basic-module/#lezione-14","text":"","title":"Lezione 14"},{"location":"java/java-basic-module/#introduzione-a-string","text":"String non \u00e8 un tipo primitivo ma \u00e8 una classe. Approfondiremo meglio questa particolare classe pi\u00f9 avanti, per adesso ti basta sapere che in quanto classe posso creare delle istanze ovvero degli elementi che hanno come modello la classe String ed applicar loro dei metodi o ricavarne propriet\u00e0 . Un metodo \u00e8 una funzione che svolge un compito ben preciso solo una determinata classe, una propriet\u00e0 \u00e8 solo un valore caratteristico di quella classe. Nell'esempio seguente instanzio un oggetto di tipo String di nome cognome ed applico i metodi : endsWith(param) : Ritorna un boolean: true se l'oggetto stringa a cui si applica questo metodo termina con la stringa indicata come parametro param lenght() : Ritorna un valore intero corrsipondente alla lunghezza dell'oggetto stringa a cui si applica questo metodo package mioTest ; public class prova01 { public static void main ( String [] args ) { //String String cognome = \"Di Ricco\" ; System . out . println ( cognome ); //Metodo \"endsWith()\" System . out . println ( cognome . endsWith ( \"co\" )); //Metodo \"lenght()\" System . out . println ( cognome . length ()); //Attenzione String lettera = \"a\" ; } } /* Di Ricco true 8 */","title":"Introduzione a String"},{"location":"java/java-basic-module/#lezione-15","text":"","title":"Lezione 15"},{"location":"java/java-basic-module/#operatori","text":"Gli operatori si possono classificare per numero di operandi e si parla quindi di operatori: Unari : Operano con un solo operando Binari : Operano con due operandi Ternari : Operano con tre operandi Inoltre, possono essere classificati in base alla posizione dell'operatore rispetto gli operandi e quindi si parla di operatori: post-fissi : Se l'operatore \u00e8 posto dopo l'operando in-fisso : Se l'operatore \u00e8 posto tra gli operandi pre-fisso : Se l'operatore \u00e8 posto prima l'operando Qualche esempio: / , + , - , * , % : qualche semplice operatore aritmetico ++ , -- : operatori di incremento/decremento. Si applicano SOLO a variabili e non a costanti letterali. Si distinguono ulteriormente in: Post-incremento/decremento : L'operatore \u00e8 post-fisso . Prima assegna il valore poi incrementa Pre-incremento/decremento : L'operatore \u00e8 pre-fisso . Prima incrementa poi assegna Vediamo qualche esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //L' operatore \"-\" nel seguente caso \u00e8 un operatore unario, prefisso int a = - 5 ; //L' operatore \"-\" nel seguente caso \u00e8 un operatore binario, infisso int b = 12 - 5 ; //Pre-Incremento: Prima incrementa poi assegna System . out . println ( ++ a ); // -4 //Post-Incremento: Prima assegna poi incrementa System . out . println ( a -- ); // -4 System . out . println ( a ); // -5 //Dualit\u00e0 tra i caratteri / interi char c1 = 'A' ; char c2 = ++ c1 ; System . out . println ( c2 ); // B } }","title":"Operatori"},{"location":"java/java-basic-module/#precedenza-degli-operatori","text":"In un espressione aritmetica o logica contenete diversi operatori, valgono regole simili alla matematica. In particolare, se \u00e8 vero che in matematica certi operatori hanno la precedenza su altri, sappiamo infatti che le moltiplicazioni e divisioni vengono valutate prima delle somme e sottrazioni, \u00e8 vero anche per la maggior parte dei linguaggi di programmazione. Inoltre rimane vera la propriet\u00e0 che per forzare precedenza \u00e8 possibile usare le parentesi ma sono valide, in informatica, solo quelle tonde () . Qui sotto ti lascio comunque un link che puoi consultare della tabella delle precedenza degli operatori in Java Oracle - Operators","title":"Precedenza degli operatori"},{"location":"java/java-basic-module/#operatori-unari","text":"! : operatore not , negazione logica package mioTest ; public class prova01 { public static void main ( String [] args ) { int eta = 17 ; boolean maggiorenne = ( eta > 18 ); System . out . println ( \"E' maggiorenne: \" + maggiorenne ); System . out . println ( \"Non e' maggiorenne: \" + ! maggiorenne ); } } /* outputf E' maggiorenne: false Non e' maggiorenne: true */ ~ negazione (complemento) bit a bit, negazione bitwise package mioTest ; public class prova01 { public static void main ( String [] args ) { //negazione bit a bit ~ //33 = 0001 0001 int myVar = 33 ; System . out . print ( ~ myVar ); //-34, 1110 1110 } }","title":"Operatori Unari"},{"location":"java/java-basic-module/#operatori-binari","text":"Qualche operazione aritmetica tra numeri interi. A causa del range limitato dei numeri di tipo Integer , non sempre va come ce lo aspettiamo.. package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari int i1 = 0 , i2 = 0 , i3 = 0 , i4 = 0 ; //Somme semplici a due operandi i1 = 5 + 3 ; i2 = 6 + i1 ; i3 = i1 + i2 ; i2 = 3 + 4 + 9 + 10 ; i2 = ( 12 + 6 ) * 2 * ( i3 - ( i4 / 5 )); //Supera ampiamente la capacit\u00e0 del range [int] //Non viene fatto nesssun controllo a runtime o in fase di compilazione Java //questi controlli deve farli il programmatore! i1 = 1000 * 1000 * 1000 * 1000 ; System . out . print ( i1 ); //-727379968 } } Attenzione: L'operatore / se applicato a operandi interi restituisce sempre il risultato della divisione intera, detto anche modulo o quoziente","title":"Operatori binari"},{"location":"java/java-basic-module/#lezione-16","text":"","title":"Lezione 16"},{"location":"java/java-basic-module/#tra-stringhe-e-caratteri","text":"Come sappiamo l'operatore + funge da concatenatore di stringhe, stessa cosa non vale per\u00f2 con i caratteri. package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari String s1 = \"\" , s2 = \"\" , s3 = \"\" ; //Concatenazione tra stringhe s1 = \"Salve a \" ; s2 = \"tutto il mondo!\" ; s3 = s1 + s2 ; System . out . println ( s3 ); //Salve a tutto il mondo! } } E' possibile assegnare a una variabile di tipo char un'espressione somma di caratteri poich\u00e8 verrebbero trattata come un'espressione somma tra interi (rappresentati con il codice ASCII corrispondente) ma non \u00e8 possibile effettuare la somma tra variabili di tipo char . package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari char c1 = ' ' , c2 = ' ' , c3 = ' ' ; //Stessa cosa non vale con i caratteri c3 = 'A' + ' ' ; System . out . println ( c3 ); //a //Nel caso della somma tra due variabili di tipo char Java segnala errore, non \u00e8 previsto c1 = 'A' ; c2 = ' ' ; c3 = c1 + c2 ; } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: Type mismatch: cannot convert from int to char at mioTest.prova01.main(prova01.java:15) */ Eclipse segnala eventuali errori in fase di scrittura del codice per facilitarne la correzione e ne suggerisce anche una possibile soluzione Seguendo il consiglio di Eclipse.. package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari char c1 = ' ' , c2 = ' ' , c3 = ' ' ; c1 = 'A' ; c2 = ' ' ; c3 = ( char ) ( c1 + c2 ); System . out . println ( c3 ); //a } } Inoltre, sebbene l'operatore + sia definito e abbia un senso per le stringhe, l'operatore - non \u00e8 definito con le stringhe package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari String s1 = \"\" , s2 = \"\" , s3 = \"\" ; //L'operatore \"-\" non \u00e8 definito per le stringhe s1 = \"Salve a \" ; s2 = \"tutto il mondo!\" ; s3 = s1 - s2 ; System . out . println ( s3 ); //Salve a tutto il mondo! } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: The operator - is undefined for the argument type(s) java.lang.String, java.lang.String at mioTest.prova01.main(prova01.java:12) */ Per la sottrazione tra char invece valgono le stesse regole viste per l'addizione. Posso quindi assegnare ad un tipo char un'espressione sottrazione di caratteri poich\u00e8 verrebbero trattata come un'espressione sottrazione tra interi (rappresentati con il codice ASCII corrispondente) ma non \u00e8 possibile effettuare la sottrazione tra variabili di tipo char package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari char c1 = ' ' , c2 = ' ' , c3 = ' ' ; //Stessa cosa non vale con i caratteri c3 = 'A' - ' ' ; System . out . println ( c3 ); //! //Nel caso della somma tra due variabili di tipo char Java segnala errore, non \u00e8 previsto c1 = 'A' ; c2 = ' ' ; c3 = c1 - c2 ; } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: Type mismatch: cannot convert from int to char at mioTest.prova01.main(prova01.java:15) */ A questo punto \u00e8 facile intuire la sorte degli operatori / e * i quali non sono definiti per la classe String mentre sono definiti per il tipo char a patto di considerarli in un'espressione tra caratteri costanti o di effettuare un cast in un'espressione tra variabili. In generale: String : E' definito solo l'operatore + che funge da concatenatore di stringhe char : Sono definiti tutti gli operatori + , - , / , * a patto di considerare un'espressione tra caratteri costanti o a patto di effettuare un cast.","title":"Tra stringhe e caratteri."},{"location":"java/java-basic-module/#lezione-17","text":"","title":"Lezione 17"},{"location":"java/java-basic-module/#e-i-boolean","text":"Per i boolean somme, sottrazioni, moltiplicazioni e divisioni non sono definiti. Riporto solo l'esempio della sommma package mioTest ; public class prova01 { public static void main ( String [] args ) { //Boolean boolean b1 = true , b2 = true ; //Tra Boolean la somma non \u00e8 pervista boolean b3 = b2 + b3 ; } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: The operator + is undefined for the argument type(s) boolean, boolean at mioTest.prova01.main(prova01.java:8) */","title":"E i boolean?"},{"location":"java/java-basic-module/#lezione-18","text":"","title":"Lezione 18"},{"location":"java/java-basic-module/#numeri-decimali","text":"Per gli operatori + , - , * valgono le stesse regole viste per i numeri interi. Tuttavia nel caso dell'operatore / viene valutata la divisione decimale, a differenza dei numeri interi che ricordo, valuta la divisione intera composta da quoziente e resto . Riporto qui sotto un esempio trappola . package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari int i1 = 0 ; double d1 = 0 ; //Divisione Intera i1 = 40 / 15 ; System . out . println ( i1 ); //2 //Attenzione!! d1 = 40 / 15 ; System . out . println ( d1 ); //2.0 //Forme equivalenti corrette d1 = 40 d / 15 ; System . out . println ( d1 ); //2.6666666666666665 d1 = 40 / 15.0 ; System . out . println ( d1 ); //2.6666666666666665 d1 = ( double ) 40 / 15 ; System . out . println ( d1 ); //2.6666666666666665 } } Soluzione trappola: Alla riga: //Attenzione!! d1 = 40 / 15 ; System . out . println ( d1 ); //2.0 Probabilmente ti sarai aspettato di veder stampato un risultato decimale.. Ma non \u00e8 cos\u00ec! Questo perch\u00e8 come gi\u00e0 detto, l'operatore / calcola la divisione intera se gli operandi sono interi. Beh, in questo caso gli operandi sono interi , non \u00e8 importante se il contenitore \u00e8 un double , viene quindi calcolata la divisione intera e poi convertita in un numero decimale che tuttavia rimane comunque troncato. Per \"forzare\" la divisione decimale quando gli operandi sono interi \u00e8 necessario convertire un operando qualsiasi da intero a double . In questo caso poi tutti gli operandi verrebbero convertiti automaticamente in double e quindi l'operatore / \u00e8 in grado di calcolare la divisione decimale.","title":"Numeri decimali"},{"location":"java/java-basic-module/#lezione-19","text":"","title":"Lezione 19"},{"location":"java/java-basic-module/#espressioni-miste","text":"In caso di espressioni miste, ci\u00f2 con operandi di tipo diversom, vale un'unica grande regola generale: Il compilatore effettuer\u00e0 delle conversioni di tipo implicite solo se durante la conversione non si perde informazione, negli altri casi segnaler\u00e0 un'errore di compilazione indicando l'errore della conversione implicita package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari int i1 = 0 ; double d1 = 0 ; //Il tipo intero \u00e8 convertito in double e poi viene calcolata la somma d1 = 100 + 34.91 ; //Il tipo double non pu\u00f2 essere convertito implicitamente in double poich\u00e8 si perderebbe informazione i1 = 100 + 34.91 ; //Error! cannot convert from double to int } } Ogni volta che si effettuano operazioni tra tipi diversi, il compilatore potrebbe rilevare la perdita di informazione, in questo caso segnala un errore di compilazione. Per \"forzare\" la conversione di tipo \u00e8 necessario utilizzare l'operatore di cast indicando cio\u00e8 tra le parentesi () il tipo di destinazione. package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari int i1 = 0 ; double d1 = 0 ; //Il tipo intero \u00e8 convertito in double e poi viene calcolata la somma d1 = 100 + 34.91 ; i1 = 100 + ( int ) 34.91 ; System . out . print ( i1 ); //134 } } Regola di buona programmazione: In un'espressione mista e' buona norma esplicitare sempre il cast quando i tipi sono diversi Java converte implicitamente anche caratteri, numeri interi o decimali in stringa: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari String s1 = \"\" ; s1 = \"cia\" + 'o' + '!' ; System . out . println ( s1 ); //ciao! s1 = \"pi greco: \" + 3.14 ; System . out . println ( s1 ); //pi greco: 3.14 } } Non \u00e8 vero il contrario. Non posso cio\u00e8 ad esempio convertire un numero decimale espresso come stringa in un double a meno di utilizzare la classe Double con il metodo parseDouble() package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari double d1 = 0d ; d1 = \"3.14\" ; } } /* output Type mismatch: cannot convert from String to double */ Utilizzando il metodo parseDouble() della classe Double sar\u00e0 possibile convertire una stringa in un numero decimale. package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori binari double d1 = 0d ; d1 = Double . parseDouble ( \"3.14\" ); System . out . print ( d1 ); //3.14 } } Interessante a questo punto vedere anche il metodo parseInt() della classe Integer . parseInt(param1, param2) : Il metodo parseInt() pu\u00f2 ricevere due parametri. Il primo parametro rappresenta la stringa da convertire, il secondo, opzionale, rappresenza invece la base del numero che rappresenta. Di default questo parametro assume che il numero sia decimale, base = 10. Nell'esempio che segue convertiro' in intero tre tipi di numeri, un decimale, un binario e un esadecimale. package mioTest ; public class prova01 { public static void main ( String [] args ) { // String string_temperatura = \"12\" ; String string_bitSequence = \"01011110\" ; String string_hexValue = \"F20B\" ; //Converto in intero una stringa che rappresenta un numero decimale, base = 10, opzione di default int temperatura = Integer . parseInt ( string_temperatura , 10 ); //Converto in intero una stringa che rappresenta un numero binario, base = 2 int bitSequence = Integer . parseInt ( string_bitSequence , 2 ); //Converto in intero una stringa che rappresenta un numero esadecimale, base = 16 int hexValue = Integer . parseInt ( string_hexValue , 16 ); System . out . println ( temperatura ); //12 System . out . println ( bitSequence ); //94 System . out . println ( hexValue ); //61963 } }","title":"Espressioni miste"},{"location":"java/java-basic-module/#lezione-20","text":"","title":"Lezione 20"},{"location":"java/java-basic-module/#numeri-esadecimali-ottali","text":"Posso rappresenare anche numeri eadecimale, ottali e binari specificando rispettivamente i prefissi 0x , 0 , 0b package mioTest ; public class prova01 { public static void main ( String [] args ) { // int esa = 0x45 ; int ott = 0237 ; int bin = 0b010010 ; System . out . println ( esa ); //69 System . out . println ( ott ); //159 System . out . println ( bin ); //18 } }","title":"Numeri Esadecimali, ottali"},{"location":"java/java-basic-module/#costanti-numeriche","text":"Di default le costanti letterali numeriche intere vengono rappresentate con il tipo Integer mentre per i numeri decimali le costanti vengono sempre rappresentate con il tipo double . Per rappresentare quindi costanti letterali appartenenti a un tipo diverso \u00e8 necessario specificarlo esplicitamente. package mioTest ; public class prova01 { public static void main ( String [] args ) { //Necessario specificare il suffisso \"L\" poich\u00e8 verrebbe interpretato come un intero long longNumber = 2427832389L ; //Necessario specificare il suffisso \"F\" poich\u00e8 verrebbe interpretato come un double float floatNumber = 12.8F ; //Necessario specificare il suffisso \"D\" poich\u00e8 verrebbe interpretato come un intero double doubleNumber = 34 D ; } }","title":"Costanti numeriche"},{"location":"java/java-basic-module/#sequenze-di-escape","text":"//a capo char c1 = '\\n' ; //backslash char c2 = '\\b' ; Interessante vedere in azione il backslash. Tuttavia \u00e8 necessario eseguire il codice da terminale package mioTest ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"ciao a tutti\\b\\b\\b\\b\\bnessuno\" ); //ciao a nessuno } } Vediamo tutte le sequenze di escape in java: Escape Sequence Description \\t Insert a tab in the text at this point. \\b Insert a backspace in the text at this point. \\n Insert a newline in the text at this point. \\r Insert a carriage return in the text at this point. \\f Insert a formfeed in the text at this point. \\' Insert a single quote character in the text at this point. \\\" Insert a double quote character in the text at this point. \\ Insert a backslash character in the text at this point. Interessante la sequenza di escape per l'inserimento di caratteri unicode \\u package mioTest ; public class prova01 { public static void main ( String [] args ) { char c = '\\u1241' ; System . out . println ( c ); //\u1241 } } Attenzione!! Il tipo char in questo caso non occupa pi\u00f9 8 bit.","title":"Sequenze di escape"},{"location":"java/java-basic-module/#lezione-21","text":"","title":"Lezione 21"},{"location":"java/java-basic-module/#operatori-di-assegnamento","text":"Gli operatori di assegnamento, come gi\u00e0 visto, sono utilizzati per assegnare un valore ad una variabile. Non esiste soltanto l'operatore di assegnamento = , esistono forme sintetiche di operatori di assegnamento che oltre che ad assegnare elaborano il valore della variabile di destinazione specificando un operatore aritmetico. Una lista completa degli operatori di assegnamento aritmetici: Operatore Esempio Equivale a = x = 5 x = 5 += x += 5 x = x + 5 -= x -= 5 x = x -5 *= x *= 5 x = x * 5 /= x /= 5 x = x / 5 %= x %= 5 x = x % 5 Un esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori di assegnamento int n = 0 ; //Assegnamento semplice n = 12 ; System . out . println ( n ); //12 //Assegnamento complesso n += 2 ; //n = n + 2 System . out . println ( n ); //14 n += 12 + n * n ; //n = n + (12 + n*n) System . out . println ( n ); //222 n /= 2 ; n -= 40 ; n *= 3 ; System . out . println ( n ); //213 } } Qui sotto riporto per completezza anche una lista degli operatori di assegnamento bit a bit | Operatore | Esempio | Equivale a | | ----------| -----------| ----------- | | &= | x &= 5 | x = x & 5 | | |= | x |= 5 | x = x | 5 | | ^= | x ^= 5 | x = x ^ 5 | | >>= | x >>= 5 | x = x >> 5 | | <<= | x <<= 5 | x = x << 5 |","title":"Operatori di Assegnamento"},{"location":"java/java-basic-module/#lezione-22","text":"","title":"Lezione 22"},{"location":"java/java-basic-module/#operatori-relazionali","text":"Gli operatori relazionali ritornano un boolean e sono utilizzati per confrontare due valori o, pi\u00f9 in generale, due espressioni: Operatore Nome Esempio == Uguale a x == y : Ritorna true solo se x \u00e8 uguale a y != Diverso da x != y : Ritorna true solo se x \u00e8 diverso da y > Maggiore di x > y : Ritorna true solo se x \u00e8 maggiore di y < Minore di x < y : Ritorna true solo se x \u00e8 minore di y >= Maggiore o uguale di x >= y : Ritorna true solo se x \u00e8 maggioere o uguale a y <= Minore o uguale di x <= y : Ritorna true solo se x \u00e8 minore o uguale a y Un esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori Relazionali int x = 0 , y = 12 ; System . out . println ( x == y ) ; //false System . out . println ( x != y ) ; //true System . out . println ( x > y ) ; //false System . out . println ( x < y ) ; //true System . out . println ( x >= y ) ; //false System . out . println ( x <= y ) ; //true } } E' possibile applicare tutti gli operatori relazionali anche ai caratteri: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori Relazionali char c1 = 'A' , c2 = 'S' ; System . out . println ( c1 == c2 ) ; //false System . out . println ( c1 != c2 ) ; //true System . out . println ( c1 > c2 ) ; //false System . out . println ( c1 < c2 ) ; //true System . out . println ( c1 >= c2 ) ; //false System . out . println ( c1 <= c2 ) ; //true } } Per le stringhe sono validi solo gli operatori relazionali: == : Ritorna true se due stringhe sono identiche != : Ritorna true se due stringhe differiscono per uno o pi\u00f9 caratteri package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori Relazionali String s1 = \"Giorno\" , s2 = \"Giornata\" ; System . out . println ( s1 == s2 ) ; //false System . out . println ( s1 != s2 ) ; //true } } Per confrontare due stringhe \u00e8 possibile ricorrere a metodi della classe String come ad esempio: compareTo(s2) : confronta la stringa a cui si applica il metodo con la stringa passata per parametro s2 e ritorna un valore intero. Se il valore di ritorno \u00e8 negativo la stringa a cui si applica il metodo \u00e8 minore dal punto lessicografico della stringa passata per parametro Se il valore di ritorno \u00e8 zero la stringa a cui si applica il metodo \u00e8 uguale alla stringa passata per parametro Se il valore di ritorno \u00e8 positivo la stringa a cui si applica il metodo \u00e8 maggiore dal punto lessicografico della stringa passata per parametro package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori Relazionali String s1 = \"Giorno\" , s2 = \"Giornata\" ; System . out . println ( s1 . compareTo ( s2 ) ) ; //14 } }","title":"Operatori Relazionali"},{"location":"java/java-basic-module/#lezione-23","text":"","title":"Lezione 23"},{"location":"java/java-basic-module/#operatori-logici","text":"Gli operatori logici ritornano un boolean e sono usati per la concatenazione di esepressioni logiche: Operatore Nome Esempio && And Logico expr1 && expr2 : Ritorna true solo se expr1 ed expr2 sono entrambe espressioni vere || Or Logico expr1 || expr2 : Ritorna true se almeno una delle espressioni expr1 e expr2 risulta vera ! Not Logico !expr : Ritorna true se expr \u00e8 false , false se expr \u00e8 true Short evalutation: Nella concatenazione di espressioni logiche il compilatore Java effettua delle ottimizzazioni. expr1 && expr2 : se expr1 \u00e8 false , expr2 non viene valutata e ritorna false expr1 || expr2 : se expr1 \u00e8 true expr2 non viene valutata e ritorna true Esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Operatori Relazionali int x = 0 , y = 12 , c = 4 , d = 3 ; System . out . println ( ( x == y ) || ( c > d ) ); //true System . out . println ( ( x != y ) && ( c >= d ) ); //true //Short evalutation. //Poich\u00e8 la prima espressione (x > y) risulta \"false\" non ha senso valutare le altre espressioni //Ritorner\u00e0 dunque \"false\" System . out . println ( ( x > y ) && ! ( c > d ) ); //false //Attenzione alle precedenze degli operatori!! //nel dubbio metti sempre le parentesi System . out . println ( ( ! ( x > y ) && ! ( c == d )) || ( d > c ) ); //true } }","title":"Operatori Logici"},{"location":"java/java-basic-module/#lezione-24","text":"","title":"Lezione 24"},{"location":"java/java-basic-module/#costrutto-condizionali-if-else","text":"Puoi Utilizzare Il costrutto if ... else per istruire il programma a prendere scelte Infatti, con il costrutto if ... else , se una determinata condizione risulta true esegue il codice delimitato dal blocco if altrimenti esegue il codice delimitato dal blocco else if ( condition ) { // code A } else { //code B } Esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Costrutto If ... Else String name = \"Marco\" ; int eta = 14 ; int maggioreEta = 18 ; if ( eta >= maggioreEta ) { System . out . print ( name + \" \u00e8 maggiorenne\" ); } if ( eta < maggioreEta ) { System . out . print ( name + \" non \u00e8 maggiorenne\" ); } } } /* output --- Marco non \u00e8 maggiorenne */ E' possibile specificare condizioni multiple con l'istruzione else if : if ( condition1 ) { // code A } else if ( condition2 ) { //code B } } else { //code C } Esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Costrutto If ... Else String name = \"Marco\" ; int eta = 18 ; int maggioreEta = 18 ; if ( eta > maggioreEta ) { System . out . print ( name + \" \u00e8 maggiorenne\" ); } else if ( eta < maggioreEta ) { System . out . print ( name + \" non \u00e8 maggiorenne\" ); } else { System . out . print ( name + \" \u00e8 un diciottenne\" ); } } } /* output --- Marco \u00e8 un diciottenne */ Nell' esempio di sopra, simile al precedente, ho cambiato l'eta' di Marco e la prima condizione del costrutto if da >= a > . In questo modo rimane fuori la condizione in cui eta == maggioreEta che sar\u00e0 rilevata dal blocco else . Il ramo if e' necessario Non pu\u00f2 esistere il ramo else if o il ramo else se non esiste il ramo if . E' un errore sintattico. else if ( condition ){ //code } else { } /* Syntax error on token \"else\" */ Il ramo else non e' necessario Il blocco else non \u00e8 necessario. Se non vengono verificate le condizioni espresse dagli if statemeant semplicemente il programma non fa niente if ( condition ) { // code A } else if ( condition2 ){ //code B } Esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Costrutto If ... Else String name = \"Marco\" ; int eta = 18 ; int maggioreEta = 18 ; if ( eta > maggioreEta ) { System . out . print ( name + \" \u00e8 maggiorenne\" ); } else if ( eta < maggioreEta ) { System . out . print ( name + \" non \u00e8 maggiorenne\" ); } } } /* output --- */ if annidati Posso annidare gli if statemeant per raggiungere condizioni pi\u00f9 specifiche. if ( condition1 ) { //code .. //.. if ( condition1A ){ //code 1A } else { //condition 1B } //.. } else if ( condition2 ) { //code B } } else { //code.. //.. if ( condition_elseA ){ //code else A } else if ( condition_elseB ) { //code else B } else { //condition else C } //code //.. } I costrutti condizionali if pi\u00f9 interni, quelli annidati, sono valutati solo se i costrutti condizionali pi\u00f9 esterni, quelli che li contengono, sono verificati. Un esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Costrutto If ... Else String name = \"Marco\" ; int eta = 23 ; int maggioreEta = 18 ; int trentenne = 30 ; if ( eta > maggioreEta ) { System . out . print ( name + \" \u00e8 maggiorenne\" ); if ( eta > trentenne ) { System . out . print ( name + \" ha anche pi\u00f9 di 30 anni\" ); } else { System . out . print ( \" ma non ha pi\u00f9 di 30 anni\" ); } } else if ( eta < maggioreEta ) { System . out . print ( name + \" non \u00e8 maggiorenne\" ); } } } /* output --- Marco \u00e8 maggiorenne ma non ha pi\u00f9 di 30 anni */ E' possibile tradurre il codice con if annidati con una serie di rami if/else if semplici facendo uso di operatori logici Vediamo lo stesso esempio di prima: package mioTest ; public class prova01 { public static void main ( String [] args ) { //Costrutto If ... Else String name = \"Marco\" ; int eta = 23 ; int maggioreEta = 18 ; int trentenne = 30 ; if ( eta > maggioreEta && eta > trentenne ) { System . out . print ( name + \" \u00e8 maggiorenne\" ); System . out . print ( name + \" ha anche pi\u00f9 di 30 anni\" ); } else if ( eta > maggioreEta && eta < trentenne ) { System . out . print ( name + \" \u00e8 maggiorenne\" ); System . out . print ( \" ma non ha pi\u00f9 di 30 anni\" ); } else { System . out . print ( name + \" non \u00e8 maggiorenne\" ); } } } /* output --- Marco \u00e8 maggiorenne ma non ha pi\u00f9 di 30 anni */","title":"Costrutto Condizionali If ... Else"},{"location":"java/java-basic-module/#lezione-25","text":"","title":"Lezione 25"},{"location":"java/java-basic-module/#costrutto-switch","text":"Il costrutto condizionale switch pu\u00f2 essere utilizzato quando la condizione in un costrutto condizionale pu\u00f2 assumere diversi valori e, ad ogni valore della condizione, associare un blocco di codice. switch ( expression ) { case x : // code block break ; case y : // code block break ; default : // code block } Un esempio: package mioTest ; public class prova01 { public static void main ( String [] args ) { int mese = 5 ; switch ( mese ) { case 1 :{ System . out . println ( \"Gennaio\" ); break ; } case 2 :{ System . out . println ( \"Febbraio\" ); break ; } case 3 :{ System . out . println ( \"Marzo\" ); break ; } case 4 :{ System . out . println ( \"Aprile\" ); break ; } case 5 :{ System . out . println ( \"Maggio\" ); break ; } case 6 :{ System . out . println ( \"Giugno\" ); break ; } case 7 :{ System . out . println ( \"Luglio\" ); break ; } case 8 :{ System . out . println ( \"Agosto\" ); break ; } case 9 :{ System . out . println ( \"Settembre\" ); break ; } case 10 :{ System . out . println ( \"Ottobre\" ); break ; } case 11 :{ System . out . println ( \"Novembre\" ); break ; } case 12 :{ System . out . println ( \"Dicembre\" ); break ; } default :{ System . out . println ( \"Errore! Mese non valido\" ); break ; } } } } Lo statemeant break rende i rami case mutuamente esclusivi. Solo una condizione \u00e8 verificabile. Lo steatement break tuttavia non \u00e8 obbligatorio. Se manca, i rami case vengono valutati in modo sequenziale. package mioTest ; public class prova01 { public static void main ( String [] args ) { int mese = 4 ; switch ( mese ) { case 1 : case 3 : case 5 : case 7 : case 8 : case 10 : case 12 :{ System . out . println ( \"Mese con 31 giorni\" ); break ; } case 4 : case 6 : case 9 : case 11 :{ System . out . println ( \"Mese con 30 giorni\" ); break ; } case 28 : { System . out . println ( \"Mese con 28 giorni\" ); break ; } default :{ System . out . println ( \"Errore! Mese non valido\" ); break ; } } } } /* output --- Mese con 30 giorni */ Puoi utilizzare qualsiasi tipo o espressione nella condizione da verificare dello switch . Puoi usare ad esempio stringhe, caratteri, boolean o espressioni complesse. package mioTest ; public class prova01 { public static void main ( String [] args ) { String mese = \"Luglio\" ; switch ( mese ) { case \"Gennaio\" : case \"Marzo\" : case \"Maggio\" : case \"Luglio\" : case \"Agosto\" : case \"Ottobre\" : case \"Dicembre\" :{ System . out . println ( \"Mese con 31 giorni\" ); break ; } case \"Aprile\" : case \"Giugno\" : case \"Settembre\" : case \"Novembre\" :{ System . out . println ( \"Mese con 30 giorni\" ); break ; } case \"Febbraio\" : { System . out . println ( \"Mese con 28 giorni\" ); break ; } default :{ System . out . println ( \"Errore! Mese non valido\" ); break ; } } } } /* output --- Mese con 31 giorni */ Attenzione a non giocare troppo in modo incosapevole con il comando break perch\u00e8 il risultato potrebbe non essere quello atteso. package mioTest ; public class prova01 { public static void main ( String [] args ) { int mese = 5 ; switch ( mese ) { case 1 :{ System . out . println ( \"Gennaio\" ); } case 2 :{ System . out . println ( \"Febbraio\" ); } case 3 :{ System . out . println ( \"Marzo\" ); } case 4 :{ System . out . println ( \"Aprile\" ); } case 5 :{ System . out . println ( \"Maggio\" ); } case 6 :{ System . out . println ( \"Giugno\" ); } case 7 :{ System . out . println ( \"Luglio\" ); } case 8 :{ System . out . println ( \"Agosto\" ); } case 9 :{ System . out . println ( \"Settembre\" ); } case 10 :{ System . out . println ( \"Ottobre\" ); } case 11 :{ System . out . println ( \"Novembre\" ); } case 12 :{ System . out . println ( \"Dicembre\" ); } default :{ System . out . println ( \"Errore! Mese non valido\" ); } } } } /* Maggio Giugno Luglio Agosto Settembre Ottobre Novembre Dicembre Errore! Mese non valido */ Non avrei potuto usare il costrutto if..else? Il costrutto if ... else \u00e8 il costrutto pi\u00f9 generico e potente alla base di ogni linguaggio di programmazione e, proprio per la sua genericit\u00e0 \u00e8 preferibile utilizzare in tutti quei casi in cui le condizioni da verificare sono complesse e non facilmente raggruppabili da una famiglia di valori specifici. Nei casi in cui il valore di un'espressione o pi\u00f9 semplicemente di una variabile determina l'esecuzione di un blocco di codice specifico, il costrutto switch si rileva pi\u00f9 lineare e leggibile.","title":"Costrutto Switch"},{"location":"java/java-basic-module/#lezione-26","text":"","title":"Lezione 26"},{"location":"java/java-basic-module/#leggere-dati-da-tastiera","text":"Partiamo da un esempio: package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { Scanner tastiera = new Scanner ( System . in ); int eta = tastiera . nextInt (); System . out . print ( \"hai: \" + eta + \" anni\" ); } } Il codice sopra riportato legge un intero da tastiera, lo memorizza nella variabile eta e stampa la variabile. Ma come funziona? Non possiamo pretendere di capire a fondo il meccanismo che sta alla base poich\u00e8 ancora dobbiamo affrontare la OOP ma di fatto, non sappiamo neanche cosa sta dietro il meccanismo della stampa System.out.print() . Ci limiteremo, per adesso ad un apprendimento intuitivo. Riporto i punti fondamentali: Creo un'istanze della classe Scanner chiamato tastiera . Scanner tastiera = .. Assegno a tastiera un nuovo oggetto appartenente alla classe Scanner passando come parametro System.in . La chiamata new Scanner(System.in) invoca il costruttore della claase Scanner , una particolare funzione che si occupa dell'inizializzazione degli oggetti istanziati attraverso classi. Scanner tastiera = new Scanner ( System . in ); A questo punto tastiera \u00e8 un oggetto inizializzato come input della classe Scanner . Posso quindi utilizzare tutti i metodi della classe Scanner applicati a tastiera . Il metodo next.Int() applicato a un oggetto Scanner inizializzato come input si occupa di prelevare da tastiera un intero. int eta = tastiera . nextInt (); Non importa se non hai capito bene tutti i passaggi. Se avrai la pazienza di arrivare in fondo al corso ne capirai il significato. E' tuttavia necessario introdurre qualche concetto sulla OOP visto che Java che \u00e8 un linguaggio costruito proprio sul meccanismo di programmazione orientata agli oggetti. Attenzione! Il metodo nextInt() acquisisce da tastiera solo numeri interi. Verr\u00e0 sollvato un errore (eccezione) a runtime se rileva un valore diverso. Quindi, come acquisisco valori decimale, Stringhe e quantaltro? Semplice, utilizzo un metodo diverso. L'autocompletamento di Eclipse pu\u00f2 aiutarci a capire tutti i metodi disponibili per quella classe Ne riporto giusto alcuni: nextDouble() : Acquisisce da tastiera un numero decimale next() : Acquisisce da tastiera una stringa, termina al primo spazio nextLine() : Acquisce da tastiera una stringa, termina con INVIO . Acquisice dunque l'intera linea immessa da tastiera","title":"Leggere dati da tastiera"},{"location":"java/java-basic-module/#lezione-27","text":"","title":"Lezione 27"},{"location":"java/java-basic-module/#costrutti-iterativi","text":"I costrutti iterativi sono costrutti essenziali presenti necessariamente in ogni linguaggio di programmazione. vengono chiamati anche loop o cicli e permettono di eseguire un blocco di codice finch\u00e9 rimane vera, true una condizione specifica.","title":"Costrutti Iterativi"},{"location":"java/java-basic-module/#ciclo-while","text":"Il ciclo while ripete un blocco di codice finch\u00e8 la condizione specificata rimane vera: while ( condition ) { // code } Esempio: package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { int i = 0 ; while ( i < 5 ) { //i = 0, 0 < 5 //i = 1, 1 < 5 .. System . out . println ( i ); //i = 1 //i = 2 .. i ++ ; } } } /* 0 1 2 3 4 */ Attenzione In una struttura iterativa \u00e8 sempre bene tener presente: - La condizione di verifica del ciclo. Prima o poi la condizione deve risultare false altrimenti si rischia di costruire un ciclo infinito, bloccando l'esecuzione di tutto il programma! - L'istruzione che altera, ad ogni iterazione, la condizione da verificare. Se non esiste nessuna istruzione in grado di modificare la condizione sotto controllo del ciclo, allo stesso modo, si ottiene un ciclo infinito. Da evitare! Il seguente codice stampa il valore 0 infinite volte, bloccando l'utilizzo della CPU . E' chiaramente un errore grave! package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { int i = 0 ; while ( i < 5 ) { System . out . println ( i ); } } } /* 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 . . */","title":"Ciclo while"},{"location":"java/java-basic-module/#lezione-28","text":"","title":"Lezione 28"},{"location":"java/java-basic-module/#qualche-esercizio","text":"","title":"Qualche esercizio"},{"location":"java/java-basic-module/#stampa-somma-esercizio-base","text":"Stampa la somma dei primi 100 numeri. package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { int i = 0 ; int ris = 0 ; while ( i <= 100 ) { ris += i ; i ++ ; } System . out . println ( ris ); //5050 } }","title":"Stampa somma esercizio base"},{"location":"java/java-basic-module/#stampa-somma-esercizio-avanzato","text":"Stampa la somma dei numeri interi immessi da tastiera compresi nel range [x, y]. Termina non appena la somma supera il valore 1000 package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); int ris = x ; while ( ( x < y ) && ( ris < 1000 ) ) { x ++ ; ris += x ; } System . out . println ( \"Ultimo valore somato: \" + x ); System . out . println ( \"Risultato: \" + ris ); } } Attenzione! La sequenza delle istruzioni \u00e8 importante soprattutto quando queste sono all'interno di una struttura iterativa! Cambiando l'ordine degli statemeant il risultato cambia eccome.. In particolare, all'interno di una struttura iterativa \u00e8 necessario fare bene i conti poich\u00e8 ad esempio l'istruzione B successiva all'istruzione A \u00e8 tale da influenzare l'istruzione A all'iterazione successiva. Consiglio sempre di fare attenzione ai casi eccezionali ovvero i valori di partenza e i valori finali. Il prossimo esercizio, simile al precedente \u00e8 sintatticamente corretto ma semanticamente sbagliato. L'algoritmo non \u00e8 corretto! package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); int ris = x ; while ( ( x < y ) && ris < 1000 ) { ris += x ; x ++ ; } System . out . println ( \"Ultimo valore somato: \" + x ); System . out . println ( \"Risultato: \" + ris ); } } Ho semplicemente invertito l'ordine della sequenza di istruzioni all'interno del ciclo while . Il risultato prodotto non \u00e8 corretto ma un occhio non attento non sarebbe in grado di scoprirlo. La somma dei numeri compresi tra [2, 5] dovrebbe dare come risultato 2 + 3 + 4 + 5 = 14 e non 11 . Cos'\u00e8 che non va? Il problema \u00e8 al primo passo iterativo. int ris = x ; while ( ( x < y ) && ris < 1000 ) { ris += x ; x ++ ; } Prima di iniziare il ciclo infatti la la variabile ris assume il valore iniziale x , quello di partenza ma alla prima iterazione del ciclo somma nuovamente x a ris , quindi quello che ottengo \u00e8: 2 + 2 + 3 + 4 = 11 . Attento che il numero 5 , l'ultimo numero non viene considerato! Perch\u00e8, al contrario di prima il numero finale non viene incluso nel ciclo? Il motivo \u00e8 sempre lo stesso, perch\u00e8 ho invertito le istruzioni all'interno del while ma in questo caso \u00e8 colpa dell'ultimo passo iterativo. Infatti all'ultimo passo iterativo, quando x=4 , il ciclo \u00e8 ancora valido, 4 viene sommato al risultato ris e solo dopo viene incrementato rendendo falsa la condizione del ciclo al passo successivo e quindi impedendo a ris di incrementarsi. Modo alternativo?? Niente paura, sei stai pensando che sia complicato ti garantisco che \u00e8 cos\u00ec, \u00e8 complicato! Per questo sto perdendo molto tempo sugli esercizi e sulla pratica. Ecco un esempio dello stesso esercizio svolto mantenendo questo ordine delle istruzioni. package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); int ris = 0 ; while ( ( x <= y ) && ris < 1000 ) { ris += x ; x ++ ; } System . out . println ( \"Ultimo valore somato: \" + -- x ); System . out . println ( \"Risultato: \" + ris ); } } Che cosa \u00e8 cambiato? Apparentemente niente ma un occhio esperto potrebbe notare che la variabile ris \u00e8 stata inizializzata con il valore 0 in modo da evitare di sommare due volte il valore iniziale ed \u00e8 stata cambiata la condizione all'interno del while da (x < y) a (x <= y) in modo da includere anche l'ultimo numero del passo iterativo. Infine anche se \u00e8 secondario, ho dovuto cambiare la stampa dell'ultimo valore sommato da x a --x cio\u00e8 decrementando il valore poich\u00e8 in questo caso x , alla fine del cilco, \u00e8 fuori range Non ti fidi? ecco il risultato. Ti ho convinto che in ciclo la sequenza delle operazioni \u00e8 fondamentale? Spero proprio di s\u00ec :)","title":"stampa somma esercizio avanzato"},{"location":"java/java-basic-module/#aggiunta-di-un-controllo","text":"Nell'esercizio precedente tutto sembra funzionare alla grande ma non \u00e8 cos\u00ec. Che cosa succede se il numero di partenza x \u00e8 maggiore del numero di fine y ? Un disastro.. Dobbiamo aggiungere un controllo per evitare questo problema, del tipo if ( x > y ){ //fai qualcosa } In questo caso ho intenzione di scambiare il valore di x con y per renderla sempre vera. package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); if ( x > y ) { int temp = x ; x = y ; y = temp ; } int ris = 0 ; while ( ( x <= y ) && ris < 1000 ) { ris += x ; x ++ ; } System . out . println ( \"Ultimo valore somato: \" + -- x ); System . out . println ( \"Risultato: \" + ris ); } } Vediamo subito un esempio che passi dal costrutto if Un po' di esercizi e modi di pensare li hai visti. Ti lascio infine un modo compatto per scrivere quel ciclo. package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); if ( x > y ) { int temp = x ; x = y ; y = temp ; } int ris = 0 ; while ( ( x <= y ) && ris < 1000 ) ris += x ++ ; System . out . println ( \"Ultimo valore somato: \" + -- x ); System . out . println ( \"Risultato: \" + ris ); } } Ancora continua a funzionare:","title":"Aggiunta di un controllo"},{"location":"java/java-basic-module/#lezione-28_1","text":"","title":"Lezione 28"},{"location":"java/java-basic-module/#ciclo-do-while","text":"Il ciclo do ... while \u00e8 una variante del ciclo while. Questo ciclo esegue sempre il blocco di codice almeno una volta prima di verificare se la condizione \u00e8 vera. Ripete il codice finch\u00e9 la condizione rimane vera. La differenza sta dunque alla prima iterazione. Infatti, in un ciclo while non \u00e8 detto che venga eseguito il codice all'interno, se la condizione risulta subito falsa, si esce. In questo caso invece almeno una volta si esegue do { // code block to be executed } while ( condition ); Riporto lo stesso esercizio della somma dei numeri utilizzando il do ... while package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); if ( x > y ) { int temp = x ; x = y ; y = temp ; } int ris = 0 ; do { ris += x ++ ; } while ( ( x <= y ) && ris < 1000 ); System . out . println ( \"Ultimo valore somato: \" + -- x ); System . out . println ( \"Risultato: \" + ris ); } }","title":"Ciclo do ... while"},{"location":"java/java-basic-module/#lezione-29","text":"","title":"Lezione 29"},{"location":"java/java-basic-module/#for-loop","text":"Quando sai esattamente quante volte vuoi ripetere un blocco di codice, puoi usare il ciclo for invece di un ciclo while : for ( statement 1 ; statement 2 ; statement 3 ) { // code block to be executed } - statement 1 \u00e8 eseguita una volta prima dell'esecuzione del ciclo - statement 2 definisce la condizione da verificare - statement 3 \u00e8 eseguita ogni volta dopo il blocco di codice un esempio classico: package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( i ); } } } Una considerazione importante La variabile i dichiarata all'interno del ciclo for NON E' VISIBILE ALL'ESTERNO rimane privata al ciclo for . Richiamando la variabile i all'esterno del ciclo for si genera un'errore in fase di compilazione poich\u00e8 di fatto i non esiste pi\u00f9. La variabile i muore appena terminato il ciclo ed \u00e8 come se non fosse mai esistita package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { for ( int i = 0 ; i < 5 ; i ++ ) { //qui nasce i System . out . println ( i ); } //qui muore i System . out . println ( i ); } } /* output Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: i cannot be resolved to a variable at mioTest.prova01.main(prova01.java:11) */ Altre considerazioni - statement 1 , statement 2 , statement 3 sono tutte opzionali opzionali - statement 1 , statement 3 possono essere composti da pi\u00f9 statement ciascuno, separati dalla virgola , Un esempio: package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { for ( int i = 0 , j = 10 ; ( i < 10 ) && ( j > 0 ); i ++ , j -- ) { System . out . println ( i + \" - \" + j ); } } } /* output 0 - 10 1 - 9 2 - 8 3 - 7 4 - 6 5 - 5 6 - 4 7 - 3 8 - 2 9 - 1 */ Vediamo infine il solito esercizio somma realizzato anche con il ciclo for package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { System . out . println ( \"Stampa la somma dei numeri interi compresi nel range [x, y]\" ); System . out . println ( \"Termina non appena la somma supera il valore 1000\" ); Scanner tastiera = new Scanner ( System . in ); System . out . println ( \"Inserisci il numero di partenza x:\" ); int x = tastiera . nextInt (); System . out . println ( \"Inserisci il numero di fine y:\" ); int y = tastiera . nextInt (); if ( x > y ) { int temp = x ; x = y ; y = temp ; } int ris = 0 ; for ( ris = 0 ; (( x <= y ) && ris < 1000 ); x ++ ) ris += x ; System . out . println ( \"Ultimo valore somato: \" + -- x ); System . out . println ( \"Risultato: \" + ris ); } }","title":"For loop"},{"location":"java/java-basic-module/#lezione-30","text":"","title":"Lezione 30"},{"location":"java/java-basic-module/#break-e-continue","text":"Hai gi\u00e0 visto l'istruzione break usata in un capitolo precedente di questo tutorial. Era usato per \"saltare fuori\" da un'istruzione switch. L'istruzione break pu\u00f2 essere utilizzata anche per uscire da un ciclo. package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == 4 ) { break ; } System . out . println ( i ); } } } /* output 0 1 2 3 */ L'istruzione continue salta all'iterazione successiva ma non termina il ciclo. package mioTest ; import java.util.Scanner ; public class prova01 { public static void main ( String [] args ) { int i = 0 ; while ( i < 10 ) { if ( i == 4 ) { i ++ ; continue ; } System . out . println ( i ); i ++ ; } } } /* output 0 1 2 3 5 6 7 8 9 */","title":"break e continue"},{"location":"java/java-basic-module/#lezione-31","text":"","title":"Lezione 31"},{"location":"java/java-basic-module/#sottoprogrammi-funzioni-metodi","text":"Per linguaggi non OOP si parla di funzioni , per linguaggi OOP si parla di metodi. Pi\u00f9 in generale si pu\u00f2 parlare di sottoprogrammi come un raggruppamento di istruzioni atte a svolgere uno scopo preciso. In Java, poich\u00e8 \u00e8 un linguaggio OOP si parla di metodi. Abbiamo gi\u00e0 visto dei metodi sottoforma di black-box come print , println della classe System.out oppure endsWith() , lenght() della classe String o ancora parseDouble() della classe Double . Dal punto di vista dell'utente si presentano sottoforma di comandi ma in realt\u00e0 sono dei pacchetti di codice scritti anch'essi in linguaggio Java e applicabili soltanto a una particolare classe . Infatti il metodo parseDouble() \u00e8 un sottoprogramma applicabile alla classe Double, , endsWith() allo stesso modo \u00e8 applicabile alla classe String . Questi sottoprogrammi non hanno una funzione sintattica specifica, non aggiungono costrutti al linguaggio quindi non lo arricchiscono ma sono indispensabili al fine di poter costruire enormi pezzi di codice poich\u00e8 permettono la scomposizione dell'intero codice in tanti piccoli pezzi fondamentali isolati e quindi studiabili separatamente. Ti ho mentito, in realt\u00e0 hai visto anche l'implementazione di un metodo package mioTest ; public class prova01 { public static void main ( String [] args ) { } } Ebbene s\u00ec, fino ad ora abbiamo scritto all'interno del metodo principale main() quello che Java cerca sempre alla partenza di un programma come entry point. E abbiamo visto che il metodo main() \u00e8 all'interno della classe prova01 quindi \u00e8 un metodo applicabile alla classe prova01 . Bando alle ciance vediamo adesso la sintassi base per la definizione di un metodo: public class prova01 { //Definizione di un metodo static returnType methodName ( type1 paramA , type2 paramB , ....) { //implementazione } public static void main ( String [] args ) { //Chiamata di un metodo methodName ( param1 , param2 , ...); } } Un metodo per funzionare deve essere definito e successivamente chiamato. Per adesso, di tutti i metodi citati sopra abbiamo visto solo la chiamata ma non sappiamo qual \u00e8 la loro definizione anche se di fatto non ci interessa. Adesso andremo a definire un nostro metodo e successivamente a chiamarlo.","title":"Sottoprogrammi, Funzioni, Metodi"},{"location":"java/java-basic-module/#definizione-di-un-metodo","text":"static returnType methodName ( type1 paramA , type2 paramB , ....) { //implementazione } - Nella definizione si stabilisce il nome del metodo, un po' come si fa nella dichiarazione delle variabili. Il nome del metodo verr\u00e0 utilizzato in fase di chiamata - Si stabiliscono i parametri formali ovvero gli input che deve ricevere dall'esterno. - Si stabilisce un tipo di ritorno cio\u00e8 l'output che dovr\u00e0 fornire all'esterno. - Si scrive l' implementazione cio\u00e8 come gli input dovranno essere elaborati per produrre gli output.","title":"Definizione di un metodo:"},{"location":"java/java-basic-module/#chiamata-di-un-metodo","text":"methodName ( param1 , param2 , ...); E' possibile chiamare un metodo solo se \u00e8 stato definito. Per la chiamata di un metodo \u00e8 sufficiente digitare il nome del metodo seguito dai parametri racchiusi tra le parentesi (param1, param2) . In questo caso i parametri sono detti attuali . Il loro valore viene trasferito alla funzione per l'elaborazione Vediamo un esempio: package mioTest ; public class prova01 { //parametri formali static void saluta ( String nome ) { System . out . println ( \"Ciao \" + nome + \"!\" ); } public static void main ( String [] args ) { //richiamo del metodo, parametri attuali saluta ( \"Simone\" ); //Ciao Simone! saluta ( \"Matteo\" ); //Ciao Matteo! } } saluta \u00e8 il nome della funzione. void \u00e8 il tipo di ritorno della funzione. Il tipo void si utilizza quando la funzione non ritorna nessun valore. Un solo parametro \u00e8 definito ed \u00e8 un oggetto String Un altro esempio. In questo esempio aggiunger\u00f2 altri parametri per la stampa di una cornice al saluto, stabilendo la lunghezza della cornice: package mioTest ; public class prova01 { //parametri formali static void saluta ( String nome , char simbolo , int lunghezza ) { for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } System . out . print ( '\\n' ); System . out . println ( \"Ciao \" + nome + \"!\" ); for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } System . out . print ( '\\n' ); } public static void main ( String [] args ) { //richiamo del metodo, parametri attuali saluta ( \"Simone\" , '*' , 30 ); saluta ( \"Matteo\" , '-' , 20 ); } } /* output ****************************** Ciao Simone! ****************************** -------------------- Ciao Matteo! -------------------- */ Cambiando solo i parametri formali ottengo gi\u00e0 un risultato molto personalizzato.","title":"Chiamata di un metodo:"},{"location":"java/java-basic-module/#lezione-32","text":"","title":"Lezione 32"},{"location":"java/java-basic-module/#due-parole-sui-parametri","text":"I parametri formali, cio\u00e8 quelli dichiarati in fase di definizione del metodo, NON SONO VISIBILI ALL'ESTERNO . E' lo stesso concetto che vale anche per le variabili dichiarate nel ciclo for . package mioTest ; public class prova01 { //parametri formali static void saluta ( String nome , char simbolo , int lunghezza ) { for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } System . out . print ( '\\n' ); System . out . println ( \"Ciao \" + nome + \"!\" ); for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } System . out . print ( '\\n' ); } public static void main ( String [] args ) { System . out . print ( simbolo ); } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: simbolo cannot be resolved to a variable at mioTest.prova01.main(prova01.java:19) */ E' un problema? Assolutamente no! Anzi, ai fini di isolare un blocco di codice \u00e8 giusto che ogni variabile o parametro sia privato al metodo. Chi scrive il metodo deve solo preoccuparsi di produrre certi output dati certi input. Allo stesso modo, all'esterno del metodo, non ci dobbiamo assolutamente preoccupare di come sono state scritte le variabili o di come \u00e8 stato implementato il metodo. Ci dobbiamo solo preoccupare di utilizzare il metodo nel modo giusto! Un altro esempio. In queso esempio ottimizzer\u00f2 ancora il metodo dell'esercizio precedente scompattando il codice ulteriormente. Mano a mano che il codice viene frammentato le singole unit\u00e0 diventano pi\u00f9 semplici e facilmente debuggabili. package mioTest ; public class prova01 { static void stampaRiga ( char simbolo , int lunghezza , boolean aCapo ) { for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } if ( aCapo ) System . out . print ( '\\n' ); } //parametri formali static void saluta ( String nome , char simbolo , int lunghezza ) { stampaRiga ( simbolo , lunghezza , true ); System . out . println ( \"Ciao \" + nome + \"!\" ); stampaRiga ( simbolo , lunghezza , true ); } public static void main ( String [] args ) { saluta ( \"Simone\" , '*' , 30 ); saluta ( \"Matteo\" , '#' , 15 ); } } Ho aggiunto inoltre una funzionalit\u00e0 in pi\u00f9. Un parametro boolean che specifica se la stampa deve andare a capo oppure no. Troppi parametri a volte potrebbero essere semplicemente \"troppi\". Un metodo alternativo: package mioTest ; public class prova01 { static void stampaRiga ( char simbolo , int lunghezza ) { for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } } static void stampaRigaLn ( char simbolo , int lunghezza ) { for ( int i = 0 ; i < lunghezza ; i ++ ) { System . out . print ( simbolo ); } System . out . print ( '\\n' ); } //parametri formali static void saluta ( String nome , char simbolo , int lunghezza ) { stampaRigaLn ( simbolo , lunghezza ); System . out . println ( \"Ciao \" + nome + \"!\" ); stampaRigaLn ( simbolo , lunghezza ); } public static void main ( String [] args ) { saluta ( \"Simone\" , '*' , 30 ); saluta ( \"Matteo\" , '#' , 15 ); } } Questo \u00e8 un metodo che fa uso di un parametro in meno ma di una funzione in pi\u00f9 distinguendo stampaRiga() da stampaRigaLn() . La prima stampa una riga ma non va a capo, la seconda stampa una riga e va a capo. Cosa ci guadagno? In questo caso di semplicit\u00e0 e intuitivit\u00e0.","title":"due parole sui parametri"},{"location":"java/java-basic-module/#lezione-33","text":"Ancora un altro esempio.","title":"Lezione 33"},{"location":"java/java-basic-module/#return","text":"Nel prossimo esempio vedremo un tipo di ritorno diverso da void . Vedremo anche la parola chiave return che permette di restituire un volore all'esterno del tipo specificato in fase di dichiarazione. Con la seguente definizione di metodo: static String ripetiSimbolo ( char simbolo , int lunghezza ) { String riga = \"\" ; //.. code return riga ; } Sto assegnando come tipo di ritorno un oggeto di tipo String . la parola chiave return interrompe la funzione restiutendo il valore indiciato Vediamo un esempio: package mioTest ; public class prova01 { static String ripetiSimbolo ( char simbolo , int lunghezza ) { String riga = \"\" ; for ( int i = 0 ; i < lunghezza ; i ++ ) { riga += simbolo ; } return riga ; } //parametri formali static void saluta ( String nome , char simbolo , int lunghezza ) { String riga = ripetiSimbolo ( simbolo , lunghezza ); System . out . println ( riga ); System . out . println ( \"Ciao \" + nome + \"!\" ); System . out . println ( riga ); } public static void main ( String [] args ) { saluta ( \"Simone\" , '*' , 30 ); saluta ( \"Matteo\" , '#' , 15 ); } } Questo \u00e8 il la soluzione migliore (per adesso). Invece di stampare direttamente la riga ritorno una String che possono quindi mandare come argomento al metodo print() o println() . In questo caso non importa neanche la suddivisione tra la stampa della riga con o senza a capo , ci penser\u00e0 il metodo print() o println() . Di gran lunga molto pulito. Inoltre ritornando una String posso usare questa stringa per fare ci\u00f2 che voglio. Con la stamp diretta non ho questa flessibilit\u00e0, una votla stampato \u00e8 stampato e la sua funzionalit\u00e0 \u00e8 terminata. Un esempio ancora pi\u00f9 compatto: package mioTest ; public class prova01 { static String ripetiSimbolo ( char simbolo , int lunghezza ) { String riga = \"\" ; for ( int i = 0 ; i < lunghezza ; i ++ ) { riga += simbolo ; } return riga ; } //parametri formali static void saluta ( String nome , char simbolo , int lunghezza ) { System . out . println ( ripetiSimbolo ( simbolo , lunghezza )); System . out . println ( \"Ciao \" + nome + \"!\" ); System . out . println ( ripetiSimbolo ( simbolo , lunghezza )); } public static void main ( String [] args ) { saluta ( \"Simone\" , '*' , 30 ); saluta ( \"Matteo\" , '#' , 15 ); } }","title":"Return"},{"location":"java/java-basic-module/#lezione-34","text":"","title":"Lezione 34"},{"location":"java/java-basic-module/#qualche-approfondimento-sui-parametri","text":"I parametri in java vengono passati per valore . Ogni parametro o variabile creata all'interno della definizione di una funzione rimane privato alla funzione e non c'\u00e8 modo di confondersi. Anche se i parametri attuali coincidono (di nome) con i parametri formali, come spesso accade, deve essere chiaro che fanno riferimento a due variabili diverse. Vediamo un esempio: package mioTest ; public class prova01 { //parametri formali static void quadrato ( int n ) { n *= n ; System . out . println ( n ); } public static void main ( String [] args ) { int n = 10 ; System . out . println ( n ); //10 quadrato ( n ); //100 System . out . println ( n ); //10 } }","title":"Qualche approfondimento sui parametri"},{"location":"java/java-basic-module/#lezione-35","text":"","title":"Lezione 35"},{"location":"java/java-basic-module/#array","text":"Un array \u00e8 un contenitore in grado di memorizzare un numero fisso di valori di un singolo tipo. La lunghezza di un array viene stabilita quando viene creato l'array. Dopo la creazione, la sua lunghezza \u00e8 fissata. Ogni elemento in un array \u00e8 chiamato elemento e si accede a ciascun elemento tramite il suo indice numerico. Come mostrato in figura, la numerazione inizia con 0. Il nono elemento, ad esempio, sarebbe quindi accessibile dall'indice 8. Un esempio di dichiarazione di un array //array di interi, la lunghezza \u00e8 4 //indice 0 1 2 3 int [] myNum = { 10 , 20 , 30 , 40 }; //array di String, la lunghezza \u00e8 4 //indice 0 1 2 3 String [] cars = { \"Volvo\" , \"BMW\" , \"Ford\" , \"Mazda\" }; Vediamo adesso come si accede in lettura ad un elemento di un array. package mioTest ; public class prova01 { public static void main ( String [] args ) { //array di interi //indice 0 1 2 3 int [] myNum = { 10 , 20 , 30 , 40 }; //array di String //indice 0 1 2 3 String [] cars = { \"Volvo\" , \"BMW\" , \"Ford\" , \"Mazda\" }; System . out . println ( cars [ 1 ] ); //BMW System . out . println ( myNum [ 3 ] ); //40 } } Vediamo adesso come accedere in scrittura agli elementi di un array. package mioTest ; public class prova01 { public static void main ( String [] args ) { //array di interi // 0 1 2 3 int [] myNum = { 10 , 20 , 30 , 40 }; //array di String // 0 1 2 3 String [] cars = { \"Volvo\" , \"BMW\" , \"Ford\" , \"Mazda\" }; //Accesso in scrittura ad un elemento di un array cars [ 1 ] = \"Mercedes\" ; myNum [ 3 ] = 140 ; System . out . println ( cars [ 1 ] ); //Mercedes System . out . println ( myNum [ 3 ] ); //140 } } Vediamo un esercizio. Nel seguente esercizio riempir\u00f2 un array di 5 numeri decimali casuali che rappresentano l'incasso settimanale di una ipotetica azienda. Per ogni giorno della settimana stamper\u00f2 l'incasso giornaliero e il parziale settimanale. Random r = new Random(); : Genera un oggetto di nome r della classe Random . Il metodo nextDouble() della classe Random genera un numero decimale casuale nel range [0, 1] package mioTest ; import java.util.Random ; public class prova01 { public static void main ( String [] args ) { Random r = new Random (); double totaleIncassi = 0 ; double [] incassiGiornalieri = new double [ 30 ] ; System . out . println ( \"Incassi dell'azienda Super inc\" ); System . out . println ( \"************************************************\" ); for ( int giorno = 0 ; giorno < 5 ; giorno ++ ) { incassiGiornalieri [ giorno ] = r . nextDouble () * 1000 ; System . out . print ( \"Incasso del giorno \" + ( giorno + 1 ) + \" vale: \" + incassiGiornalieri [ giorno ] ); totaleIncassi += incassiGiornalieri [ giorno ] ; System . out . println ( \"\\nTotale incassi al giorno \" + ( giorno + 1 ) + \": \" + totaleIncassi + '\\n' ); } } } /* Incassi dell'azienda Super inc ************************************************ Incasso del giorno 1 vale: 591.9943669250713 Totale incassi al giorno 1: 591.9943669250713 Incasso del giorno 2 vale: 361.53919223504084 Totale incassi al giorno 2: 953.5335591601122 Incasso del giorno 3 vale: 470.24992212457863 Totale incassi al giorno 3: 1423.7834812846909 Incasso del giorno 4 vale: 308.06054288474604 Totale incassi al giorno 4: 1731.844024169437 Incasso del giorno 5 vale: 893.9369612336028 Totale incassi al giorno 5: 2625.7809854030397 */ Nel prossimo esempio incapsuler\u00f2 la generazione di un numero casuale in un metodo aggiungendo la possibilit\u00e0 di esprimere un range. randomDouble(param1, param2) : Genera un numero decimale casuale nel range [param1, param2] package mioTest ; import java.util.Random ; public class prova01 { static double randomDouble ( double minValue , double maxValue ) { double ris = 0d ; Random r = new Random (); ris = r . nextDouble () * ( maxValue - minValue ) + minValue ; return ris ; } public static void main ( String [] args ) { double totaleIncassi = 0 ; double [] incassiGiornalieri = new double [ 5 ] ; System . out . println ( \"Incassi dell'azienda Super inc\" ); System . out . println ( \"************************************************\" ); for ( int giorno = 0 ; giorno < 5 ; giorno ++ ) { incassiGiornalieri [ giorno ] = randomDouble ( 0 , 1000 ); System . out . print ( \"Incasso del giorno \" + ( giorno + 1 ) + \" vale: \" + incassiGiornalieri [ giorno ] ); totaleIncassi += incassiGiornalieri [ giorno ] ; System . out . println ( \"\\nTotale incassi al giorno \" + ( giorno + 1 ) + \": \" + totaleIncassi + '\\n' ); } } } /* Incassi dell'azienda Super inc ************************************************ Incasso del giorno 1 vale: 744.9914581441986 Totale incassi al giorno 1: 744.9914581441986 Incasso del giorno 2 vale: 783.3932124466809 Totale incassi al giorno 2: 1528.3846705908795 Incasso del giorno 3 vale: 769.2791383491912 Totale incassi al giorno 3: 2297.663808940071 Incasso del giorno 4 vale: 493.77024887651777 Totale incassi al giorno 4: 2791.4340578165884 Incasso del giorno 5 vale: 136.12792423533682 Totale incassi al giorno 5: 2927.561982051925 */ Nel prossimo esempio aggiungeremo la possibilit\u00e0 di calcolare la media e i giorni in cui l'incasso \u00e8 sotto la media. package mioTest ; import java.util.Random ; public class prova01 { static double randomDouble ( double minValue , double maxValue ) { double ris = 0d ; Random r = new Random (); ris = r . nextDouble () * ( maxValue - minValue ) + minValue ; return ris ; } public static void main ( String [] args ) { double mediaIncassi = 0 ; double totaleIncassi = 0 ; double [] incassiGiornalieri = new double [ 5 ] ; System . out . println ( \"Incassi dell'azienda Super inc\" ); System . out . println ( \"************************************************\" ); //inserisco gli incassi giornalieri e stampo il parziale for ( int giorno = 0 ; giorno < 5 ; giorno ++ ) { incassiGiornalieri [ giorno ] = randomDouble ( 0 , 1000 ); System . out . print ( \"Incasso del giorno \" + ( giorno + 1 ) + \" vale: \" + incassiGiornalieri [ giorno ] ); totaleIncassi += incassiGiornalieri [ giorno ] ; System . out . println ( \"\\nTotale incassi al giorno \" + ( giorno + 1 ) + \": \" + totaleIncassi + '\\n' ); } //calcolo la media mediaIncassi = totaleIncassi / 5 ; //Stampo i giorni della settimana in cui l'incasso \u00e8 risultato inferiore all media System . out . print ( \"Incasso inferiore alla media nei giorni: \" ); for ( int giorno = 0 ; giorno < 5 ; giorno ++ ) { if ( incassiGiornalieri [ giorno ] < mediaIncassi ) System . out . print ( ( giorno + 1 ) + \", \" ); } } } /* output --- --- --- --- --- --- --- --- --- --- Incassi dell'azienda Super inc ************************************************ Incasso del giorno 1 vale: 267.3356741835512 Totale incassi al giorno 1: 267.3356741835512 Incasso del giorno 2 vale: 686.4601921175105 Totale incassi al giorno 2: 953.7958663010617 Incasso del giorno 3 vale: 610.6233133806691 Totale incassi al giorno 3: 1564.4191796817308 Incasso del giorno 4 vale: 87.57257150511832 Totale incassi al giorno 4: 1651.9917511868491 Incasso del giorno 5 vale: 513.5065433416011 Totale incassi al giorno 5: 2165.49829452845 la media degli incassi vale:433.09965890569003 Incasso inferiore alla media nei giorni: 1, 4, */","title":"Array"},{"location":"java/java-basic-module/#lezione-36","text":"","title":"Lezione 36"},{"location":"java/java-basic-module/#errori-con-gli-array","text":"Una volta definito un array, la dimensione \u00e8 stabilit\u00e0, non si possono aggiungere, togliere elementi o scrivere/leggere elementi al di fuori del range di un array. In particolare: E' un errore di compilazione se tenti di accedere ad un indice negativo package mioTest ; public class prova01 { public static void main ( String [] args ) { int [] myArr = new int [ 5 ] ; myArr [- 1 ] = 12 ; } } /* Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 5 at mioTest.prova01.main(prova01.java:7) */ E' un erroro di compilazione se tenti di accedere ad un elemento pi\u00f9 grande della grandezza dell'array. Attenzione che se la lunghezza di un array \u00e8 pari a 5 gli elementi sono elencati nel range [0 - 4] package mioTest ; public class prova01 { public static void main ( String [] args ) { int [] myArr = new int [ 5 ] ; myArr [ 8 ] = 12 ; } } /* Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 8 out of bounds for length 5 at mioTest.prova01.main(prova01.java:7) */ Per concludere aggiungo l'algoritmo per vedere se ci sono due giorni consecutivi con incasso inferiore alla media","title":"Errori con gli array"},{"location":"java/java-basic-module/#lezione-37","text":"","title":"Lezione 37"},{"location":"java/java-basic-module/#approfondimento-input-tastiera","text":"Per la gestione dei dati in input da tastiera \u00e8 necessario importare il modulo java.io.* . Il carattere * \u00e8 necessario per prelevare tutti i package del modulo java.io . La classe InputStreamReader rappresenta una classe per la lettura di un byte (non necessariamente da tastiera, per esempio anche su file). Inizializzando un oggetto della classe InputStreamReader con l'oggetto System.in consento all'oggetto di leggere dati da tastiera tramite il metodo read() . Ma non basta... package mioTest ; import java.io.* ; public class prova01 { public static void main ( String [] args ) { //InputStreamReader = flusso di byte in lettura //La tastiera \u00e8 definita in System.in InputStreamReader tastiera = new InputStreamReader ( System . in ); System . out . println ( \"Inserisci un carattere e premi INVIO\" ); int myInt = tastiera . read (); } } /* output Exception in thread \"main\" java . lang . Error : Unresolved compilation problem : Unhandled exception type IOException at mioTest . prova01 . main ( prova01 . java : 14 ) Il compilatore riporta l'errore Unhandled exception type IOException , ovvero.. Non hai gestito un eventuale errore del tipo IOException . Eclispe suggerisce anche una soluzione","title":"Approfondimento Input tastiera"},{"location":"java/java-basic-module/#lezione-38","text":"","title":"Lezione 38"},{"location":"java/java-basic-module/#costrutto-try-catch","text":"Durante l'esecuzione del codice Java, possono verificarsi diversi errori: errori di codifica commessi dal programmatore, errori dovuti a un input errato o altre cose imprevedibili. Quando si verifica un errore, Java normalmente si interrompe e genera un messaggio di errore. Il termine tecnico per questo \u00e8: Java generer\u00e0 un'eccezione (generer\u00e0 un errore). L'istruzione try consente di definire un blocco di codice da verificare durante l'esecuzione. L'istruzione catch consente di definire un blocco di codice da eseguire, se si verifica un errore nel blocco try. try { //codeA -> Da verificare } catch ( Type e ) { //codeB -> solo se codeA ha rilevato un errore del tipo specificato da Type } Vediamolo in azione: package mioTest ; import java.io.* ; public class prova01 { public static void main ( String [] args ) { //InputStreamReader = flusso di byte in lettura //La tastiera \u00e8 definita in System.in InputStreamReader tastiera = new InputStreamReader ( System . in ); int myInt = 0 ; System . out . println ( \"Inserisci un carattere e premi INVIO\" ); //Gestione dell'errore try { myInt = tastiera . read (); } catch ( IOException e ) { // TODO Auto-generated catch block e . printStackTrace (); } System . out . println ( \"Il carattere ASCII corrsipondente \u00e9: \" + myInt ); } } Attenzione Ho dovuto definire fuori dal blocco try la variabile myInt per una questione di visibilit\u00e0 all'esterno. La classe InputStreamReader permette la lettura di un byte alla volta. Nel prossimo esempio vedremo come leggere un'intera riga attraverso l'uso di BufferdReader . La classe BufferedReader prende come parametro di inizializzazione un oggetto della classe InputStreamReader e forma un buffer, cio\u00e8 consente l'acquisizione da tastiera di una serie di caratteri. Termina l'acquisizione premendo INVIO package mioTest ; import java.io.* ; public class prova01 { public static void main ( String [] args ) { //InputStreamReader = flusso di byte in lettura //La tastiera \u00e8 definita in System.in InputStreamReader tastiera = new InputStreamReader ( System . in ); BufferedReader bufferedTastiera = new BufferedReader ( tastiera ); System . out . println ( \"Inserisci una frase e premi INVIO\" ); String myString = \"\" ; try { myString = bufferedTastiera . readLine (); } catch ( IOException e ) { // TODO Auto-generated catch block e . printStackTrace (); } System . out . println ( \"la frase inserita e: \" + myString ); } } /* output Inserisci una frase e premi INVIO ciao a tutti quanti la frase inserita e: ciao a tutti quanti */","title":"Costrutto try catch"},{"location":"java/java-basic-module/#lezione-39","text":"","title":"Lezione 39"},{"location":"java/java-basic-module/#esercizio-calcolo-interesse-con-input-da-tastiera-parte-1","text":"In questa nuova versione ho aggiunto la possibilit\u00e0 di leggere i dati da tastiera esportando il metodo : leggiDouble(String mainMessage , double minValue, double maxValue) che: Chiede un dato da tastiera stampando il messaggio passato come String e come primo parametro ( mainMessage ) rileva un errore di formato attraverso il costrutto try ... catch e stampa \"Formato non corretto! Riprova..\" rileva un errore se il numero inserito non \u00e8 compreso tra minValue , maxValue passati rispettivamente come terzo e quarto parametro e stampa il messaggio d'errore \"Valore non appartenente al range: [\"minValue\" - \"maxValue\"]\" . Ritorna il valore double acquisito da tastiera solo se non ci sono errori altrimenti chiede un nuovo dato da tasiera finch\u00e8 non ci sono errori. package mioTest ; import java.io.* ; public class prova01 { static double leggiDouble ( String mainMessage , double minValue , double maxValue ) { InputStreamReader tastiera = new InputStreamReader ( System . in ); BufferedReader bufferedTastiera = new BufferedReader ( tastiera ); String rigaLetta = \"\" ; String formatErrorMessage = \"Formato non corretto! Riprova..\" ; String rangeErrorMessage = \"Valore non appartenente al range\" ; double doubleLetto = 0 ; double risultato = 0 ; boolean error = false ; do { error = false ; try { System . out . println ( mainMessage ); rigaLetta = bufferedTastiera . readLine (); doubleLetto = Double . parseDouble ( rigaLetta ); } catch ( IOException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } catch ( NumberFormatException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } if ( ( doubleLetto < minValue ) || ( doubleLetto > maxValue ) ) { error = true ; System . out . println ( rangeErrorMessage ); continue ; } else { risultato = doubleLetto ; } } while ( error ); return risultato ; } public static void main ( String [] args ) { double sommaIniziale = 0 ; double sommaFinale = 0 ; double percentualeInteresse = 0 ; int anniDeposito = 0 ; sommaIniziale = leggiDouble ( \"Inserisci la somma iniziale: \" , 100 , 1000 ); percentualeInteresse = leggiDouble ( \"Inserisci la percentuale di interesse: \" , 1 , 5 ); System . out . println ( \"---\" ); System . out . println ( \"Somma Iniziale: \" + sommaIniziale ); System . out . println ( \"Percentuale di interesse: \" + percentualeInteresse ); System . out . println ( \"---\" ); } }","title":"Esercizio calcolo interesse con input da tastiera parte 1"},{"location":"java/java-basic-module/#lezione-40","text":"","title":"Lezione 40"},{"location":"java/java-basic-module/#buffered-reader-vs-scanner","text":"Sono differenza perlopi\u00f9 dal punto di vista hardware. BufferedReader : - E' una struttura meno sempplice - legge qualsiasi tipo di dato - thread safe Scanner : - \u00e8 una struttura pi\u00f9 semplice - non \u00e8 thread safe Vediamo lo stesso esempio utilizzando la classe Scanner package mioTest ; import java.io.* ; import java.util.InputMismatchException ; import java.util.Scanner ; public class prova01 { static double leggiDouble ( String mainMessage , double minValue , double maxValue ) { Scanner sc = new Scanner ( System . in ); String formatErrorMessage = \"Formato non corretto! Riprova..\" ; String rangeErrorMessage = \"Valore non appartenente al range: \" ; double doubleLetto = 0 ; double risultato = 0 ; boolean error = false ; do { error = false ; try { System . out . println ( mainMessage ); doubleLetto = sc . nextDouble (); } catch ( InputMismatchException e ) { error = true ; System . out . println ( formatErrorMessage ); //Necessario perch\u00e8 il metodo nextDouble() non toglie il dato dalla tatiera //Al ciclo successivo quindi se c'\u00e8 un errore andrebbe a rileggerlo e continuerebbe cos\u00ec all'infinito //nextLine() scarta il dato memorizzato leggendo la prossima linea sc . nextLine (); continue ; } if ( ( doubleLetto < minValue ) || ( doubleLetto > maxValue ) ) { error = true ; System . out . println ( rangeErrorMessage + '[' + minValue + \" - \" + maxValue + ']' ); continue ; } else { risultato = doubleLetto ; } } while ( error ); return risultato ; } public static void main ( String [] args ) { double sommaIniziale = 0 ; double sommaFinale = 0 ; double percentualeInteresse = 0 ; int anniDeposito = 0 ; sommaIniziale = leggiDouble ( \"Inserisci la somma iniziale: \" , 100 , 1000 ); percentualeInteresse = leggiDouble ( \"Inserisci la percentuale di interesse: \" , 1 , 5 ); System . out . println ( \"---\" ); System . out . println ( \"Somma Iniziale: \" + sommaIniziale ); System . out . println ( \"Percentuale di interesse: \" + percentualeInteresse ); System . out . println ( \"---\" ); } } La classe Scanner ha anche altri metodi molto ultili sulla lettura dei dati. Vediamo un esmpio. package mioTest ; import java.io.* ; import java.util.InputMismatchException ; import java.util.Scanner ; public class prova01 { static double leggiDouble ( String mainMessage , double minValue , double maxValue ) { Scanner sc = new Scanner ( System . in ); String formatErrorMessage = \"Formato non corretto! Riprova..\" ; String rangeErrorMessage = \"Valore non appartenente al range: \" ; double doubleLetto = 0 ; double risultato = 0 ; boolean error = false ; do { error = false ; System . out . println ( mainMessage ); if ( sc . hasNextDouble () ) { doubleLetto = sc . nextDouble (); } else { System . out . println ( formatErrorMessage ); error = true ; sc . nextLine (); continue ; } if ( ( doubleLetto < minValue ) || ( doubleLetto > maxValue ) ) { error = true ; System . out . println ( rangeErrorMessage + '[' + minValue + \" - \" + maxValue + ']' ); continue ; } else { risultato = doubleLetto ; } } while ( error ); return risultato ; } public static void main ( String [] args ) { double sommaIniziale = 0 ; double sommaFinale = 0 ; double percentualeInteresse = 0 ; int anniDeposito = 0 ; sommaIniziale = leggiDouble ( \"Inserisci la somma iniziale: \" , 100 , 1000 ); percentualeInteresse = leggiDouble ( \"Inserisci la percentuale di interesse: \" , 1 , 5 ); System . out . println ( \"---\" ); System . out . println ( \"Somma Iniziale: \" + sommaIniziale ); System . out . println ( \"Percentuale di interesse: \" + percentualeInteresse ); System . out . println ( \"---\" ); } } Metodo alternativo: In questo metodo alternativo per\u00f2 c'\u00e8 un bug! Il bug \u00e8 che inserendo parole spezzate dallo spazio genera degli errori..... package mioTest ; import java.io.* ; import java.util.InputMismatchException ; import java.util.Scanner ; public class prova01 { static double leggiDouble ( String mainMessage , double minValue , double maxValue ) { Scanner sc = new Scanner ( System . in ); String formatErrorMessage = \"Formato non corretto! Riprova..\" ; String rangeErrorMessage = \"Valore non appartenente al range: \" ; double doubleLetto = 0 ; double risultato = 0 ; boolean error = false ; do { error = false ; System . out . println ( mainMessage ); //Comtrollo Errore di formato while ( ! sc . hasNextDouble () ) { System . out . println ( formatErrorMessage ); sc . nextLine (); } //Passato il controllo del formato doubleLetto = sc . nextDouble (); //Controllo Range if ( ( doubleLetto < minValue ) || ( doubleLetto > maxValue ) ) { error = true ; System . out . println ( rangeErrorMessage + '[' + minValue + \" - \" + maxValue + ']' ); } else { risultato = doubleLetto ; } } while ( error ); return risultato ; } public static void main ( String [] args ) { double sommaIniziale = 0 ; double sommaFinale = 0 ; double percentualeInteresse = 0 ; int anniDeposito = 0 ; sommaIniziale = leggiDouble ( \"Inserisci la somma iniziale: \" , 100 , 1000 ); percentualeInteresse = leggiDouble ( \"Inserisci la percentuale di interesse: \" , 1 , 5 ); System . out . println ( \"---\" ); System . out . println ( \"Somma Iniziale: \" + sommaIniziale ); System . out . println ( \"Percentuale di interesse: \" + percentualeInteresse ); System . out . println ( \"---\" ); } }","title":"Buffered reader Vs Scanner"},{"location":"java/java-basic-module/#lezione-41","text":"","title":"Lezione 41"},{"location":"java/java-basic-module/#regular-expression","text":"Il metodo hasNext() permette l'inserimento di un RegEpr , un'espressione regolare cio\u00e8 un'espressione in grado di effettuare dei controlli sul flusso di dati ricevuti. package mioTest ; import java.util.Scanner ; public class prova01 { public static String leggiNumeroDiTelefono () { try ( Scanner sc = new Scanner ( System . in )) { System . out . print ( \"Inserisci un numero telefonico: \" ); while ( ! sc . hasNext ( \"[0-9]{3,4}\\\\-[0-9]{6,7}\" )) { System . out . println ( \"Formato errato! Riprova ...\" ); sc . hasNext (); } return sc . next (); } } public static void main ( String [] args ) { System . out . println ( leggiNumeroDiTelefono () ); } } L'espressione regolare: [0-9]{3,4}\\\\-[0-9]{6,7} controlla: - il numero deve iniziare con una serie di 3 o 4 cifre comprese nel range 0-9 - deve essere seguito dal simbolo - (il simbolo \\\\ \u00e8 un escape, serve solo per permettere di leggere il trattino - ) successivamente che il numero prosegua con un min - deve concludere con una serie di 6 o 7 cifre comprese nel range 0-9","title":"Regular expression"},{"location":"java/java-basic-module/#lezione-42","text":"","title":"Lezione 42"},{"location":"java/java-basic-module/#esercizio-calcolo-interesse-con-input-da-tastiera-parte-2","text":"Ripartiamo con l'esercizio: package mioTest ; import java.io.* ; public class prova01 { static double leggiDouble ( String mainMessage , double minValue , double maxValue ) { InputStreamReader tastiera = new InputStreamReader ( System . in ); BufferedReader bufferedTastiera = new BufferedReader ( tastiera ); String rigaLetta = \"\" ; String formatErrorMessage = \"Formato non corretto! Riprova..\" ; String rangeErrorMessage = \"Valore non appartenente al range\" ; double doubleLetto = 0 ; double risultato = 0 ; boolean error = false ; do { error = false ; try { System . out . println ( mainMessage ); rigaLetta = bufferedTastiera . readLine (); doubleLetto = Double . parseDouble ( rigaLetta ); } catch ( IOException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } catch ( NumberFormatException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } if ( ( doubleLetto < minValue ) || ( doubleLetto > maxValue ) ) { error = true ; System . out . println ( rangeErrorMessage ); continue ; } else { risultato = doubleLetto ; } } while ( error ); return risultato ; } public static void main ( String [] args ) { double sommaIniziale = 0 ; double sommaFinale = 0 ; double percentualeInteresse = 0 ; int anniDeposito = 0 ; sommaIniziale = leggiDouble ( \"Inserisci la somma iniziale: \" , 100 , 1000 ); percentualeInteresse = leggiDouble ( \"Inserisci la percentuale di interesse: \" , 1 , 5 ); System . out . println ( \"---\" ); System . out . println ( \"Somma Iniziale: \" + sommaIniziale ); System . out . println ( \"Percentuale di interesse: \" + percentualeInteresse ); System . out . println ( \"---\" ); } } Concludo l'esercizio: package mioTest ; import java.io.* ; public class prova01 { static double leggiDouble ( String mainMessage , double minValue , double maxValue ) { InputStreamReader tastiera = new InputStreamReader ( System . in ); BufferedReader bufferedTastiera = new BufferedReader ( tastiera ); String rigaLetta = \"\" ; String formatErrorMessage = \"Formato non corretto! Riprova..\" ; String rangeErrorMessage = \"Valore non appartenente al range\" ; double doubleLetto = 0 ; double risultato = 0 ; boolean error = false ; do { error = false ; try { System . out . println ( mainMessage ); rigaLetta = bufferedTastiera . readLine (); doubleLetto = Double . parseDouble ( rigaLetta ); } catch ( IOException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } catch ( NumberFormatException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } if ( ( doubleLetto < minValue ) || ( doubleLetto > maxValue ) ) { error = true ; System . out . println ( rangeErrorMessage ); continue ; } else { risultato = doubleLetto ; } } while ( error ); return risultato ; } public static int leggiInt ( String mainMessage ) { InputStreamReader tastiera = new InputStreamReader ( System . in ); BufferedReader bufferedTastiera = new BufferedReader ( tastiera ); String rigaLetta = \"\" ; String formatErrorMessage = \"Formato non corretto! Riprova..\" ; int intLetto = 0 ; boolean error = false ; do { error = false ; try { System . out . println ( mainMessage ); rigaLetta = bufferedTastiera . readLine (); intLetto = Integer . parseInt ( rigaLetta ); } catch ( IOException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } catch ( NumberFormatException e ) { error = true ; System . out . println ( formatErrorMessage ); continue ; } } while ( error ); return intLetto ; } public static void main ( String [] args ) { double sommaIniziale = 0 ; double sommaFinale = 0 ; double percentualeInteresse = 0 ; int anniDeposito = 0 ; sommaIniziale = leggiDouble ( \"Inserisci la somma iniziale: \" , 100 , 1000 ); percentualeInteresse = leggiDouble ( \"Inserisci la percentuale di interesse: \" , 1 , 5 ); anniDeposito = leggiInt ( \"Durata in anni del deposito: \" ); System . out . println ( \"---\" ); System . out . println ( \"Somma Iniziale: \" + sommaIniziale ); System . out . println ( \"Percentuale di interesse: \" + percentualeInteresse ); System . out . println ( \"Durata in anni del deposito: \" + anniDeposito ); System . out . println ( \"---\" ); sommaFinale = sommaIniziale ; while ( anniDeposito > 0 ) { sommaFinale = sommaFinale + sommaFinale / 100 * percentualeInteresse ; anniDeposito = anniDeposito - 1 ; } System . out . println ( \"Hai ora in banca: \" + sommaFinale + \" euro.\" ); System . out . println ( \"fine..\" ); } }","title":"Esercizio calcolo interesse con input da tastiera parte 2"},{"location":"java/java-oop-module/","text":"Java OOP Java OOP Lezione 01 Perch\u00e8 la OOP? Lezione 02 Creiamo una classe Lezione 03 Getter e setter Lezione 04 - Getter e setter all'interno del costruttore Lezione 05 Cotruttore o costruttori? Lezione 01 Perch\u00e8 la OOP? Considerazioni generali del passaggio dal paradigma funzionale a quello dell OOP. Alcuni esempi sono la portabilit\u00e0, l'estensione del codice o dei pezzi di codice. I dati non devono essere separate dalle funzioni che le utilizzano In generale invece una classe contiene: i dati utilizzabili solo dalla classe o dai metodi i metodi, cio\u00e8 le funzioni che quella clase offre La classe incapsula quindi tutto il necessario. Non \u00e8 possibile accedere a dati o metodi senza prima chimare la classe. Ereditariet\u00e0 Per derivare delle classi simili riutilizzando quindi il codice \u00e8 possibile utilizzare il concetto di ereditariet\u00e0. Dopodich\u00e8, se c'\u00e8 la necessit\u00e0 di aggiungere dei metodi o dei dati o cambiare l'implementazione di qualche metodo \u00e8 possibile farlo semplicemente ridefinendola all'interno. In genere quando si scrive crea una nuova classe si fa in un file separato ma non \u00e8 obbligatorio. In eclipse puoi quindi creare un nuovo file class Packages Java Il meccanismo dei package incapsula un'insieme di classi. All'interno di ogni package posso creare strutture dati, classi che non interferiranno a livello di nomi (un po' come il concetto del namespace) all'esterno. Se all'interno di un progetto creo due package e magari questi due package hanno delle classi in comune, cio\u00e8 con lo stesso nome il compilatore riesce a distinguerli grazie al meccanismo di separazione dei package. L'assemblaggio dei package poi crea l'applicazione Di default Eclipse crea un package default package . Per accedere a una classe di un modello esterno devo esplicitare il nome del package prima del nome della classe A livello di struttura di cartelle, le classi all'interno del packege di default sono situate nella root del progetto, folder src mentre gli altri package sono situati in subfolder Lezione 02 Creiamo una classe All'interno del file Punto.java che rappresenta la classe Punto posso iniziare a popolarla dichiarando le variabili interne: //Punto.java public class Punto { //stato interno int x = 0 ; int y = 0 ; } A questo punto (scusa il gioco di parole) posso instanziare una variabile di tipo Punto nel main o meglio instanziare un oggetto appartenente alla classe Punto //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 ; } } Attenzione!! L'oggetto appena creato p1 , appartenente alla classe Punto \u00e8 solo un riferimento alla classe Punto . E' un puntatore mascherato ma di fatto l'oggetto p1 non esiste ancora. Per creare un oggetto devo chiamare il costruttore //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 ; //Chiamo il costruttore, creando di fatto l'oggetto p1 = new Punto (); //A questo punto posso accedere a dati e metodi p1 . x = 123 ; p1 . y = 234 ; } } Attenzione!! Non \u00e8 buona pratica consentire l'utilizzo e la modifica dei dati interni di una classe. Dovremmo essere in grado di agire solo a livello di metodi e nascondere lo stato interno. Per rendere private le variabile interne della classe, si usa la keyword private //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; } a Questo punto nel main si solleva un'eccezione. Non posso accedere alle strutture interne ed \u00e8 un bene, devo proteggerle! //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 ; //Chiamo il costruttore, creando di fatto l'oggetto p1 = new Punto (); p1 . x = 123 ; p1 . y = 234 ; } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problems: The field Punto.x is not visible The field Punto.y is not visible */ Per accedere alle strutture interne dovr\u00f2 affidarmi ai metodi pubblici offerti dalla classe. In particolare adesso vedremo come creare un Costruttore Un cotruttore \u00e8 un metodo pubblico, quindi esportabile all'esterno che ha lo stesso nome della classe, invocato dal costrutto new . Vediamo un semplice esempio (in questo caso non molto utile) //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore //deve avere lo stesso nome della classe //assegna un valore alle variabili interne x e y public Punto ( int _x , int _y ) { x = _x ; y = _y ; } } Un metodo alternativo molto utilizzato: //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore //deve avere lo stesso nome della classe public Punto ( int x , int y ) { this . x = x ; this . y = y ; } } this serve per discriminare i parametri del costruttore (o metodo che sia) dalle variabili dello stato interno. In particolare this.x accede alla variabile dello stato interno x mentre this.y accede alle variabili dello stato interno y dal punto di vista del main: //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 ; //Chiamo il costruttore, creando di fatto l'oggetto p1 = new Punto ( 23 , 45 ); } } Durante la creazione passo i parametri che verranno assegnati alle variabili dello stato interno x, y Lezione 03 Getter e setter Un altro modo, oltre all'uso del costruttore \u00e8 quello di utilizzare dei particolari metodi chiamati getter e setter utilizzati rispettivamente per la lettura e scrittura delle variabili interne ma sempre attraverso un metodo pubblico //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore //deve avere lo stesso nome della classe public Punto ( int x , int y ) { this . x = x ; this . y = y ; } //setter public void setX ( int _x ) { x = _x ; } //getter public int getX () { return x ; } } Getter e Setter sono dei metodi quindi posso invocarli in ogni punto del programma per leggere e scrivere le variabili dello stato interno della classe. //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 ; //Chiamo il costruttore, creando di fatto l'oggetto p1 = new Punto ( 23 , 45 ); //Chiamo il getter (\u00e8 un metodo) per la lettura della coordinata x int myX = p1 . getX (); System . out . println ( myX ); //23 //Chiamo il setter (\u00e8 un metodo) per la scrittura della coordinata x p1 . setX ( 34 ); myX = p1 . getX (); System . out . println ( myX ); //34 } } Eclipse ti aiuta a scrivere in modo automatico i getter/setter: Dopodich\u00e8 nel codice troverai: //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore //deve avere lo stesso nome della classe public Punto ( int x , int y ) { this . x = x ; this . y = y ; } //setter public void setX ( int _x ) { x = _x ; } //getter public int getX () { return x ; } public int getY () { return y ; } public void setY ( int y ) { this . y = y ; } } E' bene abituarsi all'uso di this , \u00e8 un metodo pi\u00f9 sicuro riporto il main //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 ; //Chiamo il costruttore, creando di fatto l'oggetto p1 = new Punto ( 23 , 45 ); //Chiamo il getter (\u00e8 un metodo) per la lettura della coordinata x int myX = p1 . getX (); System . out . println ( myX ); //23 //Chiamo il setter (\u00e8 un metodo) per la scrittura della coordinata x p1 . setX ( 34 ); myX = p1 . getX (); System . out . println ( myX ); //34 System . out . println ( p1 . getY ()); //45 } } Lezione 04 Getter e setter all'interno del costruttore Spesso si utilizzano le chiamate a getter e setter proprio all'interno del costruttore Durante la wizard di costruzione del getter e setter di eclipse infatti c'\u00e8 l'opzione per usare i getter e setter nella definizione (quindi nel costruttore) oppure no: Partiamo da questa situazione: //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore public Punto ( int x , int y ) { this . x = x ; this . y = y ; } } A questo punto applicando la procedura wizard mantenendo Field access in declaring type: use setter and getter alla fine avremo: //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore public Punto ( int x , int y ) { this . setX ( x ); this . setY ( y ); } public int getX () { return x ; } public void setX ( int x ) { this . x = x ; } public int getY () { return y ; } public void setY ( int y ) { this . y = y ; } } Lezione 05 Cotruttore o costruttori? Posso avere pi\u00f9 di un costruttore basta che la signature sia diversa. Il costruttore che ho dichiarato per adesso ha due parametri, prende in ingresso due interi x, y . Realizzando una signature diversa posso realizzare pi\u00f9 costruttori. Nell'esempio creer\u00f2 un signature diversa a un solo parametro //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore 1 public Punto ( int x , int y ) { this . setX ( x ); this . setY ( y ); } //Cotruttore 2 public Punto ( int x ) { this . setX ( x ); this . setY ( 0 ); } //getter x public int getX () { return x ; } //setter x public void setX ( int x ) { this . x = x ; } //getter y public int getY () { return y ; } //setter y public void setY ( int y ) { this . y = y ; } } Nel main: //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 , p2_asseX ; //Chiamo il costruttore a due parametri p1 = new Punto ( 23 , 45 ); //Chiama il costruttore a un parametro p2_asseX = new Punto ( 10 ); } } Attenzione!! la signatura comprende solo il Nome di una funzione (o del metodo) il numero dei parametri e il tipo ma NON IL NOME , non potrei quindi analogamente richiamare un costruttore con un solo parametro intero per la coordinata y","title":"Java OOP"},{"location":"java/java-oop-module/#java-oop","text":"Java OOP Lezione 01 Perch\u00e8 la OOP? Lezione 02 Creiamo una classe Lezione 03 Getter e setter Lezione 04 - Getter e setter all'interno del costruttore Lezione 05 Cotruttore o costruttori?","title":"Java OOP"},{"location":"java/java-oop-module/#lezione-01","text":"","title":"Lezione 01"},{"location":"java/java-oop-module/#perche-la-oop","text":"Considerazioni generali del passaggio dal paradigma funzionale a quello dell OOP. Alcuni esempi sono la portabilit\u00e0, l'estensione del codice o dei pezzi di codice. I dati non devono essere separate dalle funzioni che le utilizzano In generale invece una classe contiene: i dati utilizzabili solo dalla classe o dai metodi i metodi, cio\u00e8 le funzioni che quella clase offre La classe incapsula quindi tutto il necessario. Non \u00e8 possibile accedere a dati o metodi senza prima chimare la classe. Ereditariet\u00e0 Per derivare delle classi simili riutilizzando quindi il codice \u00e8 possibile utilizzare il concetto di ereditariet\u00e0. Dopodich\u00e8, se c'\u00e8 la necessit\u00e0 di aggiungere dei metodi o dei dati o cambiare l'implementazione di qualche metodo \u00e8 possibile farlo semplicemente ridefinendola all'interno. In genere quando si scrive crea una nuova classe si fa in un file separato ma non \u00e8 obbligatorio. In eclipse puoi quindi creare un nuovo file class Packages Java Il meccanismo dei package incapsula un'insieme di classi. All'interno di ogni package posso creare strutture dati, classi che non interferiranno a livello di nomi (un po' come il concetto del namespace) all'esterno. Se all'interno di un progetto creo due package e magari questi due package hanno delle classi in comune, cio\u00e8 con lo stesso nome il compilatore riesce a distinguerli grazie al meccanismo di separazione dei package. L'assemblaggio dei package poi crea l'applicazione Di default Eclipse crea un package default package . Per accedere a una classe di un modello esterno devo esplicitare il nome del package prima del nome della classe A livello di struttura di cartelle, le classi all'interno del packege di default sono situate nella root del progetto, folder src mentre gli altri package sono situati in subfolder","title":"Perch\u00e8 la OOP?"},{"location":"java/java-oop-module/#lezione-02","text":"","title":"Lezione 02"},{"location":"java/java-oop-module/#creiamo-una-classe","text":"All'interno del file Punto.java che rappresenta la classe Punto posso iniziare a popolarla dichiarando le variabili interne: //Punto.java public class Punto { //stato interno int x = 0 ; int y = 0 ; } A questo punto (scusa il gioco di parole) posso instanziare una variabile di tipo Punto nel main o meglio instanziare un oggetto appartenente alla classe Punto //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 ; } } Attenzione!! L'oggetto appena creato p1 , appartenente alla classe Punto \u00e8 solo un riferimento alla classe Punto . E' un puntatore mascherato ma di fatto l'oggetto p1 non esiste ancora. Per creare un oggetto devo chiamare il costruttore //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 ; //Chiamo il costruttore, creando di fatto l'oggetto p1 = new Punto (); //A questo punto posso accedere a dati e metodi p1 . x = 123 ; p1 . y = 234 ; } } Attenzione!! Non \u00e8 buona pratica consentire l'utilizzo e la modifica dei dati interni di una classe. Dovremmo essere in grado di agire solo a livello di metodi e nascondere lo stato interno. Per rendere private le variabile interne della classe, si usa la keyword private //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; } a Questo punto nel main si solleva un'eccezione. Non posso accedere alle strutture interne ed \u00e8 un bene, devo proteggerle! //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 ; //Chiamo il costruttore, creando di fatto l'oggetto p1 = new Punto (); p1 . x = 123 ; p1 . y = 234 ; } } /* Exception in thread \"main\" java.lang.Error: Unresolved compilation problems: The field Punto.x is not visible The field Punto.y is not visible */ Per accedere alle strutture interne dovr\u00f2 affidarmi ai metodi pubblici offerti dalla classe. In particolare adesso vedremo come creare un Costruttore Un cotruttore \u00e8 un metodo pubblico, quindi esportabile all'esterno che ha lo stesso nome della classe, invocato dal costrutto new . Vediamo un semplice esempio (in questo caso non molto utile) //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore //deve avere lo stesso nome della classe //assegna un valore alle variabili interne x e y public Punto ( int _x , int _y ) { x = _x ; y = _y ; } } Un metodo alternativo molto utilizzato: //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore //deve avere lo stesso nome della classe public Punto ( int x , int y ) { this . x = x ; this . y = y ; } } this serve per discriminare i parametri del costruttore (o metodo che sia) dalle variabili dello stato interno. In particolare this.x accede alla variabile dello stato interno x mentre this.y accede alle variabili dello stato interno y dal punto di vista del main: //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 ; //Chiamo il costruttore, creando di fatto l'oggetto p1 = new Punto ( 23 , 45 ); } } Durante la creazione passo i parametri che verranno assegnati alle variabili dello stato interno x, y","title":"Creiamo una classe"},{"location":"java/java-oop-module/#lezione-03","text":"","title":"Lezione 03"},{"location":"java/java-oop-module/#getter-e-setter","text":"Un altro modo, oltre all'uso del costruttore \u00e8 quello di utilizzare dei particolari metodi chiamati getter e setter utilizzati rispettivamente per la lettura e scrittura delle variabili interne ma sempre attraverso un metodo pubblico //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore //deve avere lo stesso nome della classe public Punto ( int x , int y ) { this . x = x ; this . y = y ; } //setter public void setX ( int _x ) { x = _x ; } //getter public int getX () { return x ; } } Getter e Setter sono dei metodi quindi posso invocarli in ogni punto del programma per leggere e scrivere le variabili dello stato interno della classe. //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 ; //Chiamo il costruttore, creando di fatto l'oggetto p1 = new Punto ( 23 , 45 ); //Chiamo il getter (\u00e8 un metodo) per la lettura della coordinata x int myX = p1 . getX (); System . out . println ( myX ); //23 //Chiamo il setter (\u00e8 un metodo) per la scrittura della coordinata x p1 . setX ( 34 ); myX = p1 . getX (); System . out . println ( myX ); //34 } } Eclipse ti aiuta a scrivere in modo automatico i getter/setter: Dopodich\u00e8 nel codice troverai: //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore //deve avere lo stesso nome della classe public Punto ( int x , int y ) { this . x = x ; this . y = y ; } //setter public void setX ( int _x ) { x = _x ; } //getter public int getX () { return x ; } public int getY () { return y ; } public void setY ( int y ) { this . y = y ; } } E' bene abituarsi all'uso di this , \u00e8 un metodo pi\u00f9 sicuro riporto il main //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 ; //Chiamo il costruttore, creando di fatto l'oggetto p1 = new Punto ( 23 , 45 ); //Chiamo il getter (\u00e8 un metodo) per la lettura della coordinata x int myX = p1 . getX (); System . out . println ( myX ); //23 //Chiamo il setter (\u00e8 un metodo) per la scrittura della coordinata x p1 . setX ( 34 ); myX = p1 . getX (); System . out . println ( myX ); //34 System . out . println ( p1 . getY ()); //45 } }","title":"Getter e setter"},{"location":"java/java-oop-module/#lezione-04","text":"","title":"Lezione 04"},{"location":"java/java-oop-module/#getter-e-setter-allinterno-del-costruttore","text":"Spesso si utilizzano le chiamate a getter e setter proprio all'interno del costruttore Durante la wizard di costruzione del getter e setter di eclipse infatti c'\u00e8 l'opzione per usare i getter e setter nella definizione (quindi nel costruttore) oppure no: Partiamo da questa situazione: //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore public Punto ( int x , int y ) { this . x = x ; this . y = y ; } } A questo punto applicando la procedura wizard mantenendo Field access in declaring type: use setter and getter alla fine avremo: //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore public Punto ( int x , int y ) { this . setX ( x ); this . setY ( y ); } public int getX () { return x ; } public void setX ( int x ) { this . x = x ; } public int getY () { return y ; } public void setY ( int y ) { this . y = y ; } }","title":"Getter e setter all'interno del costruttore"},{"location":"java/java-oop-module/#lezione-05","text":"","title":"Lezione 05"},{"location":"java/java-oop-module/#cotruttore-o-costruttori","text":"Posso avere pi\u00f9 di un costruttore basta che la signature sia diversa. Il costruttore che ho dichiarato per adesso ha due parametri, prende in ingresso due interi x, y . Realizzando una signature diversa posso realizzare pi\u00f9 costruttori. Nell'esempio creer\u00f2 un signature diversa a un solo parametro //Punto.java public class Punto { //stato interno private int x = 0 ; private int y = 0 ; //METODI //cotruttore 1 public Punto ( int x , int y ) { this . setX ( x ); this . setY ( y ); } //Cotruttore 2 public Punto ( int x ) { this . setX ( x ); this . setY ( 0 ); } //getter x public int getX () { return x ; } //setter x public void setX ( int x ) { this . x = x ; } //getter y public int getY () { return y ; } //setter y public void setY ( int y ) { this . y = y ; } } Nel main: //mainEntry.java public class mainEntry { public static void main ( String [] args ) { Punto p1 , p2_asseX ; //Chiamo il costruttore a due parametri p1 = new Punto ( 23 , 45 ); //Chiama il costruttore a un parametro p2_asseX = new Punto ( 10 ); } } Attenzione!! la signatura comprende solo il Nome di una funzione (o del metodo) il numero dei parametri e il tipo ma NON IL NOME , non potrei quindi analogamente richiamare un costruttore con un solo parametro intero per la coordinata y","title":"Cotruttore o costruttori?"},{"location":"javascript/","text":"Javascript Javascript Lezione 01 Prerequisiti al corso Approccio al corso Strumenti Necessari Introduzione Lezione 02 Cenni storici Aspetti strutturali Versioni di Javascript Configurazione di un IDE Visual Studio Code - VS code Lezione 03 Primo script Lezione 04 Console - Browser Web Alert & prompt Commenti Lezione 05 Introduzione al DOM Introduzione alla libreria JQuery DOM ed Eventi Lezione 06 Variabili Javascript Tipi di dati in JS Dati nativi Reference type Alcune regole generali per dichiarazione di variabili Reference type Const Approfondimento Null - undefined - NaN Lezione 07 Stringhe Opearotri, Propriet\u00e0 e Metodi su stringhe Operatori Approfondimento Interpolazioni di stringhe Le stringhe sono immutabili Propriet\u00e0 Metodi Lezione 08 Conta parole Lezione 09 Approfondimento - Rappresentazione numerica in Javascript Numeri in Fixed Point Numeri in Floating Point Not A Number NaN Lezione 10 Approfondimento - Codifica caratteri Javascript ASCII Unicode Caratteri di Escape Lezione 11 Type conversion Conversione esplicita Conversione implicita Lezione 12 Operatori matematici Pre e post incremento/decremento Oggetto MATH Lezione 13 Equazione di II grado Lezione 14 Operator Precedence Associativit\u00e0 Operatori di assegnamento Lezione 15 Operatori Logici Logica Booleana Approfondimento - Short evalutation Truthy e falsy Lezione 16 Control Structure if/else Ternary Operator Switch statemeant Lezione 17 while loop do-while loop Lezione 18 for loop break & coninue Lezione 19 Function Parametri di default Ritorno di una funzione Lezione 20 Funzioni - Passaggio di oggetti e array Funzioni - Ritorno di un oggetto o un array Approfondimento funzioni - Oggetto Arguments Approfondimento funzioni - Parametri Rest Approfondimento Introduzione forEach / this Lezione 21 Approfondimento Funzioni ricorsive Approfondimento Function expression Approfondimento Hoisting Approfondimento Differenza tra undefined e not defined Approfondimento IIFI Immediatly invoked function expression Paradigma di programmazione Javascript Lezione 22 Scope Visibilit\u00e0 di variabili Visibilit\u00e0 Globale (global scope) Scope Chaining Visibilit\u00e0 a livello di blocco (block scope) Approfondimento - Closure di una funzione Lezione 23 Array Matrix Lezione 24 Array - Metodi base Lezione 25 Arrays - forEach() Arrays - map() Funzioni freccia (lambda) Array - Metodi avanzati Lezione 26 Introduzione agli Object Javascript OOP Lezione 01 OOP Object Oriented Programming Lezione 02 Introduzione ai Metodi Lezione 03 Costruttore Lezione 04 Ereditariet\u00e0 Lezione 05 Ereditariet\u00e0 - Shadowing Ereditariet\u00e0 classica Lezione 06 THIS Object - Variabili Statiche (condivise) Lezione 07 Introduzione For In Oggetto Date() Lezione 08 Classi Lezione 09 Classi assegnanili a variabili Get / Set try-catch Lezione 10 Derivazione di classi , ereditariet\u00e0 Lezione 11 Ereditariet\u00e0 classi Pt 2 Lezione 12 Approfondimento - Symbols Lezione 13 Approfondimento - Iterables/Iterator Costrutto for - of Lezione 14 Approfondimento - Funzioni Generatrici Lezione 15 Approfondimento - Esempio (For .. of) custom Lezione 16 Destructuring Lezione 17 Map Object Iterazione Map Object Lezione 18 Set Conversione di un Oggetto Map / Set in un Array Lezione 19 Dom Manipulation Lezione 20 DOM - Selettori Metodi di selezione di elementi html Lezione 21 Dom - Child e Parent DOM - Manipolazione dello stile degli elementi html Lezione 22 DOM - Manipolazione del testo degli elementi html DOM - Manipolazione degli attributi html Lezione 23 DOM - Creazione di Un elemento DOM - Rimpiazzo di un elemento DOM - ELiminazione di un elemento Lezione 24 DOM Events Metodo addEventListener Lezione 25 Prevent Default Che cos'\u00e8 esattamente l'oggetto ricevuto come unico parametro \"e\"? Lezione 26 Approfondimento type event Aprrofondimento eventi tastiera e input Lezione 27 Argomeni non trattati / da approfondire Fonti APPRONDIMENTI PT.1 Node.js Cos'\u00e8 node Install node Prima applicazione nodejs Non esiste l'oggetto window global objects Modules Creiamo un modulo Moduli built-in Modulo path Modulo OS Modulo File System Eventi Modulo HTTP Approfondimenti Passare dei parametri esterni My first IO sync My first IO async Filtered APPRONDIMENTI PT.2 Promise Un esempio semplice APPRONDIMENTI PT.3 Approfondimento Hoisting Approfondimento Oggetti Approfondimento Moduli Packages Approfondimento THIS Costruttori prefdefiniti javascript for .. of for .. in Memoization Come fare una copia profonda tra oggetti? propriet\u00e0 associate ai dati e proprier\u00e0 associate all'accesso get & set Arrow functions High Order Functions Array filter Array map Array reduce Gli array possiedono gi\u00e0 come metodi filer, map, reduce Qualche chicca sugli Array Arrray.of, Array.from concat, every, some find, filter, forEach, includes, indexOf push, pop, shift, unshift sort, splice, slice setTimeout(), setInterval() Eventi Asincroni Promise, resolve, reject, then Async, Await Promise.all() e Promise.race() Set e Map Map Lezione 01 Prerequisiti al corso Prima di iniziare questo modulo, dovresti avere familiarit\u00e0 con i linguaggi HTML e CSS . Approccio al corso Questo corso \u00e8 stato scritto con l'intento di imparare il linguaggio attraverso esempi pratici. Se all'inizio pensate di trovare troppo pesanti alcuni capitoli puramente \"teorici\" vi capisco, lo penserei anch'io quindi evitate con leggerezza queste sezioni. Faccio notare anche l'approccio a \"Lezioni\" brevi che ho preferito rispetto all'approccio classico a \"Libro/capitoli\" che dal mio punto di vista allunga il tempo di apprendimento specialmente per chi non mastica gi\u00e0 un po' il linguaggio e che comunque pu\u00f2 essere seguito parallelamente per approfondimenti. Concludo nella speranza che il corso possa piacervi e risultare snello per l'apprendimento. Strumenti Necessari Per questo corso sar\u00e0 necessario un web browser e un editor di testo. Come web browser utilizzeremo Google Chrome mentre come editor di testo utilizzeremo Visual Studio Code . Introduzione JavaScript \u00e8 un linguaggio di scripting cross-platform e object-oriented. \u00c8 un linguaggio piccolo e leggero. All interno di un ambiente ospite (ad esempio un web browser), JavaScript pu\u00f2 essere connesso agli oggetti del suo ambiente per fornire controllo programmatico su di essi. JavaScript contiene una libreria standard di oggetti come Array, Date e Math, ed una serie di elementi base del linguaggio come operatori, strutture di controllo e dichiarazioni. La base di JavaScript pu\u00f2 essere estesa per una variet\u00e0 di scopi fornendogli oggetti aggiuntivi; ad esempio: Client-side JavaScript estende il linguaggio base fornendo oggetti per controllare il browser ed il suo Document Object Model (DOM). Per esempio, le estensioni client-side permettono ad una applicazione di inserire elementi in un form HTML e rispondere ad eventi dell'utente come il click del mouse, input nei form e navigazione delle pagine. Server-side JavaScript estende il linguaggio base fornendo oggetti rilevanti per eseguire JavaScript in un server. Per esempio le estensioni server-side consentono ad una applicazione di comunicare con un database, forniscono continuit\u00e0 di informazioni da una chiamata ad un altra dell'applicazione, o permettono la manipolazione di files nel server. MDN - Introduzione Lezione 02 Cenni storici Originariamente sviluppato da Brendan Eich della Netscape Communications con il nome di Mochan e successivamente di LiveScript, in seguito \u00e8 stato rinominato \"JavaScript\" ed \u00e8 stato formalizzato con una sintassi pi\u00f9 vicina a quella del linguaggio Java di Sun Microsystems (che nel 2010 \u00e8 stata acquistata da Oracle). Standardizzato per la prima volta il 1997 dalla ECMA con il nome ECMAScript, l'ultimo standard, di giugno 2017, \u00e8 ECMA-262 Edition 8 ed \u00e8 anche uno standard ISO (ISO/IEC 16262). Wikipedia - JavaScript Aspetti strutturali Le caratteristiche principali di JavaScript sono: essere un linguaggio interpretato: il codice non viene compilato, ma eseguito direttamente; in JavaScript lato client, il codice viene eseguito dall'interprete contenuto nel browser dell'utente. la sintassi \u00e8 relativamente simile a quella dei linguaggi C, C++ e Java. definisce le funzionalit\u00e0 tipiche dei linguaggi di programmazione ad alto livello (strutture di controllo, cicli, ecc.) e consente l'utilizzo del paradigma object oriented. \u00e8 un linguaggio debolmente tipizzato. \u00e8 un linguaggio debolmente orientato agli oggetti. Ad esempio, il meccanismo dell'ereditariet\u00e0 \u00e8 pi\u00f9 simile a quello del Self e del NewtonScript che a quello del linguaggio Java, fortemente orientato agli oggetti. Gli oggetti stessi ricordano pi\u00f9 gli array associativi del linguaggio Perl che gli oggetti di Java o C++. Altri aspetti di interesse: in JavaScript lato client, il codice viene eseguito direttamente sul client e non sul server. Il vantaggio di questo approccio \u00e8 che, anche con la presenza di script particolarmente complessi, il web server non rischia sovraccarichi dato che il lavoro viene svolto dal client. Un rovescio della medaglia \u00e8 che, nel caso di script particolarmente grandi, il tempo per il trasferimento dalla rete pu\u00f2 diventare eccessivamente lungo. Inoltre ogni informazione che presuppone un accesso a dati memorizzati in una base di dati remota deve essere rimandata a un linguaggio che effettui materialmente la transazione, per poi restituire i risultati ad una o pi\u00f9 variabili JavaScript; operazioni del genere richiedono un nuovo caricamento della pagina stessa. Questi limiti sono per\u00f2 stati superati in buona parte con la nascita di AJAX. Alcune altre caratteristiche di JavaScript degne di nota: Pu\u00f2 usare caratteri Unicode Pu\u00f2 valutare le espressioni regolari (introdotte nella versione 1.2; supporto da parte dei browser: a partire da Netscape Navigator 4 e Internet Explorer 4) Le espressioni JavaScript contenute in una stringa possono essere valutate usando la funzione eval. Wikipedia - JavaScript Versioni di Javascript Un linguaggio di programmazione per essere definito uno standard ha bisogno di essere revisionato da un organo dedicato che prende il nome di ECMA International. Da questo lavoro \u00e8 nato un nuovo standard che prende il nome di ECMAScript, anche se per tutti noi il termine JavaScript \u00e8 rimasto sufficiente per definirlo. Nel corso degli anni lo standard ha definito nuove versioni e aggiornamenti del linguaggio e delle funzionalit\u00e0. Nel contempo i browser si sono adattati alle modifiche introdotte per supportare il nuovo standard. Per orientarsi al supporto allo stato attuale da parte dei browser dei nuovi standard Javascript \u00e8 possibile visionare la seguente tabella: github - es6 table Possiamo affermare che la versione pi\u00f9 utilizzata ad oggi \u00e8 ES6, la ES5 \u00e8 obsoleta ma di fatto ormai anche la ES2016+ \u00e8 supportata da tutti i browser. Indice riassuntivo: ECMAScript \u2013 un linguaggio standardizzato dal ECMA Internetional e supervisionato dal comitato T39; JavaScript \u2013 il nome comune utilizzato per identificare lo standard ECMAScript. Con questo termine non ci rivolgiamo a una specifica versione dello standard, ma piuttosto al suo utilizzo a livello globale o parziale. ECMAScript 5 (ES5) \u2013 questa rappresenta la quinta versione dello standard ECMAScript rilasciata nel 2009. Dato che a oggi i maggiori browser supportano questa versione \u00e8 probabile che sar\u00e0 la pi\u00f9 comune da incontrare. ECMAScript 6 (ES6)/ECMAScript 2015 (ES2015) \u2013 questa rappresenta la sesta versione dello standard ECMAScript rilasciata nel 2015. Al momento non \u00e8 ancora supportata completamente dai nuovi browser e dato che presenta un gran numero di moduli ti consiglio di consultare questa tabella aggiornata. ECMAScript 2016 \u2013 rilasciata a inizio 2016 presenta un esiguo numero di funzionalit\u00e0 implementate e non dovrebbe comportare grossi problemi di compatibilit\u00e0 nei browser in grado di supportare la versione ES2015. skillsandmore - Conosci tutte le versioni di Javascript? Configurazione di un IDE Un ambiente di sviluppo integrato (in lingua inglese integrated development environment ovvero IDE, anche integrated design environment o integrated debugging environment, rispettivamente ambiente integrato di progettazione e ambiente integrato di debugging), in informatica, \u00e8 un ambiente di sviluppo ovvero un software che, in fase di programmazione, supporta i programmatori nello sviluppo e debugging del codice sorgente di un programma: spesso l'IDE aiuta lo sviluppatore segnalando errori di sintassi del codice direttamente in fase di scrittura, oltre a tutta una serie di strumenti e funzionalit\u00e0 di supporto alla fase stessa di sviluppo e debugging. Wikipedia - Integrated development environment Visual Studio Code - VS code Visual Studio Code \u00e8 un editor di codice sorgente sviluppato da Microsoft per Windows, Linux e macOS. Include il supporto per debugging, un controllo per Git integrato, Syntax highlighting, IntelliSense, Snippet e refactoring del codice. Sono personalizzabili il tema dell'editor, le scorciatoie da tastiera e le preferenze. \u00c8 un software libero e gratuito, anche se la versione ufficiale \u00e8 sotto una licenza proprietaria. Visual Studio Code \u00e8 basato su Electron, un framework con cui \u00e8 possibile sviluppare applicazioni Node.js. Wikipedia - Visual Studio Code In questo corso useremo Visual Studio Code come IDE con le seguenti Estensioni: HTML snippets javascript es6 code snippets live server Per installare un'estensione con VS code vi rimando alla seguente immagine animata: Lezione 03 Primo script Come integro codice javascript all'interno di una pagina html? - Modo 1: E' possibile inserire codice Javascript direttamente all'interno della pagina html tramite il tag <script></script> . - Modo 2: E' possibile creare un collegamento con un file esterno con estensione .js che rappresenter\u00e0 il file contente codice Javascript. Per creare tale collegamento \u00e8 necessario inserire prima della chiusura del body il seguente link-tag < script src = \"main.js\" ></ script > Modo 1: Codice Javascript interno alla pagina html File html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script > //Stampa \"ciao mondo\" direttamente nella pagina html document . write ( \"ciao mondo\" ); </ script > </ body > </ html > Una volta creato il file \u00e8 possibile aprirlo direttamente con un web browser o tramite l'estensione di VS code live server che permette di lanciare l'aggiornamento della pagina in automatico quando si salva il file Modo 2: Collegamento al file javascript main.js File html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script src = \"main.js\" ></ script > </ body > </ html > File JS //Stampa \"ciao mondo\" direttamente nella pagina html document . write ( \"ciao mondo\" ); Il modo migliore \u00e8 sempre quello di creare file separati per dividere il contesto tra html / css / Javascript soprattutto per progetti grandi e strutturati. In questo corso per motivi di praticit\u00e0 invece utilizzeremo spesso codice Javascript all'interno della pagina html Lezione 04 Console - Browser Web La console \u00e8 uno strumento molto utile in fase di sviluppo software all'interno del browser web. Segnala errori e warning sintattici dell'interprete javascript ed \u00e8 molto utilizzata in fase di debug. E' uno strumento interattivo, permette quindi la generazione di script Javascript in real-time e di stampare il valore di alcune variabili o strutture dati per monitorare il corretto funzionamento dello script. Il comando console.log() (o per meglio dire il metodo log() dell'oggetto Console , parleremo pi\u00f9 avanti di metodi e oggetti..) stampa un messaggio sulla web console del browser. Il messaggio pu\u00f2 essere una semplice stringa (opzionalmente, anche con valori sostituibili), o pu\u00f2 essere uno qualsiasi o pi\u00f9 oggetti JavaScript. File html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script > //Stampa \"ciao mondo\" direttamente nella pagina html console . log ( \"ciao mondo\" ); </ script > </ body > </ html > Riporto qualche comando (metodo) aggiuntivo della console: console . log ( 'Ciao a tutti' ); //stampa sulla console console . warn ( 'Avvertimento' ); //Genera un warning console . error ( 'questo \u00e8 un errore' ); //Genera un errore console . table ({ name : 'simone' }); //Stampa in formato tabella console . clear (); //Pulisce la console E' bene comuqnue precisare che qualsiasi cosa venga stampata sulla console come log, errori o warning non saranno visibili all'utente ma solo in modalit\u00e0 sviluppatore. Una lista di tutti i metodi applicabili all'oggetto si trova alla pagina MDN - Console Alert & prompt alert() mostra una finestra di avviso contenente il testo specificato mentre prompt() mostra una finestra di dialogo che chiede all'utente di inserire del testo. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script > //Salva l'input ricevuto in una variabile cio\u00e8 un contenitore testuale myName = prompt ( 'Come ti chiami?' ); alert ( \"Il tuo nome \u00e8 ..\" ); //Stampa il valore testuale contenuto nella variabile alert ( myName ); </ script > </ body > </ html > Approfondimenti sul metodo alert() dell'oggetto Window li trovate su MDN - Window.alert() mentre approfondimenti sul metodo prompt() dell'oggetto Window li trovate su MDN - Window.prompt() Commenti I commenti sono linee testuali non processate dall'interprete utili per la documentazione del codice. In javascritp ci sono due tipi di sintassi permesse per l'inserimento dei commenti. - // comment : per commenti inline - /* comment */ : per commenti su linee multiple //inline comment /* multi line comment console.log('ciao a tutti'); */ Lezione 05 Attenzione! Questa lezione sembrer\u00e0 troppo approfondita e allo stesso tempo vaga considerato l'argomento che sto per trattare. Non preoccuparti se non capisci granch\u00e8, cerca comunque di cogliere il meccanismo di funzionamento dell'esempio che riporto in fondo alla lezione. Pi\u00f9 avanti tratteremo questi argomenti in modo pi\u00f9 dettagliato e diventer\u00e0 tutto chiaro. Preferisco comunque affrontare questi argomenti \"avanzati\" fin da subito per evitare di basare l'apprendimento di Javascript sul solo comando console.log() . Mi sembra giusto passare all'interazione con html fin da subito per intuire con la pratica le potenzialit\u00e0 di questo linguaggio Introduzione al DOM E' utile introdurre fin da subito il concetto di DOM per scrivere codice Javascript in grado di interagire con la pagina html altrimenti saremmo costretti ad utilizzare per tutto il corso console.log() e non vederne un'applicazione pratica. In informatica il Document Object Model (spesso abbreviato come DOM), letteralmente modello a oggetti del documento, \u00e8 una forma di rappresentazione dei documenti strutturati come modello orientato agli oggetti. \u00c8 lo standard ufficiale del W3C per la rappresentazione di documenti strutturati in maniera da essere neutrali sia per la lingua che per la piattaforma. \u00c8 inoltre la base per una vasta gamma di interfacce di programmazione delle applicazioni, alcune di esse standardizzate dal W3C. Nativamente supportato dai browser per modificare gli elementi di un documento HTML, DOM \u00e8 un modo per accedere e aggiornare dinamicamente il contenuto, la struttura e lo stile dei documenti. Per le numerose incompatibilit\u00e0 dovute al diverso tipo di gestione di DOM dai vari browser, il W3C ha stabilito delle specifiche standard. Wikipedia - Document Object Model Nelle lezioni precedenti abbiamo gi\u00e0 utilizzato il concetto di DOM. Un esempio \u00e8 la stampa diretta sulla pagina html: document . write ( \"ciao mondo\" ); Il \"comando\" document.write() \u00e8 in realt\u00e0 un oggetto Javscript document a cui si applica un metodo write() ovvero una funzione richiamabile solo nel contesto di un particolare oggetto (DOM = Document Object Model). Introduzione alla libreria JQuery Vediamo anche il metodo per aggiungere librerie esterne, necessario qualora volessimo utilizzare funzioni particolari di Javascript non presenti nel linguaggio standard. Installeremo JQuery perch\u00e8 \u00e8 una libreria popolare molto utilizzata proprio per la manipolazione del DOM ovvero degli elementi (oggetti) html. jQuery \u00e8 una libreria JavaScript per applicazioni web, distribuita come software libero, distribuito sotto i termini della Licenza MIT. Nasce con l'obiettivo di semplificare la selezione, la manipolazione, la gestione degli eventi e l'animazione di elementi DOM in pagine HTML, nonch\u00e9 semplificare l'uso di funzionalit\u00e0 AJAX, la gestione degli eventi e la manipolazione dei CSS. Le sue caratteristiche permettono agli sviluppatori JavaScript di astrarre le interazioni a basso livello con i contenuti delle pagine HTML. L'approccio di tipo modulare di jQuery consente la creazione semplificata di applicazioni web e contenuti dinamici versatili. Nel 2020, jQuery risulta la libreria JavaScript pi\u00f9 utilizzata in Internet, ovvero \u00e8 presente nel 74,4% dei primi 10 milioni di siti Internet pi\u00f9 popolari secondo W3Techs. Wikipedia - JQuery Scaricate quindi la libreria JQeury da JQuery - download Una volta scaricato il file \u00e8 necessario copiarlo nella root del progetto e creare un collegamento al file html. Vediamo le funzioni base della libreria JQuery. Le approfondiremo quando necessario pi\u00f9 avanti nel corso $() : Selettore di elementi html. E' possibile selezionare un elemento tramite il suo id , la sua classe , un attributo .. Alcuni metodi: val() : legge/scrive l'attributo value dell'elemento selezionato click(functionName) : aggiunge l'evento click all'elemento selezionato e chiama la funzione functionName Vediamo un esempio: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table { border : 1 px dashed black } </ style > </ head > < body > < table > < tr > < td > Nome </ td > < td > < input type = \"text\" id = \"myName\" > </ td > </ tr > < tr > < td > Nuovo Nome </ td > < td > < input type = \"text\" id = \"new-name\" > </ td > </ tr > </ table > < input type = \"button\" value = \"OK\" id = \"btn-ok\" > <!-- Collegamento alla libreria JQuery.--> < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function cambiaNome (){ //Seleziono l'elemento con id \"new-name\" e ne prelevo il valore con il metodo \"val()\" //Memorizzo il risultato in una variabile di nome \"nuovoNome\" nuovoNome = $ ( \"#new-name\" ). val (); //Assegno all'elemento con id \"myName\" il valore associato alla variabile \"nuovoNome\" $ ( \"#myName\" ). val ( nuovoNome ); //Pulisco il contenuto del valore dell'elemento con id \"new-name\" $ ( \"#new-name\" ). val ( \"\" ); } //Associo all'elemento con id \"btn-ok\" un evento. //Al click sull'elemento con id \"btn-ok\" scatta la funzione \"cambiaNome\" $ ( \"#btn-ok\" ). click ( cambiaNome ) </ script > </ body > </ html > ATTENZIONE: Il simbolo $ \u00e8 un alias che sta per jQuery .E' importante saperlo perch\u00e8 ci sono altre librerie che utilizzano il simbolo $ e potrebbero quindi generare un conflitto. Per ovviare a ci\u00f2 \u00e8 possibile utilizzare il nome originale jQuery al posto del suo alias $ . Con il comando $.noConflict() \u00e8 possibile eliminare la definizione dell' alias $ evitando quindi conflitti di ogni genere. A quel punto dovremmo per\u00f2 utilizzare necessariamente jQuery al posto di $ DOM ed Eventi Appena la pagina va in esecuzione il browser deve costruire il DOM ma nel contempo potrebbe gi\u00e0 partire il codice Javascript e l'esecuzione potrebbe portare a qualche errore in certi casi a causa di asincronismo. L'esempio di sopra potrebbe essere uno di questi. Per ovviare a ci\u00f2 \u00e8 necessario racchiudere l'evento all'interno di una funzione anonima: $ ( function (){ //evento }); Vediamolo applicato all'esempio di prima: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table { border : 1 px dashed black } </ style > </ head > < body > < table > < tr > < td > Nome </ td > < td > < input type = \"text\" id = \"myName\" > </ td > </ tr > < tr > < td > Nuovo Nome </ td > < td > < input type = \"text\" id = \"new-name\" > </ td > </ tr > </ table > < input type = \"button\" value = \"OK\" id = \"btn-ok\" > <!-- Collegamento alla libreria JQuery.--> < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function cambiaNome (){ nuovoNome = $ ( \"#new-name\" ). val (); //Assegno all'elemento con id \"myName\" il valore associato alla variabile \"nuovoNome\" $ ( \"#myName\" ). val ( nuovoNome ); //Pulisco il contenuto del valore dell'elemento con id \"new-name\" $ ( \"#new-name\" ). val ( \"\" ); } //L'evento sar\u00e0 pronto a scattare soltanto quando la struttura del DOM sar\u00e0 preparata $ ( function (){ $ ( \"#btn-ok\" ). click ( cambiaNome ) }); </ script > </ body > </ html > In questo modo si ha la sicurezza che il codice javascript e quindi l'evento possa scattare solo dopo la creazione del DOM. Il che non significa che comprende il caricamento di tutti gli oggetti come immagini, video o alcune formattazioni testuali ma solo la struttura html come oggetto Javascript che \u00e8 tuttavia sufficiente al corretto funzionamento del codice Javascript. Altri metodi equivalenti: $ (). ready ( function (){ //event }) $ ( document ). ready ( function () { //event }) $ ( window ). ready ( function () { //event }) Lezione 06 Variabili Javascript Le variabili sono utilizzate per rappresentano dei valori attraverso un nome simbolico chiamato identificatore . var cognome = 'Rossi' ; let nome = 'Mario' ; const eta = 25 ; pi = 3.14 ; Esistono tre tipi di keyword per la dichiarazione di variabili/costanti in JS. var : Questa sintassi pu\u00f2 essere usata per dichiarare sia variabili locali che globali let : Introdotta nelle nuove versioni di JS pu\u00f2 essere usata per dichiarare una variabile locale visibile in un blocco. const : Introdotta nelle nuove versioni di JS \u00e8 utilizzata per creare una costante in sola lettura. Possono inoltre dichiarare una variabile senza nessuna keyword (come fatto negli esempi precedenti) ma \u00e8 da evitare perch\u00e8 sar\u00e0 l'interprete ad assegnare a tale variabile delle propriet\u00e0 Per le variabili dichiarate con let/var valgono le seguenti regole: Posso dichiarare una variabile e non inizializzarla. Se non inizializzata verr\u00e0 attribuita ad essa il valore undefined Posso assegnare il valore di una variabile successivamente nel programma e modificarne il contenuto a piacimento (Variable mutation) Per le variabili dichiarate con const valgono le seguenti regole: Una costante non pu\u00f2 cambiare il suo valore attraverso ulteriori assegnazioni o essere ridichiarata mentre lo script \u00e8 in esecuzione. Deve essere sempre inizializzata ad un valore. let myVar = 4 ; //OK, inizializzazione (dichiarazzione + assegnamento) myVar = 23 ; //OK, assegnamento let myVar2 ; //OK, solo dichiarazione myVar2 = 29 ; //OK, assegnamento successivo alla dichiarazione const myVar = 4 ; //OK, inizializzazione (dichiarazione + assegnazione) myVar = 23 ; //EEROR!! - assegnazione successiva all'inizializzazione const myVar2 ; //EEROR!! - solo dichiarazione Quando usare const, let o var E' sempre meglio usare const per tutte le strutture dati che non cambiano nel tempo, \u00e8 pi\u00f9 sicuro. E' necessario usare let o var solo per le variabili o strutture dati che cambiano valore nel tempo. Tra let e var \u00e8 preferibile usare let per mantenere la regola della visibilit\u00e0 all'interno di un blocco (l'argomento visibilit\u00e0 delle variabili verr\u00e0 trattato pi\u00f9 avanti). Tipi di dati in JS L'ultimo standard ECMAScript definisce sette tipi di dati: Sei tipi di dato che sono primitives : Boolean . true e false. null . Una parola chiave che denota un valore nullo. undefined . Una propriet\u00e0 il cui valore non \u00e8 stato definito. Number . 42 oppure 3.14159. String . \"Salve\" Symbol (nuovo in ECMAScript 2015). Un tipo di dato la cui istanza \u00e8 unica e immutabile. Due Reference Type Object Array NOTA: typeof \u00e8 una propriet\u00e0 di Javascript che stampa (ritorna) il tipo di un oggetto o una variabile. Dati nativi //String //Le stringhe si indicano attraverso i singoli apici 'mystring' //attraverso i doppi apici \"myString\" o l'accento grave `myString` const nome = 'simone' ; //Number const temp = - 1.5 ; //Boolean const isMaggiorenne = true ; //Null const value = null ; //Interessante da vedere console . log ( typeof value ); //Undefined const cognome = undefined ; //Symbol const mySymbol = Symbol (); Reference type Gli array sono tipi di dato Reference Type utilizzati per raggruppare diversi dati appartenenti alla stessa categoria, ovvero un insieme di dati omogenei. Gli object anch'essi Reference Type sono utilizzati per raggruppare qualit\u00e0 / caratteristiche di una struttura dati pi\u00f9 complessa, in genere eterogenea. //Arrays const nomi = [ 'simone' , 'matteo' , 'giovanni' ]; //Accedo ai campi di un array con l'operatore di indicizzazione [] // 0 1 2 //const nomi = ['simone', 'matteo', 'giovanni']; console . log ( nomi [ 1 ]); //matteo //Objects const persona = { nome : 'simone' , eta : 25 , isMarry : true } //Accedo ai campi di un Object spcificando il nome della propriet\u00e0 dell'oggetto console . log ( persona . nome ); //simone Formalizzeremo pi\u00f9 avanti sia la struttura dei dati primitivi sia la struttura dei reference type. Alcune regole generali per dichiarazione di variabili Usare sempre dei nomi significativi e esplicativi per le variabili Usare sempre il camelCase quando la variabile \u00e8 composta da due o pi\u00f9 parole Non si pu\u00f2 usare un numero, un # , una @ come inizio del nome di una variabile. E' accettanto invece il simbolo`$ Non si possono utilizzare, come identificatore, le keyword native di JS come: function , if , delete .. E' possibile dichiarare pi\u00f9 variabili/costanti nello stesso statement, separando le dichiarazioni con una virgola. Vediamo qualche esempio qua sotto: //Sintassi alternativa per dichiarare pi\u00f9 costanti const na = 3 , pigreco = 3.14 ; _iou = 0 ; $yui = 78 ; u - 1 = 45 ; //ERROR!! 1 T = 1 ; //ERROR!! Reference type Const ATTENZIONE: Se un oggetto/array \u00e8 dichiarato const non significa che non \u00e8 possibile modificare i campi all'interno ma solo che non posso cambiare la natura dell'oggetto/array. QUesto proprio perch\u00e8 gli oggetti/arrays sono, a differenza dei dati primitivi, dei reference type. Il loro nome rappresenta solo l'indirizzo per accedere al dato in memoria e non il dato in memoria. Questo concetto per adesso pu\u00f2 sembrare poco chiaro ma i reference type verranno trattati ampiamente nelle sezioni pi\u00f9 avanti. const myObj { nome : 'simone' , cognome : 'di ricco' , eta : 34 } myObj . nome = 'luca' ; //OK myOby = 5 ; //ERROR perch\u00e8 in questo caso cambierei la natura dell'oggetto. Da oggetto diventerebbe un <number> let myObj2 { ram : 4 , rom : 5 , anno : 2010 } myObj2 . ram = 6 ; //OK myObj2 = 18 ; //OK \u00e8 permesso in JS. Ecco perch\u00e8 si dovrebbe usare <const> invece di <let> quando \u00e8 possibile Approfondimento Null - undefined - NaN Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso undefined : Si verifica quando un oggetto o una variabile non assume nessun valore null : E' un valore attributo in fase di programmazione per identificare che un dato oggetto o variabile non assume nessun valore. Differisce da undefined poich\u00e8 null \u00e8 previsto deliberatamente in fase di programmazione NaN : Viene restituito quando l'espressione numerica valutata non restituisce un Number Esempio 1: console . log ( null === undefined ); //false NOta: Per controllare gli stati di null e undefined \u00e8 possibile utilizzare direttamente le keyword null e undefined come nell'esempio sopra illustrato. La stessa cosa non vale per NaN . In questo caso conviene utilizzare IsNaN() . //Attenzione console . log ( NaN != NaN ); //true !!!! Lezione 07 Stringhe Una stringa \u00e8 un tipo di dato formato da zero o pi\u00f9 caratteri racchiusi tra virgolette doppie \" \" , singole ' ' o tramite accento grave. \u00c8 possibile chiamare qualsiasi metodo dell'oggetto String su una stringa. const saluto = 'Ciao a tutti' ; //Stringa multi-line. Attenzione all'apice -accento grave- var fraseFilosofica = `Il mattino ha l'oro in bocca. La sera no` ; Opearotri, Propriet\u00e0 e Metodi su stringhe Operatori + : Uninione/concatenazione di stringhe. [ index ] : Indicizzazione di una stringa come array di caratteri, in sola lettura <, > : operatori di confronto tra stringhe. Ritornano un boolean , true/false {} : Interpolazione di stringhe const nome = \"marco\" ; const cognome = \"rossi\" ; console . log ( nome + \" \" + cognome ); //marco rossi // 0,1,2,3,4 //const cognome = \"r o s s i\"; console . log ( cognome [ 1 ]); //\"o\" console . log ( nome > cognome ); //true Approfondimento Interpolazioni di stringhe Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. E' possibile utilizzare espressioni all'interno di un unica stringa. Per far cio' si ricorre all'interpolazione di stringhe molto comune anche in altri linguaggi di programmazione. La sintassi prevede di usare SOLO l'accento grave e per le espressioni da valutare, l'operatore $ seguito dall'espressione racchiusa tra le parentesi graffe { } let index = 0 ; //La variabile \"index\" viene valuta console . log ( ` ${ index } ciao` ); //0 index = index + 1 ; console . log ( ` ${ index } ciao` ); //1 Le stringhe sono immutabili !! LE STRINGHE SONO IMMUTABILI IN JAVASCRIPT !! Questo significa che dal punto di vista semantico le stringhe non possono essere trattate come array di caratteri e di fatto non \u00e8 possibile applicare alle stringhe i metodi applicabili agli array. var saluto = \"ciao\" saluto [ 2 ] = 'Z' ; //Attenzione! LE STRINGHE SONO IMMUTABILI console . log ( saluto ); //ciao L'unico modo per cambiare un carattere all'interno di una stringa \u00e8 distruggere l'intera stringa e ricostruirne un'altra con il carattere modificato tramite assegnamento. Non \u00e8 possibile tuttavia modificre direttamente il singolo carattere di una stringa. var saluto = \"ciao\" saluto [ 2 ] = '2' ; console . log ( saluto ); //ciao saluto = \"super ciao\" console . log ( saluto ); //super ciao Propriet\u00e0 La propiet\u00e0 .lenght restituisce il numero di caratteri presenti nella stringa. const nome = \"marco\" ; console . log ( nome . lenght ); //5 console . log ( \"ciao\" . lenght ); //4 Metodi Vediamo adesso diversi metodi applicabili alle stringhe. Pi\u00f9 avanti, quando tratteremo gli oggetti capiremo meglio la terminologia metodo/propriet\u00e0/operatore. Per adesso \u00e8 importante capirne gli esempi applicativi e imparare ad usare le stringhe per intuirne le potenzialit\u00e0. toUpperCase() : - Parametri : - Tipo di Ritorno : String - Descrizione : Ritorna la stringa in caratteri maiuscoli console . log ( \"simOne di rIcco\" . toUpperCase ()); //SIMONE DI RICCO toLowerCase() : - Parametri : - Tipo di Ritorno : String - Descrizione :Ritorna la stringa in caratteri minuscoli console . log ( \"SimOne di rICco\" . toLowerCase ()); //simone di ricco charAt(index) : - Parametri : index ( Number ) - Tipo di Ritorno : String - Descrizione : Restituisce il carattere all'interno della stringa corrispondente all'indice index (Ottenibile anche tramite l'indicizzazione [ ]) console . log ( \"JaVascript\" . charAt ( 3 )); //a substring(indexStart, indexEnd) : - Parametri : indexStart ( Number ), indexEnd ( Number ) - Tipo di Ritorno : String - Descrizione : Ritorna la porzione di stringa compresa tra indexStart incluso e indexEnd escluso. console . log ( \"JaVascript language\" . substring ( 0 , 10 )); //JaVascript endsWith(param) - Parametri : param ( String ) - Tipo di Ritorno : boolean - Descrizione :ritorna un boolean se la stringa termina o meno con la stringa param console . log ( \"myPdfFile.pdf\" . endsWith ( \"pdf\" )); //true console . log ( \"01110000011\" . endsWith ( \"10\" )); //false startsWith(string) : - Parametri : param ( String ) - Tipo di Ritorno : boolean - Descrizione :ritorna un boolean (true/false) se la stringa inizia o meno con la stringa param console . log ( \"01110000011\" . startsWith ( \"0111\" )); //true .includes(param1, ?param2) : - Parametri : param1 ( String ), param2 ( Number ), - Tipo di Ritorno : boolean - Descrizione : cerca la stringa param1 a partire dall'indice opzionale param2 , ritorna true o false. Se param2 \u00e8 omesso cerca param1 in tutta la stringa console . log ( \"JaVascript is programming language\" . includes ( \"is\" )); //true console . log ( \"JaVascript is programming language\" . includes ( \"is\" , 16 )); //false indexOf(param1, ?param2) : - Parametri : param1 ( String ), param2 ( Number ), - Tipo di Ritorno : Number - Descrizione : Cerca la prima occorrenza della stringa param1 a partire dall'indice opzionale param2 . Restituisce l'indice della posizione di param1 . Se non trova param1 nella stringa restituisce -1. Se param2 \u00e8 omesso cerca param1 in tutta la stringa a partire dall'inizio della stringa. console . log ( \"0011010111000110\" . indexOf ( \"111\" )); //7 console . log ( \"0011010111000110\" . indexOf ( \"111\" , 10 )); //-1 lastIndexOf(param1, param2) : - Parametri : param1 ( String ), param2 ( Number ), - Tipo di Ritorno : Number - Descrizione : Cerca l'ultima occorrenza della stringa param1 vincolato dall'indice limite param2 . Restituisce l'indice della posizione di param1 . Se param2 \u00e8 omesso cerca param1 in tutta la stringa a partire dalla fine della stringa. padEnd(param1, param2) : - Parametri : param1 ( Number ), param2 ( String ), - Tipo di Ritorno : String - Descrizione : Riempie la stringa fino a una lunghezza massima di param1 , aggiungendo come riempitivo in coda la stringa param2 console . log ( \"100\" . padEnd ( 5 , \"-\" )); //100-- console . log ( \"100000\" . padEnd ( 5 , \"-\" )); //100000 console . log ( \"\" . padEnd ( 5 , \"-\" )); //----- padStart(param1, param2) : - Parametri : param1 ( Number ), param2 ( String ) - Tipo di Ritorno : String - Descrizione : Riempie la stringa fino a una lunghezza massima di param1 , aggiungendo come riempitivo in testa la stringa param2 console . log ( \"120\" . padStart ( 5 , \"0\" )); //00120 console . log ( \"9040\" . padStart ( 5 , \"0\" )); //09040 console . log ( \"2\" . padStart ( 5 , \"0\" )); //00002 repeat(param) : - Parametri : param ( Number ) - Tipo di Ritorno : String - Descrizione : Replica la stringa un numero di volte specificato da param console . log ( \"0\" . repeat ( 32 )); //00000000000000000000000000000000 console . log ( \"*-\" . repeat ( 8 )); //*-*-*-*-*-*-*-*- replace(param1, param2) : - Parametri : param1 ( String ), param2 ( String ) - Tipo di Ritorno : String - Descrizione : Sostituisce la prima occorennza della stringa param1 con la stringa param2 . Funziona anche se param1 \u00e8 un'espressione regolare. console . log ( \"Ciao a tutto il mondo\" . replace ( \"o\" , \"0\" )); //Cia0 a tutto il mondo //Uso interessante del metodo replace() con un'espressione regolare. /o/g >>> cerca tutte le occorrenze //di \"o\". Nota che \"g\" sta per \"global\" cio\u00e8 tutte console . log ( \"Ciao a tutto il mondo\" . replace ( /o/g , \"0\" )); //Cia0 a tutt0 il m0nd0 search(param) : - Parametri : param ( String ) - Tipo di Ritorno : Number - Descrizione : cerca la prima occorenza di param e restituisce l'indece della posizione. Funziona anche se param \u00e8 un'espressione regolare. console . log ( \"Ciao a tutto il mondo\" . search ( \"mondo\" )); //16 console . log ( \"Ciao a tutto il mondo\" . search ( \"ill\" )); //-1 slice(indexStart, indexEnd) : - Parametri : indexStart ( Number ), indexEnd ( Number ) - Tipo di Ritorno : String - Descrizione : Restituisce una sottostringa tra indexStart e indexEnd console . log ( \"DRCSMN91L22E715Q\" . slice ( 6 , 8 )); //91 split(separatore, ?max) : - Parametri : separatore ( String ), max ( Number ) - Tipo di Ritorno : Array of String - Descrizione : Pu\u00f2 essere utilizzato per raggruppare delle stringhe sottoforma di array contenute in un unica grande stringa e separate tramite un separatore. Crea quindi un array di stringhe contenente porzioni di stringa derivate dalla stringa a cui \u00e8 applicato il metodo separate dal carattere (o i caratteri) come indicato nel parametro separatore . Il secondo parametro, opzionale, indica il numero massimo di elementi dell'array. const myArray = \"Ciao a tutto il mondo\" . split ( \" \" ); console . log ( myArray ); //(5) [\"Ciao\", \"a\", \"tutto\", \"il\", \"mondo\"] console . log ( myArray [ 3 ]); //il const myArray2 = \"Ciao a tutto il mondo\" . split ( \" \" , 3 ); console . log ( myArray2 ); //(3) [\"Ciao\", \"a\", \"tutto\"] trim() : - Parametri : - Tipo di Ritorno : String - Descrizione : rimuove gli spazi all'inizio e alla fine di una stringa console . log ( \"#\" + \" Ciao a tutto il mondo \" . trim () + \"#\" ); //#Ciao a tutto il mondo# trimLeft() : - Parametri : - Tipo di Ritorno : String - Descrizione : rimuove gli spazi in testa a una stringa. console . log ( \"#\" + \" Ciao a tutto il mondo \" . trimLeft () + \"#\" ); //#Ciao a tutto il mondo # trimRight() : - Parametri : - Tipo di Ritorno : String - Descrizione : rimuove gli spazi in coda a una stringa console . log ( \"#\" + \" Ciao a tutto il mondo \" . trimRight () + \"#\" ); //# Ciao a tutto il mondo# Lezione 08 Conta parole Il seguente esempio conta le parole inserite in un certo input testuale. Faremo uso dell'evento keypress che scatta ad ogni tasto premuto e del metodo su stringa split() <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > Conta parole </ h1 > < table > < td > Testo: </ td > < tr > < td >< textarea cols = \"30\" rows = \"10\" id = \"myText\" ></ textarea ></ td > </ tr > < tr > < td > Parole nel testo: </ td > </ tr > < tr > < td >< input type = \"text\" id = \"word-count\" ></ td > </ tr > </ table > <!-- Collegamento alla libreria JQuery.--> < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function contaParole (){ //Prelievo il valore dell'elemento con id=\"myText\" lo converto a stringa e lo assegno alla variabile testoInserito let testoInserito = String ( $ ( \"#myText\" ). val ()); //Prelievo la propriet\u00e0 lenght di un array formato da parole separate da spazi. //ATTENZIONE. NON FUNZIONA CON I DOPPI SPAZI let conteggioParole = ( testoInserito . split ( \" \" ). length ); $ ( \"#word-count\" ). val ( conteggioParole ) } $ ( function (){ $ ( \"#myText\" ). keypress ( contaParole ) }); </ script > </ body > </ html > Lezione 09 Approfondimento - Rappresentazione numerica in Javascript Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso Numeri in Fixed Point Per il tipo nativo Number Javascript utilizza 64 bit per la memorizzazione in ram sia per i numeri interi sia per i numeri decimali a \"virgola fissa\" (fixed point). Vengono utilizzati 53 bit per la parte intera e i restanti 9 per la parte decimale anche se un numero \u00e8 intero. Il numero intero (safe) pi\u00f9 grande rappresentabile in JS \u00e8 MAX_SAFE_INTEGER . MAX_SAFE_INTEGER : E' il numero intero pi\u00f9 grande a cui posso applicare un incremento in modo affidabile. Il metodo isSafeInteger() applicato all'oggetto Number ritorna un boolean che indica se il numero \u00e8 safe oppure no console . log ( Number . MAX_SAFE_INTEGER ); //9007199254740991 /* (property) NumberConstructor.MAX_SAFE_INTEGER: number The value of the largest integer n such that n and n + 1 are both exactly representable as a Number value. The value of Number.MAX_SAFE_INTEGER is 9007199254740991 2^53 \u2212 1. */ let n1 = Number . MAX_SAFE_INTEGER ; //OK, safe console . log ( Number . isSafeInteger ( n1 )); //true let n2 = Number . MAX_SAFE_INTEGER + 1 ; //OK, safe console . log ( Number . isSafeInteger ( n2 )); //true let n3 = Number . MAX_SAFE_INTEGER + 1 //NO, non safe, il risultato non \u00e8 affidabile console . log ( Number . isSafeInteger ( n3 )); //false Numeri in Floating Point La rappresentazione dei numeri in \"virgola mobile\" (floating point) Javascript utilizza lo standard IEEE 754 //MAX_VALUE rappresenta il pi\u00f9 grande numero rappresentabile in virogla mobile console . log ( Number . MAX_VALUE ); //1.7976931348623157e+308 //Attenzione!! console . log ( 0.1 + 0.2 == 0.3 ); //false console . log ( 0.1 + 0.2 ); //0.30000000000000004 Lo standard IEE754 rappresenta i numeri reali e come tale \u00e8 necessario conoscere ed evitare alcune pratiche di cattivo utilizzo dei numeri reali. In generale con i numeri reali \u00e8 da evitare l'utilizzo di espressioni di uguglianza. E' possibile tuttavia trasformare un'espressione di uguaglianza esatta con un'espressione di \"vicinanza\" definendo un'accuratezza in questo modo: const accuracy = 0.0000001 ; console . log ( ( 0.1 + 0.2 ) - 0.3 < accuracy ); //true Il pi\u00f9 piccolo valore rappresentabile (vicino allo zero) in floating point \u00e8: console . log ( Number . MIN_VALUE ); //5e-324 E' bene ricordare che la rappresentazione dei numeri con lo standard IEEE 754 \u00e8 su scala logaritimica quindi non lineare. Questo significa che posso rappresentare numeri estremamente grandi e numeri estremamente piccoli ma la distanza tra due numeri diventa sempre pi\u00f9 grande (e quindi meno accurata) mano a mano che i numeri diventano grandi e diventa pi\u00f9 piccola (quindi pi\u00f9 accurata) mano a mano che i numeri diventano piccoli Not A Number NaN Javascript restituisce NaN quando valuta che un'espressione non pu\u00f2 essere svolta e darebbe errore. console . log ( 10 / \"ciao\" ); //NaN console . log ( 0 / 0 ); //NaN E' buona norma evitare NaN in special modo per quelle espressioni numeriche non prevedibili o che ricevono valori dall'esterno. La funzione isNaN() restituisce un boolean se un dato valore risulta o meno un NaN. let myVar = 12 / 0.9 ; if ( ! isNaN ( myVar ) ) { console . log ( myVar ); } Lezione 10 Approfondimento - Codifica caratteri Javascript Questa parte per adesso potrebbe essere troppo approfondita, \u00e8 possibile saltarla senza pregiudicare il corso ASCII ASCII (acronimo di American Standard Code for Information Interchange, Codice Standard Americano per lo Scambio di Informazioni) \u00e8 un codice per la codifica di caratteri. Lo standard ASCII \u00e8 stato pubblicato dall'American National Standards Institute (ANSI) nel 1968 Con US-ASCII si intende un sistema di codifica dei caratteri a 7 bit, comunemente utilizzato nei calcolatori, proposto dall'ingegnere dell'IBM Bob Bemer nel 1961, e successivamente accettato come standard dall'ISO, con il nome di ISO/IEC 646. Alla specifica iniziale basata su codici di 7 bit fecero seguito negli anni molte proposte di estensione ad 8 bit e quindi 256 caratteri, con lo scopo di raddoppiare il numero di caratteri rappresentabili. Nei PC IBM si fa per l'appunto uso di una di queste estensioni, ormai standard de facto, chiamata extended ASCII o high ASCII. In questo ASCII esteso, i caratteri aggiunti sono vocali accentate, simboli semigrafici e altri simboli di uso meno comune. I caratteri di ASCII esteso sono codificati nei cosiddetti codepage. Ogni paese present\u00f2 la sua proposta di ASCII esteso per rappresentare e codificare tutti i caratteri aggiuntivi relativi alla lingua creando non pochi problemi di comunicazione tra continenti. C'era quindi bisogno di uno standard nuovo e unico per tutto il mondo. Nasce quindi l'UNICODE. Wikipedia - ASCII Unicode Unicode \u00e8 stato creato per risolvere i limiti dei tradizionali schemi di codifica dei caratteri Ad esempio , sebbene i caratteri definiti nella ISO 8859-1 siano ampiamente utilizzati in paesi diversi, spesso si verifica incompatibilit\u00e0 tra paesi diversi. Molti metodi di codifica tradizionali hanno un problema comune, ovvero consentono ai computer di gestire un ambiente bilingue (di solito utilizzando lettere latine e le loro lingue native), ma non possono supportare un ambiente multilingue allo stesso tempo (riferendosi a una situazione in cui pi\u00f9 lingue possono essere mescolate contemporaneamente). Unicode era stato originariamente pensato come una codifica a 16 bit (quattro cifre esadecimali) che dava la possibilit\u00e0 di codificare 65.535 (2^16 -1) caratteri. Tanto si riteneva essere sufficiente per rappresentare i caratteri impiegati in tutte le lingue scritte del mondo. Ora invece lo standard Unicode, che tendenzialmente \u00e8 perfettamente allineato con la norma ISO/IEC 10646, prevede una codifica fino a 21 bit e supporta un repertorio di codici numerici che possono rappresentare circa un milione di caratteri. Ci\u00f2 appare sufficiente a coprire anche i fabbisogni di codifica di scritti del patrimonio storico dell'umanit\u00e0, nelle diverse lingue e negli svariati sistemi di segni utilizzati. Al 2009, solo una piccolissima parte di questa disponibilit\u00e0 di codici \u00e8 assegnata. Per lo sviluppo dei codici sono infatti previsti 17 \"piani\" (\"planes\", in inglese), da 00 a 10hex, ciascuno con 65.536 posizioni (quattro cifre esadecimali), ma solo i primi tre e gli ultimi tre piani sono ad oggi assegnati[2], e di questi il primo, detto anche BMP, \u00e8 praticamente sufficiente a coprire tutte le lingue pi\u00f9 usate. Concretamente, questo repertorio di codici numerici \u00e8 serializzato mediante diversi schemi di ricodifica, che consentono l'uso di codici pi\u00f9 compatti per i caratteri usati pi\u00f9 di frequente. \u00c8 previsto l'uso di codifiche con unit\u00e0 da 8 bit (byte), 16 bit (word) e 32 bit (double word), descritte rispettivamente come UTF-8, UTF-16 e UTF-32. UTF-8 \u00e8 di fatto lo standard successore di ASCII, perfettamente compatibile mentre javascript utilizza l'UTF-16 consentendo di rappresentare un numero elevato di caratteri, 655536. Ci\u00f2 non significa che per le codifiche UTF-8 e UTF-16 non sia possibile rappresentare tutti i caratteri unicode ma a causa della codifica potrebbe non essere conveniente in certe situazioni utilizzare UTF-8 anzich\u00e8 UTF-16. In certe situazioni infatti UTF-8 potrebbe aver bisogno di 3 byte per rappresentare un certo carattere mentre UTF-16 soltanto 2. Dipende dalla frequenza e natura dei caratteri. Si rirprenda il template html: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > </ body > </ html > Alla riga < meta charset = \"UTF-8\" > E' indicata la codifica necessaria per la trasmissione e visualizzazione corretta dei caratteri. Wikipedia - Unicode Wikibooks - Unicode/Character reference/0000-0FFF Caratteri di Escape Il backslash \\ indica la presenza di un carattere escape che non sarebbe possibile inserire direttamente con un editor di testo poich\u00e8 verrebbe interpretato come un comando. Vediamo qualche carattere di escape: \\n : a capo \\t : tab \\b : Backspace \\r : Carriage return \\\\ : Backslash \\' : Single quote \\\" : Double quote Introdotti gli escape \u00e8 possibile vedere come inserire un carattere UNICODE tramite il suo codice identificatico: \\u{codice_unicode} let str = \"\\u{1234}\" ; // \u1234 === 1234 codice unicode, 1 carattere console . log ( str ); console . log ( str , str . lenght ); //\u1234, 1 //Attenzione!! la codifica UTF-16 non raggiunge direttamnte il carattere stampato qui di seguito //Utilizza quindi 2 caratteri Javascript let str = \"\\u{1F600}\" ; // \ud83d\ude00 === 1F600 codice unicode, 2 caratteri console . log ( str , str . lenght ); //\ud83d\ude00, 2 Posso risalire al codice unicode tramite il metodo charCodeAt(index) che restituisce il codice unicode del carattere specificato da index . let str = \"\\u{1F600}\" ; // \ud83d\ude00 === 1F600 codice unicode 2 caratteri console . log ( str ); //\ud83d\ude00 console . log ( str . charCodeAt ( 0 ), strCharCodeAt ( 1 )); //55357 56832 C'\u00e8 anche il metodo che pi\u00f9 completo charCodePointAt(index) che restituisce il codice unicode che inizia da index . Questo \u00e8 necessario per quei caratteri che non possono essere rappresentati da UTF-16 e che quindi sono necessari \"due caratteri\" Javascript let str = \"\\u{1F600}\" ; // \ud83d\ude00 === 1F600 codice unicode 2 caratteri console . log ( str ); //\ud83d\ude00 console . log ( str . codePointAt ( 0 )); // 128512 === 1F600 Posso usare l'unicode anche per il nome di variabili! Da evitare. var \\ u { 1 f68 } = 2017 ; // \u1f68 Lezione 11 Type conversion JavaScript \u00e8 un linguaggio con tipi assegnati dinamicamente. Questo significa che non si va a specificare il tipo di dato che una variabile conterr\u00e0 quando viene dichiarata e anche che il tipo di un dato viene convertito automaticamente a seconda delle necessit\u00e0 durante l'esecuzione dello script. Nelle espressioni che coinvolgono valori numerici e stringhe con l'operatore + JavaScript converte i valori numerici in stringhe (conversione implicita). Vediamo come formalizzare questi concetti e distinguere tra conversioni esplicite e implicite. Conversione esplicita E' una pratica di buona programmazione far riferimento a conversioni esplicite come trattamento di errori o ricezione dati dall'esterno anche quando \"sembra\" che non sia necessario. La conversione esplicita forza un tipo e previene in molti casi errori di mal interpretazione dei dati. Vediamo alcune soluzioni disponibili per la conversione esplicita tra tipi in Javascript. String(value) : converte value (qualsiasi tipo) in un tipo String value.toString() : metodo che converte value in una stringa (equivalente a String(value) ) Number(value) : converte value in un tipo Number parseInt(value) - converte value in un tipo Number e ritorna la parte intera parseInt(value) - converte value in un tipo Number e ritorna la parte frazionaria //Number to string - String(value) let value = 45 ; String ( value ); //ritorna la stringa '45' //Boolean to string - String(value) let value2 = false ; String ( value2 ); //ritorna la stringa 'false' //Metodo alternativo - toString(); let value3 = false ; ( value3 ). toString (); //ritorna la stringa 'false' //String to number - Number(string) let string = '45' ; Number ( string ); //ritorna il numero 45 //Boolean to number - Number(string) let myBool = true ; Number ( myBool ); //1ritorna il numero 1 parseInt ( '100.31' ); //100 parseFloat ( '100.31' ); //31 Conversione implicita Anche se \u00e8 sconsigliato affidarsi alle conversioni implicite, cio\u00e8 quelle che Javascript effettua implicitamente incontrando in una espressione due o pi\u00f9 valori appartenenti a tipi diversi, \u00e8 bene conoscerle per difendersi e saperle trattare. In alcuni semplici casi non \u00e8 comunque sbagliato utilizzarle. Riporto un esempio qui sotto: // Type coercion const nome = 'marco' ; const cognome = 'rossi' ; const eta = 20 ; const sposato = false ; console . log ( nome + ' ' + cognome + ' ha ' + eta + ' anni. ' + '\u00e9 sposato? ' + sposato ); /* Console: --------------- marco rossi ha 20 anni. E' sposato? false */ Notiamo che la variabile eta \u00e8 stata convertita da tipo numero a tipo stringa e la variabile sposato \u00e8 stata convertita da boolean a stringa in modo implicito da javascript. Queste sono conversioni effettuate in modo automatico da javascript poich\u00e8 nella stessa espressione si trovano tipi diversi. Lezione 12 Operatori matematici Vediamo alcuni operatori matematici direttamente con un esempio: /* operatori matematici */ const questAnno = 2020 ; const etaMarco = 25 ; const etaStefano = 22 ; const nascitaMarco = questAnno - etaMarco ; const nascitaStefano = questAnno - etaStefano ; console . log ( nascitaMarco ); //1995 console . log ( nascitaStefano ); //1998 console . log ( 5 * 2 ); //10 console . log ( 5 / 2 ); //2.5 // Modulo: resto della divisione intera console . log ( 7 % 4 ); //3 Pre e post incremento/decremento L'operatore di incremento incrementa (aggiunge uno a) il suo operando e restituisce un valore. ++x / --x : pre incremento/decremento restituisce il valore dopo l'incremento x++ / x-- : post incremento/decremento restituisce il valore prima di incrementare Pre e post incremento/decremento rilevano una differenza solo in caso di valutazione di un'espressione. Se troviamo Pre e post incremento/decremento isolati in un singolo statement (come spesso accade) risultano equivalenti. //Pre incremento x = 0 ; y = ++ x ; //y=1, x=1 //Post incremento x = 0 ; y = x ++ ; //y=0, x=1 x = 0 ; x ++ ; //x=1 // in questo caso \u00e8 equivalente a ++x x = 0 ; ++ x ; //x=1 // in questo caso \u00e8 equivalente a x++ La lista di tutti gli operatori aritmetici la troviamo alla pagina: MDN - Operatori Aritmetici Oggetto MATH In JS \u00e8 possibile utilizzare funzioni matematiche avanzate tramite l'oggetto Math . Vediamo alcune tra le pi\u00f9 comuni: Math.round(value) : Ritorna l'arrotondamento di value al numero pi\u00f9 vicino Math.ceil(value) : Ritorna l' arrotondamento di value per eccesso Math.floor(value) : Ritorna l' arrotondamento di value per difetto Math.trunc(value) : Ritorna il troncamento di value Math.sqrt(value) : Ritorna la radice quadrata di value Math.abs(value) : Ritorna il valore assoluto di value Math.pow(base, exp) : Ritorna l'esponenziale: base^exp Math.min(value1, value2, value3, ..) : Ritorna il minimo valore tra i parametri indicati tra gli argomenti Math.max(value1, value2, value3, ..) : Ritorna il massimo valore tra i parametri indicati tra gli argomenti Math.random() : Ritorna un numero random decimale nel range 0 - 1 Esempio: //Math.PI console . log ( Math . PI ); //stampa del numero pi greco: 3,14.. Math . round ( 42.1 ); //42 Math . round ( 42.5 ); //43 Math . round ( 42.7 ); //43 Math . ceil ( 42.1 ); //43 Math . ceil ( 42.5 ); //43 Math . ceil ( 42.7 ); //43 Math . floor ( 42.1 ); //42 Math . floor ( 42.5 ); //42 Math . floor ( 42.7 ); //42 Math . sqrt ( 25 ); //5 Math . sqrt ( 42.5 ); //6. Math . abs ( - 25 ); //25 Math . abs ( 42.5 ); //42.5 Math . pow ( 2 , 5 ); //32 ( 2 ** 5 ); //32 === 2^5 >> equivalente a Math.pow(2, 5); Math . pow ( 5 , 3 ); //125 Math . min ( 2 , 5 , - 2 , 6 ); //-2 Math . max ( 2 , 5 , - 2 , 6 ); //6 Math . random (); //0.234514378429 Math . trunc ( 12.78899 ); //12 La seguente riga di codice genera un numero casuale da 0 a 100. console . log ( Math . round (( Math . reandom () * 100 ))); //45 Lezione 13 Equazione di II grado Il seguente script calcola le soluzioni reali di un'equazione di secondo grado. Stampa \"Soluzioni immaginarie\" se le soluzioni non sono reali <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table { border : 2 px solid gray ; padding : 5 px ; border-radius : 10 px ; } body { font-size : 20 px ; } . cofficient { text-align : right ; } # resolve { height : 30 px ; } </ style > </ head > < body > < h1 > Equazione di II grado </ h1 > < table > < tr > < td > < input type = \"text\" placeholder = \"a\" class = \"cofficient\" id = \"a\" > x < sup > 2 </ sup > + < input type = \"text\" placeholder = \"b\" class = \"cofficient\" id = \"b\" > x + < input type = \"text\" placeholder = \"c\" class = \"cofficient\" id = \"c\" > = 0 </ td > </ tr > < tr > < td >< input type = \"button\" value = \"Risolvi\" id = \"resolve\" ></ td > </ tr > < tr > < td > < input type = \"text\" placeholder = \"---\" id = \"ris-1\" > x < sub > 1 </ sub > </ td > </ tr > < tr > < td > < input type = \"text\" placeholder = \"---\" id = \"ris-2\" > x < sub > 2 </ sub > </ td > </ tr > </ table > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function ResolveEqIIgrado (){ //Prelievo il valore dell'elemento con id=\"myText\" lo converto a stringa e lo assegno alla variabile testoInserito let a = Number ( $ ( \"#a\" ). val ()); let b = Number ( $ ( \"#b\" ). val ()); let c = Number ( $ ( \"#c\" ). val ()); let delta = Math . sqrt ( b ** 2 - 4 * a * c ); if ( isNaN ( delta )) { $ ( \"#ris-1\" ). val ( \"Soluzioni immaginarie\" ); $ ( \"#ris-2\" ). val ( \"Soluzioni immaginarie\" ); } else { let ris1 = ( - b - delta ) / ( 2 * a ); let ris2 = ( - b + delta ) / ( 2 * a ); $ ( \"#ris-1\" ). val ( String ( ris1 )); $ ( \"#ris-2\" ). val ( String ( ris2 )); } } $ ( function (){ $ ( \"#resolve\" ). click ( ResolveEqIIgrado ) }); </ script > </ body > </ html > Lezione 14 Operator Precedence La precedenza degli operatori determina la priorit\u00e0 in cui gli operatori vengono valutati. Gli operatori con precedenza pi\u00f9 alta sono valutati prima degli operatori con precedenza pi\u00f9 bassa. La lista completa di tutti gli operatori con le rispettive precedenze la troviamo qua: MDN - Operator Precedence Da notare che l'operatore ( ) ha la priorit\u00e0 pi\u00f9 alta e quindi la precedenza su tutti gli operatori. Questo significa che per forzare la precedenza, esattamente come per la matematica \u00e8 possibile sfruttare le parentesi ( ) . Regola di buona programmazione: Non \u00e8 mai una buona pratica di programmazione lasciare espressioni troppo complesse prive di parentesi anche se sono rispettate dal punto di vista semantico tutte le precedenze previste. Le parentesi, oltre a forzare la precedenza, offrono visivamente una chiarezza maggiore, evitando di commettere errori banali di svista. /* Operatore precedence */ /* Calcolo eta' media */ const questAnno = 2020 ; const maggiorenne = 18 ; const nascitaMarco = 1996 ; const nascitaLuca = 2006 ; /* l'operatore \"-\" ha precedenza sull'operatore \">\" quindi l'espressione \u00e8 svolta correttamente da sinistra verso destra La sottrazione verr\u00e0 quindi svolta prima dell'operatore \">\" */ let isMaggiorenne = questAnno - nascitaMarco > maggiorenne console . log ( isMaggiorenne ); //true let isMaggiorenne = questAnno - nascitaMarco > maggiorenne console . log ( isMaggiorenne ); //false //Grouping const etaMarco = questAnno - nascitaMarco ; //24 const etaLuca = questAnno - nascitaLuca ; //14 // In questo caso poich\u00e8 la divisione ha precedenza sulla somma \u00e8 necessario forzare la priorit\u00e0 inserendo le parentesi // Calcolo et\u00e0 media console . log ( ( etaMarco + nascitaLuca ) / 2 ); //19 Associativit\u00e0 L'associativit\u00e0 specifica in che modo vengono eseguite le elaborazioni a parit\u00e0 di operatore. Mentre la precedenza valuta la priorit\u00e0, l'associativit\u00e0 valuta la modalit\u00e0 di esecuzione. Quasi tutti gli operatori hanno un'associativit\u00e0 left-to-right ovvero, l'elaborazione \u00e8 da sinistra verso destra esattamente come per la matematica. Alla pagina MDN - Operator Precedence si trova una tabella riassuntiva che mostra priorit\u00e0/associativit\u00e0 per ogni operatore. //Associativit\u00e0 del'operatore +. L'operatore + vale sia da somma che da concatenazione stringa for ( let i = 0 , j = 5 ; i <= j ; i ++ , j -- ){ document . writeln ( i + j + \" \" ); //5//5//5 } for ( let i = 0 , j = 5 ; i <= j ; i ++ , j -- ){ document . writeln ( i + ( j + \" \" ) ); //05//14//23 } Operatori di assegnamento L'operatore di assegnazione semplice = viene utilizzato per assegnare un valore a una variabile. L'operazione di assegnazione restituisce il valore assegnato. \u00c8 possibile concatenare l'operatore di assegnazione per assegnare un singolo valore a pi\u00f9 variabili (multiple assignment). //Multiple assignement // E' possibile dichiarare due variabili contemporaneamente let x , y ; /*Molto importante! L'operatore \"= \u00e8 un operatore da destra a sinistra */ x = y = ( 2 * 7 ) * 3 - 5 ; // 9 * 3 - 5 // 27 - 5 // 22 console . log ( x ); //22 console . log ( y ); //22 Molto utilizzati sono anche gli operatori di assegnamento composto come: +=, -=, *=, /= .. Hanno una sintassi molto chiara e compatta. Vengono utilizzati nei casi in cui \u00e8 necessario elaborare anche il valore della variabile a sinistra contrariamente all'operatore di assegnamento semplice = che ignora e distrugge il valore contenuto a sinistra. let x = 10 ; x *= 2 ; // x = x * 2 console . log ( x ); //20 x /= 2 ; // x = x / 2 console . log ( x ); //10 Lezione 15 Operatori Logici Gli operatori logici < , <= , == , > , >= , != .. trattano l'espressione come un espressione logica e ritornano un valore booleano. Sono spesso utilizzati nel controllo di condizioni in costruttti if o cicli while , for e tutti i costrutti condizionali e iterativi inerenti. console . log ( 1 >= 5 ); //false //Per le stringhe si segue un ordine lessicografico console . log ( \"ciao\" < \"pasta\" ); //true console . log ( 12 != 5 ); / / / true Nota - Operatore di uguaglianza: == Vs === Entrambi sono operatori logici di uguaglianza. === : Uguaglianza forte , valuta l'uguaglianza dell'espressione valutanto il tipo e il contenuto. == : Uguaglianza debole , valuta l'uguaglianza dell'espressione valutanto il contenuto effettuando prima una conversione di tipo. /* === */ console . log ( 5 === 5 ); //true console . log ( 15 === \"15\" ); //false -> sono tipi di dati diversi, il primo \u00e8 un numero, il secondo \u00e8 una stringa console . log ( null === undefined ); //false -> sono tipi di dati diversi. /* == */ console . log ( 5 == 5 ); //true console . log ( 15 == \"15\" ); //true!! -> sono tipi di dati diversi, il primo \u00e8 un numero, il secondo \u00e8 una stringa ma il contenuto \u00e8 lo stesso console . log ( false == 0 ); //true!! -> entrambi hanno un valore falsy anche se il tipo \u00e8 diverso console . log ( null == undefined ); //true!! -> entrambi hanno un valore falsy anche se il tipo \u00e8 diverso In generale l'uguaglianza forte \u00e8 da preferire per essere sicuri di effettuare quindi anche un controllo sul tipo e rendere pi\u00f9 semplice l'individuazione di errori run-time spesso causati da conversioni implicite di Javascript. Logica Booleana Trattano l'espressione come un'espressione logica e permettono la concatenazione di espressioni con pi\u00f9 operatori logici. Ritornano un valore booleano: TRUE , FALSE . Vediamo i principali: AND : condition1 && condition2 : Ritorna true se entrambe condition1 e condition2 risultano true . OR : condition1 || condition2 : Ritorna true se almeno una tra condition1 e condition2 risulta true . NOT : !condition1 : Inverte il risultato logico di condition1 . console . log ( ( 1 >= 5 ) || ( \"ciao\" < \"pasta\" ) ); //true console . log ( ( \"ciao\" < \"pasta\" ) && ( 12 == 5 ) ); //false Approfondimento - Short evalutation Se un' espressione logica risulta necessariamente true o false le elaborazioni concatenate non vengono elaborate. true || expr : expr non viene valutata false && expr : expr non viene valutata Esempio: console . log ( ( 1 < 2 ) || ( \"ciao\" < \"pasta\" ) ); //true, (\"ciao\" < \"pasta\") non viene valutata console . log ( ( 12 == 5 ) && ( \"c\" < \"p\" ) ); //false, (\"c\" < \"p\") non viene valutata Truthy e falsy I valori truthy e falsy sono quei valori considerati rispettivamente sempre veri o falsi o per meglio dire che ritornano sempre un boolean: true/false . Valori truthy: 1 , \"content\" .. Valori falsy: undefined , null , 0 , \"\" , NaN Vedremo adesso come mettere in pratica questi concetti attraverso l'uso di costrutti condizionali e iterativi. Lezione 16 Control Structure if/else La struttura di controllo if/else esegue un'istruzione o un blocco di istruzioni se una condizione specificata come argomento di if risulta true . Se la condizione risulta false si eseguono le istruzioni del ramo else MDN - if...else if ( condition1 ) { //code } else if ( condition2 ) { //code } else { //code } La condizione espressa come argomento di if \u00e8 trattata come un'espressione logica e quindi ritorna un boolean: true/false . /*Utilizzo di operatori logici combinati al costrutto if/else*/ const maggioreEta = 18 ; const etaLuca = 10 ; if ( etaLuca > maggioreEta ) { console . log ( \"Luca \u00e8 maggiorenne\" ); } else { console . log ( \"Luca non \u00e8 maggiorenne\" ); } /* Luca non \u00e8 maggiorenne */ /* Boolean logic, trattano l'espressione come logica AND -> && : ritorna TRUE se tutte le condizioni sono VERE OR -> || : ritorna TRUE se una condizione \u00e8 VERE NOT -> ! : inverte il risultato dell'espressione logica */ const nome = \"Luca\" ; const eta = 15 ; if ( eta <= 13 ) { console . log ( nome + \" \u00e8 un bambino\" ); } else if ( eta > 13 && eta <= 20 ) { console . log ( nome + \" \u00e8 un ragazzo\" ); } else { console . log ( nome + \" \u00e8 un adulto\" ); } /* Luca \u00e8 un ragazzo */ Ternary Operator Il Ternary Operator \u00e8 un costrutto condizionale inline. L'operatore condizionale (ternary) \u00e8 l'unico operatore JavaScript che necessit\u00e0 di tre operandi. Questo operatore \u00e8 frequentemente usato al posto del comando if per la sua sintassi concisa e perch\u00e9 fornisce direttamente un espressione valutabile. MDN - Operatore condizionale (ternary) (condition) ? (steatement1) : (steatement2); : Se condition risulta true verr\u00e0 eseguito steatement1 altrimenti steatement2 . /* Ternary Operator */ var nome = \"Marco\" ; var eta = \"17\" ; eta >= 18 ? console . log ( nome + \" pu\u00f2 guidare\" ) : console . log ( nome + \" non pu\u00f2 guidare\" ); /* Marco non pu\u00f2 guidare */ E' da preferire il ternary operator nei casi in cui si hanno due semplici statemeant da eseguire condizionati da un'espressione altrettanto semplice. In questo caso risulta chiaro ed elegante. Switch statemeant L'ultimo costrutto condizionale \u00e8 switch . Il comando switch valuta un espressione, confronta il valore dell'espressione con ciascuna delle clausole case ed esegue i comandi (statements) associati alla clausola (case) che verifica il confronto. MDN - switch switch ( key ) { case value1 : //code break ; case value2 : //code break ; default : //code break ; } Esempio: /* switch statemeant*/ const sport = \"calcio\" ; switch ( sport ) { case \"calcio\" : console . log ( \"Amo giocare a calcio\" ); break ; case \"tennis\" : console . log ( \"Amo giocare a tennis\" ); break ; default : console . log ( \"non amo nessuno sportf\" ); break ; } /* Console: --------------- Amo giocare a calcio */ In che occasioni si usa \u00e8 preferibile utilizzare il costrutto switch ? E' da preferire quando si hanno opzioni multiple di una un unico key (un tipo di dato qualsiasi) da valutare e tutte le opzioni sono omogenee. In questo caso risulta chiaro e leggibile. Nel prossimo esempio lo switch/case \u00e8 trasformato in un if/else . /* switch statemeant*/ const nome = \"Matteo\" ; const eta = 15 ; switch ( true ) { case ( eta <= 13 ) : console . log ( nome + \" \u00e8 un bambino\" ); break ; case ( eta > 13 && eta <= 20 ) : console . log ( nome + \" \u00e8 un ragazzo\" ); break ; default : console . log ( nome + \" \u00e8 un adulto\" ); break ; } /* Matteo \u00e8 un ragazzo */ In questo caso lo switch/case risulta meno chiaro di un if/else . E' importante fin da subito saper utilizzare i costrutti giusti per la situazione giusta. Lezione 17 while loop L'istruzione while crea un ciclo che esegue un'istruzione specificata fintanto che la condizione di test restituisce true . La condizione viene valutata prima di eseguire l'istruzione. MDN - while while ( condition ) { //code } Esempio: let contatore = 1 ; while ( contatore < 5 ) { console . log ( contatore ); contatore ++ ; } /* 1 2 3 4 */ In un qualsiasi costrutto iterativo \u00e8 sempre bene tenere in considerazione: - La condizione da verificare - l'evento che altera, ad ogni ciclo, la condizione da verificare. Il programmatore si deve assicurare che prima o poi la condizione diventi falsa altrimenti rischia di creare un loop infinito causando un crash del browser. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > LOOP INFINITO </ h1 > < script > /*Loop Infinito - DA EVITARE! */ var infinito = 0 ; while ( infinito < 10 ) { console . log ( infinito ); } </ script > </ body > </ html > Altro esempio di un ciclo iterativo applicato a una stringa con while : var parola = \"ciao\" ; var contatore = 0 ; while ( contatore < parola . length ) { // 0 < 4 // 1 < 4 // 2 < 4 // 3 < 4 console . log ( parola [ contatore ]); // c // i // a // o contatore ++ ; // 1 // 2 // 3 // 4 } /* parola.lenght -> restituisce il numero delle lettere che compongono la stringa parola parola[contatore] -> restituisce il contenuto relativo all'indice \"contaotore\" Output: c i a o */ do-while loop L'istruzione do ... while crea un ciclo che esegue un'istruzione specificata finch\u00e9 la condizione di test non restituisce false. La condizione viene valutata dopo l'esecuzione dell'istruzione, determinando l'esecuzione dell'istruzione specificata almeno una volta. MDN - do...while do { //code } while ( condition ); let j = 0 ; do { j ++ ; console . log ( j ); } while ( j < 5 ); console . log ( j ); /* Console: --------------- 0 1 2 3 4 */ Il do-while loop \u00e8 molto simile al while loop ma differisce nel punto in cui valuta la condizione sotto test. Qui sotto riporto un esempio dello stesso loop realizzato prima con while e poi con do-while. //while let i = 5 ; //la condizione \u00e8 falsa, non eseguo il corpo del loop while ( i < 5 ){ i ++ ; console . log ( i ); } console . log ( i ); /* 5 */ //do-while let j = 5 ; do { j ++ ; console . log ( j ); } while ( j < 5 ); //la condizione \u00e8 falsa ma ho eseguito una volta il corpo del loop console . log ( j ); /* Console: --------------- 6 6 */ do...while esegue il ciclo almeno una volta mentre while pu\u00f2 anche non eseguire mai il corpo. do...while \u00e8 meno utilizzato rispetto while ma pu\u00f2 comunque essere utilizzato in strutture iterative sempre in esecuzione come quella di selezione di un men\u00f9 grafico a opzioni multiple. Lezione 18 for loop L'istruzione for crea un ciclo che consiste di tre espressioni opzionali, racchiuse tra parentesi tonde ( ) e separate da punto e virgola, seguite da un'istruzione (di solito un'istruzione di blocco) da eseguire nel ciclo. MDN - for for ( inizializzazione ; condizione ; incremento / decremento ){ //code } Esempio: for ( let contatore = 1 ; contatore < 5 ; contatore ++ ){ console . log ( contatore ); } /* 1 2 3 4 */ Nota : la variabile \"contatore\", poich\u00e8 \u00e8 creata all'interno del ciclo for vive all'interno del ciclo. Al di fuori del ciclo non \u00e8 conosciuta. Vediamo anche un altro esempio precedentemente svolto con while : /* For Loop */ const nome = \"Marco\" ; for ( let i = 0 ; i < nome . length ; i ++ ){ // 0 < 4 // 1 < 4 // 2 < 4 // 3 < 4 // 4 < 5 // console . log ( nome [ i ]); // M // a // r // c // o } /* M a r c o */ Approfondimento: I cicli in cui sono note a priori il numero di iterazioni sono sono detti \"enumerativi\". Per questi cicli la struttura pi\u00f9 adatta \u00e8 certamente il for . I cicli si dicono invece \"indefiniti\" quando a priori non \u00e8 noto il numero esatto di iterazioni. Per questi cicli la struttura pi\u00f9 adatta \u00e8 il while o il do-while . Gli esempi riportati fino ad ora sono tutti cicli enumerativi. Notiamo infatti che la struttura for risulta pi\u00f9 chiara e compatta ed \u00e8 quindi da preferire. break & coninue All'interno del corpo di loop statemeant for / while / do... while \u00e8 possible invocare i comandi: continue , break . - continue : Salta all'iterazione successiva ignorando le istruzioni successive - break : Esce dal loop. Vediamo l'uso attraverso un esempio //NO continue NO break for ( let i = 0 ; i < 5 ; i ++ ){ if ( i === 2 ){ console . log ( 'QUESTO \u00c8 2' ); } console . log ( i ); } /* Console: --------------- 0 1 QUESTO \u00c8 2 2 3 4 */ //<conitnue> salta all'iterazione successiva for ( let i = 0 ; i < 5 ; i ++ ){ if ( i === 2 ){ console . log ( 'QUESTO \u00c8 2' ); continue } console . log ( i ); } /* 0 1 QUESTO \u00c8 2 3 4 */ //<break> esce dal ciclo for ( let i = 0 ; i < 5 ; i ++ ){ if ( i === 2 ){ console . log ( 'QUESTO \u00c8 2' ); break ; } console . log ( i ); } /* 0 1 QUESTO \u00c8 2 */ Approfondimento break: E' possibile uscire da loop innestati facendo uso di un'etichetta. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table td { text-align : center ; border : 1 px dashed black ; padding : 10 px ; margin-bottom : 10 px ; } </ style > </ head > < body > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > document . write ( \"<table>\" ); myLoop : for ( let i = 1 ; i <= 10 ; i ++ ) { document . write ( \"<tr>\" ); for ( let j = 1 ; j <= 10 ; j ++ ) { document . write ( \"<td>\" + \"A\" + \"</td>\" ); if ( j * i == 20 ) break myLoop ; } document . write ( \"</tr>\" ); } document . write ( \"</table>\" ); </ script > </ body > </ html > Lezione 19 Function Le funzioni sono tra i blocchi di programmazione fondamentali in JavaScript. Una funzione \u00e8 una procedura JavaScript \u2014 un gruppo di istruzioni ( statement ) che esegue un compito o calcola un valore. La definizione di funzione ( o dichiarazione di funzione, o istruzione di funzione ) consiste della parola chiave function , seguita da: il nome della funzione. una lista di argomenti per la funzione, chiusi tra due parentesi e separati da una virgola. le istruzioni JavaScript che definiscono la funzione, chiuse tra due parentesi graffe, { }. MDN - Funzioni //Dichiarazione o definizione di una funzione function name ( param1 , param2 , ? param3 ) { //code } //Chiamata name ( param1 , param2 ); Esempio: /* Function with arguments */ function salutoCompleanno ( nome , anni ){ console . log ( \"ciao \" + nome + \", auguri per i tuoi \" + anni + \" anni!\" ); } salutoCompleanno ( \"Francesco\" , 22 ); //ciao Francesco, auguri per i tuoi 22 anni! Nota: L'ordine dei parametri \u00e8 importante! Nota2: Il passaggio dei parametri \u00e8 sempre per valore intendendo che al momento della chiamata della funzione, si esegue una copia dei parametri. Non vengono quindi elaborati direttamente i valori passati a una funzione Parametri di default Alcuni parametri possono essere opzionali. In fase di chiamata possono quindi essere passati dei valori a tali parametri opppure no. In caso non venga passato un valore a tali parametri assumeranno all'interno della funzione un cos\u00ecdetto valore di default . Per inserire un valore di default e quindi rendere il parametro opzionale basta assegnare ad esso un valore in fase di dichiarazione della funzione. Vediamo un esempio: function salutoCompleanno ( nome , anni = 0 ){ if ( anni === 0 ){ console . log ( \"ciao \" + nome + \", auguri per il tuo compleanno!\" ); } else { console . log ( \"ciao \" + nome + \", auguri per i tuoi \" + anni + \" anni!\" ); } } salutoCompleanno ( \"Francesco\" , 22 ); //ciao Francesco, auguri per i tuoi 22 anni! salutoCompleanno ( \"Mario\" ); //ciao Mario, auguri per il tuo compleanno! NOTA: E' buona norma passare parametri in modo che i primi siano obbligatori e gli altri opzionali anche se tutto \u00e8 consentito ma di fatto in fase di chiamata della funzione i parametri passati sono interpretati a partire dal primo. Ricorda che conta solo l'ordine dei parametri e non l'identificativo utilizzato Ritorno di una funzione Una funzione pu\u00f2 restituire un valore con il comando return /* Return Keword */ function quadrato ( numero ){ return ( numero * numero ); } console . log ( quadrato ( 5 ) ); //25 E' preferibile che una funzione esegua un'elaborazione interna e che ritorni un valore invece di salvare il risultato all'interno di variabili esterne globali. In questo modo \u00e8 possibile riutilizzare la funzione ovunque e non renderla dipendente dal codice. E' quindi indispensabile l'utilizzo del return Note Una funzione ammette un solo return che termina l'esecuzione della funzione. Eventuali linee di codice dopo il return verranno ignorate. Lezione 20 Funzioni - Passaggio di oggetti e array Il passaggio di oggetti e array come parametri ad una funzione avviene per riferimento . Dal momento che viene passato il nome dell'oggetto e dell'array che corrisponde all'indirizzo puntatore dei dati contenuti, viene effettuata la copia dell'indirizzo e non dell'intero oggetto/array contenente i dati interni. In sostanza \u00e8 possibile accedere e modificare i dati dell'array o oggetto passato!! //Metodo Object - Gli oggetti sono passati per riferimento const annoAttuale = 2020 ; const objPersona = { nome : \"simone\" , eta : 24 , titolo : \"laurea\" , annoNascita : 1994 } aggiornaEta ( objPersona , annoAttuale ); console . log ( objPersona . eta ); //26 function aggiornaEta ( obj , anno ){ obj . eta = anno - obj . annoNascita ; console . log () } //Metodo Array - Gli array sono passati per riferimento const arrayPersona = [ \"simone\" , //0 24 , //1 \"laurea\" , //2 1994 //3 ]; aggiornaEta2 ( arrayPersona , annoAttuale ); console . log ( arrayPersona [ 1 ]); //26 function aggiornaEta2 ( array , anno ){ array [ 1 ] = anno - array [ 3 ]; console . log ( array ); } Funzioni - Ritorno di un oggetto o un array Una funzione in Javascript pu\u00f2 avere come tipo di ritorno anche un oggetto o un array //Metodo Oggetto let objRisultatoEqIIgrado = objCalcolaRisultatoEqIIgrado ( 1 , 5 , - 1 ); console . log ( \"Risultato 1: \" + objRisultatoEqIIgrado . x1 ); console . log ( \"Risultato 2: \" + objRisultatoEqIIgrado . x2 ); function objCalcolaRisultatoEqIIgrado ( a , b , c ){ let delta = Math . sqrt ( b * b - 4 * a * c ); let ris1 = ( - b + delta ) / 2 ; let ris2 = ( - b - delta ) / 2 ; //Ritorno un oggetto return { x1 : ris1 , x2 : ris2 }; } //Metodo Array let arrayRisultatoEqIIgrado = arrayCalcolaRisultatoEqIIgrado ( 1 , 6 , - 1 ); console . log ( \"Risultato 1: \" + arrayRisultatoEqIIgrado [ 0 ]); console . log ( \"Risultato 2: \" + arrayRisultatoEqIIgrado [ 1 ]); function arrayCalcolaRisultatoEqIIgrado ( a , b , c ){ let delta = Math . sqrt ( b * b - 4 * a * c ); let ris1 = ( - b + delta ) / 2 ; let ris2 = ( - b - delta ) / 2 ; //Ritorno un oggetto return [ ris1 , ris2 ]; } Approfondimento funzioni - Oggetto Arguments Facendo uso di arguments \u00e8 possibile passare un numero indefinito di parametri. arguments raggruppa gli argomenti in un oggetto collezione di elementi. L'oggetto arguments permette di utilizzare la propriet\u00e0 lenght , l'indicizzazione [ ] ma non \u00e8 un array e quindi non si possono applicare i metodi applicabili agli array. arguments non si specifica nella definizione di una funzione tra i parametri poich\u00e8 \u00e8 un oggetto riconosciuto nel contesto stesso della funzione //arguments \u00e8 un oggetto riconosciuto all'interno della definizione della funzione function somma (){ let ris = 0 ; for ( let index = 0 ; index < arguments . length ; index ++ ) { ris += arguments [ index ]; } console . log ( arguments ); return ris ; } console . log ( somma ( 1 , 4 )); //5 console . log ( somma ( 1 , 4 , 6 , 0 , 3 , 1 , 2 )); //17 console . log ( somma ()); //0 Approfondimento funzioni - Parametri Rest La sintassi dei rest parameter permette di rappresentare un indefinito numero di argomenti come un array. A differenza dell'oggetto arguments in questo caso gli argomenti \"restanti\" sono rappresentati e raggruppati in un array ed \u00e8 possibile quindi utilizzare ogni metodo applicabile agli arrays. Si specificano i rest parameter all'interno della definizione di una funzione come ultimo parametro attraverso l'operatore rest ... ... : Operatore rest MDN - Rest parameters function calcola ( a , b , ... altriParam ){ ris = a + b ; //Il forEach(param1, param2) ha due parametri. Il primo \u00e8 una funzione che a sua volta accetta i parametri //opzionali (valore, indice, array) in questo caso dell'array altriParam passato come argomento a calcola. //this in questo caso rappresenta il fatto che voglio ritornare il valore all'interno del contesto di ris altriParam . forEach ( controllaEsomma , this ); return ris ; } function controllaEsomma ( valore , indice , array ){ if ( valore < 100 ) { //this riesce a raggiungere il contesto di \"ris\" della funzione calcola this . ris += valore ; } } console . log ( calcola ( 1 , 4 )); //5 console . log ( calcola ( 1 , 4 , 6 , 100 , 3 , 1 , 2 )); //17 console . log ( calcola ( 1 , 2 )); //0 Approfondimento Introduzione forEach / this forEach() \u00e8 un metodo applicabile agli array. E' una struttura iterativa cheesegue una funzione fornita una volta per ogni elemento dell'array a cui si applica il metodo. La funzione riceve dall'array tre parametri opzionali in ordine: value, index, array ovvero il valore dell'elemento dell'array a cui si applica il metodo, l'indice dell'elemento e l'array stesso. myArray . forEach ( myFunc ); function myFunc ( value , index , array ){ //code; } Nell'esempio di sopra: altriParam . forEach ( controllaEsomma , this ); Esegue la funzione controllaEsomma per ogni elemento dell'array. function controllaEsomma ( valore , indice , array ){ if ( valore < 100 ) { //this riesce a raggiungere il contesto di \"ris\" della funzione calcola this . ris += valore ; } } L'identificatore this , come il forEach stesso verranno approfonditi pi\u00f9 avanti. Per adesso ci basta sapere che this consente di raggiungere un oggetto utilizzato come callback (valore di ritorno). Osservazione: Se dichiariamo la variabile \"ris\" con let o var ritorna NaN . Approfondimento: MDN - var Lezione 21 Approfondimento Funzioni ricorsive Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. La funzioni ricorsive sono funzioni che richiamano se stesse all'interno del corpo. Questa tecnica fornisce un modo per scomporre problemi complicati in problemi semplici che sono pi\u00f9 facili da risolvere. Con le funzioni ricorsive si costruiscono algoritmi potenti. function x ( contatore ){ if ( contatore > 5 ){ return ; //Terminatore, } else { x ( ++ contatore ); //passo ricorsivo console . log ( contatore ); } } x ( 0 ); /* 6 5 4 3 2 1 */ Nell'esempio di sopra al primo passo ricorsivo x(++contatore) non eseguo console.log(contatore); che rimane pending nello stack. Cos\u00ec anche per gli altri passi successivi finch\u00e8 la condizione dell' if diventa true e l'ultima funzione ritorna. A questo punto lo statemeant console.log(contatore); rimasto pending viene eseguito e cos\u00ec via i precedenti. fino al ritorno dell'intera funzione Osservazioni: - Se nulla limita il meccanismo di chiamate a funzione con una serie di ritorni a cascata, lo stack si riempie e il browser va in crash con l'errore Maximum call stack size exceeded . - E' un meccanismo che rallenta parecchio l'applicazione quando il passo ricorsivo diverge. Approfondimento Function expression Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. La parola chiave function pu\u00f2 essere utilizzata per definire una funzione all'interno di un'espressione. var media = function ( a , b ){ //funzione anonima return ( a + b ) / 2 ; }; console . log ( media ( 4 , 9 )); var fattoriale = function fatt ( n ){ if ( n === 0 ){ return 1 ; } else { return n * ( fatt ( n - 1 )); } } console . log ( fattoriale ( 4 )); //24 Approfondimento Hoisting Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. Per comprendere l'hoisting \u00e8 necessario introdurre il meccanismo di parsing dell'interprete javascript. Prima di eseguire lo script, il parser dell'interprete Javascript scansiona tutto il codice per risolvere i valori da assegnare agli identificatori ed esegue molte altre operazioni function esterna () { function interna (){ return \"interna1\" ; } return interna (); function interna (){ return \"interna2\" ; } } console . log ( esterna () ); //interna2 Nell'esempio di sopra, poich\u00e8 la funzione interna() \u00e8 stata definita due volte, il parser sovraiscrive la prima definizione con la seconda! Tutto cambia se utilizzo le function expression function esterna () { var interna = function (){ return \"interna1\" ; } return interna (); var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //interna1 In questo caso poich\u00e8 non sono definizioni di funzione ma variabili la seconda variabile non viene valutata poich\u00e8 \u00e8 codice irraggiungibile. In questo caso si segue un andamento lineare del codice anche detto paradigma imperativo. Nel caso invece di chiamate a funzione il paradigma si dice funzionale. Altro controesempio: function esterna () { return interna (); var interna = function (){ return \"interna1\" ; } var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //ERROR. interna() non \u00e8 riconosciuto perch\u00e8 non \u00e8 stato dichiarato l'identificaore Con il paradigma funzionale invece non ci sono problemi: function esterna () { return interna (); function interna (){ return \"interna1\" ; } function interna (){ return \"interna2\" ; } } console . log ( esterna () ); //interna2 Approfondimento Differenza tra undefined e not defined Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. Anche se sembra un uso improprio del vocabolario, c'\u00e8 una differenza tra una variabile undefined e un errore dell'interprete dovuto a una variabile not defined . undefined : L'interprete trova la definizione della variabile ma non trova nessun valore associato a tale variabile. Non genera un errore not defined : l'interprete non trova da nessuna parte nel codice l'identificatore. Genera un errore function esterna () { return interna ; var interna = function (){ return \"interna1\" ; } var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //undefined, l'interprete sa cos'\u00e8 ma non \u00e8 stata definita a quel punto del codice function esterna () { return y ; var interna = function (){ return \"interna1\" ; } var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //ERROR. y is not defined. L'interprete non sa cosa sia y, ben diverso Approfondimento IIFI Immediatly invoked function expression Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. Sebbene introdurre funzioni aiuti a scrivere moduli indipendenti si rischia di inondare il contesto globale di nomi di funzioni. Il pattern IIFE (Immediately Invoked Function Expression) aiuta in tal senso. Le IIFI functions sono funzioni che vengono eseguite al momento della definizione. Non necessitano quindi della chiamata. ( function name (){ //code })(); Esempio: //Questa \u00e8 una funzione standard, NON IIFI. Viene eseguita solo alla chiamata function stampaLogo (){ console . log ( 'myLogo' ); } stampaLogo (); //in questa linea eseguo la funzione /* */ //Questa \u00e8 una funzione IIFI. Viene eseguita al momento. //(function name(){})(); ( function stampaLogo (){ console . log ( 'myLogo' ); })(); //eseguo qui la funzione IIFI Esempio 2: ( //operatore di raggruppamento: cio' che e' all'interno e' una espressione function iife () { var a = 222 ; console . log ( \"parto da sola!! \" + a ); } ) //fine espressione (); //operatore di chiamata di funzione //forma alternativa ( function iife () { var a = 444 ; console . log ( \"parto da sola!! \" + a ); } () ); iife (); //errore! iife come identificatore non esiste nel contesto globale Paradigma di programmazione Javascript Javascript \u00e8 un linguaggio multiparadigma, consente quindi il paradigma imperativo, quello funzionale e il paradigma object oriented in un unico linguaggio. Non esiste il miglior paradigma in assoluto ma esista il paradigma migliore per la situazione migliore. Lezione 22 Scope Lo scope \u00e8 l'attuale contesto di esecuzione. Il contesto in cui i valori e le espressioni sono \"visibili\" o possono essere referenziati. Se una variabile o un'altra espressione non \u00e8 \"nell'ambito corrente\", non \u00e8 disponibile per l'uso. Gli ambiti possono anche essere stratificati in una gerarchia, in modo che gli ambiti figlio abbiano accesso agli ambiti padre, ma non viceversa. Una funzione funge da chiusura, closure in JavaScript e quindi crea uno scope, in modo che (ad esempio) non sia possibile accedere a una variabile definita esclusivamente all'interno della funzione dall'esterno della funzione o da altre funzioni. MDN - Scope Esempio: /* Scope */ /* Gloabl variable -> Riconosciuta da tutto il programma */ let var1 = 1 ; function function1 (){ /* Local variable -> ricnosciuta solo nel blocco di codice tra le parentesi {} in cui \u00e8 stata dichiarata*/ let var2 = 10 ; //qui nasce var2 console . log ( var2 ); } //qui muore var2 function1 (); console . log ( var1 ); //var1 is defined, var1 is global console . log ( var2 ); //var2 is not defined /* Console: --------------- 10 1 Uncaught ReferenceError: var2 is not defined */ Vediamo un esempio molto pi\u00f9 complesso: /* Scope */ /* Gloabl variable -> Riconosciuta da tutto il programma */ let var1 = 1 ; function function1 (){ /* Local variable -> ricnosciuta solo nel blocco di codice tra le parentesi {} in cui \u00e8 stata dichiarata*/ let var2 = 10 ; //qui nasce var2 console . log ( \"var2 function1 : \" + var2 ); } //qui muore var2 function function2 (){ /* Local variable -> ricnosciuta solo nel blocco di codice tra le parentesi {} in cui \u00e8 stata dichiarata*/ let var2 = 20 ; //qui nasce var2 ma \u00e8 diversa rispetto a quella di prima, \u00e8 una nuova var2 console . log ( \"var2 function2 : \" + var2 ); console . log ( \"var1: \" + var1 ); //\u00e8 riconosciuta anche var1 perch\u00e8 \u00e8 stata dichiarata in un blocco pi\u00f9 esterno for ( let var3 = 0 ; var3 < 1 ; var3 ++ ) { console . log ( \"var3: \" + var3 ); console . log ( \"var2 function2: \" + var2 ); //\u00e8 riconosciuta anche var2 perch\u00e8 \u00e8 stata dichiarata in un blocco pi\u00f9 esterno console . log ( \"var1: \" + var1 ); //\u00e8 riconosciuta anche var1 perch\u00e8 \u00e8 stata dichiarata in un blocco pi\u00f9 esterno } //qui muore var3 } //qui muore var2 function1 (); function2 (); console . log ( \"var1: \" + var1 ); //OK console . log ( \"var3: \" + var3 ); //non riconosciuta console . log ( \"var2: \" + var2 ); //non riconosciuta /* Console: --------------- var2 function1 : 10 var2 function2 : 20 var1: 1 var3: 0 var2 function2: 20 var1: 1 var1: 1 Uncaught ReferenceError: var3 is not defined */ Visibilit\u00e0 di variabili Lo 'scope' di una variabile (visibilita' di una variabile) e' la sezione di codice in cui essa e' visibile ed in Javascript e' regolato con l'uso delle funzioni. NB: non confondere lo scope con il context (contesto) che indica invece l'oggetto per il quale una funzione viene eseguita ( this ). Per una funzione visibile a livello globale cioe' non contenuta in alcun oggetto questo in realta' esiste e coincide con 'window'. La distinzione e' tra visibilita' globale, locale e di blocco. Visibilit\u00e0 Globale (global scope) E' quella che ha come riferimento l'intero codice. Sono le variabili/oggetti dichiarate all'esterno di qualunque funzione usate in una funzione senza var/let . In generale la visibilita' globale e' da evitare Esempio: var x = 100 ; function f_bad () { //modifica la variabile esterna potenzialmente all'insaputa di chi la chiama x = 2 ; } console . log ( \"Prima di invocare f_bad() \" + x ); //x = 100 f_bad (); //modifica x, da evitare console . log ( \"Dopo f_bad() \" + x ); //x = 2 L'obiettivo delle funzioni \u00e8 proprio racchiudere il codice in blocchi riutilizzabili. Se modificano/dipendono da variabili esterne/globali questo concetto viene a meno. Per risolvere questa cosa: x = 100 ; //versione corretta di f function f_good () { //dichiarazione di una variabile LOCALE (x) distinta da quella globale var x = 2 ; var y = 200 ; } console . log ( \"Prima di invocare f_good() \" + x ); // x = 100 f_good (); console . log ( \"Dopo f_good() \" + x ); // x = 100, Ok console . log ( y ); //errore: y not defined; visibile solo a f_good in esecuzione Scope Chaining Una varibaile \u00e8 visibile ai blocchi interni (figli) ma non ai contenitori (padre). I blocchi interni (figli) ereditano tutto dai loro contenitori (padri) ma i padri non conoscono i segreti dei figli ovvero non possono conoscere le variabili/oggetti dichiarati dei figli. var x = 2 ; //FUNZIONI ANNIDATE (nested) function esterna () { var x = 999 ; // dichiaro una nuova \"x\" diversa da quella globale interna (); //Accedo alla \"x\" esterna tramite il contest. <window> \u00e8 il contesto esterno, \u00e8 il contenitore di tutto window . x = 18 ; //interna accede anche allo scope di esterna ma non il viceversa function interna () { //code } } Visibilit\u00e0 a livello di blocco (block scope) La visibilit\u00e0 \u00e8 racchiusa da i delimitatori { } Per mantenere la visibilit\u00e0 a livello di blocco \u00e8 necesario usare let , var mantiene soltanto lo scope locale a livello di funzione ma non di blocco { } let : Mantiene lo scope delle variabili sia a livello locale (all'interno di una funzione) sia livello di blocco ovvero tra i delimitatori { } var : Mantiene lo scope delle variabili solo a livello locale (all'interno di una funzione) ma non a livello di blocco ovvero tra i delimitatori { } //\"var\" non mantiene la visibilit\u00e0 di blocco var x = 5 ; if ( Math . random () > 0.5 ) { var x = 100 ; } else { var x = 200 } console . log ( \"La x ora vale: \" + x ); //100 o 200!! ATTENZIONE, //\"let\" mantiene la visibilit\u00e0 di blocco x = 5 ; if ( Math . random () > 0.5 ) { let x = 100 ; } else { let x = 200 } console . log ( \"La x globale vale ancora: \" + x ); //5, ok Approfondimento - Closure di una funzione Si ricordi: Una funzione funge da chiusura, closure in JavaScript e quindi crea uno scope, in modo che (ad esempio) non sia possibile accedere a una variabile definita esclusivamente all'interno della funzione dall'esterno della funzione o da altre funzioni Applichiamo questo concetto ad un esempio pratico. La funzione: setInterval( param1, param2 ) : param1 \u00e8 una funzione, param2 rappresenta un intervallo di tempo espresso in ms . La funzione setInterval() chiama la funzione param1 ogni param2 ms . function chiamaMessaggio ( messaggio ){ setInterval ( function (){ writeln ( messaggio );}, 1000 ); //uso una funzione anonima } chiamaMessaggio ( \"il sistema \u00e8 in fase di spegnimento..\" ); Ho utilizzato il concetto di closure (e quindi dell'ereditariet\u00e0 delle variabili/oggetti padre->figlio) di una funzione per passare un parametro alla funzione (parametro) di setInterval() Esempio 2: function chiamaMessaggio2 ( ilMessaggio , volte ) { let timer = setInterval ( function () { writeln ( ilMessaggio + \" \" + volte + \" secondi...\" ); -- volte ; if ( volte < 1 ) { clearInterval ( timer ); writeln ( \"Boom!\" );} } , 1000 ) } chiamaMessaggio2 ( \"Sistem Shutdown in \" , 5 ); Approfondimento: Le funzioni che ricevono come parametri altre funzioni o ritornano altre funzioni prendono il nome di High orderd function Lezione 23 Array Gli array sono aggragatori di dati utilizzati per raggruppare elementi appartenenti alla stessa famiglia ed accedere ad uno di essi in lettura o scrittura in modo semplice. Ogni elemento dell'array \u00e8 raggiungibile tramite un numero detto indice . L'indice indica la posizione dell'elemento nell'array. La propriet\u00e0 lenght restituisce il numero degli elementi in un array // Dichiarazione e inizializzazione // 0 1 2 const elementi = [ \"elemento1\" , \"elemento2\" , \"element03\" ]; console . log ( elementi ); //(3) [\"elemento1\", \"elemento2\", \"element03\"] console . log ( elementi [ 1 ]); //elemento2 console . log ( elementi . lenght ); //3 elementi [ 2 ] = \"Silicio\" ; console . log ( elementi ); //(3) [\"elemento1\", \"elemento2\", \"Silicio\"] // Solo dichiarazione const mammiferi = []; Altre sintassi (meno utilizzate ma valide): //Array vuoto let vuoto1 = new Array (); let vuoto2 = Array (); let vuoto3 = []; //da preferire let v1 = Array ( 100 ); //100 elementi pre allocati let v2 = Array ( '100' ); //1 elemento stringa, crea confusione let v3 = new Array ( 31 , 8 , 2017 ); //meno consigliata let arr3 = [ 31 , 8 , 2017 ]; //sintassa pi\u00f9 chiara Alcuni esempi: const mammiferi = [ \"tigre\" , \"scoiattolo\" , \"orso\" ]; mammiferi [ mammiferi . length ] = \"volpe\" ; // === mammiferi[3] = \"volpe\", aggiunge in coda un elemento console . log ( mammiferi ); //(4) [\"tigre\", \"scoiattolo\", \"orso\", \"volpe\"] mammiferi [ 10 ] = \"cinghiale\" ; //aggiunge \"cinghiale\" al decimo elemento e riempie con elementi vuoti i restanti console . log ( mammiferi , mammiferi . lenght ); //(11) [\"tigre\", \"scoiattolo\", \"orso\", \"volpe\", empty \u00d7 6, \"cinghiale\"] 11 mammiferi . lenght = 20 ; console . log ( mammiferi , mammiferi . lenght ); //(11) [\"tigre\", \"scoiattolo\", \"orso\", \"volpe\", empty \u00d7 6, \"cinghiale\", lenght: 20] 20 //Iterazione sugli elementi dell'array for ( let i = 0 ; i < mammiferi . length ; i ++ ){ if ( mammiferi [ i ] != undefined ){ console . log ( i + \": \" + mammiferi [ i ]); } else { console . log ( i + \": \" + \"non \u00e8 un mammifero\" ); } } /* 0: tigre 1: scoiattolo 2: orso 3: volpe 4: non \u00e8 un mammifero 5: non \u00e8 un mammifero 6: non \u00e8 un mammifero 7: non \u00e8 un mammifero 8: non \u00e8 un mammifero 9: non \u00e8 un mammifero 10: cinghiale */ Matrix Della famiglia degli array ci sono anche le matrici che non sono altro che array di array. const social = [ [ \"facebook\" , \"instagram\" ], [ \"whatsapp\" , \"telegram\" ], [ \"tiktok\" , \"snapchat\" ], ]; console . log ( social ); console . log ( social [ 1 ][ 1 ]); console . log ( social [ 2 ][ 0 ]); /* Console: --------------- Esercizio 2 (3) [Array(2), Array(2), Array(2)] 0: (2) [\"facebook\", \"instagram\"] 1: (2) [\"whatsapp\", \"telegram\"] 2: (2) [\"tiktok\", \"snapchat\"] telegram tiktok */ Lezione 24 Array - Metodi base Qualche metodo base applicabile agli array in javascript: push(elem) : aggiunge l'elemento elem in coda all'array. Restituisce il numero di elementi dell'array. pop() : rimuove l'ultimo elemento dall'array. Restituisce l'elemento che ha tolto. array.unshift(elem) : aggiunge l'elemento elem in testa all'array. Restituisce il numero di elementi dell'array array.shift() : rimuove il primo elemento dall'array. Restituisce l'elemento che ha tolto indexOf(elem) : Restituisce l'indice dell' elemento elem nell'array. Se non lo trova restituisce -1 slice(startIndex, endIndex); : Restituisce un array derivato dall'array a cui si applica il metodo filtrando gli elementi nel range ( startIndex incluso, endIndex escluso). .concat(array2); : Restituisce un array che \u00e8 la concatenazione dell'array a cui si applica il metodo e array2 splice(startIndex, nToDelete, elem1, elem2, ...); : Restituisce un array derivato dall'array a cui si applica il metodo aggiungendo elem1 , elem2 , .. a partire da startIndex ed eliminando i primi nToDelete elementi a partire da startIndex . Se non specifico i parametri elem1 , elem2 , .. semplicemente elimina gli elementi nToDelete a partire da startIndex . fill(value, indexStart, indexEnd) : Inserisce value all'interno dell'array tra i parametri opzionali indexStart e indexEnd . Omettendo indexStart e indexEnd riempie tuttto l'array con value join() : Trasforma un array in stringa reverse() : Inverte l'ordine degli elementi sort() : Ordinamento lessicografico degli elementi. Ogni elemento viene quindi trattato come una stringa e poi ordinato secondo la precedenza definita dalla rappresentazione in UTF-8 (ASCII) //push const colori = [ \"rosso\" , \"verde\" , \"giallo\" ]; console . log ( colori ); //(3) [\"rosso\", \"verde\", \"giallo\"] let newArrayLenght = colori . push ( \"blu\" ); //push ritorna il numero degli elementi dell'array console . log ( colori , newArrayLenght ); //(4) [\"rosso\", \"verde\", \"giallo\", \"blu\"] 4 //pop console . log ( colori ); //(4) [\"rosso\", \"verde\", \"giallo\", \"blu\"] let lastElement = colori . pop (); //pop ritorna l'elemento che ha tolto console . log ( colori , lastElement ); //(3) [\"rosso\", \"verde\", \"giallo\"] \"blu\" //unshift console . log ( colori ); //[\"rosso\", \"verde\", \"giallo\"] newArrayLenght = colori . unshift ( \"gialletto\" ); //unshift ritorna il numero degli elementi dell'array console . log ( colori , newArrayLenght ); //(4) [\"gialletto\", \"rosso\", \"verde\", \"giallo\"] 4 //shift console . log ( colori ); //(4) [\"gialletto\", \"rosso\", \"verde\", \"giallo\"] let firstElement = colori . shift (); //shift ritorna l'elemento che ha tolto console . log ( colori , firstElement ); //(3) [\"rosso\", \"verde\", \"giallo\"] \"gialletto\" //indexOf console . log ( colori ); //(3) [\"rosso\", \"verde\", \"giallo\"] let indexElem = colori . indexOf ( \"verde\" ); console . log ( indexElem ); //1 //slice // 0 1 2 3 4 const social = [ \"facebook\" , \"instagram\" , \"whatsapp\" , \"telegram\" , \"snapchat\" ]; const messaggi = social . slice ( 2 , 4 ); console . log ( messaggi ); //(2) [\"whatsapp\", \"telegram\"] //concat const numeriBassi = [ 1 , 2 , 3 ]; const numeriAlti = [ 100 , 200 , 300 ]; const tuttiNumeri = numeriBassi . concat ( numeriAlti ); console . log ( tuttiNumeri ); //(6) [1, 2, 3, 100, 200, 300] //splice //poich\u00e8 il secondo parametro \u00e8 0, aggiunger\u00e0 a partire dall'indice 3 i parametri 50, 60, 70 tuttiNumeri . splice ( 3 , 0 , 50 , 60 , 70 ); //poich\u00e8 il secondo parametro \u00e8 0 console . log ( tuttiNumeri ); //(9) [1, 2, 3, 50, 60, 70, 100, 200, 300] //poich\u00e8 il secondo parametro \u00e8 3, sostituir\u00e0 50, 60, 70 con -50, -60, -70 tuttiNumeri . splice ( 3 , 3 , - 50 , - 60 , - 70 ); console . log ( tuttiNumeri ); //(9) [1, 2, 3, -50, -60, -70, 100, 200, 300] //fill() const myArr = [ 1 , 2 , 4 , 1 , 5 , 5 , 7 ]; myArr . fill ( 0 , 1 , 3 ); console . log ( myArr ); //(7) [1, 0, 0, 1, 5, 5, 7] //join() const paroleTesto = [ \"ciao\" , \" \" , \"a\" , \" \" , \"tutti\" ]; console . log ( paroleTesto ); //(5) [\"ciao\", \" \", \"a\", \" \", \"tutti\"] conole . log ( parole . Testo . join ()); // ciao, ,a, ,tutti //reverse() const numeriDispari = [ 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 ]; console . log ( numeriDispari ); //(10 [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] console . log ( numeriDispari . reverse ()); //(10) [19, 17, 15, 13, 11, 9, 7, 5, 3, 1] //sort() - ATTENZIONE console . log ( numeriDispari . sort ()); //(10) [1, 11, 13, 15, 17, 19, 3, 5, 7, 9] Lezione 25 Arrays - forEach() forEach() \u00e8 un metodo applicabile agli array utilizzato per l'iterazione. forEach ( function ( value , index , array ){ /*code*/ }); Riceve come parametro una funzione detta anonima poich\u00e8 non ha un nome. La funzione riceve tre parametri opzionali, in ordine value , index , array che, dell'array a cui \u00e8 applicato il metodo, rappresentano rispettivamente l'elemento, l'indice e l'array stesso. Viene invocata la funzione anonima per ogni elemento (forEach) presente nell'array. const frutta = [ \"mela\" , \"pera\" , \"banana\" ]; stampaArray ( frutta ); function stampaArray ( arr ) { //i parametri della funzione anonima del forEach sono opzionali e, essendo parametri posso //dare un nome simbolico qualsiasi arr . forEach ( function ( elemento , indice , a ) { console . log ( indice + \": \" + a [ indice ] ); } ); } /* 0: mela 1: pera 2: banana */ Arrays - map() map() \u00e8 un metodo applicabile agli array utilizzato per l'iterazione. map ( function ( value , index , array ){ /*code*/ }); Itera ogni elemento dell'array e ritorna un array. E' utile quindi all'elaborazione e costruzione di un nuovo array a partire da quello a cui si applica il metodo. Riceve come parametro una funzione detta anonima poich\u00e8 non ha un nome. La funzione riceve tre parametri opzionali, in ordine value , index , array che, dell'array a cui \u00e8 applicato il metodo, rappresentano rispettivamente l'elemento, l'indice e l'array stesso. Viene invocata la funzione anonima per ogni elemento (forEach) presente nell'array. const fruits = [ 'mela' , 'pera' , 'banana' ]; //In questo caso newFruits sar\u00e0 identico a fruits. Ho effettuato una copia const newFruits = fruits . map ( function ( value , index ){ return value ; }) console . log ( newFruits ); //(3) [\"mela\", \"pera\", \"banana\"] //In questo caso newFruits2 sar\u00e0 un array contenente 0, 1, 2 poich\u00e8 ritorna l'indice const newFruits2 = fruits . map ( function ( value , index ){ return index ; }) console . log ( newFruits2 ); //3) [0, 1, 2] Funzioni freccia (lambda) Oltre alla sintassi espressa tramite funzione anonima esiste anche una sintassi diversa espressa tramite l'operatore freccia => . Ogni funzione anonima pu\u00f2 essere espressa tramite l'operatore freccia, questo tipo di funzione prende il nome di funzione lambda . ( param1 , param2 , ..) => { /*code*/ }; //function(param1, param2, ..{/*code*/} //Esempi con forEach() e map() map ( ( value , index , array ) => { /*code*/ } ); forEach ( ( value , index , array ) => { /*code*/ }); Nota: - I parametri vanno sempre espressi tra parentesi. Se si ha necessit\u00e0 solo del primo parametro le parentesi possono essere omesse. - In generale il corpo della funzione lambda va tra le parentesi graffe { } . Se il corpo ha un'istruzione inline, le parentesi graffe possono essere omesse. Esempio interessante: //casuali \u00e8 un array di 30 numeri inter casuali const numeriCasuali = []; for ( let i = 0 ; i < 10 ; i ++ ) { numeriCasuali . push ( Math . floor ( Math . random () * 100 ) ) ;} console . log ( numeriCasuali ); //32, 54, 33, 91, 4, 25, 46, 37, 73, 2] //calcola il resto della divisione per 7 dei numeri casuali //e crea con questi un nuovo array const isPari = numeriCasuali . map ( ( elemento , indice , a ) => Boolean ( ! ( elemento % 2 )) ); console . log ( isPari ); //[true, true, false, false, true, false, true, false, false, true] Array - Metodi avanzati filter( (value,index,array) => {/*CONDITION*/} ); : Ritorna un array risultato del filtraggio gli elementi dell'array a cui si applica il metodo che restituiscono true nella CONDITION some ( (value,index,array) => {/*CONDITION*/} ); : Ritorna un booleano se c'\u00e8 almeno un elemento nell'array che restituisce true alla CONDITION every ( (value,index,array) => {/*CONDITION*/} ); Ritorna true (ritorna n boolean) se c'\u00e8 almeno un elemento nell'array che restituisce true alla CONDITION reduce ((accumulatore, value,index,array) => {/*CONDITION*/}, startValueAccumulatore); : Ritorna il numero di elementi che soddisfano la CONDITION . Ha due parametri: il primo \u00e8 una funzione freccia che riceve a sua volta 4 parametri in ordine: accumulatore , value , index , array , il secondo, startValueAccumulatore \u00e8 il valore di partenza dell'accumulatore, opzionale. Se non si specifica il valore di partenza dell'accumulatore startValueAccumulatore viene assegnato come valore il primo elemento. let casuali = []; for ( let i = 0 ; i < 20 ; i ++ ) { casuali . push ( Math . floor ( Math . random () * 100 ) ) ;} let diversiDaZero = casuali . filter ( elemento => elemento !== 0 ); console . log ( diversiDaZero ); if ( diversiDaZero . some ( elemento => elemento > 4 ) ) { console . log ( \"Trovato almento un resto maggiore di zero\" );} let quanti = diversiDaZero . reduce ( ( conta , elemento ) => elemento > 4 ? conta + 1 : conta , 0 ); console . log ( quanti ); //19 let totale = diversiDaZero . reduce ( ( somma , elemento ) => somma + elemento ); console . log ( totale ); //1057 /* [37, 67, 31, 88, 55, 45, 26, 21, 32, 2, 20, 62, 79, 48, 85, 53, 33, 97, 92, 84] Trovato almento un resto maggiore di zero 19 1057 */ Lezione 26 Introduzione agli Object JavaScript \u00e8 progettato su un semplice paradigma basato su oggetti. Un oggetto \u00e8 una raccolta di propriet\u00e0 e una propriet\u00e0 \u00e8 un'associazione tra un nome (o chiave) e un valore. Il valore di una propriet\u00e0 pu\u00f2 essere una funzione, nel qual caso la propriet\u00e0 \u00e8 nota come metodo. Oltre agli oggetti predefiniti nel browser, \u00e8 possibile definire i propri oggetti. Questo capitolo descrive come utilizzare oggetti, propriet\u00e0, funzioni e metodi e come creare i propri oggetti. Gli oggetti in JavaScript, proprio come in molti altri linguaggi di programmazione, possono essere paragonati agli oggetti nella vita reale. Il concetto di oggetti in JavaScript pu\u00f2 essere compreso con oggetti tangibili della vita reale. In JavaScript, un oggetto \u00e8 un'entit\u00e0 autonoma, con propriet\u00e0 e tipo. Confrontalo con una tazza, per esempio. Una tazza \u00e8 un oggetto, con propriet\u00e0. Una tazza ha un colore, un disegno, un peso, un materiale di cui \u00e8 composta, ecc. Allo stesso modo, gli oggetti JavaScript possono avere propriet\u00e0 che definiscono le loro caratteristiche. Fonte: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#:~:text=JavaScript%20is%20designed%20on%20a,is%20known%20as%20a%20method. Sono un tipo di data-structure che rappresenta elementi tramite una coppia chiave/valore . Si accede al valore tramite il nome dell'oggetto e la sua property cio\u00e8 l'identificativo della chiave. const object = { key1 : value1 , key2 : value2 , key3 : value3 } SI chiama modello per prototipazione. Cio\u00e8 un modello creato che andremo ad arricchire e modificare nel corso del codice dinamicamente. Un oggetto in js \u00e8 una collezione di coppe identificatore: valore Esempio // Dichiarazione di un oggetto, prototipo const persona = { nome : \"Simone\" , eta : 23 , citta : \"Lucca\" } //accesso ai dati //Modo 1 persona . nome ; //Simone, (=== persona[\"nome\"]) //Modo2 persona [ \"citta\" ]; //Lucca, (=== persona.citta) //modifica di un valore dell'oggetto persona . nome = \"Luigi\" ; //Eliminazione della property <citta> dall'oggetto delete persona . citta ; console . log ( persona ); /* persona = { nome: \"Luigi\", eta: 23 } */ La creazione/dichiarazione di un oggetto con propriet\u00e0 e metodi (vedremo pi\u00f9 avanti) viene anche detto prototipo. Il prototipo \u00e8 un modello base dell'oggetto che pu\u00f2 essere arricchito o modificato nel corso del programma dinamicamente Posso creare un oggetto inizialmente vuoto e aggiungere gli elementi successivamente //Dichiaro un oggetto vuoto, modo 1 - preferibile var persona = {}; //Dichiaro un oggetto vuoto, modo 2 var computer = new Object ; //Inserisco elementi in un oggetto inizialmente vuoto persona . nome = \"billy\" ; persona . hobby = \"scacchi\" ; computer . ram = \"4Gb\" ; computer . rom = \"1Tb\" ; Di seguito mostro un esempio di un oggetto pi\u00f9 complicato. In realt\u00e0 \u00e8 un array di oggetti var post = [ // index: 0 { username : \"Billy\" , like : 4 , commenti : [ \"figo!\" , \"ottimo\" , \"bleah\" ] }, // index: 1 { username : \"thebest95\" , like : 0 , commenti : [ \"fighissimo\" , \"buono\" , \"buonissimo\" ] } ] console . log ( post ); /* Console: --------------- (2) [{\u2026}, {\u2026}] 0: commenti: (3) [\"figo!\", \"ottimo\", \"bleah\"] like: 4 username: \"Billy\" __proto__: Object 1: commenti: (3) [\"fighissimo\", \"buono\", \"buonissimo\"] like: 0 username: \"thebest95\" __proto__: Object length: 2 __proto__: Array(0) */ //Aggiungo un commento al primo elemento, cio\u00e8 all'oggetto cui corrisponde username \"Billy\" post [ 0 ]. commenti . push ( \"Fantastico!\" ); console . log ( post ); /* Console: --------------- (2) [{\u2026}, {\u2026}] 0: commenti: (3) [\"figo!\", \"ottimo\", \"bleah\",\"Fantastico!\"] like: 4 username: \"Billy\" __proto__: Object 1: commenti: (3) [\"fighissimo\", \"buono\", \"buonissimo\"] like: 0 username: \"thebest95\" __proto__: Object length: 2 __proto__: Array(0) */ Javascript OOP Javascript Lezione 01 Prerequisiti al corso Approccio al corso Strumenti Necessari Introduzione Lezione 02 Cenni storici Aspetti strutturali Versioni di Javascript Configurazione di un IDE Visual Studio Code - VS code Lezione 03 Primo script Lezione 04 Console - Browser Web Alert & prompt Commenti Lezione 05 Introduzione al DOM Introduzione alla libreria JQuery DOM ed Eventi Lezione 06 Variabili Javascript Tipi di dati in JS Dati nativi Reference type Alcune regole generali per dichiarazione di variabili Reference type Const Approfondimento Null - undefined - NaN Lezione 07 Stringhe Opearotri, Propriet\u00e0 e Metodi su stringhe Operatori Approfondimento Interpolazioni di stringhe Le stringhe sono immutabili Propriet\u00e0 Metodi Lezione 08 Conta parole Lezione 09 Approfondimento - Rappresentazione numerica in Javascript Numeri in Fixed Point Numeri in Floating Point Not A Number NaN Lezione 10 Approfondimento - Codifica caratteri Javascript ASCII Unicode Caratteri di Escape Lezione 11 Type conversion Conversione esplicita Conversione implicita Lezione 12 Operatori matematici Pre e post incremento/decremento Oggetto MATH Lezione 13 Equazione di II grado Lezione 14 Operator Precedence Associativit\u00e0 Operatori di assegnamento Lezione 15 Operatori Logici Logica Booleana Approfondimento - Short evalutation Truthy e falsy Lezione 16 Control Structure if/else Ternary Operator Switch statemeant Lezione 17 while loop do-while loop Lezione 18 for loop break & coninue Lezione 19 Function Parametri di default Ritorno di una funzione Lezione 20 Funzioni - Passaggio di oggetti e array Funzioni - Ritorno di un oggetto o un array Approfondimento funzioni - Oggetto Arguments Approfondimento funzioni - Parametri Rest Approfondimento Introduzione forEach / this Lezione 21 Approfondimento Funzioni ricorsive Approfondimento Function expression Approfondimento Hoisting Approfondimento Differenza tra undefined e not defined Approfondimento IIFI Immediatly invoked function expression Paradigma di programmazione Javascript Lezione 22 Scope Visibilit\u00e0 di variabili Visibilit\u00e0 Globale (global scope) Scope Chaining Visibilit\u00e0 a livello di blocco (block scope) Approfondimento - Closure di una funzione Lezione 23 Array Matrix Lezione 24 Array - Metodi base Lezione 25 Arrays - forEach() Arrays - map() Funzioni freccia (lambda) Array - Metodi avanzati Lezione 26 Introduzione agli Object Javascript OOP Lezione 01 OOP Object Oriented Programming Lezione 02 Introduzione ai Metodi Lezione 03 Costruttore Lezione 04 Ereditariet\u00e0 Lezione 05 Ereditariet\u00e0 - Shadowing Ereditariet\u00e0 classica Lezione 06 THIS Object - Variabili Statiche (condivise) Lezione 07 Introduzione For In Oggetto Date() Lezione 08 Classi Lezione 09 Classi assegnanili a variabili Get / Set try-catch Lezione 10 Derivazione di classi , ereditariet\u00e0 Lezione 11 Ereditariet\u00e0 classi Pt 2 Lezione 12 Approfondimento - Symbols Lezione 13 Approfondimento - Iterables/Iterator Costrutto for - of Lezione 14 Approfondimento - Funzioni Generatrici Lezione 15 Approfondimento - Esempio (For .. of) custom Lezione 16 Destructuring Lezione 17 Map Object Iterazione Map Object Lezione 18 Set Conversione di un Oggetto Map / Set in un Array Lezione 19 Dom Manipulation Lezione 20 DOM - Selettori Metodi di selezione di elementi html Lezione 21 Dom - Child e Parent DOM - Manipolazione dello stile degli elementi html Lezione 22 DOM - Manipolazione del testo degli elementi html DOM - Manipolazione degli attributi html Lezione 23 DOM - Creazione di Un elemento DOM - Rimpiazzo di un elemento DOM - ELiminazione di un elemento Lezione 24 DOM Events Metodo addEventListener Lezione 25 Prevent Default Che cos'\u00e8 esattamente l'oggetto ricevuto come unico parametro \"e\"? Lezione 26 Approfondimento type event Aprrofondimento eventi tastiera e input Lezione 27 Argomeni non trattati / da approfondire Fonti APPRONDIMENTI PT.1 Node.js Cos'\u00e8 node Install node Prima applicazione nodejs Non esiste l'oggetto window global objects Modules Creiamo un modulo Moduli built-in Modulo path Modulo OS Modulo File System Eventi Modulo HTTP Approfondimenti Passare dei parametri esterni My first IO sync My first IO async Filtered APPRONDIMENTI PT.2 Promise Un esempio semplice APPRONDIMENTI PT.3 Approfondimento Hoisting Approfondimento Oggetti Approfondimento Moduli Packages Approfondimento THIS Costruttori prefdefiniti javascript for .. of for .. in Memoization Come fare una copia profonda tra oggetti? propriet\u00e0 associate ai dati e proprier\u00e0 associate all'accesso get & set Arrow functions High Order Functions Array filter Array map Array reduce Gli array possiedono gi\u00e0 come metodi filer, map, reduce Qualche chicca sugli Array Arrray.of, Array.from concat, every, some find, filter, forEach, includes, indexOf push, pop, shift, unshift sort, splice, slice setTimeout(), setInterval() Eventi Asincroni Promise, resolve, reject, then Async, Await Promise.all() e Promise.race() Set e Map Map Lezione 01 OOP Object Oriented Programming Si ricordi la frase di apertura di questo corso: In informatica JavaScript \u00e8 un linguaggio di programmazione orientato agli oggetti e agli eventi... Ma che cos'\u00e8 un linguaggio di programmazione orientato agli oggetti? In informatica, la programmazione orientata agli oggetti (in inglese object-oriented programming, in acronimo OOP) \u00e8 un paradigma di programmazione che permette di definire oggetti software in grado di interagire gli uni con gli altri attraverso lo scambio di messaggi. Particolarmente adatta nei contesti in cui si possono definire delle relazioni di interdipendenza tra i concetti da modellare (contenimento, uso, specializzazione), un ambito che pi\u00f9 di altri riesce a sfruttare i vantaggi della programmazione ad oggetti \u00e8 quello delle interfacce grafiche. Tra gli altri vantaggi della programmazione orientata agli oggetti: essa fornisce un supporto naturale alla modellazione software degli oggetti del mondo reale o del modello astratto da riprodurre; permette una pi\u00f9 facile gestione e manutenzione di progetti di grandi dimensioni; l'organizzazione del codice sotto forma di classi favorisce la modularit\u00e0 e il riuso di codice. Fonte: https://it.wikipedia.org/wiki/Programmazione_orientata_agli_oggetti Ma non esiste solo il paradigma di programmazione orientato agli oggetti. Altri due paradigmi di programmazione sono il paradigma di programmazione procedurale e il paradigma di programmazione imperativa Programmazione Procedurale In informatica la programmazione procedurale \u00e8 un paradigma di programmazione che consiste nel creare dei blocchi di codice sorgente, identificati da un nome e racchiusi da dei delimitatori, che variano a seconda del linguaggio di programmazione; questi sono detti anche sottoprogrammi (in inglese subroutine), procedure o funzioni, a seconda del linguaggio e dei loro ruoli all'interno del linguaggio stesso. Il nome deriva dal linguaggio COBOL, che \u00e8 stato il primo ad utilizzare questo concetto. Questi blocchi possono essere dotati di parametri, cio\u00e8 variabili locali i cui valori vengono forniti o passati dall'esterno del blocco di codice ed eventualmente esportati; esistono due tipi di parametri: quelli di tipo valore e quelli di tipo variabile; nei primi viene passato un valore che, se modificato, non viene comunque salvato al termine del sottoprogramma; nel tipo variabile invece, viene comunicato l'indirizzo della cella di memoria (ad es.tramite un puntatore) al quale troviamo l'informazione, che pu\u00f2 quindi essere modificata effettivamente e permanentemente. All'interno di un sottoprogramma possono essere generalmente definite o dichiarate delle variabili locali, che vengono deallocate al termine del sottoprogramma stesso; il loro contenuto viene quindi perso se non salvato o trasmesso altrimenti. In Linguaggio C esiste solo la function, che pu\u00f2 o meno restituire valori; lo stesso dicasi per il Java ed il PHP; i blocchi sono racchiusi tra parentesi graffe. Questo tipo di paradigma \u00e8 tipico per la programmazione di sistemi embedded. Fonte: https://it.wikipedia.org/wiki/Programmazione_procedurale Programmazione imperativa In informatica, la programmazione imperativa \u00e8 un paradigma di programmazione secondo cui un programma viene inteso come un insieme di istruzioni (dette anche direttive o comandi), ciascuna delle quali pu\u00f2 essere pensata come un \"ordine\" che viene impartito alla macchina virtuale del linguaggio di programmazione utilizzato. Da un punto di vista sintattico, i costrutti di un linguaggio imperativo sono spesso identificati da verbi all'imperativo. L'approccio imperativo \u00e8 l'approccio dominante in programmazione. Nello studio dei linguaggi di programmazione, si definisce il concetto di paradigma di programmazione, ovvero un insieme di regole e strutture che definiscono un tipo di linguaggio basandosi esclusivamente sulle sue strutture, e quindi non sulle sue caratteristiche peculiari legate all'implementazione dello stesso (es. le parole chiave). Sono di tipo imperativo la grande maggioranza dei (sotto-)paradigmi di programmazione (per esempio la programmazione procedurale, la programmazione strutturata, la programmazione orientata agli oggetti e cos\u00ec via) e la grande maggioranza dei linguaggi (per esempio ALGOL, Ada, BASIC, Fortran, Pascal, PHP eccetera). Fonte: https://it.wikipedia.org/wiki/Programmazione_imperativa Javascript \u00e8 un linguaggio di programmazione che si presta molto bene a tutti e tre i paradigmi. Adesso approfondiremo il paradigma di programmazione orientato agli oggetti concludendo con la definizione di classe Lezione 02 Introduzione ai Metodi Si ricordi che con Javascript \u00e8 possibile definire delle funzioni assegnabili a variabili, \u00e8 quindi possibile definire delle funzioni assegnabili a una property. In questo caso si parla di metodi Metodo: Funzione applicabile a un oggetto. Non ha senso al di fuori del contesto dell'oggetto in cui \u00e8 stata definita var persona = { nome : \"Simone\" , dataDiNascita : 1995 , sesso : \"maschio\" , isMarried : false , famiglia : [ \"Anotinio\" , \"Giovanni\" , \"Alice\" ], calcolaEta : function (){ return 2020 - this . dataDiNascita ; } } console . log ( persona . calcolaEta ()); //25 Nella definizione di un metodo (una funzione all'interno di un oggetto), this rappresenta l'oggetto stesso. E' quindi necessario per poter prelevare ed elaborare le property interne dell'oggetto che ricordiamo sono accessibili solo attraverso il nome dell'oggetto. Nella definizione di un metodo non posso accedere direttamente alle property senza invocare this l'interprete solleverebbere un'eccezione poich\u00e8 non riconoscerebbe l'identificatore invocato. var persona = { nome : \"Simone\" , dataDiNascita : 1995 , sesso : \"maschio\" , isMarried : false , famiglia : [ \"Anotinio\" , \"Giovanni\" , \"Alice\" ], calcolaEta : function (){ return 2020 - dataDiNascita ; } } console . log ( persona . calcolaEta ()); //dataDiNascita is not defined Nota: la keyword this ha anche altri significati che dipendono dal contesto in cui \u00e8 chiamato. Posso invocare un metodo anche per definire una nuova propriet\u00e0 dell'oggetto: const persona = { nome : \"Simone\" , dataDiNascita : 1995 , sesso : \"maschio\" , isMarried : false , famiglia : [ \"Anotinio\" , \"Giovanni\" , \"Alice\" ], calcolaEta : function (){ return 2020 - this . dataDiNascita ; } } //Verr\u00e0 aggiunta la property \"eta\" all'oggetto persona . eta = persona . calcolaEta (); console . log ( persona ); /* Console: --------------- {nome: \"Simone\", dataDiNascita: 1995, sesso: \"maschio\", isMarried: false, famiglia: Array(3), \u2026} calcolaEta: \u0192 () dataDiNascita: 1995 eta: 25 famiglia: (3) [\"Anotinio\", \"Giovanni\", \"Alice\"] isMarried: false nome: \"Simone\" sesso: \"maschio\" __proto__: Object */ Vediamo un altro esempio: let libro = { titolo : \"Fondazione\" , pagine : 571 } let autorePreferito = { cognome : \"Asimov\" , nome : \"Isaac\" , // E' possibile definire una property tra gli apici doppi \"nameProperty\" //in modo da forzare a valutarla come identificatore. //Infatti in questo caso il nome libro-preferito non sarebbe accettata come sintassi a causa del \"-\" //E' comunque da EVITARE \"libro-preferito\" : { titolo : \"L`uomo del bicentenario\" , pagine : 288 }, //Riferimento all'oggetto \"libro\" esterno. Attenzione! //E' un riferimento non \u00e8 una copia. Se modifico questa property di questo oggetto (autorePreferito) //modifico anche l'oggetto libro e viceversa. bestSeller : libro , } //Per accedere alla propriet\u00e0 \"libro-preferito\" devo per necessariamente utilizzare la notazione con le []. La notazione ///con \".\" non pu\u00f2 andare bene. //Ecco perch\u00e8 \u00e8 necessario evitare questi nomi con caratteri non validi cosnole . log ( autorePreferito [ \"libro-preferito\" ]. pagine ); console . log ( autorePreferito . bestSeller . titolo ); autorePreferito . bestSeller . pagine = 1000 ; console . log ( libro . pagine ); //1000, ATTENZIONE Come abbiamo visto in questo esempio, specificando come property un altro oggetto, questo viene passato per riferimento e non viene fatta una copia. La libreria JQuery pu\u00f2 aiutarci in questo. let libro = { titolo : \"Fondazione\" , pagine : 571 } let autorePreferito = { cognome : \"Asimov\" , nome : \"Isaac\" , //in questo caso sono necessari i doppi apici (o singoli) perch\u00e8 scrivendo libro-preferito lo tratterebbe com espressione. E' comunque da EVITARE \"libro-preferito\" : { titolo : \"L`uomo del bicentenario\" , pagine : 288 }, //in questo caso \u00e8 JQuery che si occupa di restituire una copia dell'oggetto bestSeller : jQuery . extend ( true , {}, libro ) } console . log ( autorePreferito [ \"libro-preferito\" ]. pagine ); //288 console . log ( autorePreferito . bestSeller . titolo ); //Fondazione autorePreferito . bestSeller . pagine = 1000 ; console . log ( libro . pagine ); //571 La funzione jQuery.extend(true, {}, object) effettua la copia ricorsiva di tutti elementi dell'oggetto specificato come terzo parametro. Lezione 03 Costruttore Partendo dall'esempio della lezione precedente, riporto un esempio completo di come creare un nuovo oggetto partendo dal prototipo. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > let libro = { titolo : \"\" , pagine : 0 } let autorePreferito = { cognome : \"\" , nome : \"\" , libroPreferito : { titolo : \"\" , pagine : 0 }, //JQuery.extend() restituisce una copia dell'oggetto bestSeller : jQuery . extend ( true , {}, libro ) } console . log ( autorePreferito . cognome ); console . log ( autorePreferito . nome ); console . log ( autorePreferito . libroPreferito . titolo ); console . log ( autorePreferito . libroPreferito . pagine ); console . log ( autorePreferito . bestSeller . titolo ); console . log ( autorePreferito . bestSeller . pagine ); //Chiamata al costruttore libro = new LibroConstructor ( \"Il ritorno all'isola\" , 301 ); //Chiamata al costruttore autorePreferito = new Autore ( \"Isaac\" , \"Asimov\" , \"L`uomo del bicentenario\" , 288 , libro ); //Modo alternativo /* autorePreferito = new Autore( \"Isaac\", \"Asimov\", \"L`uomo del bicentenario\", 288, new LibroConstructor ( \"Il ritorno all'isola\", 301 ) ); */ //Funzione costruttore function Autore ( cognome , nome , titolo , pagine , bestSeller ) { //stato interno this . cognome = cognome ; this . nome = nome ; this . libroPreferito = { titolo , pagine }; //this.libroPreferito = {titolo: titolo,pagine: pagine}; this . bestSeller = jQuery . extend ( true , {}, bestSeller ); } function LibroConstructor ( titolo , pagine ){ this . titolo = titolo ; this . pagine = pagine ; } console . log ( autorePreferito . cognome ); console . log ( autorePreferito . nome ); console . log ( autorePreferito . libroPreferito . titolo ); console . log ( autorePreferito . libroPreferito . pagine ); console . log ( autorePreferito . bestSeller . titolo ); console . log ( autorePreferito . bestSeller . pagine ); /* \"\" \"\" \"\" 0 \"\" 0 Isaac Asimov L`uomo del bicentenario 288 Il ritorno all'isola 301 */ </ script > </ body > </ html > Il costruttore \u00e8 una funzione che riceve come parametri i valori delle property e costruisce (ritorna) un oggetto. Notare l'uso del new necessario per l'invocazione del costruttore e del this ripetuto per ogni property necessario per stabilire il contesto dell'oggetto che viene creato dal costruttore. Vediamo adesso l'aggiunta di metodi all'esempio di sopra: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > let libro = { titolo : \"\" , pagine : 0 } function LibroConstructor ( titolo , pagine ){ this . titolo = titolo ; this . pagine = pagine ; } let autorePreferito = { cognome : \"\" , nome : \"\" , libroPreferito : { titolo : \"\" , pagine : 0 }, bestSeller : jQuery . extend ( true , {}, libro ) } function Autore ( cognome , nome , titolo , pagine , bestSeller ) { //stato interno this . cognome = cognome ; this . nome = nome ; this . libroPreferito = { titolo , pagine }; //this.libroPreferito = {titolo: titolo,pagine: pagine}; this . bestSeller = jQuery . extend ( true , {}, bestSeller ); //metodi this . getSchedaBestSeller = function () { let stringa = this . bestSeller . titolo + \"\\n\" + this . bestSeller . pagine ; let stringaConCornicetta = \"*\" . repeat ( 10 ) + \"\\n\" + \"BestSeller\" + \"\\n\" + \"-\" . repeat ( 10 ) + \"\\n\" + stringa + \"\\n\" + \"*\" . repeat ( 10 ); return stringaConCornicetta ; } this . getSchedaAutore = function () { let stringa = this . cognome + \"\\n\" + this . nome + \"\\n\" + this . libroPreferito . titolo + \"\\n\" + this . libroPreferito . pagine ; let stringaConCornicetta = \"*\" . repeat ( 10 ) + \"\\n\" + \"Scheda\" + \"\\n\" + \"-\" . repeat ( 10 ) + \"\\n\" + stringa + \"\\n\" + \"*\" . repeat ( 10 ); return stringaConCornicetta ; } } //Creo una collezione di oggetti, cio\u00e8 un array di oggetti let schedario = [ new Autore ( \"Runny\" , \"Ted\" , \"Lo sguardo del principe\" , 212 , new LibroConstructor ( \"Il mio viaggio\" , 272 ) ), new Autore ( \"Buld\" , \"Frank\" , \"I segreti di tutti\" , 302 , new LibroConstructor ( \"Il mio segreto\" , 180 ) ) ]; //Aggiungo in coda un nuovo oggetto schedario . push ( new Autore ( \"Tuy\" , \"malek\" , \"La voglia di te\" , 167 , new LibroConstructor ( \"la voglia di niente\" , 134 ) ) ); //itero ogni elemento dell'array e chiamo i metodi for ( let autore of schedario ) { console . log ( autore . getSchedaAutore () ); console . log ( autore . getSchedaBestSeller () ); } /* ********** Scheda ---------- Runny Ted Lo sguardo del principe 212 ********** ********** BestSeller ---------- Il mio viaggio 272 ********** ********** Scheda ---------- Buld Frank I segreti di tutti 302 ********** ********** BestSeller ---------- Il mio segreto 180 ********** ********** Scheda ---------- Tuy malek La voglia di te 167 ********** ********** BestSeller ---------- la voglia di niente 134 ********** */ </ script > </ body > </ html > Lezione 04 Ereditariet\u00e0 JavaScript confonde un po' gli sviluppatori che hanno esperienza di linguaggi basati sulle classi (come Java o C++), poich\u00e8 \u00e8 un linguaggio dinamico e non fornisce un'implementazione di class (la keyword class \u00e8 introdotto in ES2015, ma \u00e8 zucchero sintattico, Javascript rimarr\u00e0 basato sui prototipi). In termini di ereditariet\u00e0, Javascript ha solo un costrutto: gli oggetti. Ogni oggetto ha un link interno ad un altro oggetto chiamato prototype. Questo oggetto prototype ha a sua volta un suo prototype, e cos\u00ec via finch\u00e9 si raggiunge un oggetto con property null. null, per definizione, non ha un prototype, ed agisce come link finale nella catena di prototipi. Quasi tutti gli oggetti in Javascript sono istanze di Object, che risiede in cima alla catena dei prototipi. Nonostante questo sia considerato spesso come una debolezza di Javascript, il modello di ereditariet\u00e0 prototipale \u00e8 invece pi\u00f9 potente del modello classico. Per esempio, \u00e8 banale costruire un classico modello sul modello prototipale, mentre il contrario \u00e8 molto pi\u00f9 difficile. Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Inheritance_and_the_prototype_chain Supponiamo di aver creato un oggetto con certe propriet\u00e0 e metodi e di voler creare un altro oggetto con le stesse propiet\u00e0 e gli stessi metodi ed altre propriet\u00e0/metodi speifiche. Una soluzione, per quello che conosciamo adesso, si ha banalmente con un copia e incolla dell'oggetto modello (prototipo) aggiungendo poi le caratteristiche aggiuntive. Il concetto dell'ereditariet\u00e0 evita questa procedura di copia incolla non solo perch\u00e8 sarebbe una ripetizione ma anche, soprattutto, perch\u00e8 gli errori con i copia e incolla diventano intracciabili. Se \u00e8 stato individuato un errore nell'oggetto A, \u00e8 necessario riportare tutte le modifiche anche negli altri oggetti di cui si \u00e8 effettuata la copia manuale .. non \u00e8 il massimo. Per parlare di ereditariet\u00e0 dobbiamo parlare di gerarchia padre/figlio. Un figlio \u00e8 un oggetto che contiene tutte le caratteristiche del padre ovvero ne eredita le propriet\u00e0. Si parla anche di modello is-a Immaginiamo di avere questo modello piramidale: Animali Mammiferi Cane Gatto Volpe L'oggetto Volpe \u00e8 un (is-a) Mammifero , un Mammifero \u00e8 un (is-a) Animale . Secondo questo modello \u00e8 possibile costruire degli oggetti molto dettagliati semplicemente sfruttando le propriet\u00e0 ereditate Vediamo come si costruisce un oggetto con propriet\u00e0 ereditate //persona \u00e8 l'oggetto <padre> let persona = { nome : \"\" }; //Creo l'oggetto fantozzi. //fantozzi \u00e8 un oggetto che ha come prototipo l'oggetto persona. //fantozzi is-a persona let fantozzi = Object . create ( persona ); //persona e il prototipo di fantozzi sono la stesso oggetto console . log ( persona === Object . getPrototypeOf ( fantozzi )); => true //Per accedere in scrittura alle propriet\u00e0 ereditate si utilizza il metodo getPrototypeOf() //applicabile agli oggetti Object . getPrototypeOf ( fantozzi ). nome = \"Fantozzi\" ; //non avrei potuto scrivere direttamente \"fantozzi.nome\" perch\u00e8 avrebbe creato una propriet\u00e0 locale //poich\u00e8 <nome> non \u00e8 una propriet\u00e0 dell'oggetto \"fantozzi\" ma dell'oggetto \"persona\" //e quindi una propriet\u00e0 ereditata \u00e8 necessario il metodo getPrototypeOf() per distinguere in scrittura //le propriet\u00e0 locali da quelle ereditate. //In lettura, se non ci sono conflitti (vedremo pi\u00f9 avanti), //non importa specificare getPrototypeOf() perch\u00e8 il costrutto cerca prima tra le propriet\u00e0 locali //la propriet\u00e0 <nome>, se non \u00e8 presente la si cerca tra gli oggetti padre e quindi tra le property ereditate //In questo caso non la trover\u00e0 tra le propriet\u00e0 locali ma tra quelle ereditate console . log ( fantozzi . nome ); //Fantozzi //In questo caso aggiungo una propriet\u00e0 locale fantozzi . nome = \"il super sfigato\" ; //La proprit\u00e0 locale ha la precedenza. La propriet\u00e0 locale maschera quella ereditata //Shadowing console . log ( fantozzi . nome ); //il super sfigato //Per accedere in lettura alla propriet\u00e0 <nome> ereditata devo necessariamente utilizzare il //getPrototypeOf() console . log ( Object . getPrototypeOf ( fantozzi ). nome ); ATTENZIONE!! Il metodo create non crea una copia. let fantozzi = Object . create ( persona ); l'oggetto fantozzi non \u00e8 una copia dell'oggetto persona . Il figlio (fantozzi) condivide le stesse property del padre(persona). Se modifico le property del figlio (fantozzi) le trovo modificate anche nell'oggetto padre (persona) proprio perch\u00e8 condividono le stesse variabili, lo stesso spazio in memoria. Questo \u00e8 da tenere in considerazione! Lezione 05 Ereditariet\u00e0 - Shadowing Lo shadowing \u00e8 un meccanismo di mascheramento/oscuramento di property ereditate con la definizione di property locali Esempio let persona = { nome : \"\" , cognome : \"\" , Etichetta : function () //Stringhe template. Iniziano con $. Prima vengono valutate poi il valore viene sostituito e notare gli acccenti gravi { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } }; //L'oggetto persona diventa il prototipo dell'oggetto fantozzi let fantozzi = Object . create ( persona ); //Metodo hasOwnProperty(\"property\"): ritorna <true> se l'oggetto a cui si applica il metodo //ha come propriet\u00e0 diretta (non ereditata) \"property\", quella indicata come parametro. console . log ( fantozzi . hasOwnProperty ( \"nome\" )); //false //In questo caso constrollo se \"nome\" appartiene al padre console . log ( Object . getPrototypeOf ( fantozzi ). hasOwnProperty ( \"nome\" )); //true cosnole . log ( fantozzi . nome ); //non ancora inizializzata ma la variabile viene trovata come propriet\u00e0 ereditata //Accedo in scrittura alle propriet\u00e0 ereditate Object . getPrototypeOf ( fantozzi ). nome = \"Ugo\" ; Object . getPrototypeOf ( fantozzi ). cognome = \"Fantozzi\" ; //Creo una propriet\u00e0 locale fantozzi . nome = \"e io chi sono??\" ; //Accedo in lettura alla propriet\u00e0 locale console . log ( fantozzi . nome ); //e io chi sono?? //Accedo in lettura alla propriet\u00e0 ereditata console . log ( Object . getPrototypeOf ( fantozzi ). nome ); //Ugo //Posso eliminare una property tramite il comando <delete> ma solo tra quelle locali delete fantozzi . nome ; //A questo punto rimane solo la property <name> ereditata console . log ( fantozzi . nome ); //Ugo //Shadowing: Meccanismo di mascheramento/oscuramento di property ereditate con la definizione di //prperty locali //Chiamo il metodo Etichetta dell'oggetto fantozzi eredietato dall'oggetto persona console . log ( \"1: \" + fantozzi . Etichetta () ); //Oscuro il metodo <Etichetta> ereditato dal metodo <Etichetta> definito localmente -> shadowing fantozzi . Etichetta = function () { return \"il sottoposto per eccellenza\" ;} console . log ( \"2: \" + fantozzi . Etichetta ()); //Variante ... //Un po' complessa. //Definisco un metodo locale che utilizza il metodo ereditato. //il this fa riferimento all'oggetto in cui si definisce il metodo quindi \"fantozzi\" fantozzi . Etichetta = function () { return Object . getPrototypeOf ( this ). Etichetta () + \" detto il sottoposto\" ;} console . log ( \"3: \" + fantozzi . Etichetta ()); //le propriet\u00e0 del prototipo sono CONDIVISE. //Se modifico una propiet\u00e0 in un figlio ereditata da una propriet\u00e0 del padre, //la ritrovo modificata anche nel padre e negli altri figli del padre, cio\u00e8 nei \"fratelli\" //Questo non \u00e8 lo stesso meccanismo del C/C#/Java let filini = Object . create ( persona ); Object . getPrototypeOf ( filini ). cognome = \"Filini\" ; console . log (( \"4: \" + fantozzi . cognome ); //Filini, ATTTT!! Metodo hasOwnProperty() : ritorna se l'oggetto a cui si applica il metodo ha come propriet\u00e0 diretta (non ereditata) \"property\", quella indicata come parametro. Cosniderazione: Il padre di tutti gli oggetti \u00e8 proprio \"Object\" Ricorda: Con il metodo create() non creo una copia dell'oggetto, cio\u00e8 un'istanza del prototipo, ma instauro solo un rapporto di condivisione Ereditariet\u00e0 classica Per ereditariet\u00e0 classica si intende il meccanismo con il quale Javascript permette la crazione di istanze di oggetti a partire da un prototipo. Nell'esempio vedremo come realizzare una copia dato un prototipo Vediamo finalmente il metodo per creare una fottuta copia //Prototipo function Persona ( nome , cognome ) { //stato interno //Ogni istanza avr\u00e0 la sua copia di cognome e nome this . cognome = cognome ; this . nome = nome ; //ogni istanza avr\u00e0 la sua copia di etichetta this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } //chiamata al costruttore let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ) //gli oggetti fantozzi e filini hanno le loro copie distinte //delle variabili dello stato interno console . log ( \"1: \" + fantozzi . etichetta ()); cosnole . log ( \"2: \" + filini . etichetta ()); cosnole . log `3: ${ fantozzi . etichetta === filini . etichetta } ` ); //false Lezione 06 THIS In questi esempi cercheremo di capire la funzione di this in Javascript a seconda dei contesti. function Persona ( nome , cognome ) { //stato interno this . cognome = cognome ; this . nome = nome ; console . log ( this === window ); //true this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } //Attenzione, qua non utilizzo il costruttore. //this punta all'oggetto <window> (cio\u00e8 il padre del DOM). //Il risultato \u00e8 che le property <nome>, <cognme> diventano a tutti gli effetti variabili globali //poich\u00e8 <window> \u00e8 un oggetto implicito Persona ( \"\" , \"zzzzzz\" ); //cognome \u00e8 una variabile globale, window.cognome === cognome console . log ( cognome ); //zzzzzz Se invece utilizzo il costruttore dell'oggetto.. function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; console . log ( this === window ); //false this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } //Utilizzo il costruttore per creare due istanze dell'oggetto \"Persona\", \"fantozzi\", \"filini\" let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); //Adesso le variabili (property) <nome>, <cognome> sono visibili solo nel contesto degli oggetti \"fantozzi\" e \"filini\" //e accessibili solo tramite l'opertore \".\" console . log ( cognome ); //cognome is not defined. console . log ( fantozzi . cognome ); //Fantozzi. console . log ( filini . cognome ); //Filini. Quando this \u00e8 all'interno della definizione di un metodo, fa riferimento all'oggetto per cui si definisce il metodo. Nota: Non posso definire una variabile locale \"local_var\" senza far uso di this . Non sar\u00e0 disponibile nelle istanze degli oggetti ma solo nel constesto della chiamata funzione e quindi non nel contesto della chiamata a costruttore. Vediamo un esempio function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; let local_var = 999 ; //ATTENZIONE!! Non ha senso nel contesto di chiamata a costruttore //ogni istanza avr\u00e0 la sua copia di etichetta this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); console . log ( fantozzi . local_var ); //undefined console . log ( fantozzi . cognome ); //Fantozzi. console . log ( filini . cognome ); //Filini. Object - Variabili Statiche (condivise) In generale, le variabili statiche sono variabili condivise. Nel contesto di un oggetto, per creare delle variabili statiche cio\u00e8 condivise tra tutte le istanze si ottiene attraverso il metodo prototype function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); //dichairo una variabile (property) \"s\", \"ETA_MIN\" statica cio\u00e8 condivisa tra tutte le istanze create attravero il modello //dell'oggetto \"Persona\" Persona . prototype . s = \"ciao\" ; Persona . prototype . ETA_MIN = { value : 18 } ; console . log ( fantozzi . s ); //ciao console . log ( filini . s ); //ciao console . log ( fantozzi . ETA_MIN ); //{value: 18} console . log ( filini . ETA_MIN ); //{value: 18} //Posso dichiarare anche un metodo condiviso Persona . prototype . etichettaCondivisa = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } console . log ( `3: ${ fantozzi . etichetta === filini . etichetta } ` ); //false console . log ( `4: ${ fantozzi . etichettaCondivisa === filini . etichettaCondivisa } ` ); //true Vediamo un ultimo esempio: function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); Persona . prototype . s = \"ciao\" ; console . log ( fantozzi . s ); //ciao console . log ( filini . s ); //ciao //Se voglio accedere in scrittura ad una property condivisa tramite un figlio, dobbiamo al solito modo //utilizzare getPrototypeOf() Object . getPrototypeOf ( fantozzi ). s = \"amor\" ; console . log ( fantozzi . s ); //amor console . log ( filini . s ); //amor //Definisco una property locale a fantozzi fantozzi . s = \"mare\" ; console . log ( fantozzi . s ); //mare console . log ( filini . s ); //amor Lezione 07 Introduzione For In for-in \u00e8 un metodo utilizzato per iterare sulle property degli oggetti tramite l'identificativo delle chiavi. Vedremo pi\u00f9 avanti cosa sta dietro a un costrutto cos\u00ec semplice e potente for ( const x in object ){ //code } const Persona = { name : 'Simone' , eta : 23 , hobby : 'Tennis' } for ( const x in Persona ) { console . log ( '+++++++++++++++' ); console . log ( x ); //Itero sulle chiavi console . log ( typeof x ); //x \u00e8 una stringa //non posso utilizzare Persona.x poich\u00e8 x \u00e8 una stringa. //Posso comunque utilizzare la notazione Persona[x] che in questo i torna comodo console . log ( Persona [ x ]); //Itero sui valori console . log ( Persona . x ); //Itero sui valori console . log ( '+++++++++++++++' ); } /* +++++++++++++++ name string Simone +++++++++++++++ +++++++++++++++ eta string 23 +++++++++++++++ +++++++++++++++ hobby string Tennis +++++++++++++++ */ Oggetto Date() Un oggetto interessante \u00e8 l'oggetto Date() . Javascript permette di gestire in modo semplice il tempo, la data, l'ora acquisendo dati dalla rete. //Chiamata al costruttore Date() con parametri di default let oggi = new Date (); console . log ( oggi ); /* Console: --------------- Wed Nov 11 2020 17:13:04 GMT+0100 (Ora standard dell\u2019Europa centrale) */ //Passaggio di parametri al costruttore Date() let compleannoMio = new Date ( '07-22-1991-09:30:12' ); //Modi alternativi let compleannoMario = new Date ( '07/22/1991' ); let compleannoGiovanni = new Date ( 'July 22 1991' ); console . log ( 'compleannoMio: ' + compleannoMio ); console . log ( 'compleannoMario: ' + compleannoMario ); console . log ( 'compleannoGiovanni: ' + compleannoGiovanni ); /* Console: --------------- compleannoMio: Mon Jul 22 1991 09:30:12 GMT+0200 (Ora legale dell\u2019Europa centrale) compleannoMario: Mon Jul 22 1991 00:00:00 GMT+0200 (Ora legale dell\u2019Europa centrale) compleannoGiovanni: Mon Jul 22 1991 00:00:00 GMT+0200 (Ora legale dell\u2019Europa centrale) */ Essendo Date() un oggetto ci sono diversi metodi get associati a questo oggetto come: getFullYear() : Ritorna l'anno getMonth() : Ritorna il mese a partire da 0, 0 = GEN, 1 = FEB getDate() : Ritorna il giorno del mese corrente, range [1 - 31] getDay() : Ritorna il giorno della settimana a partire da 0, 0 = DOM, 1 = LUN getHours() : Ritornano le ore getMinutes() : Ritornano i minuti getSeconds() : Ritornano i secondi getMilliseconds() : Ritornano i millisecondi getTime() : he getTime() method returns the number of milliseconds between midnight of January 1, 1970 and the specified date ... Ma anche metodi analoghi di set come: - setFullYear(year) - setMonth(month) - setHours(h, m, s) - .. //Metodi get let myData = new Date (); console . log ( 'getFullYear: ' + myData . getFullYear ()); console . log ( 'getMonth: ' + myData . getMonth ()); console . log ( 'getDate: ' + myData . getDate ()); console . log ( 'getDay: ' + myData . getDay ()); console . log ( 'getHours: ' + myData . getHours ()); console . log ( 'getMinutes: ' + myData . getMinutes ()); console . log ( 'getSeconds: ' + myData . getSeconds ()); console . log ( 'getMilliseconds: ' + myData . getMilliseconds ()); console . log ( 'getTime: ' + myData . getTime ()); /* Console: --------------- getFullYear: 2020 getMonth: 10 getDate: 12 getDay: 4 getHours: 10 getMinutes: 27 getSeconds: 50 getMilliseconds: 336 getTime: 1605173270336 */ //Metodi set let compleannoMario = new Date ( 'April 02 2002' ); console . log ( 'compleannoMario: ' + compleannoMario ); /* Console: --------------- compleannoMario: Tue Apr 02 2002 00:00:00 GMT+0200 (Ora legale dell\u2019Europa centrale) */ compleannoMario . setFullYear ( '1991' ); compleannoMario . setMonth ( 9 ); compleannoMario . setHours ( 12 , 45 , 09 ); console . log ( 'compleannoMario: ' + compleannoMario ); /* Console: --------------- compleannoMario: Wed Oct 02 1991 12:45:09 GMT+0100 (Ora standard dell\u2019Europa centrale) */ Nota: Se creto un'istanza dell'oggetto Date() senza parametri, verr\u00e0 invocato il costruttore con parametri di default. Di default Date() restituisce l'ora e la data locale fornita dalla rete. Quindi l'oggetto appena creato far\u00e0 riferimento all'ora corrente, un dato dinamico. Lezione 08 Classi Le classi JavaScript, introdotte in ECMAScript 2015, sono principalmente zucchero sintattico sull'esistente ereditariet\u00e0 prototipale di JavaScript. La sintassi non introduce un nuovo modello di eredit\u00e0 orientata agli oggetti in JavaScript. Le classi sono di fatto delle \"funzioni speciali\", e cos\u00ec come puoi definire function expressions e function declarations, la sintassi per la classe ha due componenti: class expressions e class declarations. Non \u00e8 lo stesso concetto di classe definita come ad esempio per il linguaggio C++. class Persona { } let Fantozzi = new Persona (); cosnole . log ( typeof ( Fantozzi )); //Object //Dietro il meccanismo di classe c'\u00e8 di fatto il concetto di prototipo/funzione cosnole . log ( typeof ( Persona )); //function Vediamo un esempio pi\u00f9 completo class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } } //non passo nessun parametro quindi utilizzer\u00e0 i valori di default let Fantozzi = new Persona (); cosnole . log ( Fantozzi . nome ); //sconosciuto Note: - Con questa definizione di classe non esiste tuttavia un meccanismo che possa rendere privati i dati come nel concetto di classe che si avrebbe nel c++. - Non \u00e8 possibile un meccanismo di overload dei costruttori , non possono quindi coesistere pi\u00f9 costruttori. E' ammesso un solo costruttore per classe. Tuttavia ogni istanza creata avr\u00e0 i dati separati class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } } //non passo nessun parametro quindi utilizzer\u00e0 i valori di default let Fantozzi = new Persona (); console . log ( Fantozzi . nome ); //sconosciuto let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); console . log ( Fantozzi . nome ); //Ugo let Filini = new Persona ( \"Filini\" , \"Silvio\" ); console . log ( Filini . nome ); //Silvio console . log ( Fantozzi . nome ); //Ugo Ampliamo la classe con l'aggiunta di metodi: class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } } let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); let Filini = new Persona ( \"Filini\" , \"Silvio\" ); cosnole . log ( Fantozzi . etichetta ); cosnole . log ( Filini . Etichetta ); cosnole . log ( Fantozzi . etichetta === Filini . Etichetta ); //false Aggiunta di metodi condivisi class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } //metodo condiviso tra tutte le istanze static etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } //metodo separato per ogni istanza etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } } let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); let Filini = new Persona ( \"Filini\" , \"Silvio\" ); //Assegno dei \"value\" alle property della classe Persona . cognome = \"Liberti\" ; Persona . nome = \"Franco\" ; //il metodo Filini.etichetta \u00e8 il metodo locale alla classe Filini. //Prende il nome di \"Metodo di istanza\" console . log ( \"Metodo di istanza: \" + Filini . etichetta () ); //Metodo di istanza: Egr. Sig. Silvio Filini //il metodo Persona.etichetta \u00e8 il metodo condiviso tra tutte le istanze della classe Persona. //Prende il nome di \"Metodo di classe\" console . log ( \"Metodo di classe: \" + Persona . etichetta () ); //Metodo di classe: Egr. Sig. Franco Liberti Vediamo un esempio in cui posso sfruttare le variabili statiche. In questo esempio, ogni volta che creo un'istanza della classe Persona, incremento una variabile statica che indicher\u00e0 alla fine quante istanze ho creato class Persona { constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; //ogni volta che creo un'istanza della classe Persoan, si icrementa la variabile \"conta\" //Nota <conta> \u00e8 stata aggiunta dopo la creazione della classe Persona Persona . conta ++ ; } static personeCreate () { return Persona . conta ;} etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } } //Resetto il conteggio Persona . conta = 0 ; let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); let Filini = new Persona ( \"Filini\" , \"Silvio\" ); console . log ( Persona . conta ); //2 console . log ( Persona . personeCreate () ); //2 Lezione 09 Classi assegnanili a variabili Posso assegnare una classe ad una variabile esattamente come per gli oggetti, le funzioni.. //questa \u00e8 una classe anonima let Punto = class { constructor ( x , y ) { this . x = x ; this . y = y ;} } let p = new Punto ( 10 , - 30 ); console . log ( p . y ); //-30 p . x = \"paperino\" ; //non viene fatto nessun controllo semantico console . log ( p . x ); //paperino Get / Set Non c'\u00e8 un modo di definire x e y private con un meccanismo simile alle property private per le classi definite dal linguaggio C++ tuttavia esiste un sistema che ci aiuta a nascondere le variabili interne, get/set . //PuntoIQ \u00e8 una classe che assegna punti solo nel primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } } try { //poich\u00e8 questo punto non appartiene al primo quadrante si verifica l'eccezione e salta al catch let p = new PuntoIQ ( 10 , - 30 ); } catch ( eccezione ) { console . log ( eccezione ); } try-catch Nota il sistema try-catch . Con tale sistema \u00e8 possibile tentare l'esecuzione del codice presente nel corpo di try . Se va a buon fine si prosegue altrimenti si esegue il corpo del catch . Per stabilire se il codice presente nel try va o meno a buon fine si utilizza la keyword throw . Nella classe PuntoIQ infatti se i dati passati al costruttore sono minori di zero si passa un'eccezione attravero throw , l'eccezione in questo caso \u00e8 semplicemente la stringa \"Non nel primo quadrante\" che viene passata al catch try { //prova ad eseguire il codice. Se il codice presenta un'eccezione salta al catch } catch ( eccezione ){ //esegui eccezione } Riprendiamo con il concetto di get/set //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } //Per accedere a questa propriet\u00e0 devo usare \"_x\", //\u00e8 di fatto un sistema di costrizione dell'utilizzatore della classe a NON usare questa property this . _x = x ; //Per accedere a questa propriet\u00e0 devo usare \"_y\", //\u00e8 di fatto un sistema di costrizione dell'utilizzatore della classe a NON usare questa property this . _y = y ; } //Le keyword \"get\" definisce di fatto un metodo che pu\u00f2 essere richiamato con la nomenclatura //utilizzata per le propriet\u00e0. Posso quindi richiamare il metodo x tramite <punto.x> //get definisce un metodo di lettura quindi posso leggere la property \"x\" //nascondendo la \"vera\" property definita sopra tramite \"_x\" get x () { return this . _x ; } //Le keyword \"set\" definisce come \"get un metodo che pu\u00f2 essere richiamato con la nomenclatura //utilizzata per le propriet\u00e0. Posso quindi richiamare il metodo x tramite <punto.x> //get definisce un metodo di scrittura quidni posso scrivere la property \"x\" //nascondendo la \"vera\" property definita sopra \"_x\" set x ( valore ) { this . _x = valore ; } } try { var p = new PuntoIQ ( 10 , 30 ); //Ok } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 10, _y: 30} try { p . x = 56 ; // === p._x = 56 } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 56, _y: 30} try { p . _x = 12 ; // L'utilizzatore della classe sta bypassando il metodo \"ufficiale\" tramite get/set } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 12, _y: 30} Passare attravero get/set \u00e8 utile per poter eseguire controlli avanzati e restituire un errore in caso di fallimento. Vediamo di estendere la classe di sopra aggiungendo un controllo in fase di set //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore ) ){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } } try { var p = new PuntoIQ ( 10 , 30 ); //Ok } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 10, _y: 30} try { p . x = \"dodici\" ; // === p._x = 56 } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //Non \u00e8 un numero Lezione 10 Derivazione di classi , ereditariet\u00e0 Il meccanismo di derivazione delle classi ovvero la costruzione di una classe figlia a partire da una classe padre aggiungendo una specializzazione \u00e8 noto anche come meccanismo di ereditariet\u00e0 e si ottiene semplicemente la keyword extends . Abbiamo gi\u00e0 visto come \u00e8 implementato questo concetto negli oggetti in Javascript. Per quanto riguarda le classi si ricordi che \u00e8 solo \"zucchero sintattico\" quindi il meccanismo sotto sar\u00e0 il medesimo. //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore ) ){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } } class PuntoIQColorato extends PuntoIQ { } La lasse \"PuntoIQColorato\" \u00e8 derivata dalla classe madre PuntoIQ ma accede a a tutte le strutture interne della classe madre. Vediamo di estendere la classe definita sopra con altri metodi: //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore )){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } //\"distanza(altro)\", applicato a un oggetto A <PuntoIQ> calcola la distanza tra //l'oggetto a cui si applica il metodo (oggetto A) e un altro oggetto ricevuto come argomento //<altro> che dovr\u00e0 essere un oggetto della classe <PuntoIQ> distanza ( altro ){ //\"A instanceof B\" ritorna true se A \u00e8 un'istanza di B //Viene quindi fatto un controllo per essere sicuri di aver ricevuto un oggetto compatibile if ( altro instanceof PuntoIQ ){ //formula distanza tra due punti return ( Math . sqrt ( Math . pow ( this . x - altro . x , 2 ) + Math . pow ( this . y - altro . y , 2 ) ) ); } else { throw \"Il parametro attuale `altro` non \u00e8 un punto\" ; } } } class PuntoIQColorato extends PuntoIQ { } let p1 = new PuntoIQ ( 5 , 5 ); let p2 = new PuntoIQ ( 10 , 10 ); cosnole . log ( p1 . distanza ( p2 ) ); //7.07... //un oggetto della classe <PuntoIQColorato> \u00e8 identico a un oggetto della classe <PuntoIQ> let pc = new PuntoIQColorato ( 100 , 100 ); console . log ( \"Punto Colorato: \" + pc . x ); //La classe figlia PuntoIQColorato passa il controllo if (altro instanceof PuntoIQ) Poich\u00e8 \u00e8 figlia //di PuntoIQ cosnole . log ( pc . distanza ( p2 ) ); Nella prossima lezione aggiungeremo elementi specifici della classe PuntoIQColorato Lezione 11 Ereditariet\u00e0 classi Pt 2 In questo esempio vedremo aggiungeremo elementi specifici della classe PuntoIQColorato . Utilizzeremo anche il comando super . Un comando usato nella classe figlia per richiamare il costruttore della classe madre //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore )){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } //\"distanza(altro)\", applicato a un oggetto A <PuntoIQ> calcola la distanza tra //l'oggetto a cui si applica il metodo (oggetto A) e un altro oggetto ricevuto come argomento //<altro> che dovr\u00e0 essere un oggetto della classe <PuntoIQ> distanza ( altro ){ //\"A instanceof B\" ritorna true se A \u00e8 un'istanza di B //Viene quindi fatto un controllo per essere sicuri di aver ricevuto un oggetto compatibile if ( altro instanceof PuntoIQ ){ //formula distanza tra due punti return ( Math . sqrt ( Math . pow ( this . x - altro . x , 2 ) + Math . pow ( this . y - altro . y , 2 ) ) ); } else { throw \"Il parametro attuale `altro` non \u00e8 un punto\" ; } } } class PuntoIQColorato extends PuntoIQ { constructor ( x , y , colore ){ //super richiama il costruttore della classe madre //super deve essere sempre il primo statemeant super ( x , y ); this . _colore = colore ; //Potrei accedere ai dati interni della classe madre PuntoIQ tramite ad esempio //this._x = 999; //E' ASSOLUTAMENTE DA EVITARE PERCHE' BYPASSO TUTTI I CONTROLLI SU \"x\" } get colore (){ return this . _colore ; } //Shadowing. //Il metodo \"distanza\" definito qua \u00e8 locale alla classe <PuntoIQColorato> e oscura il metodo ereditato //dalla classe <PuntoIQ> distanza ( altro ){ return 1000 ; } } let p1 = new PuntoIQ ( 5 , 5 ); let p2 = new PuntoIQ ( 10 , 10 ); console . log ( p1 . distanza ( p2 ) ); //7.0... let pc = new PuntoIQColorato ( 100 , 100 , \"blue\" ); console . log ( \"Punto Colorato: \" + pc . x , pc . y , pc . colore ); //Punto Colorato: 100 100 blue //Poich\u00e8 il metodo \"distanza\" \u00e8 applicato a <pc> che \u00e8 un <PuntoIQColorato> verr\u00e0 applicato il metodo locale console . log ( pc . distanza ( p2 ) ); //1000 Attenzione: E' buona norma mettere il comando super come primo comando nel costruttore della classe figlia per poter permettere al costrutto di creare le caratteristiche ereditate correttamente Metodi locali ed ereditati possono coesistere e collaborare. Con super posso richiamare il metodo della classe madre all'interno della classe figlia //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore )){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } //\"distanza(altro)\", applicato a un oggetto A <PuntoIQ> calcola la distanza tra //l'oggetto a cui si applica il metodo (oggetto A) e un altro oggetto ricevuto come argomento //<altro> che dovr\u00e0 essere un oggetto della classe <PuntoIQ> distanza ( altro ){ //\"A instanceof B\" ritorna true se A \u00e8 un'istanza di B //Viene quindi fatto un controllo per essere sicuri di aver ricevuto un oggetto compatibile if ( altro instanceof PuntoIQ ){ //formula distanza tra due punti return ( Math . sqrt ( Math . pow ( this . x - altro . x , 2 ) + Math . pow ( this . y - altro . y , 2 ) ) ); } else { throw \"Il parametro attuale `altro` non \u00e8 un punto\" ; } } } class PuntoIQColorato extends PuntoIQ { constructor ( x , y , colore ){ //super deve essere sempre il primo statemeant super ( x , y ); this . _colore = colore ; } get colore (){ return this . _colore ; } //Shadowing. distanza ( altro ){ //richiamo il metodo \"distanza\" della classe madre return super . distanza ( altro ) + 1000 ; } } let p1 = new PuntoIQ ( 5 , 5 ); let p2 = new PuntoIQ ( 10 , 10 ); console . log ( p1 . distanza ( p2 ) ); //7.0... let pc = new PuntoIQColorato ( 100 , 100 , \"blue\" ); console . log ( \"Punto Colorato: \" + pc . x , pc . y , pc . colore ); //Punto Colorato: 100 100 blue console . log ( pc . distanza ( p2 ) ); //1127.2792206135787 Lezione 12 Approfondimento - Symbols Ogni valore symbol restituito da Symbol() \u00e8 unico. Un valore symbol pu\u00f2 essere utilizzato come identificatore per propriet\u00e0 di un oggetto; questo \u00e8 lo scopo di tale tipo di dati. Il tipo di dati symbol \u00e8 un primitive data type. Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/Symbol //Il simbolo \u00e8 un nuovo tipo che permette di creare valori univoci //Nell'esempio creo due variabili di tipo Symbol(). //I loro valori (che non possiamo stampare) saranno sicuramente diversi let un_simbolo = Symbol (); let un_altro_simbolo = Symbol (); //Posso agire per confronti ma non stampare direttamente i simboli console . log ( un_simbolo === un_altro_simbolo ); //false, sempre console . log ( un_simbolo ); //ERROR GUID: Il GUID (Globally Unique Identifier, identificatore unico globale) \u00e8 un numero pseudo-casuale usato nella programmazione software, per poter distinguere vari oggetti. Il tipo pi\u00f9 noto di GUID \u00e8 l'utilizzo di Microsoft dell'UUID, ideato dalla Open Software Foundation, ma vi sono anche altri usi, come quello all'interno di XML. Fonte: https://it.wikipedia.org/wiki/GUID Vediamo l'utilizzo di un Symbol come identificatore di una propriet\u00e0 di un oggetto let oggetto = { colore : \"giallo\" , peso : 21 , } //creo un nuovo simbolo let check = Symbol (); //aggiungo la property \"check\" \u00e8 un valore \"OK\" oggetto [ check ] = \"OK\" ; console . log ( oggetto [ check ]); //OK La property aggiunta con Symbol \u00e8 nascosta.. let oggetto = { colore : \"giallo\" , peso : 21 , scheda : function () { let s = \"\" ; //Si traduce in: per ogni property presente in questo oggetto.. //Itera sulle property tranne su \"scheda\" //E le concatena in una stringa s = \"colore peso\" for ( x in this ){ if ( x !== \"scheda\" ){ s += x + \" \" ; } } return s ; } } //Posso assegnare un'etichetta al Symbol let check = Symbol ( \"il check\" ); oggetto [ check ] = \"OK\" ; console . log ( oggetto [ check ]); //Una property aggiunta con Symbol \u00e8 nascosta. //Utilizzo il metodo \"scheda\" per stampare tutte le property. //Vedremo che la property \"check\" non apparir\u00e0 console . log ( oggetto . scheda () ); //colore peso //Notare la differenza con la seguente propery aggiunta localmente //check2 \u00e8 una propriet\u00e0 locale e visibile oggetto . check2 = \"YES\" ; console . log ( oggetto . scheda () ); //colore peso check2 Posso generare un metodo attraverso Symbol let report = Symbol (); let oggetto2 = { prodotto : \"xyz\" , //genero il metodo con il simbolo [ report ]() { return this . prodotto ;} } console . log ( oggetto2 [ report ]()); //xyz Posso aggiungere il metodo a posteriori let report = Symbol (); let oggetto2 = { prodotto : \"xyz\" , [ report ]() { return this . prodotto ;} } //Assegno al metodo un nuovo valore oggetto2 [ report ] = function () { return \"Controllo effettuato!\" ;} console . log ( oggetto2 [ report ]()); //Controllo effettuato! Lezione 13 Approfondimento - Iterables/Iterator Un oggetto \u00e8 un iterator quando sa come accedere agli elementi di una collezione uno per volta, conservando l'informazione sulla sua posizione corrente nella sequenza. In Javascript un iterator \u00e8 un oggetto che implementa il metodo next() , il quale ritorna l'elemento successivo della sequenza. Questo metodo ritorna un oggetto con due propriet\u00e0: done e value . Una volta che \u00e8 stato creato, un iterator pu\u00f2 essere utlizzato esplicitamente chiamando pi\u00f9 volte il metodo next() . Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Guida/Iteratori_e_generatori Costrutto for - of Il costrutto for...of crea un ciclo con gli oggetti iterabili (inclusi Array, Map, Set, String, TypedArray, argomenti di oggetti e cos\u00ec via), iterando le istruzioni per ogni valore di ogni propriet\u00e0. for ( elem of collection ) { /*CODE*/ }; Vediamo un esempio: let s = \"ciao\" ; //ciclo tradizionale //for (let i=0; i<s.length; i++) console.log(s[i]); //ciclo che sfrutta un iteratore e il for ... of for ( carattere of s ) console . log ( carattere ); Dietro il meccanismo di un costrutto cos\u00ec potente c'\u00e8 il concetto di Iterables/Iterator e Symbol . Se un oggetto \u00e8 iterabile avr\u00e0 un iteratore. A tale iteratore \u00e8 applicabile il metodo next() che restituisce l'elemento successivo della lista degli elementi. Tale elemento \u00e8 un oggetto con due property: done e value . La property done \u00e8 un boolean che indica se siamo arrivati in fondo alla lista degli elementi iterabili mentre la property value restituisce il valore dell'elemento let s = \"ciao\" ; for ( carattere of s ) console . log ( carattere ); let iteratore = s [ Symbol . iterator ](); cosnole . log ( typeof ( s [ Symbol . iterator ]) ); //function cosnole . log ( typeof ( iteratore ) ); //Object. Questo \u00e8 l'oggetto iteratore //l'iteratore \u00e8 un oggetto formato da due sotto elementi //done -> restituisce true se \u00e8 l'ultimo elemento della lista //value -> rappresenta il valore dell'elemento estratto let elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //c, la prima lettera di \"ciao\" //Se continuiamo con next(), passo all'elemento successivo.. elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //i elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //a elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //o elemento = iteratore . next (); console . log ( elemento . done ); //true console . log ( elemento . value ); //undefined Lezione 14 Approfondimento - Funzioni Generatrici I generatori sono funzioni dalle quali \u00e8 possibile uscire e poi rientrarvi in un secondo momento. Il loro contesto (binding delle variabili) verr\u00e0 salvato all'uscita per quando vi entrer\u00e0 successivamente. La chiamata ad un generatore non viene eseguita immediatamente; la funzione ritorner\u00e0 invece un oggetto iterator . Quando il metodo next() dell'iteratore viene chiamato, il corpo del generatore viene eseguito fino alla prima espressione yield , la quale specifica quale espressione ritornare dall'iteratore oppure, con l'espressione yield , delegare questo valore ad un'altra funzione generatrice. Il metodo next() restituisce un oggetto con propriet\u00e0 value contenente il valore da restituito all'iteratore ed una propriet\u00e0 done che contiene un valore di tipo boolean per indicare se il generatore ha restituito l'ultimo valore. Chiamando il metodo next() con un argomento far\u00e0 riprendere l'esecuzione della funzione generatrice, sostituendo l'istruzione yield in cui l'esecuzione era stata fermata con l'argomento della funzione next() . Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Statements/function function * generatrice () { //la prima volta \u00e8 in attesa ... //che venga chiamato il metodo next() sull'oggetto restituito let n = 10 ; console . log ( n ); yield ; //genera n += 1 ; console . log ( n ); } let obj = generatrice (); //non succede niente. Siamo in attesa di invocare next() obj . next (); //10, si ferma a yield e ritorna ma lo stato dei dati \u00e8 memorizzato obj . next (); //11 obj . next (); // Vediamo un esempio pi\u00f9 interessante: function * generatrice () { let n = 0 ; while ( true ){ n ++ ; console . log ( n ); yield ; } } let obj = generatrice (); obj . next (); //1 obj . next (); //2 obj . next (); //3 yield \u00e8 il \"ritorno\" della funzione generatrice e restituisce un oggetto iterator , un oggetto formato quindi da due property value e done function * generatrice () { let n = 0 ; while ( true ){ n ++ ; yield n ; } } let obj = generatrice (); console . log ( obj . next (). value ); //1 console . log ( obj . next (). value ); //2 console . log ( obj . next (). value ); //3 Lezione 15 Approfondimento - Esempio (For .. of) custom Dopo l'introduzione di Iterator/Iterables e di funzioni generatrici \u00e8 possibile costruire per una classe personale un metodo (for..of) personalizzabile class miaCollezione { //la classe contiene un array constructor () { this . items = []; } //posso aggiungere valori tramite il metodo \"add\" add ( value ) { this . items . push ( value ) } //questo definisce un metodo per il for - of * [ Symbol . iterator ] () { for ( let key in this . items ) { //Se la lunghezza dell'array \u00e8 maggiore di 4, restituisce l'array if ( this . items [ key ]. length > 4 ) yield this . items [ key ]; } } } let o = new miaCollezione (); o . add ( \"rossi\" ); o . add ( \"Bob\" ); o . add ( \"Gialli\" ); //L'elemento Bob non verr\u00e0 stampato perch\u00e8 ha 3 elementi for ( x of o ) { console . log ( x ); } /* rossi Gialli */ Posso aggiungere anche aggiungere una funzione generatrice come metodo per iterare sugli elementi sfruttando il costrutto while e come terminatore del ciclo la property done class miaCollezione { //la classe contiene in realt\u00e0 un array constructor () { this . items = []; } //posso aggiungere valori tramite il metodo \"add\" add ( value ){ this . items . push ( value ) } //questo definisce un metodo per il for - of * [ Symbol . iterator ] (){ for ( let key in this . items ){ //Se la lunghezza dell'array \u00e8 maggiore di 4, restituisce l'array if ( this . items [ key ]. length > 4 ) yield this . items [ key ]; } } * generatrice (){ for ( let key in this . items ){ yield this . items [ key ]; } } } let o = new miaCollezione (); o . add ( \"rossi\" ); o . add ( \"Bobyna\" ); o . add ( \"Gialli\" ); let iterator = o . generatrice (); //itero \"a mano\" tramite la funzione mia generatrice. //E' esattamente il (for.. of ) //Nota < (elemento=iterator.next()).done > equivale a: //elemento = iterator.next() //elemento.done while ( ! ( elemento = iterator . next ()). done ) cosnole . log ( elemento . value ); Lezione 16 Destructuring La sintassi di assegnamento di destrutturazione \u00e8 un'espressione JavaScript che rende possibile estrarre informazioni da array o oggetti in variabili distinte. Le espressioni letterali degli oggetti e degli array forniscono un modo facile per creare ad hoc pacchetti di data. Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment let prodotto = { codice : \"BPX001\" , categoria : \"alimentari\" , prezzo : 1.25 }; //FORMA ABBREVIATA //i valori delle property \"codice\" e \"prezzo\" sono memorizzate in due variabili di nome \"codice\", \"prezzo\" //il nome delle variabili deve coincidere con il nome della property let { codice , prezzo } = prodotto ; /* Equivale a: let codice = prodotto.codice; let prezzo = prodotto.prezzo; */ console . log ( ` ${ codice } - ${ prezzo } ` ); // BPX001 - 1.25 //FORMA ESTESA //E' possibile assegnare un nome alle variabili con l'associazione di un'etichetta let { codice : il_codice , prezzo : il_prezzo } = prodotto ; console . log ( ` ${ il_codice } - ${ il_prezzo } ` ); // BPX001 - 1.25 Il Destructuring funziona con qualsiasi collezione iterabile //il destructuring funziona con gli array let temperature = [ 1 , 3 , 6 , 9 , 8 , 5 , 4 , - 1 ] let [ h00 , h3 , h6 , h9 , h12 , h15 , h18 , h21 ] = temperature ; console . log ( `Temp. alle h06:00 ${ h6 } \u2103; alle h18:00 ${ h18 } \u2103` ); // Temp. alle h06:00 6\u2103; alle h18:00 $4\u2103 Posso utilizzare il destructuring per il ritorno di variabili multiple in una funzione function min_max ( vettore ) { let pos_min = 0 ; let pos_max = 0 ; //immaginiamo qui l`algoritmo che determina le //posizioni dell`elemento minimo e massimo pos_min = 3 ; pos_max = 7 ; return [ pos_min , pos_max ]; } let temperature = [ 1 , 3 , 6 , 9 , 8 , 5 , 4 , - 1 ] let [ h00 , h3 , h6 , h9 , h12 , h15 , h18 , h21 ] = temperature ; console . log ( `Temp. alle h06:00 ${ h6 } \u2103; alle h18:00 ${ h18 } \u2103` ); //Temp. alle h06:00 6\u2103; alle h18:00 4\u2103 //------------------------------------------------------------------------- let [ pos_temp_min , pos_temp_max ] = min_max ( temperature ); console . log ( `Temperatura minima alle ${ 3 * pos_temp_min } ` ); //Temperatura minima alle 9 console . log ( `Temperatura massima alle ${ 3 * pos_temp_max } ` ); //Temperatura massima alle 21 Si pu\u00f2 scavare anche dentro oggetti senza esagerare troppo let libro = { autore : { cognome : \"Alessandro\" , nome : \"Manzoni\" }, titolo : \"I promessi sposi\" , nato_a : { nome : \"Milano\" , nazione : \"Italia\" } }; let { autore : { cognome , nome }, titolo } = libro ; console . log ( cognome ); //Alessandro console . log ( nome ); //Manzoni console . log ( titolo ); //I promessi sposi let { titolo : t2 } = libro ; console . log ( t2 ); ////I promessi sposi let s = \"\" ; //questa sintassi \u00e8 per l'assegnamento ({ titolo : s } = libro ); Con gli array questo metodo dell'assegnamento \u00e8 pi\u00f9 semplice let temperature = [ 1 , 3 , 6 , 9 , 8 , 5 , 4 , - 1 ] let [ h00 , h3 , h6 , h9 , h12 , h15 , h18 , h21 ] = temperature ; console . log ( `Temp. alle h06:00 ${ h6 } \u2103; alle h18:00 ${ h18 } \u2103` ); //------------------------------------------------------------------------- let t = 0 ; [ t ] = temperature ; console . log ( t ); //1, ottengo la temperatura alla prima posizione //Estraggo il 4 elemento [,,, t ] = temperature ; //temperature[3] console . log ( t ); //9 let v = [ 1 , 2 ]; let [,, z = 0 ] = v ; console . log ( z ); //0 // in questo caso con l'operatore \"...\" (rest) creo un sottoarray con le sole temperature dalle 9 in poi let [,,,... dalle_9_in_poi ] = temperature for ( temp of dalle_9_in_poi ) console . log ( temp ); //9 8 5 4 -1 Lezione 17 Map Object L'oggetto Map \u00e8 una collezione di elementi chiave / valore . Qualsiasi valore (sia oggetti che valori primitivi) pu\u00f2 essere utilizzato come chiave o come valore. Qualche metodo applicabile all'oggetto Map : set(key, value) : Aggiunge un elemento all'oggetto Map specificando la chiave di accesso e il valore has(key) : Ritorna un boolean true/false in base al risultato della ricerca di un elemento con una particolare key . get(key) : Ritorna il valore corrispondente alla chiave key delete(key) : Elimina l'elemento con la chiave key clear() : Elimina tutto il contenuto dalla mappa Propriet\u00e0 dell'oggetto Map : size : Ritorna il numero di elementi in una mappa //Creo un nuovo oggeto Map vuoto let capitali = new Map (); //Il metodo set(key, value) aggiunge elementi indicando una coppia chiave valore capitali . set ( \"Italia\" , \"Roma\" ); capitali . set ( \"Francia\" , \"Parigi\" ); console . log ( capitali ); //Map(2) {\"Italia\" => \"Roma\", \"Francia\" => \"Parigi\"} console . log ( capitali . size ); //2 //Il punto di forza di Map \u00e8 che posso ricercare certi valori attraverso la Key nazione_richiesta = prompt ( \"Quale nazione?\" ); //Francia if ( capitali . has ( nazione_richiesta ) ){ console . log ( `La capitale \u00e8 ${ capitali . get ( nazione_richiesta ) } ` ); } //La capitale \u00e8 Parigi else { console . log ( \"Nazione non trovata\" ); } capitali . clear (); console . log ( capitali ); //Map(0) {} Posso aggiungere diversi elementi con la notazione ad array, anzi direi a Matrice visto che ogni elemento \u00e8 formato da una coppia chiave/valore //Fornisco al costruttore di Map() come parametro un oggetto iterabile let capitali = new Map ([ [ \"Italia\" , \"Roma\" ], [ \"Francia\" , \"Parigi\" ], [ \"Inghilterra\" , \"Londra\" ] ]); nazione_richiesta = prompt ( \"Quale nazione vuoi eliminare?\" ); //Se nazione_richiesta \u00e8 tra quelle specificate nell'oggetto <capitali> la eliminer\u00e0 if ( capitali . has ( nazione_richiesta ) ){ capitali . delete ( nazione_richiesta ); console . log ( ` ${ nazione_richiesta } eliminata ...` ); } else { console . log ( \"Nazione non trovata\" ); } Posso inserire qualsiasi tipo di elemento in un oggetto di tipo Map. //Creo un oggetto di tipo Map e identificativo \"listino\" vuoto let listino = new Map (); //Creo un oggetto che utilizzer\u00f2 come chiave dell'oggetto listino let prodotto = { codice : 100 , descrizione : { breve : \"bla bla\" , lunga : \"bla bla bla bla\" } } //Creo un oggetto che utilizzer\u00e0\u00ec\u00f2 come valore dell'oggetto listino let prezzo = { costo_base : 145 , sconto : 5 , metodi_pagamento : { cash : true , carta : true , paypal : false } } //Aggiungo un elemento all'oggetto listino. //Prodotto e prezzo sono due oggetti diversi listino . set ( prodotto , prezzo ); if ( listino . has ( prodotto ) ) { valore = listino . get ( prodotto ); console . log ( valore . costo_base ); //145 if ( valore . metodi_pagamento . carta ){ console . log ( \"Pagabile con carta di credito\" ); //Pagabile con carta di credito } } Iterazione Map Object Il metodo key() restituisce un iteratore sulle chiavi let capitali = new Map ([ [ \"Italia\" , \"Roma\" ], [ \"Francia\" , \"Parigi\" ], [ \"Inghilterra\" , \"Londra\" ] ]); //iterare sugli elementi for ( let elemento of capitali ) { console . log ( elemento ); } //elemento[0]=nazione, [1]=capitale /* [\"Italia\", \"Roma\"] [\"Francia\", \"Parigi\"] [\"Inghilterra\", \"Londra\"] */ //iterare sulle chiavi //key() restituisce un iteratore sulle chiavi for ( let chiave of capitali . keys ()) { console . log ( chiave ); } /* Italia Francia Inghilterra */ Esempio di iterazione applicando il destructuring: let listino = new Map (); //Chiave let prodotto = { codice : 100 , descrizione : { breve : \"bla bla\" , lunga : \"bla bla bla bla\" } } //Valore let prezzo = { costo_base : 145 , sconto : 5 , metodi_pagamento : { cash : true , carta : true , paypal : false } } listino . set ( prodotto , prezzo ); //iterare sugli elementi, applico il destructuring for ( let [ chiave , valore ] of listino ) //listino.entries()) { console . log ( chiave ); } //Restituisce prodotto /* {codice: 100, descrizione: {\u2026}} codice: 100 descrizione: {breve: \"bla bla\", lunga: \"bla bla bla bla\"} */ Lezione 18 Set L'oggetto Set permette di memorizzare valori unici di qualunque tipo, che siano valori primitivi o riferimenti ad oggetti. Gli oggetti Set sono collezioni di valori, quindi \u00e8 possibile iterare i valori nel loro ordine di inserimento. Un valore in un Set pu\u00f2 occorrere solo una volta; \u00e8 quindi unico nella collezione. A differenza di un semplice array presenta le seguenti differenze: Un oggetto Set rifiuta elementi duplicati. E' utile quindi per raggruppare elementi in una lista univoca Non consente un accesso indicizzato cio\u00e8 per posizione come negli array Non si applicano i metodi applicabili agli array ma metodi simili all'oggetto Map Vale la property size e i metodi has() e clear() , add() simili per l'oggetto Map let nazioni = new Set ([ \"Italia\" , \"Francia\" , \"Inghilterra\" ]); nazioni . add ( \"Ungheria\" ); //Metodo per aggiungere un elemento //La lista degli elementi rimane inalterata poich\u00e8 l'elemento <Francia> \u00e8 gi\u00e0 presente nazioni . add ( \"Francia\" ); for ( let nazione of nazioni ) { console . log ( nazione );} /* Italia Francia Inghilterra Ungheria */ Conversione di un Oggetto Map / Set in un Array Per la conversione di un Oggetto Map / Set in un array \u00e8 possibile sfruttare l'operatore \"...\" (rest). Questo operatore in generale si applica ad ogni elemento iterabile e restituisce un array di elementi derivati dall'iterazione sull'iteratore selezionato let nazioni = new Set ([ \"Italia\" , \"Francia\" , \"Inghilterra\" ]); nazioni . add ( \"Ungheria\" ); //Metodo per aggiungere un elemento //l'operatore \"...\" \u00e8 anche detto spread operator //In questo caso andr\u00e0 ad iterare ogni elemento di <nazioni> aggiungendolo all'array <vNazioni> let arrayNazioni = [... nazioni ]; //arrayNazioni adesso \u00e8 un array ottenuto da un oggetto Set console . log ( arrayNazioni [ 2 ]); Lezione 19 Dom Manipulation Quando programmi pagine web e app, una delle cose pi\u00f9 comuni che vorrai fare \u00e8 manipolare in qualche modo la struttura del documento. Questo di solito viene fatto utilizzando il Document Object Model (DOM), un insieme di API per il controllo dell'HTML e delle informazioni di stile che fa un uso intenso dell'oggetto Document. In questo articolo vedremo come utilizzare il DOM in dettaglio, insieme ad altre API interessanti che possono alterare il tuo ambiente in modi interessanti. I browser web sono software molto complicati con molte parti mobili, molte delle quali non possono essere controllate o manipolate da uno sviluppatore web che utilizza JavaScript. Potresti pensare che tali limitazioni siano una brutta cosa, ma i browser sono bloccati per buone ragioni, principalmente incentrate sulla sicurezza. Immagina se un sito Web potesse accedere alle tue password memorizzate o ad altre informazioni sensibili e accedere ai siti Web come se fossi tu.. Nonostante i limiti, le API Web ci danno ancora accesso a molte funzionalit\u00e0 che ci consentono di fare molte cose con le pagine web. Window \u00e8 la scheda del browser in cui viene caricata una pagina web; questo \u00e8 rappresentato in JavaScript dall'oggetto Window . Usando i metodi disponibili su questo oggetto puoi fare cose come restituire le dimensioni della finestra (vedi Window.innerWidth e Window.innerHeight ), manipolare il documento caricato in quella finestra, memorizzare i dati specifici di quel documento sul lato client (ad esempio usando un database locale o un altro meccanismo di archiviazione), collegare un gestore di eventi alla finestra corrente e altro ancora. Il navigatore rappresenta lo stato e l'identit\u00e0 del browser (ovvero lo user-agent) cos\u00ec come esiste sul web. In JavaScript, questo \u00e8 rappresentato dall'oggetto Navigator . Puoi utilizzare questo oggetto per recuperare elementi come la lingua preferita dell'utente, un flusso multimediale dalla webcam dell'utente, ecc. Il documento (rappresentato dal DOM nei browser) \u00e8 la pagina effettiva caricata nella finestra ed \u00e8 rappresentato in JavaScript dall'oggetto Document . \u00c8 possibile utilizzare questo oggetto per restituire e manipolare le informazioni sull'HTML e il CSS che compongono il documento, ad esempio ottenere un riferimento a un elemento nel DOM , modificarne il contenuto del testo, applicarvi nuovi stili, creare nuovi elementi e aggiungerli a l'elemento corrente come figli, o addirittura eliminarlo del tutto. In questo articolo ci concentreremo principalmente sulla manipolazione del DOM. DOM - Document Object Model Il documento attualmente caricato in ciascuna delle schede del browser \u00e8 rappresentato da un modello di oggetti (document object model). E' rappresentato tramita una \"struttura ad albero\" creata dal browser che consente di accedere facilmente alla struttura HTML dai linguaggi di programmazione. Fonte: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents Per la manipolazione del DOM ci torna utile il paradigma di programmazione orientato agli oggetti di Javascript. Infatti il DOM non \u00e8 altro che un enorme oggetto con diverse property e metodi console . log ( document . all ); //stampa tutti i nodi all'interno della pagina htmlconsole.log(document.body); console . log ( document . head ); //Stampa l'oggetto <head> console . log ( document . body ); //Stampa l'oggetto <body> Lezione 20 DOM - Selettori Per manipolare un elemento all'interno del DOM, \u00e8 necessario prima selezionarlo e memorizzare un riferimento ad esso all'interno di una variabile. In questo esempio selezioneremo l'elemento h1 e successivamente applicheremo dello style all'elemento, colorandolo di rosso <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > DOM: Document Object Model </ h1 > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > let h1 = document . querySelector ( \"h1\" ); h1 . style . color = 'red' ; </ script > </ body > </ html > Metodi di selezione di elementi html Vediamo i metodi per selezionare gli elementi in JS. - document.getElementById(myID) : Selziona tutti gli elementi con un particolare id = \"myID\" - document.getElementsByClassName(myClassName) : Selziona tutti gli elementi che appartengono a una particolare classe, class = \"myClassName\" - document.getElementsByTagName(\"tag\") : Selziona tutti gli elementi che hanno particolare \"tag\" HTML - document.querySelector(any) : Selziona la prima occorrenza dell' elemento spcecificato attraverso la classe , l' id oppure il tag . - Selezione attraverso la classe: Si usa il simbolo \".\" seguito dal nome della classe, esempio: \".myClassName\" - Selezione attraverso l'id: Si usa il simbolo \"#\" seguito dal nome della classe, esempio: \"#myID\" - Selezione attraverso il tag HTML: \"h1\" - document.querySelectorAll : Selziona tutti gli elementi spcecificati attraverso la classe , l' id oppure il tag . Valgono le stesse regole di selezione viste per il querySelector <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < h1 > La manipolazione </ h1 > < ul > < li id = \"FRIST-ELEM\" > elemento UNO </ li > < li class = \"myClass\" > elemento DUE </ li > < li class = \"myClass\" > elemento TRE </ li > </ ul > < script > document . getElementById ( \"FRIST-ELEM\" ); //Selezione di \"elemento UNO\" document . getElementsByClassName ( \"myClass\" ); //Selezione di \"elemento DUE\", \"elemento TRE\" document . getElementsByClassName ( \"myClass\" )[ 0 ]; //Selezione di \"elemento DUE\" document . getElementsByTagName ( \"h1\" ); //Selezione di \"DOM: Document Object Manipulation\", \"La manipolazione\" // document.querySelector document . querySelector ( \".myClass\" ); //Selezione di \"elemento DUE\" document . querySelector ( \"#FRIST-ELEM\" ); //Selezione di \"elemento UNO\" document . querySelector ( \"h1\" ); //Selezione di \"DOM: Document Object Manipulation\" // document.querySelectorAll document . querySelectorAll ( \".myClass\" ); //Selezione di \"elemento DUE\", \"elemento TRE\" document . querySelectorAll ( \"#FRIST-ELEM\" ); //Selezione di \"elemento UNO\" document . querySelectorAll ( \"h1\" ); ////Selezione di \"DOM: Document Object Manipulation\", \"La manipolazione\" //last-child & nth-child(i) document . querySelector ( 'li:last-child' ); //li:last-child seleziona l'ultimo elemento <li> document . querySelector ( 'li:nth-child(2)' ). style . color = 'brown' ; //li:nth-child(i) seleziona l'i-esimo elemento <li> </ script > </ body > </ html > E' possibile utilizzare l'operatore [index] per indicizzare la collezione di elementi HTML selezionati. Nell'esempio di sopra infatti ho selezionato soltanto \"elemento DUE\" utilizzando document.getElementsByClassName(\"myClass\")[0] . Quando ci sono pi\u00f9 elementi selezionati vengono create delle collezioni di oggetti. Nel caso si utilizzi querySelectorAll verr\u00e0 restituita una collezione NodeList che dal punto di vista di Javascript \u00e8 un array. Se tuttavia utilizzassi come selettore ad esempio getElementsByTagName verrebbe restituito un HTML Collection che non \u00e8 un array e se volessi usarlo come tale sarebbe necessaria una conversione let myLI = document . querySelectorAll ( \"li\" )[ 0 ]; /* myLI <li id=\u200b\"FRIST-ELEM\">\u200b\u2026\u200b</li>\u200b */ console . log ( typeof myLI ); //object //NODE LIST let myLIAll = document . querySelectorAll ( \"li\" ); console . log ( myLIAll ); //\u00e8 una collezione \"NodeList\", un array /* NodeList(3) [li#FRIST-ELEM, li.myClass, li.myClass] 0: li#FRIST-ELEM 1: li.myClass 2: li.myClass length: 3 __proto__: NodeList */ //Essendo un array posso applicare tutti i metodi applicabili agli array myLIAll . forEach (( elem , index ) => { //il metodo \"textContent\" assegna un valore testuale all'elemento, cambia il testo elem . textContent = 'nuovo testo in li' ; }); //HTML COLLECTION let MyH1All = document . getElementsByTagName ( \"h1\" ); console . log ( MyH1All ); //HTMLCollection(2) [h1, h1] -> NON E' UN ARRAY, Attenzione!! //Posso convertirlo in array utilizzando \"Array.from\" const listaArray = Array . from ( MyH1All ); console . log ( listaArray ); /* (2) [h1, h1] 0: h1 1: h1 length: 2 */ //A questo punto posso utilizzare tutte le propriet\u00e0 degli array listaArray . forEach (( elem , index ) => { elem . style . color = 'red' ; }); //Posso usare anche un ciclo iterativo standard for ( let i = 0 ; i < listaArray . length ; i += 2 ) { //Cambia il colore del background dell'elemento <h1> in giallo listaArray [ i ]. style . background = 'yellow' ; } Lezione 21 Dom - Child e Parent Data la struttura ad albero del DOM \u00e8 semplificato l'accesso ad elementi figli o padri di un dato elemento children : Accede agli elementi figli parentElement : Accede all'elemento padre <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < h1 > La manipolazione </ h1 > < ul > < li id = \"FRIST-ELEM\" > elemento UNO </ li > < li class = \"myClass\" > elemento DUE </ li > < li class = \"myClass\" > elemento TRE </ li > </ ul > < script > const ul = document . querySelector ( 'ul' ); //rappresenta tutti gli <li> contenuti come HTML collection console . log ( ul . children ); //HTMLCollection(3) [li#FRIST-ELEM, li.myClass, li.myClass, FRIST-ELEM: li#FRIST-ELEM] console . log ( ul . parentElement ); //Seleziona l'elemento parente quindi il <body> console . log ( ul . parentElement . parentElement ); //Seleziona l'elemento <html> cio\u00e8 il \"nonno\" //Rappresenta i figli in una NodeList (ottimo) ma considera come elementi anche eventuali elementi di formatazione //Poich\u00e8 gli <li> sono rappresentati a capo, uno sotto l'altro ci sono altri 4 elementi che rappresentano l'elemento \"a capo\" console . log ( ul . childNodes ); //NodeList(7) [text, li#FRIST-ELEM, text, li.myClass, text, li.myClass, text] </ script > </ body > </ html > DOM - Manipolazione dello stile degli elementi html La manipolazione statica dello stile degli elementi HTML non ha molto senso. Infatti \u00e8 possibile assegnare uno stile gi\u00e0 con CSS. Ha invece senso una manipolazione dinamica ovvero al verificarsi di un particolare evento classList permette di applicare dinamicamente una classe gi\u00e0 definita in formato CSS ma ancora non applicata a nessun elemento. Javascript funziona da ponte tra un elemento HTML e uno style CSS. E' infatti possibile aggiungere e rimuovere dinamicamente una classe da un elemento per aggiungere o rimuovere dello stile da quel dato elemento. classList.add(\"myClassName\") : Aggiunge la classe myClassName all'elemento selezionato classList.remove(\"myClassName\") : Rimuove la classe myClassName all'elemento selezionato classList.toggle(\"myClassName\") : Esegue il toggle della classe myClassName all'elemento selezionato, aggiungendola se non \u00e8 attiva e rimuovendola se \u00e8 attiva. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeFirstLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < h1 > La manipolazione </ h1 > < ul > < li id = \"FRIST-ELEM\" > elemento UNO </ li > < li class = \"myClass\" > elemento DUE </ li > < li class = \"myClass\" > elemento TRE </ li > </ ul > < script > var tag = document . getElementById ( \"FRIST-ELEM\" ); //Aggiungo la classe <classeFirstLi> all'elemento html associato a <tag>. //Aggiungo quindi anche tutte le proprit\u00e0 annesse alla classe <classeFirstLi>. tag . classList . add ( \"classeFirstLi\" ); //Applico lo stile all'elemento \"elemento UNO\" //Rimuovo la classe <classeFirstLi> tag . classList . remove ( \"classeFirstLi\" ); //Rimuovo lo stile all'elemento \"elemento UNO\" //Toggle della classe <classeFirstLi>. // Rimuovo la classe <classeFirstLi> se \u00e8 attiva, la aggiungo se non \u00e8 attiva tag . classList . toggle ( \"classeFirstLi\" ); //Applico lo stile all'elemento \"elemento UNO\" tag . classList . toggle ( \"classeFirstLi\" ); //Rimuovo lo stile all'elemento \"elemento UNO\" tag . classList . toggle ( \"classeFirstLi\" ); //Applico lo stile all'elemento \"elemento UNO\" </ script > </ body > </ html > Lezione 22 DOM - Manipolazione del testo degli elementi html textContent La propriet\u00e0 textContent dell'interfaccia Node rappresenta il contenuto del testo di un nodo e dei suoi discendenti innerText La propriet\u00e0 innerText dell'interfaccia HTMLElement rappresenta il contenuto di testo \"renderizzato\" di un nodo e dei suoi discendenti. Come getter, approssima il testo che l'utente otterrebbe se evidenziasse il contenuto dell'elemento con il cursore e poi lo copiasse negli appunti. Nota: innerText \u00e8 facilmente confuso con Node.textContent , ma ci sono differenze importanti tra i due. Fondamentalmente, innerText \u00e8 a conoscenza dell'aspetto renderizzato del testo, mentre textContent non lo \u00e8. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeFirstLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < p > Lorem ipsum, dolor sit amet consectetur adipisicing elit. < strong > Doloremque, modi? </ strong ></ p > < script > var p = document . querySelector ( \"p\" ); //<textContent> //<textContent> restituisce una stringa del testo contenuto dell'elemento // convertendo anche il contenuto di eventuali elementi figli in puro testo console . log ( p . textContent ); //\"Lorem ipsum, dolor sit amet consectetur adipisicing elit. Doloremque, modi?\" //E' possibile cambiare la stringa del tag selezionato semplicemente con l'assegnazione p . textContent = \"lorem ps htigh manulip ase travit\" ; console . log ( p . textContent ); //\"lorem ps htigh manulip ase travit\" //<innerHTML> //<innerHTML> restituisce l'elemento HTML mantenendo la formattazione HTML console . log ( p . innerHTML ); //\"Lorem ipsum, dolor sit amet consectetur adipisicing elit. <strong>Doloremque, modi?</strong>\" //Con <innerHTML> \u00e8 possibile inserire tag HTML p . innerHTML = \"<strong>ciao</strong>\" ; console . log ( p . innerHTML ); //<strong>ciao</strong>\" </ script > </ body > </ html > DOM - Manipolazione degli attributi html getAttribute e setAttribute sono metodi di lettura e scrittura di attributi di elementi html. getAttribute ( \"attribute\" ); //ritorna il valore dell'attributo \"attribute\" setAttribute ( \"attribute\" , \"value\" ); //Assegna il valore \"value\" all'attributo \"attribute\" Nell'esempio seguente cambier\u00f2 l'immagine di un elemento <img> e il link di un elemento <a> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeFirstLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < div > < img src = \"https://www.corriere.it/methode_image/2020/04/09/Spettacoli/Foto%20Spettacoli%20-%20Trattate/MILANO_20100328_CORSERA_43_0_0-k9PF-U3180411917161aAH-656x492@Corriere-Web-Sezioni.jpg\" > </ div > < div > < a href = \"https://www.google.com/maps\" > link </ a > </ div > < script > //Modifico l'immagine modificandone l'attributo <src> //Seleziono l'elemento \"img\" var img = document . querySelector ( \"img\" ); //<getAttribute(\"attribute\")> restituisce il valore dell'attributo passato come argomento. img . getAttribute ( \"src\" ); // \"https://www.corriere.it/methode_image/2020/04/09/Spettacoli/Foto%20Spettacoli%20-%20Trattate/MILANO_20100328_CORSERA_43_0_0-k9PF-U3180411917161aAH-656x492@Corriere-Web-Sezioni.jpg\" //<setAttribute(\"attribute\", \"value\")> consente di cambiare il valore di un attributo img . setAttribute ( \"src\" , \"https://www.pensalibero.it/wp-content/uploads/2010/02/chopin1.jpg\" ); //ho cambiato l'immagine img . getAttribute ( \"src\" ); //https://www.pensalibero.it/wp-content/uploads/2010/02/chopin1.jpg //Modifico il link, modificandone l'attributo <href> //Seleziono l'elemento \"a\" var a = document . querySelector ( \"a\" ); //<getAttribute(\"attribute\")> restituisce il valore dell'attributo passato come argomento. a . getAttribute ( \"href\" ); //\"https://www.google.com/maps\" //<setAttribute(\"attribute\", \"value\")> consente di cambiare il valore di un attributo a . setAttribute ( \"href\" , \"https://mail.google.com\" ); //Ho cambiato il link a . getAttribute ( \"href\" ); //\"https://mail.google.com\" </ script > </ body > </ html > Lezione 23 DOM - Creazione di Un elemento In un documento HTML, il metodo document.createElement() crea l'elemento HTML specificato da tagName o un HTMLUnknownElement se tagName non viene riconosciuto. Nell'esempio successivo creeremo un elemento <li> e lo piazzeremo in coda ad una <ul> gi\u00e0 esistente. Faremo uso anche del metodo appendChild() e del metodo createTextNode() Il metodo Node.appendChild() aggiunge un nodo alla fine dell'elenco di figli di un nodo genitore specificato. Se il figlio dato \u00e8 un riferimento a un nodo esistente nel documento, appendChild() lo sposta dalla sua posizione corrente alla nuova posizione (non \u00e8 necessario rimuovere il nodo dal suo nodo padre prima di aggiungerlo ad un altro nodo). A questo link c'\u00e8 un'importante discussione tra l'uso di createTextNode() e textContent : https://stackoverflow.com/questions/31643204/textnode-or-textcontent <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < script > //creo un elemento <li> vuoto const myLi = document . createElement ( 'li' ); console . log ( myLi ); //<li></li> //Inserisco del testo nell'elemento <li> myLi . textContent = 'Elemento QUATTRO' ; console . log ( myLi ); //<li><Elemento QUATTRO/li> //Aggiungo in coda l'elemento <li> a <ul> document . querySelector ( 'ul' ). appendChild ( myLi ); //Aggiungo una classe.. e lo stile annesso myLi . className = \"classeLastLi\" ; </ script > </ body > </ html > DOM - Rimpiazzo di un elemento Il metodo Node.replaceChild () sostituisce un nodo figlio all'interno del nodo (genitore) specificato. Notare l'ordine degli argomenti idiosincratico (nuovo prima del vecchio). ChildNode.replaceWith () potrebbe essere pi\u00f9 facile da leggere e utilizzare. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < script > //Creo un nuovo <li> const nuovoLi = document . createElement ( 'li' ); //Aggiungo del testo dentro <li> nuovoLi . appendChild ( document . createTextNode ( 'nuovo li' )); // equivale a \"nuovoLi.textContent = 'nuovo li';\" //Seleziono l'elemento che voglio rimpiazzare const vecchioLi = document . getElementsByTagName ( 'li' )[ 1 ]; //Selziono l'elemento padre dell'elemento che voglio rimpiazzare */ const ul = document . querySelector ( 'ul' ); //replaceChild(new,old) permette di rimpiazzare un elemento figlio //specificando come parametri il nuovo elemento e il vecchio elemento (quello da rimpiazzare) ul . replaceChild ( nuovoLi , vecchioLi ); </ script > </ body > </ html > DOM - ELiminazione di un elemento Il metodo Node.removeChild () rimuove un nodo figlio dal DOM e restituisce il nodo rimosso. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < script > /** Si possono cancellare i figli attraverso il padre */ /** Seleziono il padre */ const ulParent = document . querySelector ( 'ul' ); /** Seleziono tutti gli <li> e li metto in un contenitore che sar\u00e0 un array di <li> */ const listitem = document . querySelectorAll ( 'li' ); console . log ( listitem ); ulParent . removeChild ( listitem [ 2 ]); //rimuovo \"Elemento TRE\" //Rimuove tutti gli elementi <child> //La property <firstChild> restituisce il primo elemento \"child\" e \"null\" se non ci sono elementi child while ( ulParent . firstElementChild ){ ulParent . removeChild ( ulParent . firstElementChild ); } </ script > </ body > </ html > Property firstChild : La propriet\u00e0 di sola lettura Node.firstChild restituisce il primo figlio del nodo nell'albero o null se il nodo non ha figli. Se il nodo \u00e8 un documento, restituisce il primo nodo nell'elenco dei suoi figli diretti. Lezione 24 DOM Events Vengono trasmessi eventi per notificare al codice eventi accaduti. Ogni evento \u00e8 rappresentato da un oggetto basato su un 'interfaccia Event e pu\u00f2 avere campi e / o funzioni personalizzati aggiuntivi utilizzati per ottenere ulteriori informazioni su quanto accaduto. Gli eventi possono rappresentare qualsiasi cosa, dalle interazioni utente di base alle notifiche automatiche di eventi che accadono nel modello di rendering. Alla pagina: https://developer.mozilla.org/en-US/docs/Web/Events E' possibile consultare i cos\u00ecdetti Standard Events , eventi comuni ad ogni tipo di browser definiti dalla specifica standard Web. Metodo addEventListener Il metodo EventTarget addEventListener() imposta una funzione che verr\u00e0 chiamata ogni volta che l'evento specificato viene consegnato all'elemento di destinazione. I target comuni sono Element, Document, e Window, ma la destinazione pu\u00f2 essere qualsiasi oggetto che supporti eventi (come XMLHttpRequest). addEventListener() funziona aggiungendo una funzione o un oggetto che implementa EventListener all'elenco di listener di eventi per il tipo di evento specificato sul EventTarget sul quale \u00e8 chiamato. target . addEventListener ( type , listener [, options ]); Parametri: - type : Una stringa sensibile al maiuscolo/minuscolo che rappresenta il tipo di evento da assegnare. Alcuni tipi di eventi, click , dblclick , cut , scroll , compositionstart , blur .. - listener : L'oggetto che riceve una notifica (un oggetto che implementa l'interfaccia Event) quando si verifica un evento del tipo specificato. Questo deve essere un oggetto che implementa l'interfaccia EventListener, o una funzione. Vedi Il callback del listener di eventi per i dettagli sul callback stesso. Fonte: https://developer.mozilla.org/it/docs/Web/API/Element/addEventListener#Il_callback_del_listener_di_eventi Vedremo qualche evento attraverso gli esempi: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input id = \"changeColor\" type = \"button\" value = \"OK\" > < script > var input = document . querySelector ( \"#changeColor\" ); //Seleziono il primo <li> var ulChild = document . querySelector ( \"ul\" ). firstElementChild ; //addEventListener(\"eventType\", function) //aggiunge un evento all'elemento <input>. //Al click del mouse sull'elemento <input> viene eseguita la funzione anonima //che in questo caso esegue il toggle della classe \"classeLi\" sul primo elemento <li> input . addEventListener ( \"click\" , function (){ ulChild . classList . toggle ( \"classeLi\" ); }) </ script > </ body > </ html > Vediamo un esempio pi\u00f9 interessante. In questo esempio assegneremo lo stile agli elementi <li> ogni volta che schiacceremo il tasto OK a partire dal primo elemento. Una volta che lo stile \u00e8 applicato a tutti gli elementi, schiacciando nuovamente il tasto andremo a togliere lo stile a tutti gli elementi partendo dal primo. Per applicare e togliere stile utilizzeremo classList.toggle(\"myClassName) gi\u00e0 visto qualche lezione fa. Utilizzeremo anche firstElementChild gi\u00e0 visto e nextElementSibling che restituisce l'elemento successivo a quello attualmente puntato dal figlio. nextElementSibling La propriet\u00e0 di sola lettura NonDocumentTypeChildNode.nextElementSibling restituisce l'elemento immediatamente successivo a quello specificato nell'elenco dei figli del suo genitore o null se l'elemento specificato \u00e8 l'ultimo nell'elenco. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input id = \"changeColor\" type = \"button\" value = \"OK\" > < script > var input = document . querySelector ( \"#changeColor\" ); var ulChild = document . querySelector ( \"ul\" ). firstElementChild ; input . addEventListener ( \"click\" , function (){ if ( ulChild !== null ){ ulChild . classList . toggle ( \"classeLastLi\" ); ulChild = ulChild . nextElementSibling ; } else { ulChild = document . querySelector ( \"ul\" ). firstElementChild ; ulChild . classList . toggle ( \"classeLastLi\" ); ulChild = ulChild . nextElementSibling ; } }) </ script > </ body > </ html > Non \u00e8 necessario schiacciare elementi <input type=\"button\"> . Possono essere utilizzati tutti gli elementi html. In questo esempio associeremo un evento ad ogni elemento <li> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input id = \"changeColor\" type = \"button\" value = \"OK\" > < script > //Seleziono tutti i <li> var listaLi = document . querySelectorAll ( \"li\" ); console . log ( listaLi ); //creo un array di <li> //Itero su ogni <li> for ( var i = 0 ; i < listaLi . length ; i ++ ){ //aggiungo un evento ad ogni li. Premendo sull'elemento <li> si applicher\u00e0/toglier\u00e0 lo style definito da \"classeLastLi\" listaLi [ i ]. addEventListener ( \"click\" , function (){ this . classList . toggle ( \"classeLastLi\" ); }) } </ script > </ body > </ html > this: this in questo caso rappresenta l'elemento i-esimo a cui \u00e8 posizionato il listener cio\u00e8 listaLi[i] . Oltre alla funzione anonima, posso definire anche una funzione esterna al verificarsi di un certo evento. In questo esempio cambieremo il testo al Titolo con un testo inserito dall'utente in una casella testuale <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input type = \"text\" id = \"newTitle\" > < input id = \"changeTitle\" type = \"button\" value = \"Cambia Titolo\" > < script > var input = document . querySelector ( \"#changeTitle\" ); var h1 = document . querySelector ( \"h1\" ); function changeTitle () { testo = document . querySelector ( \"#newTitle\" ); h1 . textContent = testo . value ; } input . addEventListener ( \"click\" , changeTitle ); </ script > </ body > </ html > Nel prossimo esempio avremo una casella di testo in cui sar\u00e0 possibile inserire del testo. Facendo doppio click su un elemento qualsiasi della pagina html andr\u00e0 a cambiare il testo dell'elemento cliccato <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input type = \"text\" id = \"newTitle\" > < script > var listaLI = document . querySelectorAll ( \"li\" ); //crea un array di <li> var h1 = document . querySelector ( \"h1\" ); //seleziono <h1> function changeText () { testo = document . querySelector ( \"#newTitle\" ); this . textContent = testo . value ; this . cla } for ( let i = 0 ; i < listaLI . length ; i ++ ){ listaLI [ i ]. addEventListener ( \"dblclick\" , changeText ); } h1 . addEventListener ( \"dblclick\" , changeText ); </ script > </ body > </ html > Lezione 25 Prevent Default Il metodo preventDefault () dell'interfaccia Event dice al programma utente che se l'evento non viene gestito esplicitamente, la sua azione predefinita non dovrebbe essere eseguita come sarebbe normalmente. L'evento continua a propagarsi come al solito, a meno che uno dei suoi listener di eventi non chiami stopPropagation () o stopImmediatePropagation () , entrambi i quali terminano immediatamente la propagazione. Fonte: https://developer.mozilla.org/it/docs/Web/API/Event/preventDefault Consideriamo il seguente esempio. Al click di ogni link vorrei che venisse stampato per esteso il link nella casella testuale. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > li { margin : 2 px ; } input { margin : 2 px ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > < a href = \"https://www.youtube.com/\" > youtube </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://developer.mozilla.org/en-US/\" > MDN </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://www.google.com/maps\" > maps </ a >< br > < input type = \"text\" > </ li > </ ul > < script > var linkList = document . querySelectorAll ( \"a\" ); for ( let i = 0 ; i < linkList . length ; i ++ ) { linkList [ i ]. addEventListener ( \"click\" , function (){ //this rappresenta l'elemento <a> i-esimo //this.parentElement === <li> //this.parentElement.lastElementChild === <input> input = this . parentElement . lastElementChild ; input . value = this . href ; }); } </ script > </ body > </ html > Se avete provato ad eseguire il codice noterete che al click sull'elemento <a> , la pagina verr\u00e0 rendirizzata sul link corrispondente, in poche parole non funziona. Questo accade perch\u00e8 il comportamento di default di <a> tag \u00e8 quello di saltare alla pagina specificata dall'attributo href . Per inibire il comportamento di default di qualsiasi elemento si utilizza il metodo prevenDefault() applicato all'oggetto ricevuto come parametro (opzionale) dal listener. Normalmente questo oggetto viene indicato con e . Qui sotto riporto l'esempio funzionante. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > li { margin : 2 px ; } input { margin : 2 px ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > < a href = \"https://www.youtube.com/\" > youtube </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://developer.mozilla.org/en-US/\" > MDN </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://www.google.com/maps\" > maps </ a >< br > < input type = \"text\" > </ li > </ ul > < script > var linkList = document . querySelectorAll ( \"a\" ); for ( let i = 0 ; i < linkList . length ; i ++ ) { linkList [ i ]. addEventListener ( \"click\" , function ( e ){ //this rappresenta l'elemento <a> i-esimo //this.parentElement === <li> //this.parentElement.lastElementChild === <input> input = this . parentElement . lastElementChild ; input . value = this . href ; e . preventDefault (); }); } </ script > </ body > </ html > Che cos'\u00e8 esattamente l'oggetto ricevuto come unico parametro \"e\"? L'interfaccia Event (oggetto \"e\") I gestori degli eventi possono essere assegnati a vari elementi DOM. Quando un dato evento si verifica, un oggetto evento viene creato dinamicamente e passato agli event listener che permettono di gestirlo. L'interfaccia Event del DOM \u00e8 quindi accessibile dalla funzione che gestisce l'evento, alla quale viene passato un oggetto evento come primo e unico argomento ( e ). Fonte: https://developer.mozilla.org/en-US/docs/Web/API/Event //.. console . log ( e ); /** MouseEvent {isTrusted: true, screenX: 196, screenY: 208, clientX: 196, clientY: 105, \u2026} altKey: falsebubbles: truebutton: 0buttons: 0cancelBubble: falsecancelable: trueclientX: 196clientY: 105composed: truectrlKey: falsecurrentTarget: nulldefaultPrevented: falsedetail: 1eventPhase: 0fromElement: nullisTrusted: truelayerX: 196layerY: 105metaKey: falsemovementX: 0movementY: 0offsetX: 149offsetY: 12pageX: 196pageY: 105path: (8) [a, li#ciao.myClass, ul, div, body, html, document, Window]relatedTarget: nullreturnValue: truescreenX: 196screenY: 208shiftKey: falsesourceCapabilities: InputDeviceCapabilities {firesTouchEvents: false}srcElement: atarget: atimeStamp: 125025.42499999981toElement: atype: \"click\"view: Window {window: Window, self: Window, document: document, name: \"\", location: Location, \u2026}which: 1x: 196y: 105__proto__: MouseEvent */ L'oggetto \"Event\" fornisce un sacco di informazioni sulla natura dell'evento scatenato. Al sito: https://developer.mozilla.org/it/docs/Web/API/Event \u00e8 possibile visionare ogni propriet\u00e0 e ogni metodo dell'oggetto Event (e) Lezione 26 Approfondimento type event Vediamo adesso un'insieme di eventi typeEvent mouse/tastiera tra i pi\u00f9 usati. Ricordo che typeEvent \u00e8 il primo parametro del metodo addEventListener() La lista completa la troviamo al link: https://developer.mozilla.org/it/docs/Web/API/Element HTMLelement . addEventListener ( 'typeEvent' , function (){ //code }); Eventi mouse mousedown : Scatta l'evento al click del mouse sull'elemento mouseup : Scatta l'evento al rilascio del click del mouse sull'elemento mouseover : Scatta l'evento passando sopra l'elemento con il mouse mouseout : Scatta l'evento non appena esco dal campo dall'elemento con il mouse mousemove : Scatta l'evento ogni volta che mi muovo all'interno dell'elemento con il mouse Nell'esempio successivo, utilizzer\u00f2 gli eventi mousemove , mouseout e le propriet\u00e0 offsetX , offsetY dell'oggetto Event passato come argomento al listener utilizzate per restituire la posizione X/Y dell'evento scatenato. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . colorRed { color : red ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < div > < textarea id = \"textAreaEvent\" cols = \"60\" rows = \"30\" > Muovi il mouse all'interno di quest'area </ textarea > < div > < table > < tr > < td > Pos-x: </ td > < td >< input id = \"pos-X\" type = \"text\" ></ td > </ tr > < tr > < td > Pos-y: </ td > < td >< input id = \"pos-Y\" type = \"text\" ></ td > </ tr > </ table > </ div > </ div > < script > var textAreaEvent = document . querySelector ( \"#textAreaEvent\" ); var posX = document . querySelector ( \"#pos-X\" ); var posY = document . querySelector ( \"#pos-Y\" ); textAreaEvent . addEventListener ( \"mousemove\" , function ( e ){ posX . value = e . offsetX ; posY . value = e . offsetY ; posX . classList . remove ( \"colorRed\" ) posY . classList . remove ( \"colorRed\" ) }) textAreaEvent . addEventListener ( \"mouseout\" , function () { posX . classList . add ( \"colorRed\" ) posY . classList . add ( \"colorRed\" ) }) </ script > </ body > </ html > Finch\u00e8 il mouse si muove all'interno della textarea scatter\u00e0 l'evento mousemove che restituir\u00e0 posizione X/Y del mouse. Non appena si esce da textarea scatter\u00e0 l'evento mouseout colorando di rosso il valore della posizione X/Y. Aprrofondimento eventi tastiera e input File html < body > < h3 > evento JS </ h3 > < div > < p > Lorem ipsum, dolor sit amet consectetur adipisicing elit. < strong > Doloremque, modi? </ strong ></ p > < ul > <!-- #region Importante mettere '#' come valore di href perch\u00e8 evita il comportamento di default del link che come ricordiamo tenderebbe a raggiungere il link specificato da href ma nel caso di un bottone premuto voglio stabilirlo io cosa deve accadere--> < li id = \"ciao\" class = \"myClass\" > elemento UNO < a href = \"#\" > click me </ a ></ li > < li class = \"classe\" > elemento DUE </ li > < li class = \"classe\" > elemento TRE </ li > </ ul > < form id = 'form' action = \"\" > < input id = 'input' type = \"text\" > </ form > </ div > < script src = \"08_mainDOM.js\" ></ script > </ body > </ html > Eventi Tastiera 'keydown': genera un evento alla pressione di ogni tasto digitato 'keyup': genera un evento al rilascio di ogni tasto digitato 'keypress': genera un evento alla pressione di ogni tasto digitato (alcuni tasti speciali non sono considerati) 'focus': genera un evento quando aziono il focus sull'elemento (spesso equivale al click) 'blur': genera un evento quando esco dalla zona di focus dell'elemento 'copy': genera un evento al comando \"ctrl + c\", copia 'paste': genera un evento al comando \"ctrl + v\", incolla L'esempio seguente permette di contare il numero di tasti premuti di due caselle di input \"Nome\" e \"Cognome\" visualizzando il conteggio in una casella testuale \"Tasti Premuti\". Il conteggio si azzera con il focus sulla casella testuale \"Tasti Premuti\". Appare un alert con la scritta \"Non \u00e8 possibile usare la funzione copia!\" quando si tenta di eseguire il comando Ctrl + c (copia) all'interno della casella \"Nome\" o \"Cognome\". Inoltre, abbandonando il focus sulle caselle di input \"Nome\" o \"Cognome\" il testo digitato si colorer\u00e0 di rosso ma non appena torneremo alla digitazione il testo torner\u00e0 di colore nero. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . colorRed { color : red ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < table > < tr > < td > Tasti Premuti: </ td > < td >< input type = \"text\" id = \"pressed-key\" ></ td > </ tr > < tr > < td > Nome: </ td > < td >< input type = \"text\" id = \"name\" ></ td > </ tr > < tr > < td > Cognome: </ td > < td >< input type = \"text\" id = \"cognome\" ></ td > </ tr > </ table > < script > var form = [ document . querySelector ( \"#name\" ), document . querySelector ( \"#cognome\" )] var textPressedKey = document . querySelector ( \"#pressed-key\" ); Tasti Premuti var charInserted = 0 ; //alla pressione di un tasto nei campi \"Nome\" e \"Cognome\" verr\u00e0 aggiornato il conteggio dei caratteri //totali inseriti e tolto lo stile all' elemento che ha scatenato l'evento rimuovendo la classe \"colorRed\" function pressedKey (){ textPressedKey . value = String ( ++ charInserted ); this . classList . remove ( \"colorRed\" ); } //quando viene lasciato il focus dall'elemento viene aggiunto lo stile tramite la classe \"colorRed\" function changeColor (){ this . classList . add ( \"colorRed\" ); } //quando si tenta di lanciare il comando \"copia\" dai campi \"Nome\" e \"Cognome\" si genera un alert di errore function printErrorCopyMessage () { alert ( \"Non \u00e8 possibile usare la funzione copia!\" ); } //quando sposto il focus sull'elemento \"Tasti Premuti\" azzero il conteggio textPressedKey . addEventListener ( \"focus\" , function () { charInserted = 0 ; textPressedKey . value = String ( charInserted ); }) //Aggiungo eventi ai campi \"Nome\" e \"Cognome\" for ( elem of form ){ elem . addEventListener ( \"keydown\" , pressedKey ); elem . addEventListener ( \"blur\" , changeColor ); elem . addEventListener ( \"copy\" , printErrorCopyMessage ); } </ script > </ body > </ html > Lezione 27 Argomeni non trattati / da approfondire Typed Array : Gli array tipizzati JavaScript sono oggetti simili a array che forniscono un meccanismo per leggere e scrivere dati binari grezzi nei buffer di memoria. Come forse gi\u00e0 saprai, gli oggetti Array crescono e si riducono dinamicamente e possono avere qualsiasi valore JavaScript. I motori JavaScript eseguono ottimizzazioni in modo che questi array siano veloci. Utile per curare aspetti delicati come l'Endianess. Fonte: MDN - Typed Array Endianess. In informatica, endianness \u00e8 l'ordine o la sequenza di byte di una parola di dati digitali nella memoria del computer. L'Endianness \u00e8 principalmente espresso come big-endian (BE) o little-endian (LE) . Un sistema big-endian memorizza il byte pi\u00f9 significativo di una parola all'indirizzo di memoria pi\u00f9 piccolo e il byte meno significativo al pi\u00f9 grande. Un sistema little-endian, al contrario, memorizza il byte meno significativo all'indirizzo pi\u00f9 piccolo.L'Endianness pu\u00f2 anche essere usato per descrivere l'ordine in cui i bit vengono trasmessi su un canale di comunicazione, ad esempio, il big-endian in un canale di comunicazione trasmette prima i bit pi\u00f9 significativi. Il bit-endianness \u00e8 usato raramente in altri contesti. I protocolli Internet come TCP e IPV4 utilizzano lo schema little endian mentre i processori Intel utilizzano spesso la notazione big endian . Questo \u00e8 un problema reale da conoscere saper gestire Fonte: Wikipedia - Endianess Regular Expression Le espressioni regolari sono schemi usati per confrontare combinazioni di caratteri nelle stringhe. In JavaScript, le espressioni regolari sono anche oggetti. Questi pattern sono usati con i metodi exec() e test() della classe RegExp , e con i metodi match() , matchAll() , replace() , search() , e split() della classe String . Fonte: MDN - Espressioni_Regolari Moduli Fonte: MDN - JavaScript modules Eventi/Manipolazione DOM (programmazione asincrona, promis) Dom Manipulation Quando scrivi pagine web e app, una delle cose pi\u00f9 comuni che vorrai fare \u00e8 manipolare in qualche modo la struttura del documento. Questo di solito viene fatto utilizzando il Document Object Model (DOM), un insieme di API per il controllo dell'HTML e delle informazioni di stile che fa un uso intenso dell'oggetto Document. In questo articolo vedremo come utilizzare il DOM in dettaglio, insieme ad alcune altre API interessanti che possono alterare il tuo ambiente in modi interessanti. Fonte: MDN - Manipulating documents Javascript async function Una funzione asincrona \u00e8 una funzione dichiarata con la parola chiave asincrona. Le funzioni asincrone sono istanze del costruttore AsyncFunction e al loro interno \u00e8 consentita la parola chiave await. Le parole chiave async e await consentono di scrivere un comportamento asincrono basato sulla promessa in uno stile pi\u00f9 pulito, evitando la necessit\u00e0 di configurare esplicitamente catene di promesse. Fonte: MDN - async function Libreria JQuery jQuery \u00e8 una libreria JavaScript per applicazioni web, distribuita come software libero, distribuito sotto i termini della Licenza MIT. Nasce con l'obiettivo di semplificare la selezione, la manipolazione, la gestione degli eventi e l'animazione di elementi DOM in pagine HTML, nonch\u00e9 semplificare l'uso di funzionalit\u00e0 AJAX, la gestione degli eventi e la manipolazione dei CSS. Le sue caratteristiche permettono agli sviluppatori JavaScript di astrarre le interazioni a basso livello con i contenuti delle pagine HTML. L'approccio di tipo modulare di jQuery consente la creazione semplificata di applicazioni web e contenuti dinamici versatili. Nel 2020, jQuery risulta la libreria JavaScript pi\u00f9 utilizzata in Internet, ovvero \u00e8 presente nel 74,4% dei primi 10 milioni di siti Internet pi\u00f9 popolari secondo W3Techs. Fonte: Wikipedia - JQuery Fonti Risorse gratuite - Exploring JS: JavaScript books for programmers - MDN Video-Corsi gratuiti: - fcamuso - Corso Javascript (ES6) ITA - Andrea Tommasello - corso Javascript - 2019 italiano -------------------------------------------------------------------------- APPRONDIMENTI PT.1 -------------------------------------------------------------------------- Node.js Node.js Cos'\u00e8 node Install node Prima applicazione nodejs Non esiste l'oggetto window global objects Modules Creiamo un modulo Moduli built-in Modulo path Modulo OS Modulo File System Eventi Modulo HTTP Approfondimenti Passare dei parametri esterni My first IO sync My first IO async Filtered Cos'\u00e8 node Node \u00e8 un programma c++ che include l'engine javascript V8 di Chrome javascript che ti permette di programmare il server con Javascript Install node Verifica se hai gi\u00e0 installato node node --version Se il comando node non \u00e8 riconosciuto significa che lo hai installato, quindi installalo da qui Lancia nuovamente: node --version A questo punto dovrebbe rispondere con la versione appena installata: v14.15.4 Prima applicazione nodejs Crea un file .js ad esempio app.js e scrivi codice javascript function sayHello ( name ){ console . log ( name ); } sayHello ( 'simone' ); Adesso, digitando da terminale: node app.js Vedrai: simone node eseguir\u00e0 direttamente il codice sul terminale. Il programma di node trasferir\u00e0 il codice all'engine V8 il quale poi verr\u00e0 tradotto in c++ per essere letto dalla macchina (?almeno credo?) Non esiste l'oggetto window non esiste l'oggetto globale window poich\u00e8 fa parte del runtime environment che si ha nei browser console . log ( window ); ReferenceError: window is not defined In nodejs l'oggetto globale si chiama global ed \u00e8 condiviso e accessibile ovunque global objects Hai accesso a tutte le funzionalit\u00e0 definite da javascript grazie all'oggetto global global . console . log (); global . setTimeout (); global . clearTimeout (); global . setInterval (); global . clearInterval (); L'oggetto global \u00e8 implicito quindi puoi sempre ometterlo console . log (); setTimeout (); clearTimeout (); setInterval (); clearInterval (); Locale o globale? //Javascript nel tuo browser //Globale var message = '' ; In Javascript \u00e8 una variabile globale , poich\u00e8 viene aggiunta all'oggetto window . In node questa assume uno scope locale al file. In altre parole non viene aggiunta all'oggetto global //nodejs //Locale var message = '' ; console . log ( global . message ); //undefined Attenzione che, dichiarando una variabile, assume uno scope locale al file contrariamente a quanto accadeva con Javascript. Infatti con Javascript una variabile Modules Il concetto di modulo serve proprio a incapsulare la definizione di variabili, classi e quantaltro evitando quindi eventuali problemi di conflitto tra calssi o variabili che verrebbero brutalmente sovraiscritti. nel concetto di nodejs, ogni file \u00e8 considerato un modulo Se si parla di OOP, si potrebbe dire che all'interno di ogni file tutti gli oggetti sono privati al container che \u00e8 il file. Se vuoi utilizzare ed esportare dei dati esternamente devi renderli pubblici esplicitamente Ogni applicazione nodejs ha un modulo main Per adesso non abbiamo ancora definito un modulo node ma a breve lo faremo. module \u00e8 un oggetto richiamabile esattamente come global o window nel caso di javascript all'interno di un browser console . log ( module ); /** * Module { id: '.', path: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app', exports: {}, parent: null, filename: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\app.js', loaded: false, children: [], paths: [ 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\node_modules', 'C:\\\\Users\\\\node_modules', 'C:\\\\node_modules' ] } */ Creiamo un modulo In questo esempio creeremo un modulo, quindi un file js chiamato logger.js . In questo file definiremo una funzione e una variabile ed esporteremo la funzione esternamente. In realt\u00e0 dovremmo parlare di metodo poich\u00e8 di fatto \u00e8 appartenente al modulo logger.js che \u00e8 racchiuso in un oggetto var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports . log = log ; //module.exports.url = url; Nel file app.js andremo a richiamare l'oggetto restituito //require ritorna l'oggetto esportato dal modulo var logger = require ( './logger' ); console . log ( logger ); /** * { log: [Function: log] } */ la variabile logger ritorna ci\u00f2 che esporta il modulo logger.js infatti stampando module da logger.js avremo: var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports . log = log ; console . log ( module ); //module.exports.url = url; /* Module { id: '.', path: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app', exports: { log: [Function: log] }, parent: null, filename: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\logger.js', loaded: false, children: [], paths: [ 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\node_modules', 'C:\\\\Users\\\\node_modules', 'C:\\\\node_modules' ] } */ la property exports \u00e8 l'oggetto esportato esternamente. Ad ogni modo, adesso posso usare il metodo log del modulo logger . /*logger.js*/ var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports . log = log ; /*app.js*/ //require ritorna l'oggetto esportato dal modulo var logger = require ( './logger' ); logger . log ( 'ciao' ); >node .\\app.js ciao E' buona norma utilizzare il qualificatore const per i moduli importati questo perch\u00e8 non vogliamo in nessun modo che vengano sovraiscritti erroneamente. Se accidentalmente si prova a cambiare il valore di una costante, viene sollevato un errore a runtime /*app.js*/ //require ritorna l'oggetto esportato dal modulo const logger = require ( './logger' ); logger . log ( 'ciao' ); di sotto vedrai come esportare la funzione log in quanto funzione e non come metodo di un oggetto /*logger.js*/ var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports = log ; /*app.js*/ //require ritorna l'oggetto esportato dal modulo var log = require ( './logger' ); log ( 'ciao' ); >node .\\app.js ciao Stampiamo in questo caso cosa esporta il modulo logger /*logger.js*/ var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports = log ; console . log ( module ); /* Module { id: '.', exports: [Function: log], parent: null, filename: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\logger.js', loaded: false, children: [], paths: [ 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\node_modules', 'C:\\\\Users\\\\node_modules', 'C:\\\\node_modules' ] } */ Moduli built-in Sulla pagina ufficiale di node.js puoi trovare la sezione relativa alla documentazione . Modulo path Nel prossimo esempio useremo il modulo path che fornisce delle utility per lavorare con file e directory. Utilizzeremo in particolare il metodo parse() Il metodo parse() restituisce un oggetto le cui propriet\u00e0 rappresentano elementi significativi del percorso. L'oggetto ritorna le seguenti propriet\u00e0: dir <string> root <string> base <string> name <string> ext <string> Vediamo un esempio: const path = require ( 'path' ); const pathObj = path . parse ( './app.js' ); console . log ( pathObj ); /** * { root: '', dir: '.', base: 'app.js', ext: '.js', name: 'app' } */ Modulo OS La documentazione del modulo os la trovi qui In questo esempio vedremo come usare il modulo os e in particolare i metodi totalmem() e freemem() che restituiscono informazioni rispettivamente sulla memoria totale di sistema e la memoria libera const os = require ( 'os' ); const totalMemory = os . totalmem (); const freeMemory = os . freemem (); console . log ( 'Total Memory ' + totalMemory ); console . log ( `Free Memory: ${ freeMemory } ` ); /** * Total Memory 8502140928 * Free Memory: 4154499072 */ Modulo File System Puoi trovare l'intera documentazione qui . In particolare vedremo il metodo fs.readdirSync(path[, options]) e il metodo fs.readdir(path[, options], callback) Metodo sincrono readdirSync() . Ritorna un array di elementi contenuti al path passato come parametro. E' un metodo sincrono! I metodi sincroni sono anche detti bloccanti in quanto impegnano la CPU per tutto il tempo necessario al completamento dell'attivit\u00e0 impedendo al codice di proseguire e servire le altre attivit\u00e0. Questo \u00e8 il funzionamento tipico della programmazione procedurale sincrona const fs = require ( 'fs' ); //Metodo sincrono const files = fs . readdirSync ( './' ); console . log ( files ); Metodo asincrono readdir() . Ritorna (attraverso la callback) un array di elementi contenuti al path passato come primo parametro. Esegue la callback passata come secondo parametro. I metodi asincroni sono anche detti non-bloccanti in quanto impegnano la CPU solo al momento di partenza dell'attivit\u00e0. In questo caso il codice pu\u00f2 proseguire con le altre attivit\u00e0. Una volta che il metodo avr\u00e0 concluso l'attivit\u00e0, verr\u00e0 eseguita una cos\u00ecdetta \"callback\" una funzione in grado di comunicare se il risultato \u00e8 andato a buon fine oppure no. In una funzione \"callback\", il primo parametro rappresenta l'errore (eventuale), il secondo parametro rappresenta il valore di ritorno del metodo. Nel caso della readdir() rappresenta l'array di file contenuti al path specificato come primo parametro della readdir() const fs = require ( 'fs' ); //Metodo asincrono fs . readdir ( './' , function ( err , files ){ if ( err ) console . log ( 'Error' , err ); else console . log ( 'Result' , files ); }); /* Result [ 'app.js', 'logger.js' ] */ Simuliamo un errore: const fs = require ( 'fs' ); //Metodo asincrono fs . readdir ( 'aaaaa' , function ( err , files ){ if ( err ) console . log ( 'Error' , err ); else console . log ( 'Result' , files ); }); /* Error [Error: ENOENT: no such file or directory, scandir 'C:\\Users\\Di Ricco\\Google Drive\\Intecs\\Saleri\\Appunti-nodejs\\first-app\\aaaaa'] { errno: -4058, code: 'ENOENT', syscall: 'scandir', path: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\aaaaa' } */ Eventi La documentazione sugli eventi, in particolare la classe EventEmitter la puoi trovare qui Per poter far scattare un evento hai bisgono di: - emitter.on() : Il metodo on() si mette in ascolto dell'evento passato come primo parametro. Questa pratica in inglese si chiama \"to register a listener\". Inolte in questa fase stabilisci cosa fare quando l'evento scatta tramite una callback. - emitter.emit() : Il metodo emit() fa scattare un evento. Quando scatta torna al listener come callback. //events ritorna una classe, la classe degli eventi const EventEmitter = require ( 'events' ); //in questo modo ho istanziato un oggetto della classe EventEmitter, chiamando il suo costruttore senza nessun parametro const emitter = new EventEmitter (); //Register a listener. //devi registrare un listener prima che l'evento scatti. //E' un po' come abilitare l'interrupt per un particolare evento nei sistemi embedded e implementare l'ISR emitter . on ( 'messageLogged' , function (){ console . log ( 'listener called' ) }) //Raise an event //L'evento pu\u00f2 scattare solo dopo che \u00e8 stato registrato il listener. emitter . emit ( 'messageLogged' ); E' possibile ritornare un parametro al listener. Normalmente questo parametro viene passato come oggetto per maggiore chiarezza. La funzione di callback si aspetta un parametro. Vediamo un esempio: const EventEmitter = require ( 'events' ); const emitter = new EventEmitter (); //Register a listener. emitter . on ( 'messageLogged' , function ( eventArg ){ console . log ( 'listener called' , eventArg ) }) //Raise an event emitter . emit ( 'messageLogged' , { id : 1 , url : 'https://' }); /* listener called { id: 1, url: 'https://' } */ Puoi usare anche la sintassi \"arrow function\" const EventEmitter = require ( 'events' ); const emitter = new EventEmitter (); //Register a listener. emitter . on ( 'messageLogged' , ( eventArg ) => { console . log ( 'listener called' , eventArg ) }) //Raise an event emitter . emit ( 'messageLogged' , { id : 1 , url : 'https://' }); Normalmente gli eventi possono scattare da ogni modulo ma vorresti averne il controllo sul tuo main module. Vedremo adesso come mettersi in ascolto da eventi che possono scattare da altri moduli facendo uso delle classi /*logger.js*/ const EventEmitter = require ( 'events' ); var url = 'http://mylogger.io/log' ; //\"Logger\" contiene tutti i metodi e le propriet\u00e0 di \"EventEmitter\" class Logger extends EventEmitter { log ( message ) { //send an HTTP request console . log ( message ); //Raise an event this . emit ( 'messageLogged' , { id : 1 , url : 'https://' }); } } module . exports = Logger ; /*app.js*/ const Logger = require ( './logger' ); const logger = new Logger (); //Register a listener. logger . on ( 'messageLogged' , ( eventArg ) => { console . log ( 'listener called' , eventArg ) }) logger . log ( 'message' ); /* message listener called { id: 1, url: 'https://' } */ Modulo HTTP Se lanci questa applicazione con node.js const http = require ( 'http' ); const server = http . createServer (); server . on ( 'connection' , ( socket ) => { console . log ( 'New connection' ); }) server . listen ( 3000 ); console . log ( 'Listening on port 3000..' ); e poi dal tuo browser digiti localhost:3000 vedrai stampato New connection const http = require ( 'http' ); const server = http . createServer (( req , res ) => { if ( req . url === '/' ){ res . write ( 'hello world' ); res . end (); } if ( req . url === '/api/courses' ){ res . write ( JSON . stringify ([ 1 , 2 , 3 ])); res . end (); } }); server . listen ( 3000 ); console . log ( 'Listening on port 3000..' ); Approfondimenti Alcuni riferimenti utili: puoi imparare node su nodeschoold . Cliccando su learnyounode Ti suggerir\u00e0 di scaricare tramite npm un simpatico software per l'apprendimento di node. puoi imparare le nuoe features di es6 su es6 features Passare dei parametri esterni Eseguiremo l'esercizio baby-steps suggerito da learnyounode /*baby-steps.js*/ const argArray = process . argv ; let sum = 0 ; argArray . forEach ( ( element , index ) => { if ( index >= 2 ) sum += Number ( element ); }); console . log ( sum ); Esegui ad esempio: node .\\baby-steps.js 1 2 3 Vedrai: 6 My first IO sync Nel prossimo esempio leggeremo un file di testo e stamperemo il numero di caratteri a capo . Faremo uso del modulo fs e del metodo readFileSync() per la lettura dei file in modo sincrono const fs = require ( 'fs' ); const buf = fs . readFileSync ( './myFile.txt' ); const str = buf . toString (); const strArr = str . split ( '\\n' ); console . log ( buf ); console . log ( str ); console . log ( strArr ); console . log ( strArr . length - 1 ); /* <Buffer 63 69 61 6f 20 0a 61 20 0a 74 75 74 74 69 0a 71 75 61 6e 74 69> ciao a tutti quanti [ 'ciao ', 'a ', 'tutti', 'quanti' ] 3 */ Di default readFileSync() resistutisce un oggetto della classe Buffer che puoi approfondire direttamente sulla documentazione di nodejs. In pratica comunque resitituisce i caratteri decodificandoli in binario attraverso utf8 che \u00e8 equivalente al codice ASCII. Se vuoi verificare, basta tu prenda una tabella ASCII e tu legga il valore esadecimale per ogni lettera. Questo sistema potrebbe essere molto interessante per la comunicazione con un microcontrollore. Se vuoi tuttavia convertire direttamente in stringa puoi specificare il tipo di codifica utf8 come secondo parametro. Il codice si semplifica e diventa const fs = require ( 'fs' ); const str = fs . readFileSync ( './myFile.txt' , 'utf8' ); const strArr = str . split ( '\\n' ); console . log ( str ); console . log ( strArr ); console . log ( strArr . length ); /* ciao a tutti quanti [ 'ciao ', 'a ', 'tutti', 'quanti' ] 3 */ My first IO async In questo esempio vedremo invece lo stesso esempio ma utilizzando la programmazione asincrona e quindi tramite il metodo readFile() . Questo metodo non ritorna niente, il suo output \u00e8 in realt\u00e0 la funzione di callback passata come secondo parametro che viene chiamata solo quando si \u00e8 raggiunto un risultato const fs = require ( 'fs' ); console . log ( 'before' ); fs . readFile ( './myFile.txt' , 'utf8' , ( err , data ) => { //fs.readFile('./myFile.txt', 'utf8', function(err, data){ console . log ( data ); console . log ( data . split ( '\\n' ). length - 1 ); }) console . log ( 'after' ); /* before after ciao a tutti quanti 3 */ Attenzione Quello che devi notare \u00e8 che con questo sistema, al contrario del sistema sincrono, l'evoluzione del programma continua una volta chiamato il metodo readFile() . Per questo ho inserito console.log('before'); e console.log('after'); , per dimostrare in output che il risultato non \u00e8 quello atteso In genere conviene sempre fare il check di eventuali errori. Poich\u00e8 la callback come primo parametro riceve anche un errore segnalandoci se qualcosa \u00e8 andato storto, \u00e8 buona norma utilizzarlo per sollevare un'eccezione attraverso throw oppure qualsiasi altra operazione desiderata const fs = require ( 'fs' ); console . log ( 'before' ); fs . readFile ( './myFile.txt' , 'utf8' , ( err , data ) => { if ( err ) throw err console . log ( data ); console . log ( data . split ( '\\n' ). length - 1 ); }) console . log ( 'after' ); /* before after ciao a tutti quanti 3 */ Filtered In questo esempio vedrai come stampare il contenuto dei file all'interno di una directory con una particolare estensione. Il path e l'estensione vengono passati come parametri esterni allo script /*05-filtered-ls.js*/ const fs = require ( 'fs' ); const path = require ( 'path' ); const dir = process . argv [ 2 ]; const ext = process . argv [ 3 ]; fs . readdir ( dir , ( err , files ) => { files . forEach (( elem )=>{ if ( path . extname ( elem ) == ext ) console . log ( elem ) }) }) Otterrai: >node 05-filtered-ls.js ./ .js 01-hello-node.js 02-baby-steps.js 03-my-first-io-async.js 04-my-first-io.js 05-filtered-ls.js Puoi renderlo migliore.. In questo esempio utilizzero il metodo filter e passer\u00f2 l'estensione del file senza dover specificare il . const fs = require ( 'fs' ); const path = require ( 'path' ); const dir = process . argv [ 2 ]; const ext = `. ${ process . argv [ 3 ] } ` ; fs . readdir ( dir , ( err , files ) => { if ( err ) throw err ; const filesFiltered = files . filter (( file ) => path . extname ( file ) === ext ); filesFiltered . forEach (( file ) => console . log ( file )); }); -------------------------------------------------------------------------- APPRONDIMENTI PT.2 -------------------------------------------------------------------------- Promise Puoi trovare degli approfondimenti utili sull'argomento qua: MDN Gli oggetti Promise sono usati per computazioni in differita e asincrone. Una Promise rappresenta un'operazione che non \u00e8 ancora completata, ma lo sar\u00e0 in futuro. new Promise ( function ( resolve , reject ) { ... }); Una promise accetta come argomento una funzione che ha due parametri: resolve e reject . Tale funzione viene chiamata immediatamente dall'implementazione della Promise, passando i due argomenti resolve e reject , che sono due funzioni. Le due funzioni resolve e reject , quando chiamate, risolvono o rigettano la promise. L'esecutore inizia del lavoro (solitamente asincrono), e, una volta completato, chiama resolve per risolvere la promise, o reject se c'\u00e8 stato qualche errore. Se un errore viene sollevato nella funzione di esecuzione (executor) la promise viene rigettata. Una Promise consente di associare degli handlers con il successo o il fallimento di un'azione asincrona. Questo in pratica consente di utilizzare dei metodi asincroni di fatto come se fossero sincroni. Una Promise pu\u00f2 presentarsi in uno dei seguenti stati: pending (attesa): stato iniziale, n\u00e9 soddisfatto n\u00e9 respinto. fulfilled (soddisfatto): significa che l'operazione si \u00e8 conclusa con sucesso. rejected (respinto): significa che l'operazione \u00e0 fallita. Una promise in pending pu\u00f2 evolvere sia in fulfilled , sia in rejected con la possibilit\u00e0 in entrambi i casi di passare valori. Quando accade una di queste situazioni, vengono chiamati gli handler associati che sono stati accodati dal metodo then della promise. Poich\u00e8 i metodi .then e .catch restituiscono delle promise , \u00e8 possibile concatenarli tramite l'operazione di composition . Un esempio semplice In questo esempio creo una promise in cui chiamer\u00f2 la funzione setTimeout() . Una volta che setTimeout() sar\u00e0 completata la promise entrer\u00e0 nello stato fulfilled ritornando un messaggio di successo rappresentato dal parametro della funzione resolve() . Poich\u00e8 mi aspetto che non ci siano errori in questa situazione, ho aggiunto una variabile esterna in modo da simulare una qualsiasi condizione di errore. Con la variabile booleana ForceRejected forzo la promise ad entrare nello stato di rejected , ritornando il valore identificato dal parametro della funzione reject() . Una volta che la Promise ha terminato ed \u00e8 passata da pending a fulfilled \u00e8 possibile restituire il risultato tramite il metodo .then della Promise . Tale metodo accetta come parametro una callbackc che come parametro ha il valore passato da resolve() . Allo stesso modo, quando la Promise ha terminato ed \u00e8 passata da pending a rejected viene restituito il valore passato a reject() alla callback del metodo catch() const ForceRejected = false ; console . log ( \"Inizio\" ); let myFirstPromise = new Promise (( resolve , reject ) => { if ( ForceRejected ) { reject ( \"Error\" ); } else { setTimeout ( function (){ resolve ( \"Success!\" ); }, 1000 ); } }); myFirstPromise . then (( successMessage ) => { console . log ( \"Yee! \" + successMessage ); }). catch (( errorMessage ) => { console . log ( \"...! \" + errorMessage ); }) console . log ( \"Fine\" ); Il risultato sar\u00e0: Inizio Fine Yee! Success! Se esegui il codice con const ForceRejected = true; avrai come risultato: Inizio Fine ...! Error Nota che ho inserito anche due extra-stampe Inizio , Fine per evidenziare che il processo \u00e8 asincrono e quindi continua la sua esecuzione nel mentre che la Promise cerca di evolvere da pending a fulfilled o rejected -------------------------------------------------------------------------- APPRONDIMENTI PT.3 -------------------------------------------------------------------------- Approfondimento Hoisting Differenza tra var , let , const , blocchi di codici, funzioni etc.. Puoi trovare un approfondimento qui Approfondimento Oggetti Modo alternativo per inizializzare un oggetto let fsName = 'simone' ; let lsName = 'diricco' ; let user = { fsName , lsName }; console . log ( user ); //{ fsName: 'simone', lsName: 'diricco' } In questo caso l'oggeto prende come key il nome della variabile let fsName = 'simone' ; let lsName = 'diricco' ; let user = { fsName , lsName }; console . log ( user ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user [ 'lsName' ]); //diricco console . log ( user . fsName ); //simone let user2 = { [ 'fs' + 'Name' ] : fsName , lsName }; console . log ( user ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user2 [ 'fsName' ]); //simone console . log ( user2 . lsName ); //diricco Con la notazione ['nomeKey] ho il vantaggio di poter valutare delle espressioni stringhe Per verificare se esiste unar propriet\u00e0 all'interno di un oggetto: let fsName = 'simone' ; let lsName = 'diricco' ; let user = { fsName , lsName }; console . log ( 'fsName' in user ); //true Approfondimento Moduli CommonJS require / exports Con require posso importare tutto ci\u00f2 che desidero appartenente a moduli esterni //main.js let a = require ( './module1' ); console . log ( a ) Con module.exports posso esportare cio\u00e8 che desidero di un modulo //module1.js let a = 10 ; module . exports = a ; Mandando in esecuzione main.js otterremo la stampa di a , il cui valore \u00e8 prelevato dal modulo module1.js . E' lo stesso identico concetto di include in c++ solo che in questo caso l'esportazione e l'importazione non \u00e8 a livello di file ma a livello proprio di funzionalit\u00e0, oggetti, classi etc.. Vediamo un esempio pi\u00f9 completo //main.js let math = require ( './math' ); console . log ( math . sum ( 20 , 30 )); console . log ( math . sub ( 20 , 30 )); console . log ( math . mul ( 20 , 30 )); console . log ( math . div ( 20 , 30 )); //math.js let sum = function ( x , y ){ return x + y ; } let div = function ( x , y ){ return x / y ; } let mul = function ( x , y ){ return x * y ; } let sub = function ( x , y ){ return x - y ; } module . exports = { sum , div , mul , sub } Packages NPM Installiamo ad esempio il pacchetto prompt-sync tramite npm install prompt-sync . Verr\u00e0 scaricato una cartella node_modules Questo pacchetto serve per l'acquisizione di dati da tastiera. Vediamo un esempio: let prompt = require ( 'prompt-sync' )(); let number = prompt ( 'Insert a number: ' ); console . log ( number ); Approfondimento THIS this si riferisce sempre all'oggetto referenziato al quale il metodo fa riferimento let printName = function (){ return this . fsName + ' ' + this . lsName ; } let user1 = { fsName : 'mario' , lsName : 'rossi' , printName } let user2 = { fsName : 'matteo' , lsName : 'bianchi' , printName } console . log ( user1 . printName ()); //mario rossi console . log ( user2 . printName ()); //matteo bianchi Vediamo un alrto esercizio let listProducts = { \"0001\" : { name : 'PC' , price : 12.45 }, \"0002\" : { name : 'smth' , price : 13.45 }, \"0002\" : { name : 'tast' , price : 2.45 }, \"0003\" : { name : 'Monit' , price : 12.35 }, \"0004\" : { name : 'mous' , price : 124.45 } } let store = { listProducts , print : function (){ for ( let item in this . listProducts ){ console . log ( this . listProducts [ item ]. name ); console . log ( this . listProducts [ item ]. price ); console . log ( '------------------------' ); } } } store . print (); /* PC 12.45 ------------------------ tast 2.45 ------------------------ Monit 12.35 ------------------------ mous 124.45 ------------------------ */ Un altro esempio che usa il costruttore in modo da poter utilizzare un oggetto come modello e poter istanziare delle copie del modello dell'oggetto function User ( fsName , lsName , email ){ this . fsName = fsName , this . lsName = lsName , this . email = email this . name = function (){ return this . fsName + ' ' + this . lsName ; } } let user1 = new User ( 'sim' , 'dir' , 'em@em.it' ); console . log ( user1 ); console . log ( user1 . name ()); /* User { fsName: 'sim', lsName: 'dir', email: 'em@em.it', name: [Function (anonymous)] } sim dir */ Reference data type Al contrario delle strutture dati primitive, con le strutture dati referenziate come array o oggetti, l'assegnamento tra strutture dati referenziate effettua una copia solo dell'indirizzo a cui \u00e8 allocato il nome della struttura referenziata il che \u00e8 diverso dall'eseguire una copia del valore come accade con le strutture dati primitive. Questo significa che in fase di assegnamento tra due oggetti o array poich\u00e8 copio l'indirizzo dell'oggetto o array, di fatto ho ottenuto due oggetti che puntano alla stessa struttura dati. Se modifico uno, modifico anche l'altro.. Vediamo un esempio.. let user1 = { fsname : 'mario' , lsname : 'rossi' } let user2 = user1 ; console . log ( user1 ); //{ fsname: 'mario', lsname: 'rossi' } console . log ( user2 ); //{ fsname: 'mario', lsname: 'rossi' } user2 . fsname = 'Luigi' ; console . log ( user1 ); //{ fsname: 'Luigi', lsname: 'rossi' } console . log ( user2 ); //{ fsname: 'Luigi', lsname: 'rossi' } user1 . email = 'em@em.it' ; console . log ( user1 ); //{ fsname: 'Luigi', lsname: 'rossi', email: 'em@em.it' } console . log ( user2 ); //{ fsname: 'Luigi', lsname: 'rossi', email: 'em@em.it' } Costruttori prefdefiniti javascript Object, String, Boolean, Number, Array RegExp, Function, Error, Symbol, Date let user = new Object (); Questo significa che anche i dati primitivi sono implementati in javascript come oggetti e quindi avranno propriet\u00e0 e metodi! ecco perch\u00e8 puoi fare str.lenght oppure str.toUpperCase() oppure nmb.toFixed() Non \u00e8 possibile modificare tuttavia metodi e propriet\u00e0 di un dato primitivo! Attenzione! Anche gli Array sono particolari oggetti estesi for .. of for .. in Memoization Come fare una copia profonda tra oggetti? Sappiamo che l'assegnamento standard effetua solo una copia dei riferimenti e questo equivale a creare un oggetto che punta alla stessa struttura dati. il metodo Object.assig() invece effettua una copia profonda dell'oggetto passato come parametro restituendo di fatto un oggetto copia let user1 = { fsName : 'simone' , lsName : 'diricco' }; let user2 = Object . assign ({}, user1 ); //deep copy console . log ( user1 ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user2 ); //{ fsName: 'simone', lsName: 'diricco' } user2 . lsName = 'rossi' ; console . log ( user1 ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user2 ); //{ fsName: 'simone', lsName: 'rossi' } propriet\u00e0 associate ai dati e proprier\u00e0 associate all'accesso get & set let square = { x : 10 , //propriet\u00e0 di accesso get area (){ return this . x * this . x ; } }; console . log ( square . x ); //10 console . log ( square . area ); //100 square . x = 20 ; console . log ( square . x ); //20 console . log ( square . area ); //400 square . area = 23 ; console . log ( square . x ); //20 //La propriet\u00e0 area non viene modificata console . log ( square . area ); //400 let square = { x : 10 , //propriet\u00e0 di accesso get area (){ return this . x * this . x ; }, set area ( val ){ this . x = Math . sqrt ( val ); } }; console . log ( square . x ); //10 console . log ( square . area ); //100 square . area = 25 ; console . log ( square . x ); //5 //La propriet\u00e0 area non viene modificata console . log ( square . area ); //25 Arrow functions Sintassi funzioni function sum ( x , y ){ return x + y ; } //anonymous fucntions let sum2 = function ( x , y ){ return x + y ; } //Arrow functions let sum3 = ( x , y ) => { return x + y ; } //arrow functions with 1 argument let square = x => { return x * x ; } //arrow functions with 1 argument //compact let square2 = x => x * x ; High Order Functions //funzione identit\u00e0 let id = x => x ; let sum = ( x , y ) => x + y ; //Funzione di ordine superiore //poich\u00e8 accetta come argomento una funzione e ritorna una funzione id ( sum )( 4 , 5 ); Array filter let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //test \u00e8 una funzione che decido in fase di invocazione let filter = ( array , test ) => { let result = []; for ( let item of array ) if ( test ( item )){ result . push ( item ) } return result ; } //ritorno un array con l'elemento 'simone' se \u00e8 presente console . log ( filter ( array , x => x == 'simone' )); //ritorno un array con gli elementi che contengono una 'a' console . log ( filter ( array , x => x . search ( \"a\" ) >= 0 )); Array map let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //test \u00e8 una funzione che decido in fase di invocazione let filter = ( array , test ) => { let result = []; for ( let item of array ) if ( test ( item )){ result . push ( item ) } return result ; } let map = ( array , trans ) => { let result = []; for ( let item of array ){ result . push ( trans ( item )); } return result ; } console . log ( map ( array , x => x . toUpperCase ())); //[ 'SIMONE', 'CIAO', 'MATTEO', 'ALESSANDRO' ] Array reduce let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //test \u00e8 una funzione che decido in fase di invocazione let filter = ( array , test ) => { let result = []; for ( let item of array ) if ( test ( item )){ result . push ( item ) } return result ; } let map = ( array , trans ) => { let result = []; for ( let item of array ){ result . push ( trans ( item )); } return result ; } let reduce = ( array , combine , start ) => { let current = start ; for ( let item of array ){ current = combine ( current , item ) } return current ; } let count = map ( array , x => x . length ); let totCount = reduce ( count , ( a , b ) => a + b , 0 ); console . log ( count ); //[ 6, 4, 6, 10 ] console . log ( totCount ); //26 Gli array possiedono gi\u00e0 come metodi filer, map, reduce Gli array possiedono gi\u00e0 come metodi filer, map, reduce array . map (); array . filter (); array . reduce (); E funzionano allo stesso modo di come li abbiamo implementati noi. Vediamo adesso come combinare queste funzioni let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //conta le lettere totali degli elementi che contengono una 'a' console . log ( //['ciao', 'matteo', 'alessandro']; array . filter ( item => { return item . search ( 'a' ) >= 0 ; }) //[ 4, 6, 10 ] . map ( item => { return item . length ; }) //20 . reduce (( a , b ) => { return a + b ; }) ); //20 Qualche chicca sugli Array Arrray.of, Array.from let numbers = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 ]; console . log ( numbers . length ); //10 let numbers1 = Array . of ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 ); console . log ( numbers1 ); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 0] let numberString = \"1234567890\" ; let numbers2 = Array . from ( numberString ); console . log ( numbers2 ); //['1', '2', '3', '4','5', '6', '7', '8','9', '0'] let numbers3 = Array . from ( numberString , value => parseInt ( value )); console . log ( numbers3 ); //[1, 2, 3, 4, 5,6, 7, 8, 9, 0] let numbers4 = Array . from ( numbers3 , value => value + 1 ); console . log ( numbers4 ); //[2, 3, 4, 5, 6,7, 8, 9, 10, 1] concat, every, some let array1 = [ 1 , 2 , 3 , 4 , 5 ]; let array2 = [ 6 , 7 , 8 , 9 , 0 ]; console . log ( array1 . concat ( array2 )); //[1, 2, 3, 4, 5,6, 7, 8, 9, 0] //ogni elemento deve soddisfare la condizione console . log ( array1 . every ( value => typeof value === \"number\" )); //true //almeno un elemento deve soddisfare la condizione console . log ( array1 . some ( value => typeof value === \"number\" )); //true find, filter, forEach, includes, indexOf let users = [ \"Cosimo\" , \"Simone\" , \"mario\" , \"maria\" , \"giuseppe\" , \"asinello\" ]; //find console . log ( users . find ( value => value == \"mario\" )); //mario //find //ritorna un elemento dell'array console . log ( users . find ( value => value . search ( \"g\" ) == 0 )); //giuseppe //filter //ritorna un array console . log ( users . filter ( value => value . search ( \"a\" ) == 0 )); //[ 'asinello' ] /* COSIMO SIMONE MARIO MARIA GIUSEPPE ASINELLO */ //forEach users . forEach ( value => { console . log ( value . toLocaleUpperCase ()); }) //includes console . log ( users . includes ( \"pippo\" )); //false console . log ( users . includes ( \"Simone\" )); //true //indexOf console . log ( users . indexOf ( \"Simone\" )); //1 console . log ( users . indexOf ( \"maria\" )); //3 push, pop, shift, unshift let numbers = [ 1 , 2 , 3 , 4 ]; //push //ritorna la lunghezza dell'array console . log ( numbers . push ( 17 )); //5 console . log ( numbers ); //[ 1, 2, 3, 4, 17 ] //pop //ritorna l'elemento rimosso console . log ( numbers . pop ( 4 )); //17 console . log ( numbers ); //[ 1, 2, 3, 4 ] //shift //ritorna l'elemento rimosso console . log ( numbers . shift ()); //1 console . log ( numbers ); //[ 2, 3, 4 ] //unshift //ritorna la lunghezza dell'array console . log ( numbers . unshift ( 23 )); //4 console . log ( numbers ); //[ 23, 2, 3, 4 ] sort, splice, slice let users = [ \"Cosimo\" , \"Luigi\" , \"Mario\" , \"Alessio\" , \"Matteo\" ]; console . log ( users ); //[ 'Cosimo', 'Luigi', 'Mario', 'Alessio', 'Matteo' ] //sort //Consente l'ordinamento degli elementi dell'array //L'argomento specifica la condizione di ordinamento //modifica l'array console . log ( users . sort ( compare )); //[ 'Alessio', 'Cosimo', 'Luigi', 'Mario', 'Matteo' ] function compare ( a , b ) { if ( a < b ) { return - 1 ; } else if ( a > b ) { return 1 ; } else { return 0 ; } } users = [ \"Cosimo\" , \"Luigi\" , \"Mario\" , \"Alessio\" , \"Matteo\" ]; //splice(x, y) //elimina y elementi a partire da una posizione x //modifica l'array users . splice ( 2 , 1 ); console . log ( users ); //[ 'Cosimo', 'Luigi', 'Alessio', 'Matteo' ] //splice //puoi anche aggiungere elementi //modifica l'array users . splice ( 2 , 0 , \"giuseppia\" , \"antonio\" ); console . log ( users ); //[ 'Cosimo', 'Luigi', 'giuseppia', 'antonio', 'Alessio', 'Matteo' ] users = [ \"Cosimo\" , \"Luigi\" , \"Mario\" , \"Alessio\" , \"Matteo\" ]; //slice //ritorna un sub-array let subArray = users . slice ( 0 , 2 ); console . log ( subArray ); //[ 'Cosimo', 'Luigi' ] setTimeout(), setInterval() la setTimeout() chiama la funzione passata come argomento dopo un certo valore di tempo specificato come argomento. La setInterval() invece chiama la funzione passata come argomento periodicamente con il periodo specificato come argomento //setTimeout() setTimeout (() => { console . log ( 'start' ); }, 1000 ); let i = 0 ; //setTimeout() setInterval (() => { console . log ( i ++ ); }, 1000 ); /* start 0 1 2 3 4 5 */ Eventi Asincroni // ----------------------------------> t // x x const fs = require ( 'fs' ); //chiamata asincrona.. //viene passato un path e una callback, una funzione //la callback viene chiamata una volta che la lettura \u00e8 completata //readFile restituisce un buffer fs . readFile ( './data.txt' , function ( err , data ){ console . log ( data . toString ()); }); console . log ( 'end!!' ); /* end!! hello! */ Promise, resolve, reject, then const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise ( function ( resolve , reject ){ fs . readFile ( fileName , function ( err , data ){ if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let file = readFile ( './data.txt' ); console . log ( file ); //Promise { <pending> } //metodo .then della Promise //Come primo parametro accetta una funzione che viene invocata se la Promise evolve in resolve //Come secondo parametro accetta una funzione che viene invocata se la Promise evolve in reject file . then ( function ( data ){ console . log ( data . toString ()); //hello! }, function ( err ){ console . log ( err ) }) Vediamo lo stesso esempio ma con qualche console.log() const fs = require ( 'fs' ); console . log ( 'start' ); //1 //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ console . log ( 'readFIle() inizio esecuzione' ); //3 return new Promise ( function ( resolve , reject ){ console . log ( \"promise(), prima dell'invocazione del metodo async readFile\" ); //4 fs . readFile ( fileName , function ( err , data ){ console . log ( \"promise(), esecuzione callback del metodo async readFile\" ); //8 if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } console . log ( \"Prima dell'invocazione di readFile()\" ); //2 let file = readFile ( './data.txt' ); console . log ( file ); //Promise { <pending> } //5 console . log ( \"Dopo l'invocazione di readFile()\" ); //6 //metodo .then della Promise //Come primo parametro accetta una funzione che viene invocata se la Promise evolve in resolve //Come secondo parametro accetta una funzione che viene invocata se la Promise evolve in reject console . log ( \".then(), invocazione del metodo della Promise\" ); //7 file . then ( function ( data ){ console . log ( \".then(), esecuzione del metodo della Promise\" ); //9 console . log ( data . toString ()); //hello! //10 }, function ( err ){ console . log ( err ) }) /* start Prima dell'invocazione di readFile() readFIle() inizio esecuzione promise(), prima dell'invocazione del metodo async readFile Promise { <pending> } Dopo l'invocazione di readFile() .then(), invocazione del metodo della Promise promise(), esecuzione callback del metodo async readFile .then(), esecuzione del metodo della Promise hello! */ Async, Await Vediamo lo stesso esempio di prima inserendo la chiamata a readFile in un contesto di chiamata asincrona const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let main = async function (){ console . log ( 'start' ); readFile ( './data.txt' ). then ( data => { console . log ( data . toString ()); }); console . log ( 'end' ); } main (); /* start end hello! */ Se per\u00f2 sfruttiamo anche la parola chiave await const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let main = async function (){ console . log ( 'start' ); await readFile ( './data.txt' ). then ( data => { console . log ( data . toString ()); }) console . log ( 'end' ); } main (); Oppure, visto che ritorna una Promise , posso anche fare cos\u00ec: const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let main = async function (){ console . log ( 'start' ); let data = await readFile ( './data.txt' ); console . log ( data . toString ()); console . log ( 'end' ); } main (); In questo modo ottengo un comportamento sequenziale del codice Vediamo un esempio pi\u00f9 completo const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } function wait ( time ){ return new Promise (( resolve , reject ) => { setTimeout (() => { resolve () }, time ); }) } let main = async function (){ console . log ( 'start' ); console . log ( 'attendi 5 sec..' ); await wait ( 5000 ); console . log ( 'sono passati 5 sec' ); let data = await readFile ( './data.txt' ); console . log ( 'attendi 5 sec..' ); await wait ( 5000 ); console . log ( 'sono passati 5 sec' ); console . log ( data . toString ()); console . log ( 'end' ); } main (); /* start attendi 5 sec.. sono passati 5 sec attendi 5 sec.. sono passati 5 sec hello! end */ Promise.all() e Promise.race() Le Promise.all() accettano come parametro un array di Promise function wait ( time , string ){ return new Promise (( resolve , reject ) => { setTimeout (() => { resolve ( string ) }, time ); }) } //Pormise.all() //Cercano come argomento un array di Promise Promise . all ([ wait ( 1000 , 1 ), wait ( 2000 , 2 ), wait ( 3000 , 3 )]). then ( value => { console . log ( value ); }) /* [ 1, 2, 3 ] */ Dopo 3 secondi stampa a video [ 1, 2, 3 ] cio\u00e8 il valore delle Promise dopo che tutte sono state risolte. La Promise.race() invece ritorna il valore della Promise che viene risolta per prima function wait ( time , string ){ return new Promise (( resolve , reject ) => { setTimeout (() => { resolve ( string ) }, time ); }) } //Pormise.all() //Cercano come argomento un array di Promise Promise . race ([ wait ( 1000 , 1 ), wait ( 2000 , 2 ), wait ( 3000 , 3 )]). then ( value => { console . log ( value ); }) Set e Map let set = new Set (); set . add ( 56 ); set . add ( 'test' ); set . add ( '34' ); //con i set \u00e8 possibile aggiungere univocamente un valore //questo significa che aggiungendo pi\u00f9 volte lo stesso valore non avr\u00e0 effetto set . add ( 34 ); set . add ( 34 ); set . add ( 34 ); console . log ( set . size ); //4 let set = new Set ([ 32 , '45' , 5 , 6 , 7 , 8 , 8 , 8 ]); console . log ( set . size ); //6 set . delete ( 32 ); console . log ( set . size ); //5 console . log ( set . has ( 6 )); //true console . log ( '-----' ); set . forEach (( value , key , set ) => { console . log ( value ); console . log ( key ); console . log ( set . size ); console . log ( '-----' ); }) /** ----- 45 45 5 ----- 5 5 5 ----- 6 6 5 ----- 7 7 5 ----- 8 8 5 ----- */ E' possibile convertire un set in un array con lo spread operator. let set = new Set ([ 32 , '45' , 5 , 6 , 7 , 8 , 8 , 8 ]); let array = [... set ]; console . log ( array ); //[ 32, '45', 5, 6, 7, 8 ] In questo caso l'array non conterr\u00e0 elementi duplicati. E' quindi possibile usare il set per rimuovere i duplicati all'interno di un array function deleteDuplicates ( items ){ return [... new Set ( items )]; } console . log ( deleteDuplicates ([ 0 , 1 , 2 , 3 , 3 , 3 , 3 , 4 , 5 , 6 , 7 , 7 , 7 , 7 ])); //[0, 1, 2, 3, 4, 5, 6, 7] Map let map = new Map () map . set ( 'user1' , 'Cosimo' ); map . set ( 'user2' , 'Simone' ); console . log ( map ); //Map(2) { 'user1' => 'Cosimo', 'user2' => 'Simone' } console . log ( map . get ( 'user1' )); //Cosimo console . log ( map . has ( 'user1' )); //true map . delete ( 'user2' ); console . log ( map . has ( 'user2' )); //false map . clear (); //svuota la mappa console . log ( map . size ); //0 let map = new Map ([[ 'key1' , 1 ], [ 'key2' , 2 ]]); console . log ( map . get ( 'key1' )); //1 map . forEach (( value , key ) => { console . log ( key , value ); }) /* key1 1 key2 2 */","title":"Javascript"},{"location":"javascript/#javascript","text":"Javascript Lezione 01 Prerequisiti al corso Approccio al corso Strumenti Necessari Introduzione Lezione 02 Cenni storici Aspetti strutturali Versioni di Javascript Configurazione di un IDE Visual Studio Code - VS code Lezione 03 Primo script Lezione 04 Console - Browser Web Alert & prompt Commenti Lezione 05 Introduzione al DOM Introduzione alla libreria JQuery DOM ed Eventi Lezione 06 Variabili Javascript Tipi di dati in JS Dati nativi Reference type Alcune regole generali per dichiarazione di variabili Reference type Const Approfondimento Null - undefined - NaN Lezione 07 Stringhe Opearotri, Propriet\u00e0 e Metodi su stringhe Operatori Approfondimento Interpolazioni di stringhe Le stringhe sono immutabili Propriet\u00e0 Metodi Lezione 08 Conta parole Lezione 09 Approfondimento - Rappresentazione numerica in Javascript Numeri in Fixed Point Numeri in Floating Point Not A Number NaN Lezione 10 Approfondimento - Codifica caratteri Javascript ASCII Unicode Caratteri di Escape Lezione 11 Type conversion Conversione esplicita Conversione implicita Lezione 12 Operatori matematici Pre e post incremento/decremento Oggetto MATH Lezione 13 Equazione di II grado Lezione 14 Operator Precedence Associativit\u00e0 Operatori di assegnamento Lezione 15 Operatori Logici Logica Booleana Approfondimento - Short evalutation Truthy e falsy Lezione 16 Control Structure if/else Ternary Operator Switch statemeant Lezione 17 while loop do-while loop Lezione 18 for loop break & coninue Lezione 19 Function Parametri di default Ritorno di una funzione Lezione 20 Funzioni - Passaggio di oggetti e array Funzioni - Ritorno di un oggetto o un array Approfondimento funzioni - Oggetto Arguments Approfondimento funzioni - Parametri Rest Approfondimento Introduzione forEach / this Lezione 21 Approfondimento Funzioni ricorsive Approfondimento Function expression Approfondimento Hoisting Approfondimento Differenza tra undefined e not defined Approfondimento IIFI Immediatly invoked function expression Paradigma di programmazione Javascript Lezione 22 Scope Visibilit\u00e0 di variabili Visibilit\u00e0 Globale (global scope) Scope Chaining Visibilit\u00e0 a livello di blocco (block scope) Approfondimento - Closure di una funzione Lezione 23 Array Matrix Lezione 24 Array - Metodi base Lezione 25 Arrays - forEach() Arrays - map() Funzioni freccia (lambda) Array - Metodi avanzati Lezione 26 Introduzione agli Object Javascript OOP Lezione 01 OOP Object Oriented Programming Lezione 02 Introduzione ai Metodi Lezione 03 Costruttore Lezione 04 Ereditariet\u00e0 Lezione 05 Ereditariet\u00e0 - Shadowing Ereditariet\u00e0 classica Lezione 06 THIS Object - Variabili Statiche (condivise) Lezione 07 Introduzione For In Oggetto Date() Lezione 08 Classi Lezione 09 Classi assegnanili a variabili Get / Set try-catch Lezione 10 Derivazione di classi , ereditariet\u00e0 Lezione 11 Ereditariet\u00e0 classi Pt 2 Lezione 12 Approfondimento - Symbols Lezione 13 Approfondimento - Iterables/Iterator Costrutto for - of Lezione 14 Approfondimento - Funzioni Generatrici Lezione 15 Approfondimento - Esempio (For .. of) custom Lezione 16 Destructuring Lezione 17 Map Object Iterazione Map Object Lezione 18 Set Conversione di un Oggetto Map / Set in un Array Lezione 19 Dom Manipulation Lezione 20 DOM - Selettori Metodi di selezione di elementi html Lezione 21 Dom - Child e Parent DOM - Manipolazione dello stile degli elementi html Lezione 22 DOM - Manipolazione del testo degli elementi html DOM - Manipolazione degli attributi html Lezione 23 DOM - Creazione di Un elemento DOM - Rimpiazzo di un elemento DOM - ELiminazione di un elemento Lezione 24 DOM Events Metodo addEventListener Lezione 25 Prevent Default Che cos'\u00e8 esattamente l'oggetto ricevuto come unico parametro \"e\"? Lezione 26 Approfondimento type event Aprrofondimento eventi tastiera e input Lezione 27 Argomeni non trattati / da approfondire Fonti APPRONDIMENTI PT.1 Node.js Cos'\u00e8 node Install node Prima applicazione nodejs Non esiste l'oggetto window global objects Modules Creiamo un modulo Moduli built-in Modulo path Modulo OS Modulo File System Eventi Modulo HTTP Approfondimenti Passare dei parametri esterni My first IO sync My first IO async Filtered APPRONDIMENTI PT.2 Promise Un esempio semplice APPRONDIMENTI PT.3 Approfondimento Hoisting Approfondimento Oggetti Approfondimento Moduli Packages Approfondimento THIS Costruttori prefdefiniti javascript for .. of for .. in Memoization Come fare una copia profonda tra oggetti? propriet\u00e0 associate ai dati e proprier\u00e0 associate all'accesso get & set Arrow functions High Order Functions Array filter Array map Array reduce Gli array possiedono gi\u00e0 come metodi filer, map, reduce Qualche chicca sugli Array Arrray.of, Array.from concat, every, some find, filter, forEach, includes, indexOf push, pop, shift, unshift sort, splice, slice setTimeout(), setInterval() Eventi Asincroni Promise, resolve, reject, then Async, Await Promise.all() e Promise.race() Set e Map Map","title":"Javascript"},{"location":"javascript/#lezione-01","text":"","title":"Lezione 01"},{"location":"javascript/#prerequisiti-al-corso","text":"Prima di iniziare questo modulo, dovresti avere familiarit\u00e0 con i linguaggi HTML e CSS .","title":"Prerequisiti al corso"},{"location":"javascript/#approccio-al-corso","text":"Questo corso \u00e8 stato scritto con l'intento di imparare il linguaggio attraverso esempi pratici. Se all'inizio pensate di trovare troppo pesanti alcuni capitoli puramente \"teorici\" vi capisco, lo penserei anch'io quindi evitate con leggerezza queste sezioni. Faccio notare anche l'approccio a \"Lezioni\" brevi che ho preferito rispetto all'approccio classico a \"Libro/capitoli\" che dal mio punto di vista allunga il tempo di apprendimento specialmente per chi non mastica gi\u00e0 un po' il linguaggio e che comunque pu\u00f2 essere seguito parallelamente per approfondimenti. Concludo nella speranza che il corso possa piacervi e risultare snello per l'apprendimento.","title":"Approccio al corso"},{"location":"javascript/#strumenti-necessari","text":"Per questo corso sar\u00e0 necessario un web browser e un editor di testo. Come web browser utilizzeremo Google Chrome mentre come editor di testo utilizzeremo Visual Studio Code .","title":"Strumenti Necessari"},{"location":"javascript/#introduzione","text":"JavaScript \u00e8 un linguaggio di scripting cross-platform e object-oriented. \u00c8 un linguaggio piccolo e leggero. All interno di un ambiente ospite (ad esempio un web browser), JavaScript pu\u00f2 essere connesso agli oggetti del suo ambiente per fornire controllo programmatico su di essi. JavaScript contiene una libreria standard di oggetti come Array, Date e Math, ed una serie di elementi base del linguaggio come operatori, strutture di controllo e dichiarazioni. La base di JavaScript pu\u00f2 essere estesa per una variet\u00e0 di scopi fornendogli oggetti aggiuntivi; ad esempio: Client-side JavaScript estende il linguaggio base fornendo oggetti per controllare il browser ed il suo Document Object Model (DOM). Per esempio, le estensioni client-side permettono ad una applicazione di inserire elementi in un form HTML e rispondere ad eventi dell'utente come il click del mouse, input nei form e navigazione delle pagine. Server-side JavaScript estende il linguaggio base fornendo oggetti rilevanti per eseguire JavaScript in un server. Per esempio le estensioni server-side consentono ad una applicazione di comunicare con un database, forniscono continuit\u00e0 di informazioni da una chiamata ad un altra dell'applicazione, o permettono la manipolazione di files nel server. MDN - Introduzione","title":"Introduzione"},{"location":"javascript/#lezione-02","text":"","title":"Lezione 02"},{"location":"javascript/#cenni-storici","text":"Originariamente sviluppato da Brendan Eich della Netscape Communications con il nome di Mochan e successivamente di LiveScript, in seguito \u00e8 stato rinominato \"JavaScript\" ed \u00e8 stato formalizzato con una sintassi pi\u00f9 vicina a quella del linguaggio Java di Sun Microsystems (che nel 2010 \u00e8 stata acquistata da Oracle). Standardizzato per la prima volta il 1997 dalla ECMA con il nome ECMAScript, l'ultimo standard, di giugno 2017, \u00e8 ECMA-262 Edition 8 ed \u00e8 anche uno standard ISO (ISO/IEC 16262). Wikipedia - JavaScript","title":"Cenni storici"},{"location":"javascript/#aspetti-strutturali","text":"Le caratteristiche principali di JavaScript sono: essere un linguaggio interpretato: il codice non viene compilato, ma eseguito direttamente; in JavaScript lato client, il codice viene eseguito dall'interprete contenuto nel browser dell'utente. la sintassi \u00e8 relativamente simile a quella dei linguaggi C, C++ e Java. definisce le funzionalit\u00e0 tipiche dei linguaggi di programmazione ad alto livello (strutture di controllo, cicli, ecc.) e consente l'utilizzo del paradigma object oriented. \u00e8 un linguaggio debolmente tipizzato. \u00e8 un linguaggio debolmente orientato agli oggetti. Ad esempio, il meccanismo dell'ereditariet\u00e0 \u00e8 pi\u00f9 simile a quello del Self e del NewtonScript che a quello del linguaggio Java, fortemente orientato agli oggetti. Gli oggetti stessi ricordano pi\u00f9 gli array associativi del linguaggio Perl che gli oggetti di Java o C++. Altri aspetti di interesse: in JavaScript lato client, il codice viene eseguito direttamente sul client e non sul server. Il vantaggio di questo approccio \u00e8 che, anche con la presenza di script particolarmente complessi, il web server non rischia sovraccarichi dato che il lavoro viene svolto dal client. Un rovescio della medaglia \u00e8 che, nel caso di script particolarmente grandi, il tempo per il trasferimento dalla rete pu\u00f2 diventare eccessivamente lungo. Inoltre ogni informazione che presuppone un accesso a dati memorizzati in una base di dati remota deve essere rimandata a un linguaggio che effettui materialmente la transazione, per poi restituire i risultati ad una o pi\u00f9 variabili JavaScript; operazioni del genere richiedono un nuovo caricamento della pagina stessa. Questi limiti sono per\u00f2 stati superati in buona parte con la nascita di AJAX. Alcune altre caratteristiche di JavaScript degne di nota: Pu\u00f2 usare caratteri Unicode Pu\u00f2 valutare le espressioni regolari (introdotte nella versione 1.2; supporto da parte dei browser: a partire da Netscape Navigator 4 e Internet Explorer 4) Le espressioni JavaScript contenute in una stringa possono essere valutate usando la funzione eval. Wikipedia - JavaScript","title":"Aspetti strutturali"},{"location":"javascript/#versioni-di-javascript","text":"Un linguaggio di programmazione per essere definito uno standard ha bisogno di essere revisionato da un organo dedicato che prende il nome di ECMA International. Da questo lavoro \u00e8 nato un nuovo standard che prende il nome di ECMAScript, anche se per tutti noi il termine JavaScript \u00e8 rimasto sufficiente per definirlo. Nel corso degli anni lo standard ha definito nuove versioni e aggiornamenti del linguaggio e delle funzionalit\u00e0. Nel contempo i browser si sono adattati alle modifiche introdotte per supportare il nuovo standard. Per orientarsi al supporto allo stato attuale da parte dei browser dei nuovi standard Javascript \u00e8 possibile visionare la seguente tabella: github - es6 table Possiamo affermare che la versione pi\u00f9 utilizzata ad oggi \u00e8 ES6, la ES5 \u00e8 obsoleta ma di fatto ormai anche la ES2016+ \u00e8 supportata da tutti i browser. Indice riassuntivo: ECMAScript \u2013 un linguaggio standardizzato dal ECMA Internetional e supervisionato dal comitato T39; JavaScript \u2013 il nome comune utilizzato per identificare lo standard ECMAScript. Con questo termine non ci rivolgiamo a una specifica versione dello standard, ma piuttosto al suo utilizzo a livello globale o parziale. ECMAScript 5 (ES5) \u2013 questa rappresenta la quinta versione dello standard ECMAScript rilasciata nel 2009. Dato che a oggi i maggiori browser supportano questa versione \u00e8 probabile che sar\u00e0 la pi\u00f9 comune da incontrare. ECMAScript 6 (ES6)/ECMAScript 2015 (ES2015) \u2013 questa rappresenta la sesta versione dello standard ECMAScript rilasciata nel 2015. Al momento non \u00e8 ancora supportata completamente dai nuovi browser e dato che presenta un gran numero di moduli ti consiglio di consultare questa tabella aggiornata. ECMAScript 2016 \u2013 rilasciata a inizio 2016 presenta un esiguo numero di funzionalit\u00e0 implementate e non dovrebbe comportare grossi problemi di compatibilit\u00e0 nei browser in grado di supportare la versione ES2015. skillsandmore - Conosci tutte le versioni di Javascript?","title":"Versioni di Javascript"},{"location":"javascript/#configurazione-di-un-ide","text":"Un ambiente di sviluppo integrato (in lingua inglese integrated development environment ovvero IDE, anche integrated design environment o integrated debugging environment, rispettivamente ambiente integrato di progettazione e ambiente integrato di debugging), in informatica, \u00e8 un ambiente di sviluppo ovvero un software che, in fase di programmazione, supporta i programmatori nello sviluppo e debugging del codice sorgente di un programma: spesso l'IDE aiuta lo sviluppatore segnalando errori di sintassi del codice direttamente in fase di scrittura, oltre a tutta una serie di strumenti e funzionalit\u00e0 di supporto alla fase stessa di sviluppo e debugging. Wikipedia - Integrated development environment","title":"Configurazione di un IDE"},{"location":"javascript/#visual-studio-code-vs-code","text":"Visual Studio Code \u00e8 un editor di codice sorgente sviluppato da Microsoft per Windows, Linux e macOS. Include il supporto per debugging, un controllo per Git integrato, Syntax highlighting, IntelliSense, Snippet e refactoring del codice. Sono personalizzabili il tema dell'editor, le scorciatoie da tastiera e le preferenze. \u00c8 un software libero e gratuito, anche se la versione ufficiale \u00e8 sotto una licenza proprietaria. Visual Studio Code \u00e8 basato su Electron, un framework con cui \u00e8 possibile sviluppare applicazioni Node.js. Wikipedia - Visual Studio Code In questo corso useremo Visual Studio Code come IDE con le seguenti Estensioni: HTML snippets javascript es6 code snippets live server Per installare un'estensione con VS code vi rimando alla seguente immagine animata:","title":"Visual Studio Code - VS code"},{"location":"javascript/#lezione-03","text":"","title":"Lezione 03"},{"location":"javascript/#primo-script","text":"Come integro codice javascript all'interno di una pagina html? - Modo 1: E' possibile inserire codice Javascript direttamente all'interno della pagina html tramite il tag <script></script> . - Modo 2: E' possibile creare un collegamento con un file esterno con estensione .js che rappresenter\u00e0 il file contente codice Javascript. Per creare tale collegamento \u00e8 necessario inserire prima della chiusura del body il seguente link-tag < script src = \"main.js\" ></ script > Modo 1: Codice Javascript interno alla pagina html File html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script > //Stampa \"ciao mondo\" direttamente nella pagina html document . write ( \"ciao mondo\" ); </ script > </ body > </ html > Una volta creato il file \u00e8 possibile aprirlo direttamente con un web browser o tramite l'estensione di VS code live server che permette di lanciare l'aggiornamento della pagina in automatico quando si salva il file Modo 2: Collegamento al file javascript main.js File html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script src = \"main.js\" ></ script > </ body > </ html > File JS //Stampa \"ciao mondo\" direttamente nella pagina html document . write ( \"ciao mondo\" ); Il modo migliore \u00e8 sempre quello di creare file separati per dividere il contesto tra html / css / Javascript soprattutto per progetti grandi e strutturati. In questo corso per motivi di praticit\u00e0 invece utilizzeremo spesso codice Javascript all'interno della pagina html","title":"Primo script"},{"location":"javascript/#lezione-04","text":"","title":"Lezione 04"},{"location":"javascript/#console-browser-web","text":"La console \u00e8 uno strumento molto utile in fase di sviluppo software all'interno del browser web. Segnala errori e warning sintattici dell'interprete javascript ed \u00e8 molto utilizzata in fase di debug. E' uno strumento interattivo, permette quindi la generazione di script Javascript in real-time e di stampare il valore di alcune variabili o strutture dati per monitorare il corretto funzionamento dello script. Il comando console.log() (o per meglio dire il metodo log() dell'oggetto Console , parleremo pi\u00f9 avanti di metodi e oggetti..) stampa un messaggio sulla web console del browser. Il messaggio pu\u00f2 essere una semplice stringa (opzionalmente, anche con valori sostituibili), o pu\u00f2 essere uno qualsiasi o pi\u00f9 oggetti JavaScript. File html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script > //Stampa \"ciao mondo\" direttamente nella pagina html console . log ( \"ciao mondo\" ); </ script > </ body > </ html > Riporto qualche comando (metodo) aggiuntivo della console: console . log ( 'Ciao a tutti' ); //stampa sulla console console . warn ( 'Avvertimento' ); //Genera un warning console . error ( 'questo \u00e8 un errore' ); //Genera un errore console . table ({ name : 'simone' }); //Stampa in formato tabella console . clear (); //Pulisce la console E' bene comuqnue precisare che qualsiasi cosa venga stampata sulla console come log, errori o warning non saranno visibili all'utente ma solo in modalit\u00e0 sviluppatore. Una lista di tutti i metodi applicabili all'oggetto si trova alla pagina MDN - Console","title":"Console - Browser Web"},{"location":"javascript/#alert-prompt","text":"alert() mostra una finestra di avviso contenente il testo specificato mentre prompt() mostra una finestra di dialogo che chiede all'utente di inserire del testo. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script > //Salva l'input ricevuto in una variabile cio\u00e8 un contenitore testuale myName = prompt ( 'Come ti chiami?' ); alert ( \"Il tuo nome \u00e8 ..\" ); //Stampa il valore testuale contenuto nella variabile alert ( myName ); </ script > </ body > </ html > Approfondimenti sul metodo alert() dell'oggetto Window li trovate su MDN - Window.alert() mentre approfondimenti sul metodo prompt() dell'oggetto Window li trovate su MDN - Window.prompt()","title":"Alert &amp; prompt"},{"location":"javascript/#commenti","text":"I commenti sono linee testuali non processate dall'interprete utili per la documentazione del codice. In javascritp ci sono due tipi di sintassi permesse per l'inserimento dei commenti. - // comment : per commenti inline - /* comment */ : per commenti su linee multiple //inline comment /* multi line comment console.log('ciao a tutti'); */","title":"Commenti"},{"location":"javascript/#lezione-05","text":"Attenzione! Questa lezione sembrer\u00e0 troppo approfondita e allo stesso tempo vaga considerato l'argomento che sto per trattare. Non preoccuparti se non capisci granch\u00e8, cerca comunque di cogliere il meccanismo di funzionamento dell'esempio che riporto in fondo alla lezione. Pi\u00f9 avanti tratteremo questi argomenti in modo pi\u00f9 dettagliato e diventer\u00e0 tutto chiaro. Preferisco comunque affrontare questi argomenti \"avanzati\" fin da subito per evitare di basare l'apprendimento di Javascript sul solo comando console.log() . Mi sembra giusto passare all'interazione con html fin da subito per intuire con la pratica le potenzialit\u00e0 di questo linguaggio","title":"Lezione 05"},{"location":"javascript/#introduzione-al-dom","text":"E' utile introdurre fin da subito il concetto di DOM per scrivere codice Javascript in grado di interagire con la pagina html altrimenti saremmo costretti ad utilizzare per tutto il corso console.log() e non vederne un'applicazione pratica. In informatica il Document Object Model (spesso abbreviato come DOM), letteralmente modello a oggetti del documento, \u00e8 una forma di rappresentazione dei documenti strutturati come modello orientato agli oggetti. \u00c8 lo standard ufficiale del W3C per la rappresentazione di documenti strutturati in maniera da essere neutrali sia per la lingua che per la piattaforma. \u00c8 inoltre la base per una vasta gamma di interfacce di programmazione delle applicazioni, alcune di esse standardizzate dal W3C. Nativamente supportato dai browser per modificare gli elementi di un documento HTML, DOM \u00e8 un modo per accedere e aggiornare dinamicamente il contenuto, la struttura e lo stile dei documenti. Per le numerose incompatibilit\u00e0 dovute al diverso tipo di gestione di DOM dai vari browser, il W3C ha stabilito delle specifiche standard. Wikipedia - Document Object Model Nelle lezioni precedenti abbiamo gi\u00e0 utilizzato il concetto di DOM. Un esempio \u00e8 la stampa diretta sulla pagina html: document . write ( \"ciao mondo\" ); Il \"comando\" document.write() \u00e8 in realt\u00e0 un oggetto Javscript document a cui si applica un metodo write() ovvero una funzione richiamabile solo nel contesto di un particolare oggetto (DOM = Document Object Model).","title":"Introduzione al DOM"},{"location":"javascript/#introduzione-alla-libreria-jquery","text":"Vediamo anche il metodo per aggiungere librerie esterne, necessario qualora volessimo utilizzare funzioni particolari di Javascript non presenti nel linguaggio standard. Installeremo JQuery perch\u00e8 \u00e8 una libreria popolare molto utilizzata proprio per la manipolazione del DOM ovvero degli elementi (oggetti) html. jQuery \u00e8 una libreria JavaScript per applicazioni web, distribuita come software libero, distribuito sotto i termini della Licenza MIT. Nasce con l'obiettivo di semplificare la selezione, la manipolazione, la gestione degli eventi e l'animazione di elementi DOM in pagine HTML, nonch\u00e9 semplificare l'uso di funzionalit\u00e0 AJAX, la gestione degli eventi e la manipolazione dei CSS. Le sue caratteristiche permettono agli sviluppatori JavaScript di astrarre le interazioni a basso livello con i contenuti delle pagine HTML. L'approccio di tipo modulare di jQuery consente la creazione semplificata di applicazioni web e contenuti dinamici versatili. Nel 2020, jQuery risulta la libreria JavaScript pi\u00f9 utilizzata in Internet, ovvero \u00e8 presente nel 74,4% dei primi 10 milioni di siti Internet pi\u00f9 popolari secondo W3Techs. Wikipedia - JQuery Scaricate quindi la libreria JQeury da JQuery - download Una volta scaricato il file \u00e8 necessario copiarlo nella root del progetto e creare un collegamento al file html. Vediamo le funzioni base della libreria JQuery. Le approfondiremo quando necessario pi\u00f9 avanti nel corso $() : Selettore di elementi html. E' possibile selezionare un elemento tramite il suo id , la sua classe , un attributo .. Alcuni metodi: val() : legge/scrive l'attributo value dell'elemento selezionato click(functionName) : aggiunge l'evento click all'elemento selezionato e chiama la funzione functionName Vediamo un esempio: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table { border : 1 px dashed black } </ style > </ head > < body > < table > < tr > < td > Nome </ td > < td > < input type = \"text\" id = \"myName\" > </ td > </ tr > < tr > < td > Nuovo Nome </ td > < td > < input type = \"text\" id = \"new-name\" > </ td > </ tr > </ table > < input type = \"button\" value = \"OK\" id = \"btn-ok\" > <!-- Collegamento alla libreria JQuery.--> < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function cambiaNome (){ //Seleziono l'elemento con id \"new-name\" e ne prelevo il valore con il metodo \"val()\" //Memorizzo il risultato in una variabile di nome \"nuovoNome\" nuovoNome = $ ( \"#new-name\" ). val (); //Assegno all'elemento con id \"myName\" il valore associato alla variabile \"nuovoNome\" $ ( \"#myName\" ). val ( nuovoNome ); //Pulisco il contenuto del valore dell'elemento con id \"new-name\" $ ( \"#new-name\" ). val ( \"\" ); } //Associo all'elemento con id \"btn-ok\" un evento. //Al click sull'elemento con id \"btn-ok\" scatta la funzione \"cambiaNome\" $ ( \"#btn-ok\" ). click ( cambiaNome ) </ script > </ body > </ html > ATTENZIONE: Il simbolo $ \u00e8 un alias che sta per jQuery .E' importante saperlo perch\u00e8 ci sono altre librerie che utilizzano il simbolo $ e potrebbero quindi generare un conflitto. Per ovviare a ci\u00f2 \u00e8 possibile utilizzare il nome originale jQuery al posto del suo alias $ . Con il comando $.noConflict() \u00e8 possibile eliminare la definizione dell' alias $ evitando quindi conflitti di ogni genere. A quel punto dovremmo per\u00f2 utilizzare necessariamente jQuery al posto di $","title":"Introduzione alla libreria JQuery"},{"location":"javascript/#dom-ed-eventi","text":"Appena la pagina va in esecuzione il browser deve costruire il DOM ma nel contempo potrebbe gi\u00e0 partire il codice Javascript e l'esecuzione potrebbe portare a qualche errore in certi casi a causa di asincronismo. L'esempio di sopra potrebbe essere uno di questi. Per ovviare a ci\u00f2 \u00e8 necessario racchiudere l'evento all'interno di una funzione anonima: $ ( function (){ //evento }); Vediamolo applicato all'esempio di prima: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table { border : 1 px dashed black } </ style > </ head > < body > < table > < tr > < td > Nome </ td > < td > < input type = \"text\" id = \"myName\" > </ td > </ tr > < tr > < td > Nuovo Nome </ td > < td > < input type = \"text\" id = \"new-name\" > </ td > </ tr > </ table > < input type = \"button\" value = \"OK\" id = \"btn-ok\" > <!-- Collegamento alla libreria JQuery.--> < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function cambiaNome (){ nuovoNome = $ ( \"#new-name\" ). val (); //Assegno all'elemento con id \"myName\" il valore associato alla variabile \"nuovoNome\" $ ( \"#myName\" ). val ( nuovoNome ); //Pulisco il contenuto del valore dell'elemento con id \"new-name\" $ ( \"#new-name\" ). val ( \"\" ); } //L'evento sar\u00e0 pronto a scattare soltanto quando la struttura del DOM sar\u00e0 preparata $ ( function (){ $ ( \"#btn-ok\" ). click ( cambiaNome ) }); </ script > </ body > </ html > In questo modo si ha la sicurezza che il codice javascript e quindi l'evento possa scattare solo dopo la creazione del DOM. Il che non significa che comprende il caricamento di tutti gli oggetti come immagini, video o alcune formattazioni testuali ma solo la struttura html come oggetto Javascript che \u00e8 tuttavia sufficiente al corretto funzionamento del codice Javascript. Altri metodi equivalenti: $ (). ready ( function (){ //event }) $ ( document ). ready ( function () { //event }) $ ( window ). ready ( function () { //event })","title":"DOM ed Eventi"},{"location":"javascript/#lezione-06","text":"","title":"Lezione 06"},{"location":"javascript/#variabili-javascript","text":"Le variabili sono utilizzate per rappresentano dei valori attraverso un nome simbolico chiamato identificatore . var cognome = 'Rossi' ; let nome = 'Mario' ; const eta = 25 ; pi = 3.14 ; Esistono tre tipi di keyword per la dichiarazione di variabili/costanti in JS. var : Questa sintassi pu\u00f2 essere usata per dichiarare sia variabili locali che globali let : Introdotta nelle nuove versioni di JS pu\u00f2 essere usata per dichiarare una variabile locale visibile in un blocco. const : Introdotta nelle nuove versioni di JS \u00e8 utilizzata per creare una costante in sola lettura. Possono inoltre dichiarare una variabile senza nessuna keyword (come fatto negli esempi precedenti) ma \u00e8 da evitare perch\u00e8 sar\u00e0 l'interprete ad assegnare a tale variabile delle propriet\u00e0 Per le variabili dichiarate con let/var valgono le seguenti regole: Posso dichiarare una variabile e non inizializzarla. Se non inizializzata verr\u00e0 attribuita ad essa il valore undefined Posso assegnare il valore di una variabile successivamente nel programma e modificarne il contenuto a piacimento (Variable mutation) Per le variabili dichiarate con const valgono le seguenti regole: Una costante non pu\u00f2 cambiare il suo valore attraverso ulteriori assegnazioni o essere ridichiarata mentre lo script \u00e8 in esecuzione. Deve essere sempre inizializzata ad un valore. let myVar = 4 ; //OK, inizializzazione (dichiarazzione + assegnamento) myVar = 23 ; //OK, assegnamento let myVar2 ; //OK, solo dichiarazione myVar2 = 29 ; //OK, assegnamento successivo alla dichiarazione const myVar = 4 ; //OK, inizializzazione (dichiarazione + assegnazione) myVar = 23 ; //EEROR!! - assegnazione successiva all'inizializzazione const myVar2 ; //EEROR!! - solo dichiarazione Quando usare const, let o var E' sempre meglio usare const per tutte le strutture dati che non cambiano nel tempo, \u00e8 pi\u00f9 sicuro. E' necessario usare let o var solo per le variabili o strutture dati che cambiano valore nel tempo. Tra let e var \u00e8 preferibile usare let per mantenere la regola della visibilit\u00e0 all'interno di un blocco (l'argomento visibilit\u00e0 delle variabili verr\u00e0 trattato pi\u00f9 avanti).","title":"Variabili Javascript"},{"location":"javascript/#tipi-di-dati-in-js","text":"L'ultimo standard ECMAScript definisce sette tipi di dati: Sei tipi di dato che sono primitives : Boolean . true e false. null . Una parola chiave che denota un valore nullo. undefined . Una propriet\u00e0 il cui valore non \u00e8 stato definito. Number . 42 oppure 3.14159. String . \"Salve\" Symbol (nuovo in ECMAScript 2015). Un tipo di dato la cui istanza \u00e8 unica e immutabile. Due Reference Type Object Array NOTA: typeof \u00e8 una propriet\u00e0 di Javascript che stampa (ritorna) il tipo di un oggetto o una variabile.","title":"Tipi di dati in JS"},{"location":"javascript/#dati-nativi","text":"//String //Le stringhe si indicano attraverso i singoli apici 'mystring' //attraverso i doppi apici \"myString\" o l'accento grave `myString` const nome = 'simone' ; //Number const temp = - 1.5 ; //Boolean const isMaggiorenne = true ; //Null const value = null ; //Interessante da vedere console . log ( typeof value ); //Undefined const cognome = undefined ; //Symbol const mySymbol = Symbol ();","title":"Dati nativi"},{"location":"javascript/#reference-type","text":"Gli array sono tipi di dato Reference Type utilizzati per raggruppare diversi dati appartenenti alla stessa categoria, ovvero un insieme di dati omogenei. Gli object anch'essi Reference Type sono utilizzati per raggruppare qualit\u00e0 / caratteristiche di una struttura dati pi\u00f9 complessa, in genere eterogenea. //Arrays const nomi = [ 'simone' , 'matteo' , 'giovanni' ]; //Accedo ai campi di un array con l'operatore di indicizzazione [] // 0 1 2 //const nomi = ['simone', 'matteo', 'giovanni']; console . log ( nomi [ 1 ]); //matteo //Objects const persona = { nome : 'simone' , eta : 25 , isMarry : true } //Accedo ai campi di un Object spcificando il nome della propriet\u00e0 dell'oggetto console . log ( persona . nome ); //simone Formalizzeremo pi\u00f9 avanti sia la struttura dei dati primitivi sia la struttura dei reference type.","title":"Reference type"},{"location":"javascript/#alcune-regole-generali-per-dichiarazione-di-variabili","text":"Usare sempre dei nomi significativi e esplicativi per le variabili Usare sempre il camelCase quando la variabile \u00e8 composta da due o pi\u00f9 parole Non si pu\u00f2 usare un numero, un # , una @ come inizio del nome di una variabile. E' accettanto invece il simbolo`$ Non si possono utilizzare, come identificatore, le keyword native di JS come: function , if , delete .. E' possibile dichiarare pi\u00f9 variabili/costanti nello stesso statement, separando le dichiarazioni con una virgola. Vediamo qualche esempio qua sotto: //Sintassi alternativa per dichiarare pi\u00f9 costanti const na = 3 , pigreco = 3.14 ; _iou = 0 ; $yui = 78 ; u - 1 = 45 ; //ERROR!! 1 T = 1 ; //ERROR!!","title":"Alcune regole generali per dichiarazione di variabili"},{"location":"javascript/#reference-type-const","text":"ATTENZIONE: Se un oggetto/array \u00e8 dichiarato const non significa che non \u00e8 possibile modificare i campi all'interno ma solo che non posso cambiare la natura dell'oggetto/array. QUesto proprio perch\u00e8 gli oggetti/arrays sono, a differenza dei dati primitivi, dei reference type. Il loro nome rappresenta solo l'indirizzo per accedere al dato in memoria e non il dato in memoria. Questo concetto per adesso pu\u00f2 sembrare poco chiaro ma i reference type verranno trattati ampiamente nelle sezioni pi\u00f9 avanti. const myObj { nome : 'simone' , cognome : 'di ricco' , eta : 34 } myObj . nome = 'luca' ; //OK myOby = 5 ; //ERROR perch\u00e8 in questo caso cambierei la natura dell'oggetto. Da oggetto diventerebbe un <number> let myObj2 { ram : 4 , rom : 5 , anno : 2010 } myObj2 . ram = 6 ; //OK myObj2 = 18 ; //OK \u00e8 permesso in JS. Ecco perch\u00e8 si dovrebbe usare <const> invece di <let> quando \u00e8 possibile","title":"Reference type Const"},{"location":"javascript/#approfondimento-null-undefined-nan","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso undefined : Si verifica quando un oggetto o una variabile non assume nessun valore null : E' un valore attributo in fase di programmazione per identificare che un dato oggetto o variabile non assume nessun valore. Differisce da undefined poich\u00e8 null \u00e8 previsto deliberatamente in fase di programmazione NaN : Viene restituito quando l'espressione numerica valutata non restituisce un Number Esempio 1: console . log ( null === undefined ); //false NOta: Per controllare gli stati di null e undefined \u00e8 possibile utilizzare direttamente le keyword null e undefined come nell'esempio sopra illustrato. La stessa cosa non vale per NaN . In questo caso conviene utilizzare IsNaN() . //Attenzione console . log ( NaN != NaN ); //true !!!!","title":"Approfondimento Null - undefined - NaN"},{"location":"javascript/#lezione-07","text":"","title":"Lezione 07"},{"location":"javascript/#stringhe","text":"Una stringa \u00e8 un tipo di dato formato da zero o pi\u00f9 caratteri racchiusi tra virgolette doppie \" \" , singole ' ' o tramite accento grave. \u00c8 possibile chiamare qualsiasi metodo dell'oggetto String su una stringa. const saluto = 'Ciao a tutti' ; //Stringa multi-line. Attenzione all'apice -accento grave- var fraseFilosofica = `Il mattino ha l'oro in bocca. La sera no` ;","title":"Stringhe"},{"location":"javascript/#opearotri-proprieta-e-metodi-su-stringhe","text":"","title":"Opearotri, Propriet\u00e0 e Metodi su stringhe"},{"location":"javascript/#operatori","text":"+ : Uninione/concatenazione di stringhe. [ index ] : Indicizzazione di una stringa come array di caratteri, in sola lettura <, > : operatori di confronto tra stringhe. Ritornano un boolean , true/false {} : Interpolazione di stringhe const nome = \"marco\" ; const cognome = \"rossi\" ; console . log ( nome + \" \" + cognome ); //marco rossi // 0,1,2,3,4 //const cognome = \"r o s s i\"; console . log ( cognome [ 1 ]); //\"o\" console . log ( nome > cognome ); //true","title":"Operatori"},{"location":"javascript/#approfondimento-interpolazioni-di-stringhe","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. E' possibile utilizzare espressioni all'interno di un unica stringa. Per far cio' si ricorre all'interpolazione di stringhe molto comune anche in altri linguaggi di programmazione. La sintassi prevede di usare SOLO l'accento grave e per le espressioni da valutare, l'operatore $ seguito dall'espressione racchiusa tra le parentesi graffe { } let index = 0 ; //La variabile \"index\" viene valuta console . log ( ` ${ index } ciao` ); //0 index = index + 1 ; console . log ( ` ${ index } ciao` ); //1","title":"Approfondimento Interpolazioni di stringhe"},{"location":"javascript/#le-stringhe-sono-immutabili","text":"!! LE STRINGHE SONO IMMUTABILI IN JAVASCRIPT !! Questo significa che dal punto di vista semantico le stringhe non possono essere trattate come array di caratteri e di fatto non \u00e8 possibile applicare alle stringhe i metodi applicabili agli array. var saluto = \"ciao\" saluto [ 2 ] = 'Z' ; //Attenzione! LE STRINGHE SONO IMMUTABILI console . log ( saluto ); //ciao L'unico modo per cambiare un carattere all'interno di una stringa \u00e8 distruggere l'intera stringa e ricostruirne un'altra con il carattere modificato tramite assegnamento. Non \u00e8 possibile tuttavia modificre direttamente il singolo carattere di una stringa. var saluto = \"ciao\" saluto [ 2 ] = '2' ; console . log ( saluto ); //ciao saluto = \"super ciao\" console . log ( saluto ); //super ciao","title":"Le stringhe sono immutabili"},{"location":"javascript/#proprieta","text":"La propiet\u00e0 .lenght restituisce il numero di caratteri presenti nella stringa. const nome = \"marco\" ; console . log ( nome . lenght ); //5 console . log ( \"ciao\" . lenght ); //4","title":"Propriet\u00e0"},{"location":"javascript/#metodi","text":"Vediamo adesso diversi metodi applicabili alle stringhe. Pi\u00f9 avanti, quando tratteremo gli oggetti capiremo meglio la terminologia metodo/propriet\u00e0/operatore. Per adesso \u00e8 importante capirne gli esempi applicativi e imparare ad usare le stringhe per intuirne le potenzialit\u00e0. toUpperCase() : - Parametri : - Tipo di Ritorno : String - Descrizione : Ritorna la stringa in caratteri maiuscoli console . log ( \"simOne di rIcco\" . toUpperCase ()); //SIMONE DI RICCO toLowerCase() : - Parametri : - Tipo di Ritorno : String - Descrizione :Ritorna la stringa in caratteri minuscoli console . log ( \"SimOne di rICco\" . toLowerCase ()); //simone di ricco charAt(index) : - Parametri : index ( Number ) - Tipo di Ritorno : String - Descrizione : Restituisce il carattere all'interno della stringa corrispondente all'indice index (Ottenibile anche tramite l'indicizzazione [ ]) console . log ( \"JaVascript\" . charAt ( 3 )); //a substring(indexStart, indexEnd) : - Parametri : indexStart ( Number ), indexEnd ( Number ) - Tipo di Ritorno : String - Descrizione : Ritorna la porzione di stringa compresa tra indexStart incluso e indexEnd escluso. console . log ( \"JaVascript language\" . substring ( 0 , 10 )); //JaVascript endsWith(param) - Parametri : param ( String ) - Tipo di Ritorno : boolean - Descrizione :ritorna un boolean se la stringa termina o meno con la stringa param console . log ( \"myPdfFile.pdf\" . endsWith ( \"pdf\" )); //true console . log ( \"01110000011\" . endsWith ( \"10\" )); //false startsWith(string) : - Parametri : param ( String ) - Tipo di Ritorno : boolean - Descrizione :ritorna un boolean (true/false) se la stringa inizia o meno con la stringa param console . log ( \"01110000011\" . startsWith ( \"0111\" )); //true .includes(param1, ?param2) : - Parametri : param1 ( String ), param2 ( Number ), - Tipo di Ritorno : boolean - Descrizione : cerca la stringa param1 a partire dall'indice opzionale param2 , ritorna true o false. Se param2 \u00e8 omesso cerca param1 in tutta la stringa console . log ( \"JaVascript is programming language\" . includes ( \"is\" )); //true console . log ( \"JaVascript is programming language\" . includes ( \"is\" , 16 )); //false indexOf(param1, ?param2) : - Parametri : param1 ( String ), param2 ( Number ), - Tipo di Ritorno : Number - Descrizione : Cerca la prima occorrenza della stringa param1 a partire dall'indice opzionale param2 . Restituisce l'indice della posizione di param1 . Se non trova param1 nella stringa restituisce -1. Se param2 \u00e8 omesso cerca param1 in tutta la stringa a partire dall'inizio della stringa. console . log ( \"0011010111000110\" . indexOf ( \"111\" )); //7 console . log ( \"0011010111000110\" . indexOf ( \"111\" , 10 )); //-1 lastIndexOf(param1, param2) : - Parametri : param1 ( String ), param2 ( Number ), - Tipo di Ritorno : Number - Descrizione : Cerca l'ultima occorrenza della stringa param1 vincolato dall'indice limite param2 . Restituisce l'indice della posizione di param1 . Se param2 \u00e8 omesso cerca param1 in tutta la stringa a partire dalla fine della stringa. padEnd(param1, param2) : - Parametri : param1 ( Number ), param2 ( String ), - Tipo di Ritorno : String - Descrizione : Riempie la stringa fino a una lunghezza massima di param1 , aggiungendo come riempitivo in coda la stringa param2 console . log ( \"100\" . padEnd ( 5 , \"-\" )); //100-- console . log ( \"100000\" . padEnd ( 5 , \"-\" )); //100000 console . log ( \"\" . padEnd ( 5 , \"-\" )); //----- padStart(param1, param2) : - Parametri : param1 ( Number ), param2 ( String ) - Tipo di Ritorno : String - Descrizione : Riempie la stringa fino a una lunghezza massima di param1 , aggiungendo come riempitivo in testa la stringa param2 console . log ( \"120\" . padStart ( 5 , \"0\" )); //00120 console . log ( \"9040\" . padStart ( 5 , \"0\" )); //09040 console . log ( \"2\" . padStart ( 5 , \"0\" )); //00002 repeat(param) : - Parametri : param ( Number ) - Tipo di Ritorno : String - Descrizione : Replica la stringa un numero di volte specificato da param console . log ( \"0\" . repeat ( 32 )); //00000000000000000000000000000000 console . log ( \"*-\" . repeat ( 8 )); //*-*-*-*-*-*-*-*- replace(param1, param2) : - Parametri : param1 ( String ), param2 ( String ) - Tipo di Ritorno : String - Descrizione : Sostituisce la prima occorennza della stringa param1 con la stringa param2 . Funziona anche se param1 \u00e8 un'espressione regolare. console . log ( \"Ciao a tutto il mondo\" . replace ( \"o\" , \"0\" )); //Cia0 a tutto il mondo //Uso interessante del metodo replace() con un'espressione regolare. /o/g >>> cerca tutte le occorrenze //di \"o\". Nota che \"g\" sta per \"global\" cio\u00e8 tutte console . log ( \"Ciao a tutto il mondo\" . replace ( /o/g , \"0\" )); //Cia0 a tutt0 il m0nd0 search(param) : - Parametri : param ( String ) - Tipo di Ritorno : Number - Descrizione : cerca la prima occorenza di param e restituisce l'indece della posizione. Funziona anche se param \u00e8 un'espressione regolare. console . log ( \"Ciao a tutto il mondo\" . search ( \"mondo\" )); //16 console . log ( \"Ciao a tutto il mondo\" . search ( \"ill\" )); //-1 slice(indexStart, indexEnd) : - Parametri : indexStart ( Number ), indexEnd ( Number ) - Tipo di Ritorno : String - Descrizione : Restituisce una sottostringa tra indexStart e indexEnd console . log ( \"DRCSMN91L22E715Q\" . slice ( 6 , 8 )); //91 split(separatore, ?max) : - Parametri : separatore ( String ), max ( Number ) - Tipo di Ritorno : Array of String - Descrizione : Pu\u00f2 essere utilizzato per raggruppare delle stringhe sottoforma di array contenute in un unica grande stringa e separate tramite un separatore. Crea quindi un array di stringhe contenente porzioni di stringa derivate dalla stringa a cui \u00e8 applicato il metodo separate dal carattere (o i caratteri) come indicato nel parametro separatore . Il secondo parametro, opzionale, indica il numero massimo di elementi dell'array. const myArray = \"Ciao a tutto il mondo\" . split ( \" \" ); console . log ( myArray ); //(5) [\"Ciao\", \"a\", \"tutto\", \"il\", \"mondo\"] console . log ( myArray [ 3 ]); //il const myArray2 = \"Ciao a tutto il mondo\" . split ( \" \" , 3 ); console . log ( myArray2 ); //(3) [\"Ciao\", \"a\", \"tutto\"] trim() : - Parametri : - Tipo di Ritorno : String - Descrizione : rimuove gli spazi all'inizio e alla fine di una stringa console . log ( \"#\" + \" Ciao a tutto il mondo \" . trim () + \"#\" ); //#Ciao a tutto il mondo# trimLeft() : - Parametri : - Tipo di Ritorno : String - Descrizione : rimuove gli spazi in testa a una stringa. console . log ( \"#\" + \" Ciao a tutto il mondo \" . trimLeft () + \"#\" ); //#Ciao a tutto il mondo # trimRight() : - Parametri : - Tipo di Ritorno : String - Descrizione : rimuove gli spazi in coda a una stringa console . log ( \"#\" + \" Ciao a tutto il mondo \" . trimRight () + \"#\" ); //# Ciao a tutto il mondo#","title":"Metodi"},{"location":"javascript/#lezione-08","text":"","title":"Lezione 08"},{"location":"javascript/#conta-parole","text":"Il seguente esempio conta le parole inserite in un certo input testuale. Faremo uso dell'evento keypress che scatta ad ogni tasto premuto e del metodo su stringa split() <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > Conta parole </ h1 > < table > < td > Testo: </ td > < tr > < td >< textarea cols = \"30\" rows = \"10\" id = \"myText\" ></ textarea ></ td > </ tr > < tr > < td > Parole nel testo: </ td > </ tr > < tr > < td >< input type = \"text\" id = \"word-count\" ></ td > </ tr > </ table > <!-- Collegamento alla libreria JQuery.--> < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function contaParole (){ //Prelievo il valore dell'elemento con id=\"myText\" lo converto a stringa e lo assegno alla variabile testoInserito let testoInserito = String ( $ ( \"#myText\" ). val ()); //Prelievo la propriet\u00e0 lenght di un array formato da parole separate da spazi. //ATTENZIONE. NON FUNZIONA CON I DOPPI SPAZI let conteggioParole = ( testoInserito . split ( \" \" ). length ); $ ( \"#word-count\" ). val ( conteggioParole ) } $ ( function (){ $ ( \"#myText\" ). keypress ( contaParole ) }); </ script > </ body > </ html >","title":"Conta parole"},{"location":"javascript/#lezione-09","text":"","title":"Lezione 09"},{"location":"javascript/#approfondimento-rappresentazione-numerica-in-javascript","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso","title":"Approfondimento - Rappresentazione numerica in Javascript"},{"location":"javascript/#numeri-in-fixed-point","text":"Per il tipo nativo Number Javascript utilizza 64 bit per la memorizzazione in ram sia per i numeri interi sia per i numeri decimali a \"virgola fissa\" (fixed point). Vengono utilizzati 53 bit per la parte intera e i restanti 9 per la parte decimale anche se un numero \u00e8 intero. Il numero intero (safe) pi\u00f9 grande rappresentabile in JS \u00e8 MAX_SAFE_INTEGER . MAX_SAFE_INTEGER : E' il numero intero pi\u00f9 grande a cui posso applicare un incremento in modo affidabile. Il metodo isSafeInteger() applicato all'oggetto Number ritorna un boolean che indica se il numero \u00e8 safe oppure no console . log ( Number . MAX_SAFE_INTEGER ); //9007199254740991 /* (property) NumberConstructor.MAX_SAFE_INTEGER: number The value of the largest integer n such that n and n + 1 are both exactly representable as a Number value. The value of Number.MAX_SAFE_INTEGER is 9007199254740991 2^53 \u2212 1. */ let n1 = Number . MAX_SAFE_INTEGER ; //OK, safe console . log ( Number . isSafeInteger ( n1 )); //true let n2 = Number . MAX_SAFE_INTEGER + 1 ; //OK, safe console . log ( Number . isSafeInteger ( n2 )); //true let n3 = Number . MAX_SAFE_INTEGER + 1 //NO, non safe, il risultato non \u00e8 affidabile console . log ( Number . isSafeInteger ( n3 )); //false","title":"Numeri in Fixed Point"},{"location":"javascript/#numeri-in-floating-point","text":"La rappresentazione dei numeri in \"virgola mobile\" (floating point) Javascript utilizza lo standard IEEE 754 //MAX_VALUE rappresenta il pi\u00f9 grande numero rappresentabile in virogla mobile console . log ( Number . MAX_VALUE ); //1.7976931348623157e+308 //Attenzione!! console . log ( 0.1 + 0.2 == 0.3 ); //false console . log ( 0.1 + 0.2 ); //0.30000000000000004 Lo standard IEE754 rappresenta i numeri reali e come tale \u00e8 necessario conoscere ed evitare alcune pratiche di cattivo utilizzo dei numeri reali. In generale con i numeri reali \u00e8 da evitare l'utilizzo di espressioni di uguglianza. E' possibile tuttavia trasformare un'espressione di uguaglianza esatta con un'espressione di \"vicinanza\" definendo un'accuratezza in questo modo: const accuracy = 0.0000001 ; console . log ( ( 0.1 + 0.2 ) - 0.3 < accuracy ); //true Il pi\u00f9 piccolo valore rappresentabile (vicino allo zero) in floating point \u00e8: console . log ( Number . MIN_VALUE ); //5e-324 E' bene ricordare che la rappresentazione dei numeri con lo standard IEEE 754 \u00e8 su scala logaritimica quindi non lineare. Questo significa che posso rappresentare numeri estremamente grandi e numeri estremamente piccoli ma la distanza tra due numeri diventa sempre pi\u00f9 grande (e quindi meno accurata) mano a mano che i numeri diventano grandi e diventa pi\u00f9 piccola (quindi pi\u00f9 accurata) mano a mano che i numeri diventano piccoli","title":"Numeri in Floating Point"},{"location":"javascript/#not-a-number-nan","text":"Javascript restituisce NaN quando valuta che un'espressione non pu\u00f2 essere svolta e darebbe errore. console . log ( 10 / \"ciao\" ); //NaN console . log ( 0 / 0 ); //NaN E' buona norma evitare NaN in special modo per quelle espressioni numeriche non prevedibili o che ricevono valori dall'esterno. La funzione isNaN() restituisce un boolean se un dato valore risulta o meno un NaN. let myVar = 12 / 0.9 ; if ( ! isNaN ( myVar ) ) { console . log ( myVar ); }","title":"Not A Number NaN"},{"location":"javascript/#lezione-10","text":"","title":"Lezione 10"},{"location":"javascript/#approfondimento-codifica-caratteri-javascript","text":"Questa parte per adesso potrebbe essere troppo approfondita, \u00e8 possibile saltarla senza pregiudicare il corso","title":"Approfondimento - Codifica caratteri Javascript"},{"location":"javascript/#ascii","text":"ASCII (acronimo di American Standard Code for Information Interchange, Codice Standard Americano per lo Scambio di Informazioni) \u00e8 un codice per la codifica di caratteri. Lo standard ASCII \u00e8 stato pubblicato dall'American National Standards Institute (ANSI) nel 1968 Con US-ASCII si intende un sistema di codifica dei caratteri a 7 bit, comunemente utilizzato nei calcolatori, proposto dall'ingegnere dell'IBM Bob Bemer nel 1961, e successivamente accettato come standard dall'ISO, con il nome di ISO/IEC 646. Alla specifica iniziale basata su codici di 7 bit fecero seguito negli anni molte proposte di estensione ad 8 bit e quindi 256 caratteri, con lo scopo di raddoppiare il numero di caratteri rappresentabili. Nei PC IBM si fa per l'appunto uso di una di queste estensioni, ormai standard de facto, chiamata extended ASCII o high ASCII. In questo ASCII esteso, i caratteri aggiunti sono vocali accentate, simboli semigrafici e altri simboli di uso meno comune. I caratteri di ASCII esteso sono codificati nei cosiddetti codepage. Ogni paese present\u00f2 la sua proposta di ASCII esteso per rappresentare e codificare tutti i caratteri aggiuntivi relativi alla lingua creando non pochi problemi di comunicazione tra continenti. C'era quindi bisogno di uno standard nuovo e unico per tutto il mondo. Nasce quindi l'UNICODE. Wikipedia - ASCII","title":"ASCII"},{"location":"javascript/#unicode","text":"Unicode \u00e8 stato creato per risolvere i limiti dei tradizionali schemi di codifica dei caratteri Ad esempio , sebbene i caratteri definiti nella ISO 8859-1 siano ampiamente utilizzati in paesi diversi, spesso si verifica incompatibilit\u00e0 tra paesi diversi. Molti metodi di codifica tradizionali hanno un problema comune, ovvero consentono ai computer di gestire un ambiente bilingue (di solito utilizzando lettere latine e le loro lingue native), ma non possono supportare un ambiente multilingue allo stesso tempo (riferendosi a una situazione in cui pi\u00f9 lingue possono essere mescolate contemporaneamente). Unicode era stato originariamente pensato come una codifica a 16 bit (quattro cifre esadecimali) che dava la possibilit\u00e0 di codificare 65.535 (2^16 -1) caratteri. Tanto si riteneva essere sufficiente per rappresentare i caratteri impiegati in tutte le lingue scritte del mondo. Ora invece lo standard Unicode, che tendenzialmente \u00e8 perfettamente allineato con la norma ISO/IEC 10646, prevede una codifica fino a 21 bit e supporta un repertorio di codici numerici che possono rappresentare circa un milione di caratteri. Ci\u00f2 appare sufficiente a coprire anche i fabbisogni di codifica di scritti del patrimonio storico dell'umanit\u00e0, nelle diverse lingue e negli svariati sistemi di segni utilizzati. Al 2009, solo una piccolissima parte di questa disponibilit\u00e0 di codici \u00e8 assegnata. Per lo sviluppo dei codici sono infatti previsti 17 \"piani\" (\"planes\", in inglese), da 00 a 10hex, ciascuno con 65.536 posizioni (quattro cifre esadecimali), ma solo i primi tre e gli ultimi tre piani sono ad oggi assegnati[2], e di questi il primo, detto anche BMP, \u00e8 praticamente sufficiente a coprire tutte le lingue pi\u00f9 usate. Concretamente, questo repertorio di codici numerici \u00e8 serializzato mediante diversi schemi di ricodifica, che consentono l'uso di codici pi\u00f9 compatti per i caratteri usati pi\u00f9 di frequente. \u00c8 previsto l'uso di codifiche con unit\u00e0 da 8 bit (byte), 16 bit (word) e 32 bit (double word), descritte rispettivamente come UTF-8, UTF-16 e UTF-32. UTF-8 \u00e8 di fatto lo standard successore di ASCII, perfettamente compatibile mentre javascript utilizza l'UTF-16 consentendo di rappresentare un numero elevato di caratteri, 655536. Ci\u00f2 non significa che per le codifiche UTF-8 e UTF-16 non sia possibile rappresentare tutti i caratteri unicode ma a causa della codifica potrebbe non essere conveniente in certe situazioni utilizzare UTF-8 anzich\u00e8 UTF-16. In certe situazioni infatti UTF-8 potrebbe aver bisogno di 3 byte per rappresentare un certo carattere mentre UTF-16 soltanto 2. Dipende dalla frequenza e natura dei caratteri. Si rirprenda il template html: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > </ body > </ html > Alla riga < meta charset = \"UTF-8\" > E' indicata la codifica necessaria per la trasmissione e visualizzazione corretta dei caratteri. Wikipedia - Unicode Wikibooks - Unicode/Character reference/0000-0FFF","title":"Unicode"},{"location":"javascript/#caratteri-di-escape","text":"Il backslash \\ indica la presenza di un carattere escape che non sarebbe possibile inserire direttamente con un editor di testo poich\u00e8 verrebbe interpretato come un comando. Vediamo qualche carattere di escape: \\n : a capo \\t : tab \\b : Backspace \\r : Carriage return \\\\ : Backslash \\' : Single quote \\\" : Double quote Introdotti gli escape \u00e8 possibile vedere come inserire un carattere UNICODE tramite il suo codice identificatico: \\u{codice_unicode} let str = \"\\u{1234}\" ; // \u1234 === 1234 codice unicode, 1 carattere console . log ( str ); console . log ( str , str . lenght ); //\u1234, 1 //Attenzione!! la codifica UTF-16 non raggiunge direttamnte il carattere stampato qui di seguito //Utilizza quindi 2 caratteri Javascript let str = \"\\u{1F600}\" ; // \ud83d\ude00 === 1F600 codice unicode, 2 caratteri console . log ( str , str . lenght ); //\ud83d\ude00, 2 Posso risalire al codice unicode tramite il metodo charCodeAt(index) che restituisce il codice unicode del carattere specificato da index . let str = \"\\u{1F600}\" ; // \ud83d\ude00 === 1F600 codice unicode 2 caratteri console . log ( str ); //\ud83d\ude00 console . log ( str . charCodeAt ( 0 ), strCharCodeAt ( 1 )); //55357 56832 C'\u00e8 anche il metodo che pi\u00f9 completo charCodePointAt(index) che restituisce il codice unicode che inizia da index . Questo \u00e8 necessario per quei caratteri che non possono essere rappresentati da UTF-16 e che quindi sono necessari \"due caratteri\" Javascript let str = \"\\u{1F600}\" ; // \ud83d\ude00 === 1F600 codice unicode 2 caratteri console . log ( str ); //\ud83d\ude00 console . log ( str . codePointAt ( 0 )); // 128512 === 1F600 Posso usare l'unicode anche per il nome di variabili! Da evitare. var \\ u { 1 f68 } = 2017 ; // \u1f68","title":"Caratteri di Escape"},{"location":"javascript/#lezione-11","text":"","title":"Lezione 11"},{"location":"javascript/#type-conversion","text":"JavaScript \u00e8 un linguaggio con tipi assegnati dinamicamente. Questo significa che non si va a specificare il tipo di dato che una variabile conterr\u00e0 quando viene dichiarata e anche che il tipo di un dato viene convertito automaticamente a seconda delle necessit\u00e0 durante l'esecuzione dello script. Nelle espressioni che coinvolgono valori numerici e stringhe con l'operatore + JavaScript converte i valori numerici in stringhe (conversione implicita). Vediamo come formalizzare questi concetti e distinguere tra conversioni esplicite e implicite.","title":"Type conversion"},{"location":"javascript/#conversione-esplicita","text":"E' una pratica di buona programmazione far riferimento a conversioni esplicite come trattamento di errori o ricezione dati dall'esterno anche quando \"sembra\" che non sia necessario. La conversione esplicita forza un tipo e previene in molti casi errori di mal interpretazione dei dati. Vediamo alcune soluzioni disponibili per la conversione esplicita tra tipi in Javascript. String(value) : converte value (qualsiasi tipo) in un tipo String value.toString() : metodo che converte value in una stringa (equivalente a String(value) ) Number(value) : converte value in un tipo Number parseInt(value) - converte value in un tipo Number e ritorna la parte intera parseInt(value) - converte value in un tipo Number e ritorna la parte frazionaria //Number to string - String(value) let value = 45 ; String ( value ); //ritorna la stringa '45' //Boolean to string - String(value) let value2 = false ; String ( value2 ); //ritorna la stringa 'false' //Metodo alternativo - toString(); let value3 = false ; ( value3 ). toString (); //ritorna la stringa 'false' //String to number - Number(string) let string = '45' ; Number ( string ); //ritorna il numero 45 //Boolean to number - Number(string) let myBool = true ; Number ( myBool ); //1ritorna il numero 1 parseInt ( '100.31' ); //100 parseFloat ( '100.31' ); //31","title":"Conversione esplicita"},{"location":"javascript/#conversione-implicita","text":"Anche se \u00e8 sconsigliato affidarsi alle conversioni implicite, cio\u00e8 quelle che Javascript effettua implicitamente incontrando in una espressione due o pi\u00f9 valori appartenenti a tipi diversi, \u00e8 bene conoscerle per difendersi e saperle trattare. In alcuni semplici casi non \u00e8 comunque sbagliato utilizzarle. Riporto un esempio qui sotto: // Type coercion const nome = 'marco' ; const cognome = 'rossi' ; const eta = 20 ; const sposato = false ; console . log ( nome + ' ' + cognome + ' ha ' + eta + ' anni. ' + '\u00e9 sposato? ' + sposato ); /* Console: --------------- marco rossi ha 20 anni. E' sposato? false */ Notiamo che la variabile eta \u00e8 stata convertita da tipo numero a tipo stringa e la variabile sposato \u00e8 stata convertita da boolean a stringa in modo implicito da javascript. Queste sono conversioni effettuate in modo automatico da javascript poich\u00e8 nella stessa espressione si trovano tipi diversi.","title":"Conversione implicita"},{"location":"javascript/#lezione-12","text":"","title":"Lezione 12"},{"location":"javascript/#operatori-matematici","text":"Vediamo alcuni operatori matematici direttamente con un esempio: /* operatori matematici */ const questAnno = 2020 ; const etaMarco = 25 ; const etaStefano = 22 ; const nascitaMarco = questAnno - etaMarco ; const nascitaStefano = questAnno - etaStefano ; console . log ( nascitaMarco ); //1995 console . log ( nascitaStefano ); //1998 console . log ( 5 * 2 ); //10 console . log ( 5 / 2 ); //2.5 // Modulo: resto della divisione intera console . log ( 7 % 4 ); //3","title":"Operatori matematici"},{"location":"javascript/#pre-e-post-incrementodecremento","text":"L'operatore di incremento incrementa (aggiunge uno a) il suo operando e restituisce un valore. ++x / --x : pre incremento/decremento restituisce il valore dopo l'incremento x++ / x-- : post incremento/decremento restituisce il valore prima di incrementare Pre e post incremento/decremento rilevano una differenza solo in caso di valutazione di un'espressione. Se troviamo Pre e post incremento/decremento isolati in un singolo statement (come spesso accade) risultano equivalenti. //Pre incremento x = 0 ; y = ++ x ; //y=1, x=1 //Post incremento x = 0 ; y = x ++ ; //y=0, x=1 x = 0 ; x ++ ; //x=1 // in questo caso \u00e8 equivalente a ++x x = 0 ; ++ x ; //x=1 // in questo caso \u00e8 equivalente a x++ La lista di tutti gli operatori aritmetici la troviamo alla pagina: MDN - Operatori Aritmetici","title":"Pre e post incremento/decremento"},{"location":"javascript/#oggetto-math","text":"In JS \u00e8 possibile utilizzare funzioni matematiche avanzate tramite l'oggetto Math . Vediamo alcune tra le pi\u00f9 comuni: Math.round(value) : Ritorna l'arrotondamento di value al numero pi\u00f9 vicino Math.ceil(value) : Ritorna l' arrotondamento di value per eccesso Math.floor(value) : Ritorna l' arrotondamento di value per difetto Math.trunc(value) : Ritorna il troncamento di value Math.sqrt(value) : Ritorna la radice quadrata di value Math.abs(value) : Ritorna il valore assoluto di value Math.pow(base, exp) : Ritorna l'esponenziale: base^exp Math.min(value1, value2, value3, ..) : Ritorna il minimo valore tra i parametri indicati tra gli argomenti Math.max(value1, value2, value3, ..) : Ritorna il massimo valore tra i parametri indicati tra gli argomenti Math.random() : Ritorna un numero random decimale nel range 0 - 1 Esempio: //Math.PI console . log ( Math . PI ); //stampa del numero pi greco: 3,14.. Math . round ( 42.1 ); //42 Math . round ( 42.5 ); //43 Math . round ( 42.7 ); //43 Math . ceil ( 42.1 ); //43 Math . ceil ( 42.5 ); //43 Math . ceil ( 42.7 ); //43 Math . floor ( 42.1 ); //42 Math . floor ( 42.5 ); //42 Math . floor ( 42.7 ); //42 Math . sqrt ( 25 ); //5 Math . sqrt ( 42.5 ); //6. Math . abs ( - 25 ); //25 Math . abs ( 42.5 ); //42.5 Math . pow ( 2 , 5 ); //32 ( 2 ** 5 ); //32 === 2^5 >> equivalente a Math.pow(2, 5); Math . pow ( 5 , 3 ); //125 Math . min ( 2 , 5 , - 2 , 6 ); //-2 Math . max ( 2 , 5 , - 2 , 6 ); //6 Math . random (); //0.234514378429 Math . trunc ( 12.78899 ); //12 La seguente riga di codice genera un numero casuale da 0 a 100. console . log ( Math . round (( Math . reandom () * 100 ))); //45","title":"Oggetto MATH"},{"location":"javascript/#lezione-13","text":"","title":"Lezione 13"},{"location":"javascript/#equazione-di-ii-grado","text":"Il seguente script calcola le soluzioni reali di un'equazione di secondo grado. Stampa \"Soluzioni immaginarie\" se le soluzioni non sono reali <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table { border : 2 px solid gray ; padding : 5 px ; border-radius : 10 px ; } body { font-size : 20 px ; } . cofficient { text-align : right ; } # resolve { height : 30 px ; } </ style > </ head > < body > < h1 > Equazione di II grado </ h1 > < table > < tr > < td > < input type = \"text\" placeholder = \"a\" class = \"cofficient\" id = \"a\" > x < sup > 2 </ sup > + < input type = \"text\" placeholder = \"b\" class = \"cofficient\" id = \"b\" > x + < input type = \"text\" placeholder = \"c\" class = \"cofficient\" id = \"c\" > = 0 </ td > </ tr > < tr > < td >< input type = \"button\" value = \"Risolvi\" id = \"resolve\" ></ td > </ tr > < tr > < td > < input type = \"text\" placeholder = \"---\" id = \"ris-1\" > x < sub > 1 </ sub > </ td > </ tr > < tr > < td > < input type = \"text\" placeholder = \"---\" id = \"ris-2\" > x < sub > 2 </ sub > </ td > </ tr > </ table > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function ResolveEqIIgrado (){ //Prelievo il valore dell'elemento con id=\"myText\" lo converto a stringa e lo assegno alla variabile testoInserito let a = Number ( $ ( \"#a\" ). val ()); let b = Number ( $ ( \"#b\" ). val ()); let c = Number ( $ ( \"#c\" ). val ()); let delta = Math . sqrt ( b ** 2 - 4 * a * c ); if ( isNaN ( delta )) { $ ( \"#ris-1\" ). val ( \"Soluzioni immaginarie\" ); $ ( \"#ris-2\" ). val ( \"Soluzioni immaginarie\" ); } else { let ris1 = ( - b - delta ) / ( 2 * a ); let ris2 = ( - b + delta ) / ( 2 * a ); $ ( \"#ris-1\" ). val ( String ( ris1 )); $ ( \"#ris-2\" ). val ( String ( ris2 )); } } $ ( function (){ $ ( \"#resolve\" ). click ( ResolveEqIIgrado ) }); </ script > </ body > </ html >","title":"Equazione di II grado"},{"location":"javascript/#lezione-14","text":"","title":"Lezione 14"},{"location":"javascript/#operator-precedence","text":"La precedenza degli operatori determina la priorit\u00e0 in cui gli operatori vengono valutati. Gli operatori con precedenza pi\u00f9 alta sono valutati prima degli operatori con precedenza pi\u00f9 bassa. La lista completa di tutti gli operatori con le rispettive precedenze la troviamo qua: MDN - Operator Precedence Da notare che l'operatore ( ) ha la priorit\u00e0 pi\u00f9 alta e quindi la precedenza su tutti gli operatori. Questo significa che per forzare la precedenza, esattamente come per la matematica \u00e8 possibile sfruttare le parentesi ( ) . Regola di buona programmazione: Non \u00e8 mai una buona pratica di programmazione lasciare espressioni troppo complesse prive di parentesi anche se sono rispettate dal punto di vista semantico tutte le precedenze previste. Le parentesi, oltre a forzare la precedenza, offrono visivamente una chiarezza maggiore, evitando di commettere errori banali di svista. /* Operatore precedence */ /* Calcolo eta' media */ const questAnno = 2020 ; const maggiorenne = 18 ; const nascitaMarco = 1996 ; const nascitaLuca = 2006 ; /* l'operatore \"-\" ha precedenza sull'operatore \">\" quindi l'espressione \u00e8 svolta correttamente da sinistra verso destra La sottrazione verr\u00e0 quindi svolta prima dell'operatore \">\" */ let isMaggiorenne = questAnno - nascitaMarco > maggiorenne console . log ( isMaggiorenne ); //true let isMaggiorenne = questAnno - nascitaMarco > maggiorenne console . log ( isMaggiorenne ); //false //Grouping const etaMarco = questAnno - nascitaMarco ; //24 const etaLuca = questAnno - nascitaLuca ; //14 // In questo caso poich\u00e8 la divisione ha precedenza sulla somma \u00e8 necessario forzare la priorit\u00e0 inserendo le parentesi // Calcolo et\u00e0 media console . log ( ( etaMarco + nascitaLuca ) / 2 ); //19","title":"Operator Precedence"},{"location":"javascript/#associativita","text":"L'associativit\u00e0 specifica in che modo vengono eseguite le elaborazioni a parit\u00e0 di operatore. Mentre la precedenza valuta la priorit\u00e0, l'associativit\u00e0 valuta la modalit\u00e0 di esecuzione. Quasi tutti gli operatori hanno un'associativit\u00e0 left-to-right ovvero, l'elaborazione \u00e8 da sinistra verso destra esattamente come per la matematica. Alla pagina MDN - Operator Precedence si trova una tabella riassuntiva che mostra priorit\u00e0/associativit\u00e0 per ogni operatore. //Associativit\u00e0 del'operatore +. L'operatore + vale sia da somma che da concatenazione stringa for ( let i = 0 , j = 5 ; i <= j ; i ++ , j -- ){ document . writeln ( i + j + \" \" ); //5//5//5 } for ( let i = 0 , j = 5 ; i <= j ; i ++ , j -- ){ document . writeln ( i + ( j + \" \" ) ); //05//14//23 }","title":"Associativit\u00e0"},{"location":"javascript/#operatori-di-assegnamento","text":"L'operatore di assegnazione semplice = viene utilizzato per assegnare un valore a una variabile. L'operazione di assegnazione restituisce il valore assegnato. \u00c8 possibile concatenare l'operatore di assegnazione per assegnare un singolo valore a pi\u00f9 variabili (multiple assignment). //Multiple assignement // E' possibile dichiarare due variabili contemporaneamente let x , y ; /*Molto importante! L'operatore \"= \u00e8 un operatore da destra a sinistra */ x = y = ( 2 * 7 ) * 3 - 5 ; // 9 * 3 - 5 // 27 - 5 // 22 console . log ( x ); //22 console . log ( y ); //22 Molto utilizzati sono anche gli operatori di assegnamento composto come: +=, -=, *=, /= .. Hanno una sintassi molto chiara e compatta. Vengono utilizzati nei casi in cui \u00e8 necessario elaborare anche il valore della variabile a sinistra contrariamente all'operatore di assegnamento semplice = che ignora e distrugge il valore contenuto a sinistra. let x = 10 ; x *= 2 ; // x = x * 2 console . log ( x ); //20 x /= 2 ; // x = x / 2 console . log ( x ); //10","title":"Operatori di assegnamento"},{"location":"javascript/#lezione-15","text":"","title":"Lezione 15"},{"location":"javascript/#operatori-logici","text":"Gli operatori logici < , <= , == , > , >= , != .. trattano l'espressione come un espressione logica e ritornano un valore booleano. Sono spesso utilizzati nel controllo di condizioni in costruttti if o cicli while , for e tutti i costrutti condizionali e iterativi inerenti. console . log ( 1 >= 5 ); //false //Per le stringhe si segue un ordine lessicografico console . log ( \"ciao\" < \"pasta\" ); //true console . log ( 12 != 5 ); / / / true Nota - Operatore di uguaglianza: == Vs === Entrambi sono operatori logici di uguaglianza. === : Uguaglianza forte , valuta l'uguaglianza dell'espressione valutanto il tipo e il contenuto. == : Uguaglianza debole , valuta l'uguaglianza dell'espressione valutanto il contenuto effettuando prima una conversione di tipo. /* === */ console . log ( 5 === 5 ); //true console . log ( 15 === \"15\" ); //false -> sono tipi di dati diversi, il primo \u00e8 un numero, il secondo \u00e8 una stringa console . log ( null === undefined ); //false -> sono tipi di dati diversi. /* == */ console . log ( 5 == 5 ); //true console . log ( 15 == \"15\" ); //true!! -> sono tipi di dati diversi, il primo \u00e8 un numero, il secondo \u00e8 una stringa ma il contenuto \u00e8 lo stesso console . log ( false == 0 ); //true!! -> entrambi hanno un valore falsy anche se il tipo \u00e8 diverso console . log ( null == undefined ); //true!! -> entrambi hanno un valore falsy anche se il tipo \u00e8 diverso In generale l'uguaglianza forte \u00e8 da preferire per essere sicuri di effettuare quindi anche un controllo sul tipo e rendere pi\u00f9 semplice l'individuazione di errori run-time spesso causati da conversioni implicite di Javascript.","title":"Operatori Logici"},{"location":"javascript/#logica-booleana","text":"Trattano l'espressione come un'espressione logica e permettono la concatenazione di espressioni con pi\u00f9 operatori logici. Ritornano un valore booleano: TRUE , FALSE . Vediamo i principali: AND : condition1 && condition2 : Ritorna true se entrambe condition1 e condition2 risultano true . OR : condition1 || condition2 : Ritorna true se almeno una tra condition1 e condition2 risulta true . NOT : !condition1 : Inverte il risultato logico di condition1 . console . log ( ( 1 >= 5 ) || ( \"ciao\" < \"pasta\" ) ); //true console . log ( ( \"ciao\" < \"pasta\" ) && ( 12 == 5 ) ); //false","title":"Logica Booleana"},{"location":"javascript/#approfondimento-short-evalutation","text":"Se un' espressione logica risulta necessariamente true o false le elaborazioni concatenate non vengono elaborate. true || expr : expr non viene valutata false && expr : expr non viene valutata Esempio: console . log ( ( 1 < 2 ) || ( \"ciao\" < \"pasta\" ) ); //true, (\"ciao\" < \"pasta\") non viene valutata console . log ( ( 12 == 5 ) && ( \"c\" < \"p\" ) ); //false, (\"c\" < \"p\") non viene valutata","title":"Approfondimento - Short evalutation"},{"location":"javascript/#truthy-e-falsy","text":"I valori truthy e falsy sono quei valori considerati rispettivamente sempre veri o falsi o per meglio dire che ritornano sempre un boolean: true/false . Valori truthy: 1 , \"content\" .. Valori falsy: undefined , null , 0 , \"\" , NaN Vedremo adesso come mettere in pratica questi concetti attraverso l'uso di costrutti condizionali e iterativi.","title":"Truthy e falsy"},{"location":"javascript/#lezione-16","text":"","title":"Lezione 16"},{"location":"javascript/#control-structure-ifelse","text":"La struttura di controllo if/else esegue un'istruzione o un blocco di istruzioni se una condizione specificata come argomento di if risulta true . Se la condizione risulta false si eseguono le istruzioni del ramo else MDN - if...else if ( condition1 ) { //code } else if ( condition2 ) { //code } else { //code } La condizione espressa come argomento di if \u00e8 trattata come un'espressione logica e quindi ritorna un boolean: true/false . /*Utilizzo di operatori logici combinati al costrutto if/else*/ const maggioreEta = 18 ; const etaLuca = 10 ; if ( etaLuca > maggioreEta ) { console . log ( \"Luca \u00e8 maggiorenne\" ); } else { console . log ( \"Luca non \u00e8 maggiorenne\" ); } /* Luca non \u00e8 maggiorenne */ /* Boolean logic, trattano l'espressione come logica AND -> && : ritorna TRUE se tutte le condizioni sono VERE OR -> || : ritorna TRUE se una condizione \u00e8 VERE NOT -> ! : inverte il risultato dell'espressione logica */ const nome = \"Luca\" ; const eta = 15 ; if ( eta <= 13 ) { console . log ( nome + \" \u00e8 un bambino\" ); } else if ( eta > 13 && eta <= 20 ) { console . log ( nome + \" \u00e8 un ragazzo\" ); } else { console . log ( nome + \" \u00e8 un adulto\" ); } /* Luca \u00e8 un ragazzo */","title":"Control Structure if/else"},{"location":"javascript/#ternary-operator","text":"Il Ternary Operator \u00e8 un costrutto condizionale inline. L'operatore condizionale (ternary) \u00e8 l'unico operatore JavaScript che necessit\u00e0 di tre operandi. Questo operatore \u00e8 frequentemente usato al posto del comando if per la sua sintassi concisa e perch\u00e9 fornisce direttamente un espressione valutabile. MDN - Operatore condizionale (ternary) (condition) ? (steatement1) : (steatement2); : Se condition risulta true verr\u00e0 eseguito steatement1 altrimenti steatement2 . /* Ternary Operator */ var nome = \"Marco\" ; var eta = \"17\" ; eta >= 18 ? console . log ( nome + \" pu\u00f2 guidare\" ) : console . log ( nome + \" non pu\u00f2 guidare\" ); /* Marco non pu\u00f2 guidare */ E' da preferire il ternary operator nei casi in cui si hanno due semplici statemeant da eseguire condizionati da un'espressione altrettanto semplice. In questo caso risulta chiaro ed elegante.","title":"Ternary Operator"},{"location":"javascript/#switch-statemeant","text":"L'ultimo costrutto condizionale \u00e8 switch . Il comando switch valuta un espressione, confronta il valore dell'espressione con ciascuna delle clausole case ed esegue i comandi (statements) associati alla clausola (case) che verifica il confronto. MDN - switch switch ( key ) { case value1 : //code break ; case value2 : //code break ; default : //code break ; } Esempio: /* switch statemeant*/ const sport = \"calcio\" ; switch ( sport ) { case \"calcio\" : console . log ( \"Amo giocare a calcio\" ); break ; case \"tennis\" : console . log ( \"Amo giocare a tennis\" ); break ; default : console . log ( \"non amo nessuno sportf\" ); break ; } /* Console: --------------- Amo giocare a calcio */ In che occasioni si usa \u00e8 preferibile utilizzare il costrutto switch ? E' da preferire quando si hanno opzioni multiple di una un unico key (un tipo di dato qualsiasi) da valutare e tutte le opzioni sono omogenee. In questo caso risulta chiaro e leggibile. Nel prossimo esempio lo switch/case \u00e8 trasformato in un if/else . /* switch statemeant*/ const nome = \"Matteo\" ; const eta = 15 ; switch ( true ) { case ( eta <= 13 ) : console . log ( nome + \" \u00e8 un bambino\" ); break ; case ( eta > 13 && eta <= 20 ) : console . log ( nome + \" \u00e8 un ragazzo\" ); break ; default : console . log ( nome + \" \u00e8 un adulto\" ); break ; } /* Matteo \u00e8 un ragazzo */ In questo caso lo switch/case risulta meno chiaro di un if/else . E' importante fin da subito saper utilizzare i costrutti giusti per la situazione giusta.","title":"Switch statemeant"},{"location":"javascript/#lezione-17","text":"","title":"Lezione 17"},{"location":"javascript/#while-loop","text":"L'istruzione while crea un ciclo che esegue un'istruzione specificata fintanto che la condizione di test restituisce true . La condizione viene valutata prima di eseguire l'istruzione. MDN - while while ( condition ) { //code } Esempio: let contatore = 1 ; while ( contatore < 5 ) { console . log ( contatore ); contatore ++ ; } /* 1 2 3 4 */ In un qualsiasi costrutto iterativo \u00e8 sempre bene tenere in considerazione: - La condizione da verificare - l'evento che altera, ad ogni ciclo, la condizione da verificare. Il programmatore si deve assicurare che prima o poi la condizione diventi falsa altrimenti rischia di creare un loop infinito causando un crash del browser. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > LOOP INFINITO </ h1 > < script > /*Loop Infinito - DA EVITARE! */ var infinito = 0 ; while ( infinito < 10 ) { console . log ( infinito ); } </ script > </ body > </ html > Altro esempio di un ciclo iterativo applicato a una stringa con while : var parola = \"ciao\" ; var contatore = 0 ; while ( contatore < parola . length ) { // 0 < 4 // 1 < 4 // 2 < 4 // 3 < 4 console . log ( parola [ contatore ]); // c // i // a // o contatore ++ ; // 1 // 2 // 3 // 4 } /* parola.lenght -> restituisce il numero delle lettere che compongono la stringa parola parola[contatore] -> restituisce il contenuto relativo all'indice \"contaotore\" Output: c i a o */","title":"while loop"},{"location":"javascript/#do-while-loop","text":"L'istruzione do ... while crea un ciclo che esegue un'istruzione specificata finch\u00e9 la condizione di test non restituisce false. La condizione viene valutata dopo l'esecuzione dell'istruzione, determinando l'esecuzione dell'istruzione specificata almeno una volta. MDN - do...while do { //code } while ( condition ); let j = 0 ; do { j ++ ; console . log ( j ); } while ( j < 5 ); console . log ( j ); /* Console: --------------- 0 1 2 3 4 */ Il do-while loop \u00e8 molto simile al while loop ma differisce nel punto in cui valuta la condizione sotto test. Qui sotto riporto un esempio dello stesso loop realizzato prima con while e poi con do-while. //while let i = 5 ; //la condizione \u00e8 falsa, non eseguo il corpo del loop while ( i < 5 ){ i ++ ; console . log ( i ); } console . log ( i ); /* 5 */ //do-while let j = 5 ; do { j ++ ; console . log ( j ); } while ( j < 5 ); //la condizione \u00e8 falsa ma ho eseguito una volta il corpo del loop console . log ( j ); /* Console: --------------- 6 6 */ do...while esegue il ciclo almeno una volta mentre while pu\u00f2 anche non eseguire mai il corpo. do...while \u00e8 meno utilizzato rispetto while ma pu\u00f2 comunque essere utilizzato in strutture iterative sempre in esecuzione come quella di selezione di un men\u00f9 grafico a opzioni multiple.","title":"do-while loop"},{"location":"javascript/#lezione-18","text":"","title":"Lezione 18"},{"location":"javascript/#for-loop","text":"L'istruzione for crea un ciclo che consiste di tre espressioni opzionali, racchiuse tra parentesi tonde ( ) e separate da punto e virgola, seguite da un'istruzione (di solito un'istruzione di blocco) da eseguire nel ciclo. MDN - for for ( inizializzazione ; condizione ; incremento / decremento ){ //code } Esempio: for ( let contatore = 1 ; contatore < 5 ; contatore ++ ){ console . log ( contatore ); } /* 1 2 3 4 */ Nota : la variabile \"contatore\", poich\u00e8 \u00e8 creata all'interno del ciclo for vive all'interno del ciclo. Al di fuori del ciclo non \u00e8 conosciuta. Vediamo anche un altro esempio precedentemente svolto con while : /* For Loop */ const nome = \"Marco\" ; for ( let i = 0 ; i < nome . length ; i ++ ){ // 0 < 4 // 1 < 4 // 2 < 4 // 3 < 4 // 4 < 5 // console . log ( nome [ i ]); // M // a // r // c // o } /* M a r c o */ Approfondimento: I cicli in cui sono note a priori il numero di iterazioni sono sono detti \"enumerativi\". Per questi cicli la struttura pi\u00f9 adatta \u00e8 certamente il for . I cicli si dicono invece \"indefiniti\" quando a priori non \u00e8 noto il numero esatto di iterazioni. Per questi cicli la struttura pi\u00f9 adatta \u00e8 il while o il do-while . Gli esempi riportati fino ad ora sono tutti cicli enumerativi. Notiamo infatti che la struttura for risulta pi\u00f9 chiara e compatta ed \u00e8 quindi da preferire.","title":"for loop"},{"location":"javascript/#break-coninue","text":"All'interno del corpo di loop statemeant for / while / do... while \u00e8 possible invocare i comandi: continue , break . - continue : Salta all'iterazione successiva ignorando le istruzioni successive - break : Esce dal loop. Vediamo l'uso attraverso un esempio //NO continue NO break for ( let i = 0 ; i < 5 ; i ++ ){ if ( i === 2 ){ console . log ( 'QUESTO \u00c8 2' ); } console . log ( i ); } /* Console: --------------- 0 1 QUESTO \u00c8 2 2 3 4 */ //<conitnue> salta all'iterazione successiva for ( let i = 0 ; i < 5 ; i ++ ){ if ( i === 2 ){ console . log ( 'QUESTO \u00c8 2' ); continue } console . log ( i ); } /* 0 1 QUESTO \u00c8 2 3 4 */ //<break> esce dal ciclo for ( let i = 0 ; i < 5 ; i ++ ){ if ( i === 2 ){ console . log ( 'QUESTO \u00c8 2' ); break ; } console . log ( i ); } /* 0 1 QUESTO \u00c8 2 */ Approfondimento break: E' possibile uscire da loop innestati facendo uso di un'etichetta. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table td { text-align : center ; border : 1 px dashed black ; padding : 10 px ; margin-bottom : 10 px ; } </ style > </ head > < body > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > document . write ( \"<table>\" ); myLoop : for ( let i = 1 ; i <= 10 ; i ++ ) { document . write ( \"<tr>\" ); for ( let j = 1 ; j <= 10 ; j ++ ) { document . write ( \"<td>\" + \"A\" + \"</td>\" ); if ( j * i == 20 ) break myLoop ; } document . write ( \"</tr>\" ); } document . write ( \"</table>\" ); </ script > </ body > </ html >","title":"break &amp; coninue"},{"location":"javascript/#lezione-19","text":"","title":"Lezione 19"},{"location":"javascript/#function","text":"Le funzioni sono tra i blocchi di programmazione fondamentali in JavaScript. Una funzione \u00e8 una procedura JavaScript \u2014 un gruppo di istruzioni ( statement ) che esegue un compito o calcola un valore. La definizione di funzione ( o dichiarazione di funzione, o istruzione di funzione ) consiste della parola chiave function , seguita da: il nome della funzione. una lista di argomenti per la funzione, chiusi tra due parentesi e separati da una virgola. le istruzioni JavaScript che definiscono la funzione, chiuse tra due parentesi graffe, { }. MDN - Funzioni //Dichiarazione o definizione di una funzione function name ( param1 , param2 , ? param3 ) { //code } //Chiamata name ( param1 , param2 ); Esempio: /* Function with arguments */ function salutoCompleanno ( nome , anni ){ console . log ( \"ciao \" + nome + \", auguri per i tuoi \" + anni + \" anni!\" ); } salutoCompleanno ( \"Francesco\" , 22 ); //ciao Francesco, auguri per i tuoi 22 anni! Nota: L'ordine dei parametri \u00e8 importante! Nota2: Il passaggio dei parametri \u00e8 sempre per valore intendendo che al momento della chiamata della funzione, si esegue una copia dei parametri. Non vengono quindi elaborati direttamente i valori passati a una funzione","title":"Function"},{"location":"javascript/#parametri-di-default","text":"Alcuni parametri possono essere opzionali. In fase di chiamata possono quindi essere passati dei valori a tali parametri opppure no. In caso non venga passato un valore a tali parametri assumeranno all'interno della funzione un cos\u00ecdetto valore di default . Per inserire un valore di default e quindi rendere il parametro opzionale basta assegnare ad esso un valore in fase di dichiarazione della funzione. Vediamo un esempio: function salutoCompleanno ( nome , anni = 0 ){ if ( anni === 0 ){ console . log ( \"ciao \" + nome + \", auguri per il tuo compleanno!\" ); } else { console . log ( \"ciao \" + nome + \", auguri per i tuoi \" + anni + \" anni!\" ); } } salutoCompleanno ( \"Francesco\" , 22 ); //ciao Francesco, auguri per i tuoi 22 anni! salutoCompleanno ( \"Mario\" ); //ciao Mario, auguri per il tuo compleanno! NOTA: E' buona norma passare parametri in modo che i primi siano obbligatori e gli altri opzionali anche se tutto \u00e8 consentito ma di fatto in fase di chiamata della funzione i parametri passati sono interpretati a partire dal primo. Ricorda che conta solo l'ordine dei parametri e non l'identificativo utilizzato","title":"Parametri di default"},{"location":"javascript/#ritorno-di-una-funzione","text":"Una funzione pu\u00f2 restituire un valore con il comando return /* Return Keword */ function quadrato ( numero ){ return ( numero * numero ); } console . log ( quadrato ( 5 ) ); //25 E' preferibile che una funzione esegua un'elaborazione interna e che ritorni un valore invece di salvare il risultato all'interno di variabili esterne globali. In questo modo \u00e8 possibile riutilizzare la funzione ovunque e non renderla dipendente dal codice. E' quindi indispensabile l'utilizzo del return Note Una funzione ammette un solo return che termina l'esecuzione della funzione. Eventuali linee di codice dopo il return verranno ignorate.","title":"Ritorno di una funzione"},{"location":"javascript/#lezione-20","text":"","title":"Lezione 20"},{"location":"javascript/#funzioni-passaggio-di-oggetti-e-array","text":"Il passaggio di oggetti e array come parametri ad una funzione avviene per riferimento . Dal momento che viene passato il nome dell'oggetto e dell'array che corrisponde all'indirizzo puntatore dei dati contenuti, viene effettuata la copia dell'indirizzo e non dell'intero oggetto/array contenente i dati interni. In sostanza \u00e8 possibile accedere e modificare i dati dell'array o oggetto passato!! //Metodo Object - Gli oggetti sono passati per riferimento const annoAttuale = 2020 ; const objPersona = { nome : \"simone\" , eta : 24 , titolo : \"laurea\" , annoNascita : 1994 } aggiornaEta ( objPersona , annoAttuale ); console . log ( objPersona . eta ); //26 function aggiornaEta ( obj , anno ){ obj . eta = anno - obj . annoNascita ; console . log () } //Metodo Array - Gli array sono passati per riferimento const arrayPersona = [ \"simone\" , //0 24 , //1 \"laurea\" , //2 1994 //3 ]; aggiornaEta2 ( arrayPersona , annoAttuale ); console . log ( arrayPersona [ 1 ]); //26 function aggiornaEta2 ( array , anno ){ array [ 1 ] = anno - array [ 3 ]; console . log ( array ); }","title":"Funzioni - Passaggio di oggetti e array"},{"location":"javascript/#funzioni-ritorno-di-un-oggetto-o-un-array","text":"Una funzione in Javascript pu\u00f2 avere come tipo di ritorno anche un oggetto o un array //Metodo Oggetto let objRisultatoEqIIgrado = objCalcolaRisultatoEqIIgrado ( 1 , 5 , - 1 ); console . log ( \"Risultato 1: \" + objRisultatoEqIIgrado . x1 ); console . log ( \"Risultato 2: \" + objRisultatoEqIIgrado . x2 ); function objCalcolaRisultatoEqIIgrado ( a , b , c ){ let delta = Math . sqrt ( b * b - 4 * a * c ); let ris1 = ( - b + delta ) / 2 ; let ris2 = ( - b - delta ) / 2 ; //Ritorno un oggetto return { x1 : ris1 , x2 : ris2 }; } //Metodo Array let arrayRisultatoEqIIgrado = arrayCalcolaRisultatoEqIIgrado ( 1 , 6 , - 1 ); console . log ( \"Risultato 1: \" + arrayRisultatoEqIIgrado [ 0 ]); console . log ( \"Risultato 2: \" + arrayRisultatoEqIIgrado [ 1 ]); function arrayCalcolaRisultatoEqIIgrado ( a , b , c ){ let delta = Math . sqrt ( b * b - 4 * a * c ); let ris1 = ( - b + delta ) / 2 ; let ris2 = ( - b - delta ) / 2 ; //Ritorno un oggetto return [ ris1 , ris2 ]; }","title":"Funzioni - Ritorno di un oggetto o un array"},{"location":"javascript/#approfondimento-funzioni-oggetto-arguments","text":"Facendo uso di arguments \u00e8 possibile passare un numero indefinito di parametri. arguments raggruppa gli argomenti in un oggetto collezione di elementi. L'oggetto arguments permette di utilizzare la propriet\u00e0 lenght , l'indicizzazione [ ] ma non \u00e8 un array e quindi non si possono applicare i metodi applicabili agli array. arguments non si specifica nella definizione di una funzione tra i parametri poich\u00e8 \u00e8 un oggetto riconosciuto nel contesto stesso della funzione //arguments \u00e8 un oggetto riconosciuto all'interno della definizione della funzione function somma (){ let ris = 0 ; for ( let index = 0 ; index < arguments . length ; index ++ ) { ris += arguments [ index ]; } console . log ( arguments ); return ris ; } console . log ( somma ( 1 , 4 )); //5 console . log ( somma ( 1 , 4 , 6 , 0 , 3 , 1 , 2 )); //17 console . log ( somma ()); //0","title":"Approfondimento funzioni - Oggetto Arguments"},{"location":"javascript/#approfondimento-funzioni-parametri-rest","text":"La sintassi dei rest parameter permette di rappresentare un indefinito numero di argomenti come un array. A differenza dell'oggetto arguments in questo caso gli argomenti \"restanti\" sono rappresentati e raggruppati in un array ed \u00e8 possibile quindi utilizzare ogni metodo applicabile agli arrays. Si specificano i rest parameter all'interno della definizione di una funzione come ultimo parametro attraverso l'operatore rest ... ... : Operatore rest MDN - Rest parameters function calcola ( a , b , ... altriParam ){ ris = a + b ; //Il forEach(param1, param2) ha due parametri. Il primo \u00e8 una funzione che a sua volta accetta i parametri //opzionali (valore, indice, array) in questo caso dell'array altriParam passato come argomento a calcola. //this in questo caso rappresenta il fatto che voglio ritornare il valore all'interno del contesto di ris altriParam . forEach ( controllaEsomma , this ); return ris ; } function controllaEsomma ( valore , indice , array ){ if ( valore < 100 ) { //this riesce a raggiungere il contesto di \"ris\" della funzione calcola this . ris += valore ; } } console . log ( calcola ( 1 , 4 )); //5 console . log ( calcola ( 1 , 4 , 6 , 100 , 3 , 1 , 2 )); //17 console . log ( calcola ( 1 , 2 )); //0","title":"Approfondimento funzioni - Parametri Rest"},{"location":"javascript/#approfondimento-introduzione-foreach-this","text":"forEach() \u00e8 un metodo applicabile agli array. E' una struttura iterativa cheesegue una funzione fornita una volta per ogni elemento dell'array a cui si applica il metodo. La funzione riceve dall'array tre parametri opzionali in ordine: value, index, array ovvero il valore dell'elemento dell'array a cui si applica il metodo, l'indice dell'elemento e l'array stesso. myArray . forEach ( myFunc ); function myFunc ( value , index , array ){ //code; } Nell'esempio di sopra: altriParam . forEach ( controllaEsomma , this ); Esegue la funzione controllaEsomma per ogni elemento dell'array. function controllaEsomma ( valore , indice , array ){ if ( valore < 100 ) { //this riesce a raggiungere il contesto di \"ris\" della funzione calcola this . ris += valore ; } } L'identificatore this , come il forEach stesso verranno approfonditi pi\u00f9 avanti. Per adesso ci basta sapere che this consente di raggiungere un oggetto utilizzato come callback (valore di ritorno). Osservazione: Se dichiariamo la variabile \"ris\" con let o var ritorna NaN . Approfondimento: MDN - var","title":"Approfondimento Introduzione forEach / this"},{"location":"javascript/#lezione-21","text":"","title":"Lezione 21"},{"location":"javascript/#approfondimento-funzioni-ricorsive","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. La funzioni ricorsive sono funzioni che richiamano se stesse all'interno del corpo. Questa tecnica fornisce un modo per scomporre problemi complicati in problemi semplici che sono pi\u00f9 facili da risolvere. Con le funzioni ricorsive si costruiscono algoritmi potenti. function x ( contatore ){ if ( contatore > 5 ){ return ; //Terminatore, } else { x ( ++ contatore ); //passo ricorsivo console . log ( contatore ); } } x ( 0 ); /* 6 5 4 3 2 1 */ Nell'esempio di sopra al primo passo ricorsivo x(++contatore) non eseguo console.log(contatore); che rimane pending nello stack. Cos\u00ec anche per gli altri passi successivi finch\u00e8 la condizione dell' if diventa true e l'ultima funzione ritorna. A questo punto lo statemeant console.log(contatore); rimasto pending viene eseguito e cos\u00ec via i precedenti. fino al ritorno dell'intera funzione Osservazioni: - Se nulla limita il meccanismo di chiamate a funzione con una serie di ritorni a cascata, lo stack si riempie e il browser va in crash con l'errore Maximum call stack size exceeded . - E' un meccanismo che rallenta parecchio l'applicazione quando il passo ricorsivo diverge.","title":"Approfondimento Funzioni ricorsive"},{"location":"javascript/#approfondimento-function-expression","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. La parola chiave function pu\u00f2 essere utilizzata per definire una funzione all'interno di un'espressione. var media = function ( a , b ){ //funzione anonima return ( a + b ) / 2 ; }; console . log ( media ( 4 , 9 )); var fattoriale = function fatt ( n ){ if ( n === 0 ){ return 1 ; } else { return n * ( fatt ( n - 1 )); } } console . log ( fattoriale ( 4 )); //24","title":"Approfondimento Function expression"},{"location":"javascript/#approfondimento-hoisting","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. Per comprendere l'hoisting \u00e8 necessario introdurre il meccanismo di parsing dell'interprete javascript. Prima di eseguire lo script, il parser dell'interprete Javascript scansiona tutto il codice per risolvere i valori da assegnare agli identificatori ed esegue molte altre operazioni function esterna () { function interna (){ return \"interna1\" ; } return interna (); function interna (){ return \"interna2\" ; } } console . log ( esterna () ); //interna2 Nell'esempio di sopra, poich\u00e8 la funzione interna() \u00e8 stata definita due volte, il parser sovraiscrive la prima definizione con la seconda! Tutto cambia se utilizzo le function expression function esterna () { var interna = function (){ return \"interna1\" ; } return interna (); var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //interna1 In questo caso poich\u00e8 non sono definizioni di funzione ma variabili la seconda variabile non viene valutata poich\u00e8 \u00e8 codice irraggiungibile. In questo caso si segue un andamento lineare del codice anche detto paradigma imperativo. Nel caso invece di chiamate a funzione il paradigma si dice funzionale. Altro controesempio: function esterna () { return interna (); var interna = function (){ return \"interna1\" ; } var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //ERROR. interna() non \u00e8 riconosciuto perch\u00e8 non \u00e8 stato dichiarato l'identificaore Con il paradigma funzionale invece non ci sono problemi: function esterna () { return interna (); function interna (){ return \"interna1\" ; } function interna (){ return \"interna2\" ; } } console . log ( esterna () ); //interna2","title":"Approfondimento Hoisting"},{"location":"javascript/#approfondimento-differenza-tra-undefined-e-not-defined","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. Anche se sembra un uso improprio del vocabolario, c'\u00e8 una differenza tra una variabile undefined e un errore dell'interprete dovuto a una variabile not defined . undefined : L'interprete trova la definizione della variabile ma non trova nessun valore associato a tale variabile. Non genera un errore not defined : l'interprete non trova da nessuna parte nel codice l'identificatore. Genera un errore function esterna () { return interna ; var interna = function (){ return \"interna1\" ; } var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //undefined, l'interprete sa cos'\u00e8 ma non \u00e8 stata definita a quel punto del codice function esterna () { return y ; var interna = function (){ return \"interna1\" ; } var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //ERROR. y is not defined. L'interprete non sa cosa sia y, ben diverso","title":"Approfondimento Differenza tra undefined e not defined"},{"location":"javascript/#approfondimento-iifi-immediatly-invoked-function-expression","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. Sebbene introdurre funzioni aiuti a scrivere moduli indipendenti si rischia di inondare il contesto globale di nomi di funzioni. Il pattern IIFE (Immediately Invoked Function Expression) aiuta in tal senso. Le IIFI functions sono funzioni che vengono eseguite al momento della definizione. Non necessitano quindi della chiamata. ( function name (){ //code })(); Esempio: //Questa \u00e8 una funzione standard, NON IIFI. Viene eseguita solo alla chiamata function stampaLogo (){ console . log ( 'myLogo' ); } stampaLogo (); //in questa linea eseguo la funzione /* */ //Questa \u00e8 una funzione IIFI. Viene eseguita al momento. //(function name(){})(); ( function stampaLogo (){ console . log ( 'myLogo' ); })(); //eseguo qui la funzione IIFI Esempio 2: ( //operatore di raggruppamento: cio' che e' all'interno e' una espressione function iife () { var a = 222 ; console . log ( \"parto da sola!! \" + a ); } ) //fine espressione (); //operatore di chiamata di funzione //forma alternativa ( function iife () { var a = 444 ; console . log ( \"parto da sola!! \" + a ); } () ); iife (); //errore! iife come identificatore non esiste nel contesto globale","title":"Approfondimento IIFI Immediatly invoked function expression"},{"location":"javascript/#paradigma-di-programmazione-javascript","text":"Javascript \u00e8 un linguaggio multiparadigma, consente quindi il paradigma imperativo, quello funzionale e il paradigma object oriented in un unico linguaggio. Non esiste il miglior paradigma in assoluto ma esista il paradigma migliore per la situazione migliore.","title":"Paradigma di programmazione Javascript"},{"location":"javascript/#lezione-22","text":"","title":"Lezione 22"},{"location":"javascript/#scope","text":"Lo scope \u00e8 l'attuale contesto di esecuzione. Il contesto in cui i valori e le espressioni sono \"visibili\" o possono essere referenziati. Se una variabile o un'altra espressione non \u00e8 \"nell'ambito corrente\", non \u00e8 disponibile per l'uso. Gli ambiti possono anche essere stratificati in una gerarchia, in modo che gli ambiti figlio abbiano accesso agli ambiti padre, ma non viceversa. Una funzione funge da chiusura, closure in JavaScript e quindi crea uno scope, in modo che (ad esempio) non sia possibile accedere a una variabile definita esclusivamente all'interno della funzione dall'esterno della funzione o da altre funzioni. MDN - Scope Esempio: /* Scope */ /* Gloabl variable -> Riconosciuta da tutto il programma */ let var1 = 1 ; function function1 (){ /* Local variable -> ricnosciuta solo nel blocco di codice tra le parentesi {} in cui \u00e8 stata dichiarata*/ let var2 = 10 ; //qui nasce var2 console . log ( var2 ); } //qui muore var2 function1 (); console . log ( var1 ); //var1 is defined, var1 is global console . log ( var2 ); //var2 is not defined /* Console: --------------- 10 1 Uncaught ReferenceError: var2 is not defined */ Vediamo un esempio molto pi\u00f9 complesso: /* Scope */ /* Gloabl variable -> Riconosciuta da tutto il programma */ let var1 = 1 ; function function1 (){ /* Local variable -> ricnosciuta solo nel blocco di codice tra le parentesi {} in cui \u00e8 stata dichiarata*/ let var2 = 10 ; //qui nasce var2 console . log ( \"var2 function1 : \" + var2 ); } //qui muore var2 function function2 (){ /* Local variable -> ricnosciuta solo nel blocco di codice tra le parentesi {} in cui \u00e8 stata dichiarata*/ let var2 = 20 ; //qui nasce var2 ma \u00e8 diversa rispetto a quella di prima, \u00e8 una nuova var2 console . log ( \"var2 function2 : \" + var2 ); console . log ( \"var1: \" + var1 ); //\u00e8 riconosciuta anche var1 perch\u00e8 \u00e8 stata dichiarata in un blocco pi\u00f9 esterno for ( let var3 = 0 ; var3 < 1 ; var3 ++ ) { console . log ( \"var3: \" + var3 ); console . log ( \"var2 function2: \" + var2 ); //\u00e8 riconosciuta anche var2 perch\u00e8 \u00e8 stata dichiarata in un blocco pi\u00f9 esterno console . log ( \"var1: \" + var1 ); //\u00e8 riconosciuta anche var1 perch\u00e8 \u00e8 stata dichiarata in un blocco pi\u00f9 esterno } //qui muore var3 } //qui muore var2 function1 (); function2 (); console . log ( \"var1: \" + var1 ); //OK console . log ( \"var3: \" + var3 ); //non riconosciuta console . log ( \"var2: \" + var2 ); //non riconosciuta /* Console: --------------- var2 function1 : 10 var2 function2 : 20 var1: 1 var3: 0 var2 function2: 20 var1: 1 var1: 1 Uncaught ReferenceError: var3 is not defined */","title":"Scope"},{"location":"javascript/#visibilita-di-variabili","text":"Lo 'scope' di una variabile (visibilita' di una variabile) e' la sezione di codice in cui essa e' visibile ed in Javascript e' regolato con l'uso delle funzioni. NB: non confondere lo scope con il context (contesto) che indica invece l'oggetto per il quale una funzione viene eseguita ( this ). Per una funzione visibile a livello globale cioe' non contenuta in alcun oggetto questo in realta' esiste e coincide con 'window'. La distinzione e' tra visibilita' globale, locale e di blocco.","title":"Visibilit\u00e0 di variabili"},{"location":"javascript/#visibilita-globale-global-scope","text":"E' quella che ha come riferimento l'intero codice. Sono le variabili/oggetti dichiarate all'esterno di qualunque funzione usate in una funzione senza var/let . In generale la visibilita' globale e' da evitare Esempio: var x = 100 ; function f_bad () { //modifica la variabile esterna potenzialmente all'insaputa di chi la chiama x = 2 ; } console . log ( \"Prima di invocare f_bad() \" + x ); //x = 100 f_bad (); //modifica x, da evitare console . log ( \"Dopo f_bad() \" + x ); //x = 2 L'obiettivo delle funzioni \u00e8 proprio racchiudere il codice in blocchi riutilizzabili. Se modificano/dipendono da variabili esterne/globali questo concetto viene a meno. Per risolvere questa cosa: x = 100 ; //versione corretta di f function f_good () { //dichiarazione di una variabile LOCALE (x) distinta da quella globale var x = 2 ; var y = 200 ; } console . log ( \"Prima di invocare f_good() \" + x ); // x = 100 f_good (); console . log ( \"Dopo f_good() \" + x ); // x = 100, Ok console . log ( y ); //errore: y not defined; visibile solo a f_good in esecuzione","title":"Visibilit\u00e0 Globale (global scope)"},{"location":"javascript/#scope-chaining","text":"Una varibaile \u00e8 visibile ai blocchi interni (figli) ma non ai contenitori (padre). I blocchi interni (figli) ereditano tutto dai loro contenitori (padri) ma i padri non conoscono i segreti dei figli ovvero non possono conoscere le variabili/oggetti dichiarati dei figli. var x = 2 ; //FUNZIONI ANNIDATE (nested) function esterna () { var x = 999 ; // dichiaro una nuova \"x\" diversa da quella globale interna (); //Accedo alla \"x\" esterna tramite il contest. <window> \u00e8 il contesto esterno, \u00e8 il contenitore di tutto window . x = 18 ; //interna accede anche allo scope di esterna ma non il viceversa function interna () { //code } }","title":"Scope Chaining"},{"location":"javascript/#visibilita-a-livello-di-blocco-block-scope","text":"La visibilit\u00e0 \u00e8 racchiusa da i delimitatori { } Per mantenere la visibilit\u00e0 a livello di blocco \u00e8 necesario usare let , var mantiene soltanto lo scope locale a livello di funzione ma non di blocco { } let : Mantiene lo scope delle variabili sia a livello locale (all'interno di una funzione) sia livello di blocco ovvero tra i delimitatori { } var : Mantiene lo scope delle variabili solo a livello locale (all'interno di una funzione) ma non a livello di blocco ovvero tra i delimitatori { } //\"var\" non mantiene la visibilit\u00e0 di blocco var x = 5 ; if ( Math . random () > 0.5 ) { var x = 100 ; } else { var x = 200 } console . log ( \"La x ora vale: \" + x ); //100 o 200!! ATTENZIONE, //\"let\" mantiene la visibilit\u00e0 di blocco x = 5 ; if ( Math . random () > 0.5 ) { let x = 100 ; } else { let x = 200 } console . log ( \"La x globale vale ancora: \" + x ); //5, ok","title":"Visibilit\u00e0 a livello di blocco (block scope)"},{"location":"javascript/#approfondimento-closure-di-una-funzione","text":"Si ricordi: Una funzione funge da chiusura, closure in JavaScript e quindi crea uno scope, in modo che (ad esempio) non sia possibile accedere a una variabile definita esclusivamente all'interno della funzione dall'esterno della funzione o da altre funzioni Applichiamo questo concetto ad un esempio pratico. La funzione: setInterval( param1, param2 ) : param1 \u00e8 una funzione, param2 rappresenta un intervallo di tempo espresso in ms . La funzione setInterval() chiama la funzione param1 ogni param2 ms . function chiamaMessaggio ( messaggio ){ setInterval ( function (){ writeln ( messaggio );}, 1000 ); //uso una funzione anonima } chiamaMessaggio ( \"il sistema \u00e8 in fase di spegnimento..\" ); Ho utilizzato il concetto di closure (e quindi dell'ereditariet\u00e0 delle variabili/oggetti padre->figlio) di una funzione per passare un parametro alla funzione (parametro) di setInterval() Esempio 2: function chiamaMessaggio2 ( ilMessaggio , volte ) { let timer = setInterval ( function () { writeln ( ilMessaggio + \" \" + volte + \" secondi...\" ); -- volte ; if ( volte < 1 ) { clearInterval ( timer ); writeln ( \"Boom!\" );} } , 1000 ) } chiamaMessaggio2 ( \"Sistem Shutdown in \" , 5 ); Approfondimento: Le funzioni che ricevono come parametri altre funzioni o ritornano altre funzioni prendono il nome di High orderd function","title":"Approfondimento - Closure di una funzione"},{"location":"javascript/#lezione-23","text":"","title":"Lezione 23"},{"location":"javascript/#array","text":"Gli array sono aggragatori di dati utilizzati per raggruppare elementi appartenenti alla stessa famiglia ed accedere ad uno di essi in lettura o scrittura in modo semplice. Ogni elemento dell'array \u00e8 raggiungibile tramite un numero detto indice . L'indice indica la posizione dell'elemento nell'array. La propriet\u00e0 lenght restituisce il numero degli elementi in un array // Dichiarazione e inizializzazione // 0 1 2 const elementi = [ \"elemento1\" , \"elemento2\" , \"element03\" ]; console . log ( elementi ); //(3) [\"elemento1\", \"elemento2\", \"element03\"] console . log ( elementi [ 1 ]); //elemento2 console . log ( elementi . lenght ); //3 elementi [ 2 ] = \"Silicio\" ; console . log ( elementi ); //(3) [\"elemento1\", \"elemento2\", \"Silicio\"] // Solo dichiarazione const mammiferi = []; Altre sintassi (meno utilizzate ma valide): //Array vuoto let vuoto1 = new Array (); let vuoto2 = Array (); let vuoto3 = []; //da preferire let v1 = Array ( 100 ); //100 elementi pre allocati let v2 = Array ( '100' ); //1 elemento stringa, crea confusione let v3 = new Array ( 31 , 8 , 2017 ); //meno consigliata let arr3 = [ 31 , 8 , 2017 ]; //sintassa pi\u00f9 chiara Alcuni esempi: const mammiferi = [ \"tigre\" , \"scoiattolo\" , \"orso\" ]; mammiferi [ mammiferi . length ] = \"volpe\" ; // === mammiferi[3] = \"volpe\", aggiunge in coda un elemento console . log ( mammiferi ); //(4) [\"tigre\", \"scoiattolo\", \"orso\", \"volpe\"] mammiferi [ 10 ] = \"cinghiale\" ; //aggiunge \"cinghiale\" al decimo elemento e riempie con elementi vuoti i restanti console . log ( mammiferi , mammiferi . lenght ); //(11) [\"tigre\", \"scoiattolo\", \"orso\", \"volpe\", empty \u00d7 6, \"cinghiale\"] 11 mammiferi . lenght = 20 ; console . log ( mammiferi , mammiferi . lenght ); //(11) [\"tigre\", \"scoiattolo\", \"orso\", \"volpe\", empty \u00d7 6, \"cinghiale\", lenght: 20] 20 //Iterazione sugli elementi dell'array for ( let i = 0 ; i < mammiferi . length ; i ++ ){ if ( mammiferi [ i ] != undefined ){ console . log ( i + \": \" + mammiferi [ i ]); } else { console . log ( i + \": \" + \"non \u00e8 un mammifero\" ); } } /* 0: tigre 1: scoiattolo 2: orso 3: volpe 4: non \u00e8 un mammifero 5: non \u00e8 un mammifero 6: non \u00e8 un mammifero 7: non \u00e8 un mammifero 8: non \u00e8 un mammifero 9: non \u00e8 un mammifero 10: cinghiale */","title":"Array"},{"location":"javascript/#matrix","text":"Della famiglia degli array ci sono anche le matrici che non sono altro che array di array. const social = [ [ \"facebook\" , \"instagram\" ], [ \"whatsapp\" , \"telegram\" ], [ \"tiktok\" , \"snapchat\" ], ]; console . log ( social ); console . log ( social [ 1 ][ 1 ]); console . log ( social [ 2 ][ 0 ]); /* Console: --------------- Esercizio 2 (3) [Array(2), Array(2), Array(2)] 0: (2) [\"facebook\", \"instagram\"] 1: (2) [\"whatsapp\", \"telegram\"] 2: (2) [\"tiktok\", \"snapchat\"] telegram tiktok */","title":"Matrix"},{"location":"javascript/#lezione-24","text":"","title":"Lezione 24"},{"location":"javascript/#array-metodi-base","text":"Qualche metodo base applicabile agli array in javascript: push(elem) : aggiunge l'elemento elem in coda all'array. Restituisce il numero di elementi dell'array. pop() : rimuove l'ultimo elemento dall'array. Restituisce l'elemento che ha tolto. array.unshift(elem) : aggiunge l'elemento elem in testa all'array. Restituisce il numero di elementi dell'array array.shift() : rimuove il primo elemento dall'array. Restituisce l'elemento che ha tolto indexOf(elem) : Restituisce l'indice dell' elemento elem nell'array. Se non lo trova restituisce -1 slice(startIndex, endIndex); : Restituisce un array derivato dall'array a cui si applica il metodo filtrando gli elementi nel range ( startIndex incluso, endIndex escluso). .concat(array2); : Restituisce un array che \u00e8 la concatenazione dell'array a cui si applica il metodo e array2 splice(startIndex, nToDelete, elem1, elem2, ...); : Restituisce un array derivato dall'array a cui si applica il metodo aggiungendo elem1 , elem2 , .. a partire da startIndex ed eliminando i primi nToDelete elementi a partire da startIndex . Se non specifico i parametri elem1 , elem2 , .. semplicemente elimina gli elementi nToDelete a partire da startIndex . fill(value, indexStart, indexEnd) : Inserisce value all'interno dell'array tra i parametri opzionali indexStart e indexEnd . Omettendo indexStart e indexEnd riempie tuttto l'array con value join() : Trasforma un array in stringa reverse() : Inverte l'ordine degli elementi sort() : Ordinamento lessicografico degli elementi. Ogni elemento viene quindi trattato come una stringa e poi ordinato secondo la precedenza definita dalla rappresentazione in UTF-8 (ASCII) //push const colori = [ \"rosso\" , \"verde\" , \"giallo\" ]; console . log ( colori ); //(3) [\"rosso\", \"verde\", \"giallo\"] let newArrayLenght = colori . push ( \"blu\" ); //push ritorna il numero degli elementi dell'array console . log ( colori , newArrayLenght ); //(4) [\"rosso\", \"verde\", \"giallo\", \"blu\"] 4 //pop console . log ( colori ); //(4) [\"rosso\", \"verde\", \"giallo\", \"blu\"] let lastElement = colori . pop (); //pop ritorna l'elemento che ha tolto console . log ( colori , lastElement ); //(3) [\"rosso\", \"verde\", \"giallo\"] \"blu\" //unshift console . log ( colori ); //[\"rosso\", \"verde\", \"giallo\"] newArrayLenght = colori . unshift ( \"gialletto\" ); //unshift ritorna il numero degli elementi dell'array console . log ( colori , newArrayLenght ); //(4) [\"gialletto\", \"rosso\", \"verde\", \"giallo\"] 4 //shift console . log ( colori ); //(4) [\"gialletto\", \"rosso\", \"verde\", \"giallo\"] let firstElement = colori . shift (); //shift ritorna l'elemento che ha tolto console . log ( colori , firstElement ); //(3) [\"rosso\", \"verde\", \"giallo\"] \"gialletto\" //indexOf console . log ( colori ); //(3) [\"rosso\", \"verde\", \"giallo\"] let indexElem = colori . indexOf ( \"verde\" ); console . log ( indexElem ); //1 //slice // 0 1 2 3 4 const social = [ \"facebook\" , \"instagram\" , \"whatsapp\" , \"telegram\" , \"snapchat\" ]; const messaggi = social . slice ( 2 , 4 ); console . log ( messaggi ); //(2) [\"whatsapp\", \"telegram\"] //concat const numeriBassi = [ 1 , 2 , 3 ]; const numeriAlti = [ 100 , 200 , 300 ]; const tuttiNumeri = numeriBassi . concat ( numeriAlti ); console . log ( tuttiNumeri ); //(6) [1, 2, 3, 100, 200, 300] //splice //poich\u00e8 il secondo parametro \u00e8 0, aggiunger\u00e0 a partire dall'indice 3 i parametri 50, 60, 70 tuttiNumeri . splice ( 3 , 0 , 50 , 60 , 70 ); //poich\u00e8 il secondo parametro \u00e8 0 console . log ( tuttiNumeri ); //(9) [1, 2, 3, 50, 60, 70, 100, 200, 300] //poich\u00e8 il secondo parametro \u00e8 3, sostituir\u00e0 50, 60, 70 con -50, -60, -70 tuttiNumeri . splice ( 3 , 3 , - 50 , - 60 , - 70 ); console . log ( tuttiNumeri ); //(9) [1, 2, 3, -50, -60, -70, 100, 200, 300] //fill() const myArr = [ 1 , 2 , 4 , 1 , 5 , 5 , 7 ]; myArr . fill ( 0 , 1 , 3 ); console . log ( myArr ); //(7) [1, 0, 0, 1, 5, 5, 7] //join() const paroleTesto = [ \"ciao\" , \" \" , \"a\" , \" \" , \"tutti\" ]; console . log ( paroleTesto ); //(5) [\"ciao\", \" \", \"a\", \" \", \"tutti\"] conole . log ( parole . Testo . join ()); // ciao, ,a, ,tutti //reverse() const numeriDispari = [ 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 ]; console . log ( numeriDispari ); //(10 [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] console . log ( numeriDispari . reverse ()); //(10) [19, 17, 15, 13, 11, 9, 7, 5, 3, 1] //sort() - ATTENZIONE console . log ( numeriDispari . sort ()); //(10) [1, 11, 13, 15, 17, 19, 3, 5, 7, 9]","title":"Array - Metodi base"},{"location":"javascript/#lezione-25","text":"","title":"Lezione 25"},{"location":"javascript/#arrays-foreach","text":"forEach() \u00e8 un metodo applicabile agli array utilizzato per l'iterazione. forEach ( function ( value , index , array ){ /*code*/ }); Riceve come parametro una funzione detta anonima poich\u00e8 non ha un nome. La funzione riceve tre parametri opzionali, in ordine value , index , array che, dell'array a cui \u00e8 applicato il metodo, rappresentano rispettivamente l'elemento, l'indice e l'array stesso. Viene invocata la funzione anonima per ogni elemento (forEach) presente nell'array. const frutta = [ \"mela\" , \"pera\" , \"banana\" ]; stampaArray ( frutta ); function stampaArray ( arr ) { //i parametri della funzione anonima del forEach sono opzionali e, essendo parametri posso //dare un nome simbolico qualsiasi arr . forEach ( function ( elemento , indice , a ) { console . log ( indice + \": \" + a [ indice ] ); } ); } /* 0: mela 1: pera 2: banana */","title":"Arrays - forEach()"},{"location":"javascript/#arrays-map","text":"map() \u00e8 un metodo applicabile agli array utilizzato per l'iterazione. map ( function ( value , index , array ){ /*code*/ }); Itera ogni elemento dell'array e ritorna un array. E' utile quindi all'elaborazione e costruzione di un nuovo array a partire da quello a cui si applica il metodo. Riceve come parametro una funzione detta anonima poich\u00e8 non ha un nome. La funzione riceve tre parametri opzionali, in ordine value , index , array che, dell'array a cui \u00e8 applicato il metodo, rappresentano rispettivamente l'elemento, l'indice e l'array stesso. Viene invocata la funzione anonima per ogni elemento (forEach) presente nell'array. const fruits = [ 'mela' , 'pera' , 'banana' ]; //In questo caso newFruits sar\u00e0 identico a fruits. Ho effettuato una copia const newFruits = fruits . map ( function ( value , index ){ return value ; }) console . log ( newFruits ); //(3) [\"mela\", \"pera\", \"banana\"] //In questo caso newFruits2 sar\u00e0 un array contenente 0, 1, 2 poich\u00e8 ritorna l'indice const newFruits2 = fruits . map ( function ( value , index ){ return index ; }) console . log ( newFruits2 ); //3) [0, 1, 2]","title":"Arrays - map()"},{"location":"javascript/#funzioni-freccia-lambda","text":"Oltre alla sintassi espressa tramite funzione anonima esiste anche una sintassi diversa espressa tramite l'operatore freccia => . Ogni funzione anonima pu\u00f2 essere espressa tramite l'operatore freccia, questo tipo di funzione prende il nome di funzione lambda . ( param1 , param2 , ..) => { /*code*/ }; //function(param1, param2, ..{/*code*/} //Esempi con forEach() e map() map ( ( value , index , array ) => { /*code*/ } ); forEach ( ( value , index , array ) => { /*code*/ }); Nota: - I parametri vanno sempre espressi tra parentesi. Se si ha necessit\u00e0 solo del primo parametro le parentesi possono essere omesse. - In generale il corpo della funzione lambda va tra le parentesi graffe { } . Se il corpo ha un'istruzione inline, le parentesi graffe possono essere omesse. Esempio interessante: //casuali \u00e8 un array di 30 numeri inter casuali const numeriCasuali = []; for ( let i = 0 ; i < 10 ; i ++ ) { numeriCasuali . push ( Math . floor ( Math . random () * 100 ) ) ;} console . log ( numeriCasuali ); //32, 54, 33, 91, 4, 25, 46, 37, 73, 2] //calcola il resto della divisione per 7 dei numeri casuali //e crea con questi un nuovo array const isPari = numeriCasuali . map ( ( elemento , indice , a ) => Boolean ( ! ( elemento % 2 )) ); console . log ( isPari ); //[true, true, false, false, true, false, true, false, false, true]","title":"Funzioni freccia (lambda)"},{"location":"javascript/#array-metodi-avanzati","text":"filter( (value,index,array) => {/*CONDITION*/} ); : Ritorna un array risultato del filtraggio gli elementi dell'array a cui si applica il metodo che restituiscono true nella CONDITION some ( (value,index,array) => {/*CONDITION*/} ); : Ritorna un booleano se c'\u00e8 almeno un elemento nell'array che restituisce true alla CONDITION every ( (value,index,array) => {/*CONDITION*/} ); Ritorna true (ritorna n boolean) se c'\u00e8 almeno un elemento nell'array che restituisce true alla CONDITION reduce ((accumulatore, value,index,array) => {/*CONDITION*/}, startValueAccumulatore); : Ritorna il numero di elementi che soddisfano la CONDITION . Ha due parametri: il primo \u00e8 una funzione freccia che riceve a sua volta 4 parametri in ordine: accumulatore , value , index , array , il secondo, startValueAccumulatore \u00e8 il valore di partenza dell'accumulatore, opzionale. Se non si specifica il valore di partenza dell'accumulatore startValueAccumulatore viene assegnato come valore il primo elemento. let casuali = []; for ( let i = 0 ; i < 20 ; i ++ ) { casuali . push ( Math . floor ( Math . random () * 100 ) ) ;} let diversiDaZero = casuali . filter ( elemento => elemento !== 0 ); console . log ( diversiDaZero ); if ( diversiDaZero . some ( elemento => elemento > 4 ) ) { console . log ( \"Trovato almento un resto maggiore di zero\" );} let quanti = diversiDaZero . reduce ( ( conta , elemento ) => elemento > 4 ? conta + 1 : conta , 0 ); console . log ( quanti ); //19 let totale = diversiDaZero . reduce ( ( somma , elemento ) => somma + elemento ); console . log ( totale ); //1057 /* [37, 67, 31, 88, 55, 45, 26, 21, 32, 2, 20, 62, 79, 48, 85, 53, 33, 97, 92, 84] Trovato almento un resto maggiore di zero 19 1057 */","title":"Array - Metodi avanzati"},{"location":"javascript/#lezione-26","text":"","title":"Lezione 26"},{"location":"javascript/#introduzione-agli-object","text":"JavaScript \u00e8 progettato su un semplice paradigma basato su oggetti. Un oggetto \u00e8 una raccolta di propriet\u00e0 e una propriet\u00e0 \u00e8 un'associazione tra un nome (o chiave) e un valore. Il valore di una propriet\u00e0 pu\u00f2 essere una funzione, nel qual caso la propriet\u00e0 \u00e8 nota come metodo. Oltre agli oggetti predefiniti nel browser, \u00e8 possibile definire i propri oggetti. Questo capitolo descrive come utilizzare oggetti, propriet\u00e0, funzioni e metodi e come creare i propri oggetti. Gli oggetti in JavaScript, proprio come in molti altri linguaggi di programmazione, possono essere paragonati agli oggetti nella vita reale. Il concetto di oggetti in JavaScript pu\u00f2 essere compreso con oggetti tangibili della vita reale. In JavaScript, un oggetto \u00e8 un'entit\u00e0 autonoma, con propriet\u00e0 e tipo. Confrontalo con una tazza, per esempio. Una tazza \u00e8 un oggetto, con propriet\u00e0. Una tazza ha un colore, un disegno, un peso, un materiale di cui \u00e8 composta, ecc. Allo stesso modo, gli oggetti JavaScript possono avere propriet\u00e0 che definiscono le loro caratteristiche. Fonte: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#:~:text=JavaScript%20is%20designed%20on%20a,is%20known%20as%20a%20method. Sono un tipo di data-structure che rappresenta elementi tramite una coppia chiave/valore . Si accede al valore tramite il nome dell'oggetto e la sua property cio\u00e8 l'identificativo della chiave. const object = { key1 : value1 , key2 : value2 , key3 : value3 } SI chiama modello per prototipazione. Cio\u00e8 un modello creato che andremo ad arricchire e modificare nel corso del codice dinamicamente. Un oggetto in js \u00e8 una collezione di coppe identificatore: valore Esempio // Dichiarazione di un oggetto, prototipo const persona = { nome : \"Simone\" , eta : 23 , citta : \"Lucca\" } //accesso ai dati //Modo 1 persona . nome ; //Simone, (=== persona[\"nome\"]) //Modo2 persona [ \"citta\" ]; //Lucca, (=== persona.citta) //modifica di un valore dell'oggetto persona . nome = \"Luigi\" ; //Eliminazione della property <citta> dall'oggetto delete persona . citta ; console . log ( persona ); /* persona = { nome: \"Luigi\", eta: 23 } */ La creazione/dichiarazione di un oggetto con propriet\u00e0 e metodi (vedremo pi\u00f9 avanti) viene anche detto prototipo. Il prototipo \u00e8 un modello base dell'oggetto che pu\u00f2 essere arricchito o modificato nel corso del programma dinamicamente Posso creare un oggetto inizialmente vuoto e aggiungere gli elementi successivamente //Dichiaro un oggetto vuoto, modo 1 - preferibile var persona = {}; //Dichiaro un oggetto vuoto, modo 2 var computer = new Object ; //Inserisco elementi in un oggetto inizialmente vuoto persona . nome = \"billy\" ; persona . hobby = \"scacchi\" ; computer . ram = \"4Gb\" ; computer . rom = \"1Tb\" ; Di seguito mostro un esempio di un oggetto pi\u00f9 complicato. In realt\u00e0 \u00e8 un array di oggetti var post = [ // index: 0 { username : \"Billy\" , like : 4 , commenti : [ \"figo!\" , \"ottimo\" , \"bleah\" ] }, // index: 1 { username : \"thebest95\" , like : 0 , commenti : [ \"fighissimo\" , \"buono\" , \"buonissimo\" ] } ] console . log ( post ); /* Console: --------------- (2) [{\u2026}, {\u2026}] 0: commenti: (3) [\"figo!\", \"ottimo\", \"bleah\"] like: 4 username: \"Billy\" __proto__: Object 1: commenti: (3) [\"fighissimo\", \"buono\", \"buonissimo\"] like: 0 username: \"thebest95\" __proto__: Object length: 2 __proto__: Array(0) */ //Aggiungo un commento al primo elemento, cio\u00e8 all'oggetto cui corrisponde username \"Billy\" post [ 0 ]. commenti . push ( \"Fantastico!\" ); console . log ( post ); /* Console: --------------- (2) [{\u2026}, {\u2026}] 0: commenti: (3) [\"figo!\", \"ottimo\", \"bleah\",\"Fantastico!\"] like: 4 username: \"Billy\" __proto__: Object 1: commenti: (3) [\"fighissimo\", \"buono\", \"buonissimo\"] like: 0 username: \"thebest95\" __proto__: Object length: 2 __proto__: Array(0) */","title":"Introduzione agli Object"},{"location":"javascript/#javascript-oop","text":"Javascript Lezione 01 Prerequisiti al corso Approccio al corso Strumenti Necessari Introduzione Lezione 02 Cenni storici Aspetti strutturali Versioni di Javascript Configurazione di un IDE Visual Studio Code - VS code Lezione 03 Primo script Lezione 04 Console - Browser Web Alert & prompt Commenti Lezione 05 Introduzione al DOM Introduzione alla libreria JQuery DOM ed Eventi Lezione 06 Variabili Javascript Tipi di dati in JS Dati nativi Reference type Alcune regole generali per dichiarazione di variabili Reference type Const Approfondimento Null - undefined - NaN Lezione 07 Stringhe Opearotri, Propriet\u00e0 e Metodi su stringhe Operatori Approfondimento Interpolazioni di stringhe Le stringhe sono immutabili Propriet\u00e0 Metodi Lezione 08 Conta parole Lezione 09 Approfondimento - Rappresentazione numerica in Javascript Numeri in Fixed Point Numeri in Floating Point Not A Number NaN Lezione 10 Approfondimento - Codifica caratteri Javascript ASCII Unicode Caratteri di Escape Lezione 11 Type conversion Conversione esplicita Conversione implicita Lezione 12 Operatori matematici Pre e post incremento/decremento Oggetto MATH Lezione 13 Equazione di II grado Lezione 14 Operator Precedence Associativit\u00e0 Operatori di assegnamento Lezione 15 Operatori Logici Logica Booleana Approfondimento - Short evalutation Truthy e falsy Lezione 16 Control Structure if/else Ternary Operator Switch statemeant Lezione 17 while loop do-while loop Lezione 18 for loop break & coninue Lezione 19 Function Parametri di default Ritorno di una funzione Lezione 20 Funzioni - Passaggio di oggetti e array Funzioni - Ritorno di un oggetto o un array Approfondimento funzioni - Oggetto Arguments Approfondimento funzioni - Parametri Rest Approfondimento Introduzione forEach / this Lezione 21 Approfondimento Funzioni ricorsive Approfondimento Function expression Approfondimento Hoisting Approfondimento Differenza tra undefined e not defined Approfondimento IIFI Immediatly invoked function expression Paradigma di programmazione Javascript Lezione 22 Scope Visibilit\u00e0 di variabili Visibilit\u00e0 Globale (global scope) Scope Chaining Visibilit\u00e0 a livello di blocco (block scope) Approfondimento - Closure di una funzione Lezione 23 Array Matrix Lezione 24 Array - Metodi base Lezione 25 Arrays - forEach() Arrays - map() Funzioni freccia (lambda) Array - Metodi avanzati Lezione 26 Introduzione agli Object Javascript OOP Lezione 01 OOP Object Oriented Programming Lezione 02 Introduzione ai Metodi Lezione 03 Costruttore Lezione 04 Ereditariet\u00e0 Lezione 05 Ereditariet\u00e0 - Shadowing Ereditariet\u00e0 classica Lezione 06 THIS Object - Variabili Statiche (condivise) Lezione 07 Introduzione For In Oggetto Date() Lezione 08 Classi Lezione 09 Classi assegnanili a variabili Get / Set try-catch Lezione 10 Derivazione di classi , ereditariet\u00e0 Lezione 11 Ereditariet\u00e0 classi Pt 2 Lezione 12 Approfondimento - Symbols Lezione 13 Approfondimento - Iterables/Iterator Costrutto for - of Lezione 14 Approfondimento - Funzioni Generatrici Lezione 15 Approfondimento - Esempio (For .. of) custom Lezione 16 Destructuring Lezione 17 Map Object Iterazione Map Object Lezione 18 Set Conversione di un Oggetto Map / Set in un Array Lezione 19 Dom Manipulation Lezione 20 DOM - Selettori Metodi di selezione di elementi html Lezione 21 Dom - Child e Parent DOM - Manipolazione dello stile degli elementi html Lezione 22 DOM - Manipolazione del testo degli elementi html DOM - Manipolazione degli attributi html Lezione 23 DOM - Creazione di Un elemento DOM - Rimpiazzo di un elemento DOM - ELiminazione di un elemento Lezione 24 DOM Events Metodo addEventListener Lezione 25 Prevent Default Che cos'\u00e8 esattamente l'oggetto ricevuto come unico parametro \"e\"? Lezione 26 Approfondimento type event Aprrofondimento eventi tastiera e input Lezione 27 Argomeni non trattati / da approfondire Fonti APPRONDIMENTI PT.1 Node.js Cos'\u00e8 node Install node Prima applicazione nodejs Non esiste l'oggetto window global objects Modules Creiamo un modulo Moduli built-in Modulo path Modulo OS Modulo File System Eventi Modulo HTTP Approfondimenti Passare dei parametri esterni My first IO sync My first IO async Filtered APPRONDIMENTI PT.2 Promise Un esempio semplice APPRONDIMENTI PT.3 Approfondimento Hoisting Approfondimento Oggetti Approfondimento Moduli Packages Approfondimento THIS Costruttori prefdefiniti javascript for .. of for .. in Memoization Come fare una copia profonda tra oggetti? propriet\u00e0 associate ai dati e proprier\u00e0 associate all'accesso get & set Arrow functions High Order Functions Array filter Array map Array reduce Gli array possiedono gi\u00e0 come metodi filer, map, reduce Qualche chicca sugli Array Arrray.of, Array.from concat, every, some find, filter, forEach, includes, indexOf push, pop, shift, unshift sort, splice, slice setTimeout(), setInterval() Eventi Asincroni Promise, resolve, reject, then Async, Await Promise.all() e Promise.race() Set e Map Map","title":"Javascript OOP"},{"location":"javascript/#lezione-01_1","text":"","title":"Lezione 01"},{"location":"javascript/#oop-object-oriented-programming","text":"Si ricordi la frase di apertura di questo corso: In informatica JavaScript \u00e8 un linguaggio di programmazione orientato agli oggetti e agli eventi... Ma che cos'\u00e8 un linguaggio di programmazione orientato agli oggetti? In informatica, la programmazione orientata agli oggetti (in inglese object-oriented programming, in acronimo OOP) \u00e8 un paradigma di programmazione che permette di definire oggetti software in grado di interagire gli uni con gli altri attraverso lo scambio di messaggi. Particolarmente adatta nei contesti in cui si possono definire delle relazioni di interdipendenza tra i concetti da modellare (contenimento, uso, specializzazione), un ambito che pi\u00f9 di altri riesce a sfruttare i vantaggi della programmazione ad oggetti \u00e8 quello delle interfacce grafiche. Tra gli altri vantaggi della programmazione orientata agli oggetti: essa fornisce un supporto naturale alla modellazione software degli oggetti del mondo reale o del modello astratto da riprodurre; permette una pi\u00f9 facile gestione e manutenzione di progetti di grandi dimensioni; l'organizzazione del codice sotto forma di classi favorisce la modularit\u00e0 e il riuso di codice. Fonte: https://it.wikipedia.org/wiki/Programmazione_orientata_agli_oggetti Ma non esiste solo il paradigma di programmazione orientato agli oggetti. Altri due paradigmi di programmazione sono il paradigma di programmazione procedurale e il paradigma di programmazione imperativa Programmazione Procedurale In informatica la programmazione procedurale \u00e8 un paradigma di programmazione che consiste nel creare dei blocchi di codice sorgente, identificati da un nome e racchiusi da dei delimitatori, che variano a seconda del linguaggio di programmazione; questi sono detti anche sottoprogrammi (in inglese subroutine), procedure o funzioni, a seconda del linguaggio e dei loro ruoli all'interno del linguaggio stesso. Il nome deriva dal linguaggio COBOL, che \u00e8 stato il primo ad utilizzare questo concetto. Questi blocchi possono essere dotati di parametri, cio\u00e8 variabili locali i cui valori vengono forniti o passati dall'esterno del blocco di codice ed eventualmente esportati; esistono due tipi di parametri: quelli di tipo valore e quelli di tipo variabile; nei primi viene passato un valore che, se modificato, non viene comunque salvato al termine del sottoprogramma; nel tipo variabile invece, viene comunicato l'indirizzo della cella di memoria (ad es.tramite un puntatore) al quale troviamo l'informazione, che pu\u00f2 quindi essere modificata effettivamente e permanentemente. All'interno di un sottoprogramma possono essere generalmente definite o dichiarate delle variabili locali, che vengono deallocate al termine del sottoprogramma stesso; il loro contenuto viene quindi perso se non salvato o trasmesso altrimenti. In Linguaggio C esiste solo la function, che pu\u00f2 o meno restituire valori; lo stesso dicasi per il Java ed il PHP; i blocchi sono racchiusi tra parentesi graffe. Questo tipo di paradigma \u00e8 tipico per la programmazione di sistemi embedded. Fonte: https://it.wikipedia.org/wiki/Programmazione_procedurale Programmazione imperativa In informatica, la programmazione imperativa \u00e8 un paradigma di programmazione secondo cui un programma viene inteso come un insieme di istruzioni (dette anche direttive o comandi), ciascuna delle quali pu\u00f2 essere pensata come un \"ordine\" che viene impartito alla macchina virtuale del linguaggio di programmazione utilizzato. Da un punto di vista sintattico, i costrutti di un linguaggio imperativo sono spesso identificati da verbi all'imperativo. L'approccio imperativo \u00e8 l'approccio dominante in programmazione. Nello studio dei linguaggi di programmazione, si definisce il concetto di paradigma di programmazione, ovvero un insieme di regole e strutture che definiscono un tipo di linguaggio basandosi esclusivamente sulle sue strutture, e quindi non sulle sue caratteristiche peculiari legate all'implementazione dello stesso (es. le parole chiave). Sono di tipo imperativo la grande maggioranza dei (sotto-)paradigmi di programmazione (per esempio la programmazione procedurale, la programmazione strutturata, la programmazione orientata agli oggetti e cos\u00ec via) e la grande maggioranza dei linguaggi (per esempio ALGOL, Ada, BASIC, Fortran, Pascal, PHP eccetera). Fonte: https://it.wikipedia.org/wiki/Programmazione_imperativa Javascript \u00e8 un linguaggio di programmazione che si presta molto bene a tutti e tre i paradigmi. Adesso approfondiremo il paradigma di programmazione orientato agli oggetti concludendo con la definizione di classe","title":"OOP Object Oriented Programming"},{"location":"javascript/#lezione-02_1","text":"","title":"Lezione 02"},{"location":"javascript/#introduzione-ai-metodi","text":"Si ricordi che con Javascript \u00e8 possibile definire delle funzioni assegnabili a variabili, \u00e8 quindi possibile definire delle funzioni assegnabili a una property. In questo caso si parla di metodi Metodo: Funzione applicabile a un oggetto. Non ha senso al di fuori del contesto dell'oggetto in cui \u00e8 stata definita var persona = { nome : \"Simone\" , dataDiNascita : 1995 , sesso : \"maschio\" , isMarried : false , famiglia : [ \"Anotinio\" , \"Giovanni\" , \"Alice\" ], calcolaEta : function (){ return 2020 - this . dataDiNascita ; } } console . log ( persona . calcolaEta ()); //25 Nella definizione di un metodo (una funzione all'interno di un oggetto), this rappresenta l'oggetto stesso. E' quindi necessario per poter prelevare ed elaborare le property interne dell'oggetto che ricordiamo sono accessibili solo attraverso il nome dell'oggetto. Nella definizione di un metodo non posso accedere direttamente alle property senza invocare this l'interprete solleverebbere un'eccezione poich\u00e8 non riconoscerebbe l'identificatore invocato. var persona = { nome : \"Simone\" , dataDiNascita : 1995 , sesso : \"maschio\" , isMarried : false , famiglia : [ \"Anotinio\" , \"Giovanni\" , \"Alice\" ], calcolaEta : function (){ return 2020 - dataDiNascita ; } } console . log ( persona . calcolaEta ()); //dataDiNascita is not defined Nota: la keyword this ha anche altri significati che dipendono dal contesto in cui \u00e8 chiamato. Posso invocare un metodo anche per definire una nuova propriet\u00e0 dell'oggetto: const persona = { nome : \"Simone\" , dataDiNascita : 1995 , sesso : \"maschio\" , isMarried : false , famiglia : [ \"Anotinio\" , \"Giovanni\" , \"Alice\" ], calcolaEta : function (){ return 2020 - this . dataDiNascita ; } } //Verr\u00e0 aggiunta la property \"eta\" all'oggetto persona . eta = persona . calcolaEta (); console . log ( persona ); /* Console: --------------- {nome: \"Simone\", dataDiNascita: 1995, sesso: \"maschio\", isMarried: false, famiglia: Array(3), \u2026} calcolaEta: \u0192 () dataDiNascita: 1995 eta: 25 famiglia: (3) [\"Anotinio\", \"Giovanni\", \"Alice\"] isMarried: false nome: \"Simone\" sesso: \"maschio\" __proto__: Object */ Vediamo un altro esempio: let libro = { titolo : \"Fondazione\" , pagine : 571 } let autorePreferito = { cognome : \"Asimov\" , nome : \"Isaac\" , // E' possibile definire una property tra gli apici doppi \"nameProperty\" //in modo da forzare a valutarla come identificatore. //Infatti in questo caso il nome libro-preferito non sarebbe accettata come sintassi a causa del \"-\" //E' comunque da EVITARE \"libro-preferito\" : { titolo : \"L`uomo del bicentenario\" , pagine : 288 }, //Riferimento all'oggetto \"libro\" esterno. Attenzione! //E' un riferimento non \u00e8 una copia. Se modifico questa property di questo oggetto (autorePreferito) //modifico anche l'oggetto libro e viceversa. bestSeller : libro , } //Per accedere alla propriet\u00e0 \"libro-preferito\" devo per necessariamente utilizzare la notazione con le []. La notazione ///con \".\" non pu\u00f2 andare bene. //Ecco perch\u00e8 \u00e8 necessario evitare questi nomi con caratteri non validi cosnole . log ( autorePreferito [ \"libro-preferito\" ]. pagine ); console . log ( autorePreferito . bestSeller . titolo ); autorePreferito . bestSeller . pagine = 1000 ; console . log ( libro . pagine ); //1000, ATTENZIONE Come abbiamo visto in questo esempio, specificando come property un altro oggetto, questo viene passato per riferimento e non viene fatta una copia. La libreria JQuery pu\u00f2 aiutarci in questo. let libro = { titolo : \"Fondazione\" , pagine : 571 } let autorePreferito = { cognome : \"Asimov\" , nome : \"Isaac\" , //in questo caso sono necessari i doppi apici (o singoli) perch\u00e8 scrivendo libro-preferito lo tratterebbe com espressione. E' comunque da EVITARE \"libro-preferito\" : { titolo : \"L`uomo del bicentenario\" , pagine : 288 }, //in questo caso \u00e8 JQuery che si occupa di restituire una copia dell'oggetto bestSeller : jQuery . extend ( true , {}, libro ) } console . log ( autorePreferito [ \"libro-preferito\" ]. pagine ); //288 console . log ( autorePreferito . bestSeller . titolo ); //Fondazione autorePreferito . bestSeller . pagine = 1000 ; console . log ( libro . pagine ); //571 La funzione jQuery.extend(true, {}, object) effettua la copia ricorsiva di tutti elementi dell'oggetto specificato come terzo parametro.","title":"Introduzione ai Metodi"},{"location":"javascript/#lezione-03_1","text":"","title":"Lezione 03"},{"location":"javascript/#costruttore","text":"Partendo dall'esempio della lezione precedente, riporto un esempio completo di come creare un nuovo oggetto partendo dal prototipo. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > let libro = { titolo : \"\" , pagine : 0 } let autorePreferito = { cognome : \"\" , nome : \"\" , libroPreferito : { titolo : \"\" , pagine : 0 }, //JQuery.extend() restituisce una copia dell'oggetto bestSeller : jQuery . extend ( true , {}, libro ) } console . log ( autorePreferito . cognome ); console . log ( autorePreferito . nome ); console . log ( autorePreferito . libroPreferito . titolo ); console . log ( autorePreferito . libroPreferito . pagine ); console . log ( autorePreferito . bestSeller . titolo ); console . log ( autorePreferito . bestSeller . pagine ); //Chiamata al costruttore libro = new LibroConstructor ( \"Il ritorno all'isola\" , 301 ); //Chiamata al costruttore autorePreferito = new Autore ( \"Isaac\" , \"Asimov\" , \"L`uomo del bicentenario\" , 288 , libro ); //Modo alternativo /* autorePreferito = new Autore( \"Isaac\", \"Asimov\", \"L`uomo del bicentenario\", 288, new LibroConstructor ( \"Il ritorno all'isola\", 301 ) ); */ //Funzione costruttore function Autore ( cognome , nome , titolo , pagine , bestSeller ) { //stato interno this . cognome = cognome ; this . nome = nome ; this . libroPreferito = { titolo , pagine }; //this.libroPreferito = {titolo: titolo,pagine: pagine}; this . bestSeller = jQuery . extend ( true , {}, bestSeller ); } function LibroConstructor ( titolo , pagine ){ this . titolo = titolo ; this . pagine = pagine ; } console . log ( autorePreferito . cognome ); console . log ( autorePreferito . nome ); console . log ( autorePreferito . libroPreferito . titolo ); console . log ( autorePreferito . libroPreferito . pagine ); console . log ( autorePreferito . bestSeller . titolo ); console . log ( autorePreferito . bestSeller . pagine ); /* \"\" \"\" \"\" 0 \"\" 0 Isaac Asimov L`uomo del bicentenario 288 Il ritorno all'isola 301 */ </ script > </ body > </ html > Il costruttore \u00e8 una funzione che riceve come parametri i valori delle property e costruisce (ritorna) un oggetto. Notare l'uso del new necessario per l'invocazione del costruttore e del this ripetuto per ogni property necessario per stabilire il contesto dell'oggetto che viene creato dal costruttore. Vediamo adesso l'aggiunta di metodi all'esempio di sopra: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > let libro = { titolo : \"\" , pagine : 0 } function LibroConstructor ( titolo , pagine ){ this . titolo = titolo ; this . pagine = pagine ; } let autorePreferito = { cognome : \"\" , nome : \"\" , libroPreferito : { titolo : \"\" , pagine : 0 }, bestSeller : jQuery . extend ( true , {}, libro ) } function Autore ( cognome , nome , titolo , pagine , bestSeller ) { //stato interno this . cognome = cognome ; this . nome = nome ; this . libroPreferito = { titolo , pagine }; //this.libroPreferito = {titolo: titolo,pagine: pagine}; this . bestSeller = jQuery . extend ( true , {}, bestSeller ); //metodi this . getSchedaBestSeller = function () { let stringa = this . bestSeller . titolo + \"\\n\" + this . bestSeller . pagine ; let stringaConCornicetta = \"*\" . repeat ( 10 ) + \"\\n\" + \"BestSeller\" + \"\\n\" + \"-\" . repeat ( 10 ) + \"\\n\" + stringa + \"\\n\" + \"*\" . repeat ( 10 ); return stringaConCornicetta ; } this . getSchedaAutore = function () { let stringa = this . cognome + \"\\n\" + this . nome + \"\\n\" + this . libroPreferito . titolo + \"\\n\" + this . libroPreferito . pagine ; let stringaConCornicetta = \"*\" . repeat ( 10 ) + \"\\n\" + \"Scheda\" + \"\\n\" + \"-\" . repeat ( 10 ) + \"\\n\" + stringa + \"\\n\" + \"*\" . repeat ( 10 ); return stringaConCornicetta ; } } //Creo una collezione di oggetti, cio\u00e8 un array di oggetti let schedario = [ new Autore ( \"Runny\" , \"Ted\" , \"Lo sguardo del principe\" , 212 , new LibroConstructor ( \"Il mio viaggio\" , 272 ) ), new Autore ( \"Buld\" , \"Frank\" , \"I segreti di tutti\" , 302 , new LibroConstructor ( \"Il mio segreto\" , 180 ) ) ]; //Aggiungo in coda un nuovo oggetto schedario . push ( new Autore ( \"Tuy\" , \"malek\" , \"La voglia di te\" , 167 , new LibroConstructor ( \"la voglia di niente\" , 134 ) ) ); //itero ogni elemento dell'array e chiamo i metodi for ( let autore of schedario ) { console . log ( autore . getSchedaAutore () ); console . log ( autore . getSchedaBestSeller () ); } /* ********** Scheda ---------- Runny Ted Lo sguardo del principe 212 ********** ********** BestSeller ---------- Il mio viaggio 272 ********** ********** Scheda ---------- Buld Frank I segreti di tutti 302 ********** ********** BestSeller ---------- Il mio segreto 180 ********** ********** Scheda ---------- Tuy malek La voglia di te 167 ********** ********** BestSeller ---------- la voglia di niente 134 ********** */ </ script > </ body > </ html >","title":"Costruttore"},{"location":"javascript/#lezione-04_1","text":"","title":"Lezione 04"},{"location":"javascript/#ereditarieta","text":"JavaScript confonde un po' gli sviluppatori che hanno esperienza di linguaggi basati sulle classi (come Java o C++), poich\u00e8 \u00e8 un linguaggio dinamico e non fornisce un'implementazione di class (la keyword class \u00e8 introdotto in ES2015, ma \u00e8 zucchero sintattico, Javascript rimarr\u00e0 basato sui prototipi). In termini di ereditariet\u00e0, Javascript ha solo un costrutto: gli oggetti. Ogni oggetto ha un link interno ad un altro oggetto chiamato prototype. Questo oggetto prototype ha a sua volta un suo prototype, e cos\u00ec via finch\u00e9 si raggiunge un oggetto con property null. null, per definizione, non ha un prototype, ed agisce come link finale nella catena di prototipi. Quasi tutti gli oggetti in Javascript sono istanze di Object, che risiede in cima alla catena dei prototipi. Nonostante questo sia considerato spesso come una debolezza di Javascript, il modello di ereditariet\u00e0 prototipale \u00e8 invece pi\u00f9 potente del modello classico. Per esempio, \u00e8 banale costruire un classico modello sul modello prototipale, mentre il contrario \u00e8 molto pi\u00f9 difficile. Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Inheritance_and_the_prototype_chain Supponiamo di aver creato un oggetto con certe propriet\u00e0 e metodi e di voler creare un altro oggetto con le stesse propiet\u00e0 e gli stessi metodi ed altre propriet\u00e0/metodi speifiche. Una soluzione, per quello che conosciamo adesso, si ha banalmente con un copia e incolla dell'oggetto modello (prototipo) aggiungendo poi le caratteristiche aggiuntive. Il concetto dell'ereditariet\u00e0 evita questa procedura di copia incolla non solo perch\u00e8 sarebbe una ripetizione ma anche, soprattutto, perch\u00e8 gli errori con i copia e incolla diventano intracciabili. Se \u00e8 stato individuato un errore nell'oggetto A, \u00e8 necessario riportare tutte le modifiche anche negli altri oggetti di cui si \u00e8 effettuata la copia manuale .. non \u00e8 il massimo. Per parlare di ereditariet\u00e0 dobbiamo parlare di gerarchia padre/figlio. Un figlio \u00e8 un oggetto che contiene tutte le caratteristiche del padre ovvero ne eredita le propriet\u00e0. Si parla anche di modello is-a Immaginiamo di avere questo modello piramidale: Animali Mammiferi Cane Gatto Volpe L'oggetto Volpe \u00e8 un (is-a) Mammifero , un Mammifero \u00e8 un (is-a) Animale . Secondo questo modello \u00e8 possibile costruire degli oggetti molto dettagliati semplicemente sfruttando le propriet\u00e0 ereditate Vediamo come si costruisce un oggetto con propriet\u00e0 ereditate //persona \u00e8 l'oggetto <padre> let persona = { nome : \"\" }; //Creo l'oggetto fantozzi. //fantozzi \u00e8 un oggetto che ha come prototipo l'oggetto persona. //fantozzi is-a persona let fantozzi = Object . create ( persona ); //persona e il prototipo di fantozzi sono la stesso oggetto console . log ( persona === Object . getPrototypeOf ( fantozzi )); => true //Per accedere in scrittura alle propriet\u00e0 ereditate si utilizza il metodo getPrototypeOf() //applicabile agli oggetti Object . getPrototypeOf ( fantozzi ). nome = \"Fantozzi\" ; //non avrei potuto scrivere direttamente \"fantozzi.nome\" perch\u00e8 avrebbe creato una propriet\u00e0 locale //poich\u00e8 <nome> non \u00e8 una propriet\u00e0 dell'oggetto \"fantozzi\" ma dell'oggetto \"persona\" //e quindi una propriet\u00e0 ereditata \u00e8 necessario il metodo getPrototypeOf() per distinguere in scrittura //le propriet\u00e0 locali da quelle ereditate. //In lettura, se non ci sono conflitti (vedremo pi\u00f9 avanti), //non importa specificare getPrototypeOf() perch\u00e8 il costrutto cerca prima tra le propriet\u00e0 locali //la propriet\u00e0 <nome>, se non \u00e8 presente la si cerca tra gli oggetti padre e quindi tra le property ereditate //In questo caso non la trover\u00e0 tra le propriet\u00e0 locali ma tra quelle ereditate console . log ( fantozzi . nome ); //Fantozzi //In questo caso aggiungo una propriet\u00e0 locale fantozzi . nome = \"il super sfigato\" ; //La proprit\u00e0 locale ha la precedenza. La propriet\u00e0 locale maschera quella ereditata //Shadowing console . log ( fantozzi . nome ); //il super sfigato //Per accedere in lettura alla propriet\u00e0 <nome> ereditata devo necessariamente utilizzare il //getPrototypeOf() console . log ( Object . getPrototypeOf ( fantozzi ). nome ); ATTENZIONE!! Il metodo create non crea una copia. let fantozzi = Object . create ( persona ); l'oggetto fantozzi non \u00e8 una copia dell'oggetto persona . Il figlio (fantozzi) condivide le stesse property del padre(persona). Se modifico le property del figlio (fantozzi) le trovo modificate anche nell'oggetto padre (persona) proprio perch\u00e8 condividono le stesse variabili, lo stesso spazio in memoria. Questo \u00e8 da tenere in considerazione!","title":"Ereditariet\u00e0"},{"location":"javascript/#lezione-05_1","text":"","title":"Lezione 05"},{"location":"javascript/#ereditarieta-shadowing","text":"Lo shadowing \u00e8 un meccanismo di mascheramento/oscuramento di property ereditate con la definizione di property locali Esempio let persona = { nome : \"\" , cognome : \"\" , Etichetta : function () //Stringhe template. Iniziano con $. Prima vengono valutate poi il valore viene sostituito e notare gli acccenti gravi { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } }; //L'oggetto persona diventa il prototipo dell'oggetto fantozzi let fantozzi = Object . create ( persona ); //Metodo hasOwnProperty(\"property\"): ritorna <true> se l'oggetto a cui si applica il metodo //ha come propriet\u00e0 diretta (non ereditata) \"property\", quella indicata come parametro. console . log ( fantozzi . hasOwnProperty ( \"nome\" )); //false //In questo caso constrollo se \"nome\" appartiene al padre console . log ( Object . getPrototypeOf ( fantozzi ). hasOwnProperty ( \"nome\" )); //true cosnole . log ( fantozzi . nome ); //non ancora inizializzata ma la variabile viene trovata come propriet\u00e0 ereditata //Accedo in scrittura alle propriet\u00e0 ereditate Object . getPrototypeOf ( fantozzi ). nome = \"Ugo\" ; Object . getPrototypeOf ( fantozzi ). cognome = \"Fantozzi\" ; //Creo una propriet\u00e0 locale fantozzi . nome = \"e io chi sono??\" ; //Accedo in lettura alla propriet\u00e0 locale console . log ( fantozzi . nome ); //e io chi sono?? //Accedo in lettura alla propriet\u00e0 ereditata console . log ( Object . getPrototypeOf ( fantozzi ). nome ); //Ugo //Posso eliminare una property tramite il comando <delete> ma solo tra quelle locali delete fantozzi . nome ; //A questo punto rimane solo la property <name> ereditata console . log ( fantozzi . nome ); //Ugo //Shadowing: Meccanismo di mascheramento/oscuramento di property ereditate con la definizione di //prperty locali //Chiamo il metodo Etichetta dell'oggetto fantozzi eredietato dall'oggetto persona console . log ( \"1: \" + fantozzi . Etichetta () ); //Oscuro il metodo <Etichetta> ereditato dal metodo <Etichetta> definito localmente -> shadowing fantozzi . Etichetta = function () { return \"il sottoposto per eccellenza\" ;} console . log ( \"2: \" + fantozzi . Etichetta ()); //Variante ... //Un po' complessa. //Definisco un metodo locale che utilizza il metodo ereditato. //il this fa riferimento all'oggetto in cui si definisce il metodo quindi \"fantozzi\" fantozzi . Etichetta = function () { return Object . getPrototypeOf ( this ). Etichetta () + \" detto il sottoposto\" ;} console . log ( \"3: \" + fantozzi . Etichetta ()); //le propriet\u00e0 del prototipo sono CONDIVISE. //Se modifico una propiet\u00e0 in un figlio ereditata da una propriet\u00e0 del padre, //la ritrovo modificata anche nel padre e negli altri figli del padre, cio\u00e8 nei \"fratelli\" //Questo non \u00e8 lo stesso meccanismo del C/C#/Java let filini = Object . create ( persona ); Object . getPrototypeOf ( filini ). cognome = \"Filini\" ; console . log (( \"4: \" + fantozzi . cognome ); //Filini, ATTTT!! Metodo hasOwnProperty() : ritorna se l'oggetto a cui si applica il metodo ha come propriet\u00e0 diretta (non ereditata) \"property\", quella indicata come parametro. Cosniderazione: Il padre di tutti gli oggetti \u00e8 proprio \"Object\" Ricorda: Con il metodo create() non creo una copia dell'oggetto, cio\u00e8 un'istanza del prototipo, ma instauro solo un rapporto di condivisione","title":"Ereditariet\u00e0 - Shadowing"},{"location":"javascript/#ereditarieta-classica","text":"Per ereditariet\u00e0 classica si intende il meccanismo con il quale Javascript permette la crazione di istanze di oggetti a partire da un prototipo. Nell'esempio vedremo come realizzare una copia dato un prototipo Vediamo finalmente il metodo per creare una fottuta copia //Prototipo function Persona ( nome , cognome ) { //stato interno //Ogni istanza avr\u00e0 la sua copia di cognome e nome this . cognome = cognome ; this . nome = nome ; //ogni istanza avr\u00e0 la sua copia di etichetta this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } //chiamata al costruttore let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ) //gli oggetti fantozzi e filini hanno le loro copie distinte //delle variabili dello stato interno console . log ( \"1: \" + fantozzi . etichetta ()); cosnole . log ( \"2: \" + filini . etichetta ()); cosnole . log `3: ${ fantozzi . etichetta === filini . etichetta } ` ); //false","title":"Ereditariet\u00e0 classica"},{"location":"javascript/#lezione-06_1","text":"","title":"Lezione 06"},{"location":"javascript/#this","text":"In questi esempi cercheremo di capire la funzione di this in Javascript a seconda dei contesti. function Persona ( nome , cognome ) { //stato interno this . cognome = cognome ; this . nome = nome ; console . log ( this === window ); //true this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } //Attenzione, qua non utilizzo il costruttore. //this punta all'oggetto <window> (cio\u00e8 il padre del DOM). //Il risultato \u00e8 che le property <nome>, <cognme> diventano a tutti gli effetti variabili globali //poich\u00e8 <window> \u00e8 un oggetto implicito Persona ( \"\" , \"zzzzzz\" ); //cognome \u00e8 una variabile globale, window.cognome === cognome console . log ( cognome ); //zzzzzz Se invece utilizzo il costruttore dell'oggetto.. function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; console . log ( this === window ); //false this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } //Utilizzo il costruttore per creare due istanze dell'oggetto \"Persona\", \"fantozzi\", \"filini\" let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); //Adesso le variabili (property) <nome>, <cognome> sono visibili solo nel contesto degli oggetti \"fantozzi\" e \"filini\" //e accessibili solo tramite l'opertore \".\" console . log ( cognome ); //cognome is not defined. console . log ( fantozzi . cognome ); //Fantozzi. console . log ( filini . cognome ); //Filini. Quando this \u00e8 all'interno della definizione di un metodo, fa riferimento all'oggetto per cui si definisce il metodo. Nota: Non posso definire una variabile locale \"local_var\" senza far uso di this . Non sar\u00e0 disponibile nelle istanze degli oggetti ma solo nel constesto della chiamata funzione e quindi non nel contesto della chiamata a costruttore. Vediamo un esempio function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; let local_var = 999 ; //ATTENZIONE!! Non ha senso nel contesto di chiamata a costruttore //ogni istanza avr\u00e0 la sua copia di etichetta this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); console . log ( fantozzi . local_var ); //undefined console . log ( fantozzi . cognome ); //Fantozzi. console . log ( filini . cognome ); //Filini.","title":"THIS"},{"location":"javascript/#object-variabili-statiche-condivise","text":"In generale, le variabili statiche sono variabili condivise. Nel contesto di un oggetto, per creare delle variabili statiche cio\u00e8 condivise tra tutte le istanze si ottiene attraverso il metodo prototype function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); //dichairo una variabile (property) \"s\", \"ETA_MIN\" statica cio\u00e8 condivisa tra tutte le istanze create attravero il modello //dell'oggetto \"Persona\" Persona . prototype . s = \"ciao\" ; Persona . prototype . ETA_MIN = { value : 18 } ; console . log ( fantozzi . s ); //ciao console . log ( filini . s ); //ciao console . log ( fantozzi . ETA_MIN ); //{value: 18} console . log ( filini . ETA_MIN ); //{value: 18} //Posso dichiarare anche un metodo condiviso Persona . prototype . etichettaCondivisa = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } console . log ( `3: ${ fantozzi . etichetta === filini . etichetta } ` ); //false console . log ( `4: ${ fantozzi . etichettaCondivisa === filini . etichettaCondivisa } ` ); //true Vediamo un ultimo esempio: function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); Persona . prototype . s = \"ciao\" ; console . log ( fantozzi . s ); //ciao console . log ( filini . s ); //ciao //Se voglio accedere in scrittura ad una property condivisa tramite un figlio, dobbiamo al solito modo //utilizzare getPrototypeOf() Object . getPrototypeOf ( fantozzi ). s = \"amor\" ; console . log ( fantozzi . s ); //amor console . log ( filini . s ); //amor //Definisco una property locale a fantozzi fantozzi . s = \"mare\" ; console . log ( fantozzi . s ); //mare console . log ( filini . s ); //amor","title":"Object - Variabili Statiche (condivise)"},{"location":"javascript/#lezione-07_1","text":"","title":"Lezione 07"},{"location":"javascript/#introduzione-for-in","text":"for-in \u00e8 un metodo utilizzato per iterare sulle property degli oggetti tramite l'identificativo delle chiavi. Vedremo pi\u00f9 avanti cosa sta dietro a un costrutto cos\u00ec semplice e potente for ( const x in object ){ //code } const Persona = { name : 'Simone' , eta : 23 , hobby : 'Tennis' } for ( const x in Persona ) { console . log ( '+++++++++++++++' ); console . log ( x ); //Itero sulle chiavi console . log ( typeof x ); //x \u00e8 una stringa //non posso utilizzare Persona.x poich\u00e8 x \u00e8 una stringa. //Posso comunque utilizzare la notazione Persona[x] che in questo i torna comodo console . log ( Persona [ x ]); //Itero sui valori console . log ( Persona . x ); //Itero sui valori console . log ( '+++++++++++++++' ); } /* +++++++++++++++ name string Simone +++++++++++++++ +++++++++++++++ eta string 23 +++++++++++++++ +++++++++++++++ hobby string Tennis +++++++++++++++ */","title":"Introduzione For In"},{"location":"javascript/#oggetto-date","text":"Un oggetto interessante \u00e8 l'oggetto Date() . Javascript permette di gestire in modo semplice il tempo, la data, l'ora acquisendo dati dalla rete. //Chiamata al costruttore Date() con parametri di default let oggi = new Date (); console . log ( oggi ); /* Console: --------------- Wed Nov 11 2020 17:13:04 GMT+0100 (Ora standard dell\u2019Europa centrale) */ //Passaggio di parametri al costruttore Date() let compleannoMio = new Date ( '07-22-1991-09:30:12' ); //Modi alternativi let compleannoMario = new Date ( '07/22/1991' ); let compleannoGiovanni = new Date ( 'July 22 1991' ); console . log ( 'compleannoMio: ' + compleannoMio ); console . log ( 'compleannoMario: ' + compleannoMario ); console . log ( 'compleannoGiovanni: ' + compleannoGiovanni ); /* Console: --------------- compleannoMio: Mon Jul 22 1991 09:30:12 GMT+0200 (Ora legale dell\u2019Europa centrale) compleannoMario: Mon Jul 22 1991 00:00:00 GMT+0200 (Ora legale dell\u2019Europa centrale) compleannoGiovanni: Mon Jul 22 1991 00:00:00 GMT+0200 (Ora legale dell\u2019Europa centrale) */ Essendo Date() un oggetto ci sono diversi metodi get associati a questo oggetto come: getFullYear() : Ritorna l'anno getMonth() : Ritorna il mese a partire da 0, 0 = GEN, 1 = FEB getDate() : Ritorna il giorno del mese corrente, range [1 - 31] getDay() : Ritorna il giorno della settimana a partire da 0, 0 = DOM, 1 = LUN getHours() : Ritornano le ore getMinutes() : Ritornano i minuti getSeconds() : Ritornano i secondi getMilliseconds() : Ritornano i millisecondi getTime() : he getTime() method returns the number of milliseconds between midnight of January 1, 1970 and the specified date ... Ma anche metodi analoghi di set come: - setFullYear(year) - setMonth(month) - setHours(h, m, s) - .. //Metodi get let myData = new Date (); console . log ( 'getFullYear: ' + myData . getFullYear ()); console . log ( 'getMonth: ' + myData . getMonth ()); console . log ( 'getDate: ' + myData . getDate ()); console . log ( 'getDay: ' + myData . getDay ()); console . log ( 'getHours: ' + myData . getHours ()); console . log ( 'getMinutes: ' + myData . getMinutes ()); console . log ( 'getSeconds: ' + myData . getSeconds ()); console . log ( 'getMilliseconds: ' + myData . getMilliseconds ()); console . log ( 'getTime: ' + myData . getTime ()); /* Console: --------------- getFullYear: 2020 getMonth: 10 getDate: 12 getDay: 4 getHours: 10 getMinutes: 27 getSeconds: 50 getMilliseconds: 336 getTime: 1605173270336 */ //Metodi set let compleannoMario = new Date ( 'April 02 2002' ); console . log ( 'compleannoMario: ' + compleannoMario ); /* Console: --------------- compleannoMario: Tue Apr 02 2002 00:00:00 GMT+0200 (Ora legale dell\u2019Europa centrale) */ compleannoMario . setFullYear ( '1991' ); compleannoMario . setMonth ( 9 ); compleannoMario . setHours ( 12 , 45 , 09 ); console . log ( 'compleannoMario: ' + compleannoMario ); /* Console: --------------- compleannoMario: Wed Oct 02 1991 12:45:09 GMT+0100 (Ora standard dell\u2019Europa centrale) */ Nota: Se creto un'istanza dell'oggetto Date() senza parametri, verr\u00e0 invocato il costruttore con parametri di default. Di default Date() restituisce l'ora e la data locale fornita dalla rete. Quindi l'oggetto appena creato far\u00e0 riferimento all'ora corrente, un dato dinamico.","title":"Oggetto Date()"},{"location":"javascript/#lezione-08_1","text":"","title":"Lezione 08"},{"location":"javascript/#classi","text":"Le classi JavaScript, introdotte in ECMAScript 2015, sono principalmente zucchero sintattico sull'esistente ereditariet\u00e0 prototipale di JavaScript. La sintassi non introduce un nuovo modello di eredit\u00e0 orientata agli oggetti in JavaScript. Le classi sono di fatto delle \"funzioni speciali\", e cos\u00ec come puoi definire function expressions e function declarations, la sintassi per la classe ha due componenti: class expressions e class declarations. Non \u00e8 lo stesso concetto di classe definita come ad esempio per il linguaggio C++. class Persona { } let Fantozzi = new Persona (); cosnole . log ( typeof ( Fantozzi )); //Object //Dietro il meccanismo di classe c'\u00e8 di fatto il concetto di prototipo/funzione cosnole . log ( typeof ( Persona )); //function Vediamo un esempio pi\u00f9 completo class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } } //non passo nessun parametro quindi utilizzer\u00e0 i valori di default let Fantozzi = new Persona (); cosnole . log ( Fantozzi . nome ); //sconosciuto Note: - Con questa definizione di classe non esiste tuttavia un meccanismo che possa rendere privati i dati come nel concetto di classe che si avrebbe nel c++. - Non \u00e8 possibile un meccanismo di overload dei costruttori , non possono quindi coesistere pi\u00f9 costruttori. E' ammesso un solo costruttore per classe. Tuttavia ogni istanza creata avr\u00e0 i dati separati class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } } //non passo nessun parametro quindi utilizzer\u00e0 i valori di default let Fantozzi = new Persona (); console . log ( Fantozzi . nome ); //sconosciuto let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); console . log ( Fantozzi . nome ); //Ugo let Filini = new Persona ( \"Filini\" , \"Silvio\" ); console . log ( Filini . nome ); //Silvio console . log ( Fantozzi . nome ); //Ugo Ampliamo la classe con l'aggiunta di metodi: class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } } let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); let Filini = new Persona ( \"Filini\" , \"Silvio\" ); cosnole . log ( Fantozzi . etichetta ); cosnole . log ( Filini . Etichetta ); cosnole . log ( Fantozzi . etichetta === Filini . Etichetta ); //false Aggiunta di metodi condivisi class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } //metodo condiviso tra tutte le istanze static etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } //metodo separato per ogni istanza etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } } let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); let Filini = new Persona ( \"Filini\" , \"Silvio\" ); //Assegno dei \"value\" alle property della classe Persona . cognome = \"Liberti\" ; Persona . nome = \"Franco\" ; //il metodo Filini.etichetta \u00e8 il metodo locale alla classe Filini. //Prende il nome di \"Metodo di istanza\" console . log ( \"Metodo di istanza: \" + Filini . etichetta () ); //Metodo di istanza: Egr. Sig. Silvio Filini //il metodo Persona.etichetta \u00e8 il metodo condiviso tra tutte le istanze della classe Persona. //Prende il nome di \"Metodo di classe\" console . log ( \"Metodo di classe: \" + Persona . etichetta () ); //Metodo di classe: Egr. Sig. Franco Liberti Vediamo un esempio in cui posso sfruttare le variabili statiche. In questo esempio, ogni volta che creo un'istanza della classe Persona, incremento una variabile statica che indicher\u00e0 alla fine quante istanze ho creato class Persona { constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; //ogni volta che creo un'istanza della classe Persoan, si icrementa la variabile \"conta\" //Nota <conta> \u00e8 stata aggiunta dopo la creazione della classe Persona Persona . conta ++ ; } static personeCreate () { return Persona . conta ;} etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } } //Resetto il conteggio Persona . conta = 0 ; let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); let Filini = new Persona ( \"Filini\" , \"Silvio\" ); console . log ( Persona . conta ); //2 console . log ( Persona . personeCreate () ); //2","title":"Classi"},{"location":"javascript/#lezione-09_1","text":"","title":"Lezione 09"},{"location":"javascript/#classi-assegnanili-a-variabili","text":"Posso assegnare una classe ad una variabile esattamente come per gli oggetti, le funzioni.. //questa \u00e8 una classe anonima let Punto = class { constructor ( x , y ) { this . x = x ; this . y = y ;} } let p = new Punto ( 10 , - 30 ); console . log ( p . y ); //-30 p . x = \"paperino\" ; //non viene fatto nessun controllo semantico console . log ( p . x ); //paperino","title":"Classi assegnanili a variabili"},{"location":"javascript/#get-set","text":"Non c'\u00e8 un modo di definire x e y private con un meccanismo simile alle property private per le classi definite dal linguaggio C++ tuttavia esiste un sistema che ci aiuta a nascondere le variabili interne, get/set . //PuntoIQ \u00e8 una classe che assegna punti solo nel primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } } try { //poich\u00e8 questo punto non appartiene al primo quadrante si verifica l'eccezione e salta al catch let p = new PuntoIQ ( 10 , - 30 ); } catch ( eccezione ) { console . log ( eccezione ); }","title":"Get / Set"},{"location":"javascript/#try-catch","text":"Nota il sistema try-catch . Con tale sistema \u00e8 possibile tentare l'esecuzione del codice presente nel corpo di try . Se va a buon fine si prosegue altrimenti si esegue il corpo del catch . Per stabilire se il codice presente nel try va o meno a buon fine si utilizza la keyword throw . Nella classe PuntoIQ infatti se i dati passati al costruttore sono minori di zero si passa un'eccezione attravero throw , l'eccezione in questo caso \u00e8 semplicemente la stringa \"Non nel primo quadrante\" che viene passata al catch try { //prova ad eseguire il codice. Se il codice presenta un'eccezione salta al catch } catch ( eccezione ){ //esegui eccezione } Riprendiamo con il concetto di get/set //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } //Per accedere a questa propriet\u00e0 devo usare \"_x\", //\u00e8 di fatto un sistema di costrizione dell'utilizzatore della classe a NON usare questa property this . _x = x ; //Per accedere a questa propriet\u00e0 devo usare \"_y\", //\u00e8 di fatto un sistema di costrizione dell'utilizzatore della classe a NON usare questa property this . _y = y ; } //Le keyword \"get\" definisce di fatto un metodo che pu\u00f2 essere richiamato con la nomenclatura //utilizzata per le propriet\u00e0. Posso quindi richiamare il metodo x tramite <punto.x> //get definisce un metodo di lettura quindi posso leggere la property \"x\" //nascondendo la \"vera\" property definita sopra tramite \"_x\" get x () { return this . _x ; } //Le keyword \"set\" definisce come \"get un metodo che pu\u00f2 essere richiamato con la nomenclatura //utilizzata per le propriet\u00e0. Posso quindi richiamare il metodo x tramite <punto.x> //get definisce un metodo di scrittura quidni posso scrivere la property \"x\" //nascondendo la \"vera\" property definita sopra \"_x\" set x ( valore ) { this . _x = valore ; } } try { var p = new PuntoIQ ( 10 , 30 ); //Ok } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 10, _y: 30} try { p . x = 56 ; // === p._x = 56 } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 56, _y: 30} try { p . _x = 12 ; // L'utilizzatore della classe sta bypassando il metodo \"ufficiale\" tramite get/set } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 12, _y: 30} Passare attravero get/set \u00e8 utile per poter eseguire controlli avanzati e restituire un errore in caso di fallimento. Vediamo di estendere la classe di sopra aggiungendo un controllo in fase di set //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore ) ){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } } try { var p = new PuntoIQ ( 10 , 30 ); //Ok } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 10, _y: 30} try { p . x = \"dodici\" ; // === p._x = 56 } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //Non \u00e8 un numero","title":"try-catch"},{"location":"javascript/#lezione-10_1","text":"","title":"Lezione 10"},{"location":"javascript/#derivazione-di-classi-ereditarieta","text":"Il meccanismo di derivazione delle classi ovvero la costruzione di una classe figlia a partire da una classe padre aggiungendo una specializzazione \u00e8 noto anche come meccanismo di ereditariet\u00e0 e si ottiene semplicemente la keyword extends . Abbiamo gi\u00e0 visto come \u00e8 implementato questo concetto negli oggetti in Javascript. Per quanto riguarda le classi si ricordi che \u00e8 solo \"zucchero sintattico\" quindi il meccanismo sotto sar\u00e0 il medesimo. //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore ) ){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } } class PuntoIQColorato extends PuntoIQ { } La lasse \"PuntoIQColorato\" \u00e8 derivata dalla classe madre PuntoIQ ma accede a a tutte le strutture interne della classe madre. Vediamo di estendere la classe definita sopra con altri metodi: //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore )){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } //\"distanza(altro)\", applicato a un oggetto A <PuntoIQ> calcola la distanza tra //l'oggetto a cui si applica il metodo (oggetto A) e un altro oggetto ricevuto come argomento //<altro> che dovr\u00e0 essere un oggetto della classe <PuntoIQ> distanza ( altro ){ //\"A instanceof B\" ritorna true se A \u00e8 un'istanza di B //Viene quindi fatto un controllo per essere sicuri di aver ricevuto un oggetto compatibile if ( altro instanceof PuntoIQ ){ //formula distanza tra due punti return ( Math . sqrt ( Math . pow ( this . x - altro . x , 2 ) + Math . pow ( this . y - altro . y , 2 ) ) ); } else { throw \"Il parametro attuale `altro` non \u00e8 un punto\" ; } } } class PuntoIQColorato extends PuntoIQ { } let p1 = new PuntoIQ ( 5 , 5 ); let p2 = new PuntoIQ ( 10 , 10 ); cosnole . log ( p1 . distanza ( p2 ) ); //7.07... //un oggetto della classe <PuntoIQColorato> \u00e8 identico a un oggetto della classe <PuntoIQ> let pc = new PuntoIQColorato ( 100 , 100 ); console . log ( \"Punto Colorato: \" + pc . x ); //La classe figlia PuntoIQColorato passa il controllo if (altro instanceof PuntoIQ) Poich\u00e8 \u00e8 figlia //di PuntoIQ cosnole . log ( pc . distanza ( p2 ) ); Nella prossima lezione aggiungeremo elementi specifici della classe PuntoIQColorato","title":"Derivazione di classi , ereditariet\u00e0"},{"location":"javascript/#lezione-11_1","text":"","title":"Lezione 11"},{"location":"javascript/#ereditarieta-classi-pt-2","text":"In questo esempio vedremo aggiungeremo elementi specifici della classe PuntoIQColorato . Utilizzeremo anche il comando super . Un comando usato nella classe figlia per richiamare il costruttore della classe madre //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore )){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } //\"distanza(altro)\", applicato a un oggetto A <PuntoIQ> calcola la distanza tra //l'oggetto a cui si applica il metodo (oggetto A) e un altro oggetto ricevuto come argomento //<altro> che dovr\u00e0 essere un oggetto della classe <PuntoIQ> distanza ( altro ){ //\"A instanceof B\" ritorna true se A \u00e8 un'istanza di B //Viene quindi fatto un controllo per essere sicuri di aver ricevuto un oggetto compatibile if ( altro instanceof PuntoIQ ){ //formula distanza tra due punti return ( Math . sqrt ( Math . pow ( this . x - altro . x , 2 ) + Math . pow ( this . y - altro . y , 2 ) ) ); } else { throw \"Il parametro attuale `altro` non \u00e8 un punto\" ; } } } class PuntoIQColorato extends PuntoIQ { constructor ( x , y , colore ){ //super richiama il costruttore della classe madre //super deve essere sempre il primo statemeant super ( x , y ); this . _colore = colore ; //Potrei accedere ai dati interni della classe madre PuntoIQ tramite ad esempio //this._x = 999; //E' ASSOLUTAMENTE DA EVITARE PERCHE' BYPASSO TUTTI I CONTROLLI SU \"x\" } get colore (){ return this . _colore ; } //Shadowing. //Il metodo \"distanza\" definito qua \u00e8 locale alla classe <PuntoIQColorato> e oscura il metodo ereditato //dalla classe <PuntoIQ> distanza ( altro ){ return 1000 ; } } let p1 = new PuntoIQ ( 5 , 5 ); let p2 = new PuntoIQ ( 10 , 10 ); console . log ( p1 . distanza ( p2 ) ); //7.0... let pc = new PuntoIQColorato ( 100 , 100 , \"blue\" ); console . log ( \"Punto Colorato: \" + pc . x , pc . y , pc . colore ); //Punto Colorato: 100 100 blue //Poich\u00e8 il metodo \"distanza\" \u00e8 applicato a <pc> che \u00e8 un <PuntoIQColorato> verr\u00e0 applicato il metodo locale console . log ( pc . distanza ( p2 ) ); //1000 Attenzione: E' buona norma mettere il comando super come primo comando nel costruttore della classe figlia per poter permettere al costrutto di creare le caratteristiche ereditate correttamente Metodi locali ed ereditati possono coesistere e collaborare. Con super posso richiamare il metodo della classe madre all'interno della classe figlia //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore )){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } //\"distanza(altro)\", applicato a un oggetto A <PuntoIQ> calcola la distanza tra //l'oggetto a cui si applica il metodo (oggetto A) e un altro oggetto ricevuto come argomento //<altro> che dovr\u00e0 essere un oggetto della classe <PuntoIQ> distanza ( altro ){ //\"A instanceof B\" ritorna true se A \u00e8 un'istanza di B //Viene quindi fatto un controllo per essere sicuri di aver ricevuto un oggetto compatibile if ( altro instanceof PuntoIQ ){ //formula distanza tra due punti return ( Math . sqrt ( Math . pow ( this . x - altro . x , 2 ) + Math . pow ( this . y - altro . y , 2 ) ) ); } else { throw \"Il parametro attuale `altro` non \u00e8 un punto\" ; } } } class PuntoIQColorato extends PuntoIQ { constructor ( x , y , colore ){ //super deve essere sempre il primo statemeant super ( x , y ); this . _colore = colore ; } get colore (){ return this . _colore ; } //Shadowing. distanza ( altro ){ //richiamo il metodo \"distanza\" della classe madre return super . distanza ( altro ) + 1000 ; } } let p1 = new PuntoIQ ( 5 , 5 ); let p2 = new PuntoIQ ( 10 , 10 ); console . log ( p1 . distanza ( p2 ) ); //7.0... let pc = new PuntoIQColorato ( 100 , 100 , \"blue\" ); console . log ( \"Punto Colorato: \" + pc . x , pc . y , pc . colore ); //Punto Colorato: 100 100 blue console . log ( pc . distanza ( p2 ) ); //1127.2792206135787","title":"Ereditariet\u00e0 classi Pt 2"},{"location":"javascript/#lezione-12_1","text":"","title":"Lezione 12"},{"location":"javascript/#approfondimento-symbols","text":"Ogni valore symbol restituito da Symbol() \u00e8 unico. Un valore symbol pu\u00f2 essere utilizzato come identificatore per propriet\u00e0 di un oggetto; questo \u00e8 lo scopo di tale tipo di dati. Il tipo di dati symbol \u00e8 un primitive data type. Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/Symbol //Il simbolo \u00e8 un nuovo tipo che permette di creare valori univoci //Nell'esempio creo due variabili di tipo Symbol(). //I loro valori (che non possiamo stampare) saranno sicuramente diversi let un_simbolo = Symbol (); let un_altro_simbolo = Symbol (); //Posso agire per confronti ma non stampare direttamente i simboli console . log ( un_simbolo === un_altro_simbolo ); //false, sempre console . log ( un_simbolo ); //ERROR GUID: Il GUID (Globally Unique Identifier, identificatore unico globale) \u00e8 un numero pseudo-casuale usato nella programmazione software, per poter distinguere vari oggetti. Il tipo pi\u00f9 noto di GUID \u00e8 l'utilizzo di Microsoft dell'UUID, ideato dalla Open Software Foundation, ma vi sono anche altri usi, come quello all'interno di XML. Fonte: https://it.wikipedia.org/wiki/GUID Vediamo l'utilizzo di un Symbol come identificatore di una propriet\u00e0 di un oggetto let oggetto = { colore : \"giallo\" , peso : 21 , } //creo un nuovo simbolo let check = Symbol (); //aggiungo la property \"check\" \u00e8 un valore \"OK\" oggetto [ check ] = \"OK\" ; console . log ( oggetto [ check ]); //OK La property aggiunta con Symbol \u00e8 nascosta.. let oggetto = { colore : \"giallo\" , peso : 21 , scheda : function () { let s = \"\" ; //Si traduce in: per ogni property presente in questo oggetto.. //Itera sulle property tranne su \"scheda\" //E le concatena in una stringa s = \"colore peso\" for ( x in this ){ if ( x !== \"scheda\" ){ s += x + \" \" ; } } return s ; } } //Posso assegnare un'etichetta al Symbol let check = Symbol ( \"il check\" ); oggetto [ check ] = \"OK\" ; console . log ( oggetto [ check ]); //Una property aggiunta con Symbol \u00e8 nascosta. //Utilizzo il metodo \"scheda\" per stampare tutte le property. //Vedremo che la property \"check\" non apparir\u00e0 console . log ( oggetto . scheda () ); //colore peso //Notare la differenza con la seguente propery aggiunta localmente //check2 \u00e8 una propriet\u00e0 locale e visibile oggetto . check2 = \"YES\" ; console . log ( oggetto . scheda () ); //colore peso check2 Posso generare un metodo attraverso Symbol let report = Symbol (); let oggetto2 = { prodotto : \"xyz\" , //genero il metodo con il simbolo [ report ]() { return this . prodotto ;} } console . log ( oggetto2 [ report ]()); //xyz Posso aggiungere il metodo a posteriori let report = Symbol (); let oggetto2 = { prodotto : \"xyz\" , [ report ]() { return this . prodotto ;} } //Assegno al metodo un nuovo valore oggetto2 [ report ] = function () { return \"Controllo effettuato!\" ;} console . log ( oggetto2 [ report ]()); //Controllo effettuato!","title":"Approfondimento - Symbols"},{"location":"javascript/#lezione-13_1","text":"","title":"Lezione 13"},{"location":"javascript/#approfondimento-iterablesiterator","text":"Un oggetto \u00e8 un iterator quando sa come accedere agli elementi di una collezione uno per volta, conservando l'informazione sulla sua posizione corrente nella sequenza. In Javascript un iterator \u00e8 un oggetto che implementa il metodo next() , il quale ritorna l'elemento successivo della sequenza. Questo metodo ritorna un oggetto con due propriet\u00e0: done e value . Una volta che \u00e8 stato creato, un iterator pu\u00f2 essere utlizzato esplicitamente chiamando pi\u00f9 volte il metodo next() . Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Guida/Iteratori_e_generatori","title":"Approfondimento - Iterables/Iterator"},{"location":"javascript/#costrutto-for-of","text":"Il costrutto for...of crea un ciclo con gli oggetti iterabili (inclusi Array, Map, Set, String, TypedArray, argomenti di oggetti e cos\u00ec via), iterando le istruzioni per ogni valore di ogni propriet\u00e0. for ( elem of collection ) { /*CODE*/ }; Vediamo un esempio: let s = \"ciao\" ; //ciclo tradizionale //for (let i=0; i<s.length; i++) console.log(s[i]); //ciclo che sfrutta un iteratore e il for ... of for ( carattere of s ) console . log ( carattere ); Dietro il meccanismo di un costrutto cos\u00ec potente c'\u00e8 il concetto di Iterables/Iterator e Symbol . Se un oggetto \u00e8 iterabile avr\u00e0 un iteratore. A tale iteratore \u00e8 applicabile il metodo next() che restituisce l'elemento successivo della lista degli elementi. Tale elemento \u00e8 un oggetto con due property: done e value . La property done \u00e8 un boolean che indica se siamo arrivati in fondo alla lista degli elementi iterabili mentre la property value restituisce il valore dell'elemento let s = \"ciao\" ; for ( carattere of s ) console . log ( carattere ); let iteratore = s [ Symbol . iterator ](); cosnole . log ( typeof ( s [ Symbol . iterator ]) ); //function cosnole . log ( typeof ( iteratore ) ); //Object. Questo \u00e8 l'oggetto iteratore //l'iteratore \u00e8 un oggetto formato da due sotto elementi //done -> restituisce true se \u00e8 l'ultimo elemento della lista //value -> rappresenta il valore dell'elemento estratto let elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //c, la prima lettera di \"ciao\" //Se continuiamo con next(), passo all'elemento successivo.. elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //i elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //a elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //o elemento = iteratore . next (); console . log ( elemento . done ); //true console . log ( elemento . value ); //undefined","title":"Costrutto for - of"},{"location":"javascript/#lezione-14_1","text":"","title":"Lezione 14"},{"location":"javascript/#approfondimento-funzioni-generatrici","text":"I generatori sono funzioni dalle quali \u00e8 possibile uscire e poi rientrarvi in un secondo momento. Il loro contesto (binding delle variabili) verr\u00e0 salvato all'uscita per quando vi entrer\u00e0 successivamente. La chiamata ad un generatore non viene eseguita immediatamente; la funzione ritorner\u00e0 invece un oggetto iterator . Quando il metodo next() dell'iteratore viene chiamato, il corpo del generatore viene eseguito fino alla prima espressione yield , la quale specifica quale espressione ritornare dall'iteratore oppure, con l'espressione yield , delegare questo valore ad un'altra funzione generatrice. Il metodo next() restituisce un oggetto con propriet\u00e0 value contenente il valore da restituito all'iteratore ed una propriet\u00e0 done che contiene un valore di tipo boolean per indicare se il generatore ha restituito l'ultimo valore. Chiamando il metodo next() con un argomento far\u00e0 riprendere l'esecuzione della funzione generatrice, sostituendo l'istruzione yield in cui l'esecuzione era stata fermata con l'argomento della funzione next() . Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Statements/function function * generatrice () { //la prima volta \u00e8 in attesa ... //che venga chiamato il metodo next() sull'oggetto restituito let n = 10 ; console . log ( n ); yield ; //genera n += 1 ; console . log ( n ); } let obj = generatrice (); //non succede niente. Siamo in attesa di invocare next() obj . next (); //10, si ferma a yield e ritorna ma lo stato dei dati \u00e8 memorizzato obj . next (); //11 obj . next (); // Vediamo un esempio pi\u00f9 interessante: function * generatrice () { let n = 0 ; while ( true ){ n ++ ; console . log ( n ); yield ; } } let obj = generatrice (); obj . next (); //1 obj . next (); //2 obj . next (); //3 yield \u00e8 il \"ritorno\" della funzione generatrice e restituisce un oggetto iterator , un oggetto formato quindi da due property value e done function * generatrice () { let n = 0 ; while ( true ){ n ++ ; yield n ; } } let obj = generatrice (); console . log ( obj . next (). value ); //1 console . log ( obj . next (). value ); //2 console . log ( obj . next (). value ); //3","title":"Approfondimento - Funzioni Generatrici"},{"location":"javascript/#lezione-15_1","text":"","title":"Lezione 15"},{"location":"javascript/#approfondimento-esempio-for-of-custom","text":"Dopo l'introduzione di Iterator/Iterables e di funzioni generatrici \u00e8 possibile costruire per una classe personale un metodo (for..of) personalizzabile class miaCollezione { //la classe contiene un array constructor () { this . items = []; } //posso aggiungere valori tramite il metodo \"add\" add ( value ) { this . items . push ( value ) } //questo definisce un metodo per il for - of * [ Symbol . iterator ] () { for ( let key in this . items ) { //Se la lunghezza dell'array \u00e8 maggiore di 4, restituisce l'array if ( this . items [ key ]. length > 4 ) yield this . items [ key ]; } } } let o = new miaCollezione (); o . add ( \"rossi\" ); o . add ( \"Bob\" ); o . add ( \"Gialli\" ); //L'elemento Bob non verr\u00e0 stampato perch\u00e8 ha 3 elementi for ( x of o ) { console . log ( x ); } /* rossi Gialli */ Posso aggiungere anche aggiungere una funzione generatrice come metodo per iterare sugli elementi sfruttando il costrutto while e come terminatore del ciclo la property done class miaCollezione { //la classe contiene in realt\u00e0 un array constructor () { this . items = []; } //posso aggiungere valori tramite il metodo \"add\" add ( value ){ this . items . push ( value ) } //questo definisce un metodo per il for - of * [ Symbol . iterator ] (){ for ( let key in this . items ){ //Se la lunghezza dell'array \u00e8 maggiore di 4, restituisce l'array if ( this . items [ key ]. length > 4 ) yield this . items [ key ]; } } * generatrice (){ for ( let key in this . items ){ yield this . items [ key ]; } } } let o = new miaCollezione (); o . add ( \"rossi\" ); o . add ( \"Bobyna\" ); o . add ( \"Gialli\" ); let iterator = o . generatrice (); //itero \"a mano\" tramite la funzione mia generatrice. //E' esattamente il (for.. of ) //Nota < (elemento=iterator.next()).done > equivale a: //elemento = iterator.next() //elemento.done while ( ! ( elemento = iterator . next ()). done ) cosnole . log ( elemento . value );","title":"Approfondimento - Esempio (For .. of) custom"},{"location":"javascript/#lezione-16_1","text":"","title":"Lezione 16"},{"location":"javascript/#destructuring","text":"La sintassi di assegnamento di destrutturazione \u00e8 un'espressione JavaScript che rende possibile estrarre informazioni da array o oggetti in variabili distinte. Le espressioni letterali degli oggetti e degli array forniscono un modo facile per creare ad hoc pacchetti di data. Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment let prodotto = { codice : \"BPX001\" , categoria : \"alimentari\" , prezzo : 1.25 }; //FORMA ABBREVIATA //i valori delle property \"codice\" e \"prezzo\" sono memorizzate in due variabili di nome \"codice\", \"prezzo\" //il nome delle variabili deve coincidere con il nome della property let { codice , prezzo } = prodotto ; /* Equivale a: let codice = prodotto.codice; let prezzo = prodotto.prezzo; */ console . log ( ` ${ codice } - ${ prezzo } ` ); // BPX001 - 1.25 //FORMA ESTESA //E' possibile assegnare un nome alle variabili con l'associazione di un'etichetta let { codice : il_codice , prezzo : il_prezzo } = prodotto ; console . log ( ` ${ il_codice } - ${ il_prezzo } ` ); // BPX001 - 1.25 Il Destructuring funziona con qualsiasi collezione iterabile //il destructuring funziona con gli array let temperature = [ 1 , 3 , 6 , 9 , 8 , 5 , 4 , - 1 ] let [ h00 , h3 , h6 , h9 , h12 , h15 , h18 , h21 ] = temperature ; console . log ( `Temp. alle h06:00 ${ h6 } \u2103; alle h18:00 ${ h18 } \u2103` ); // Temp. alle h06:00 6\u2103; alle h18:00 $4\u2103 Posso utilizzare il destructuring per il ritorno di variabili multiple in una funzione function min_max ( vettore ) { let pos_min = 0 ; let pos_max = 0 ; //immaginiamo qui l`algoritmo che determina le //posizioni dell`elemento minimo e massimo pos_min = 3 ; pos_max = 7 ; return [ pos_min , pos_max ]; } let temperature = [ 1 , 3 , 6 , 9 , 8 , 5 , 4 , - 1 ] let [ h00 , h3 , h6 , h9 , h12 , h15 , h18 , h21 ] = temperature ; console . log ( `Temp. alle h06:00 ${ h6 } \u2103; alle h18:00 ${ h18 } \u2103` ); //Temp. alle h06:00 6\u2103; alle h18:00 4\u2103 //------------------------------------------------------------------------- let [ pos_temp_min , pos_temp_max ] = min_max ( temperature ); console . log ( `Temperatura minima alle ${ 3 * pos_temp_min } ` ); //Temperatura minima alle 9 console . log ( `Temperatura massima alle ${ 3 * pos_temp_max } ` ); //Temperatura massima alle 21 Si pu\u00f2 scavare anche dentro oggetti senza esagerare troppo let libro = { autore : { cognome : \"Alessandro\" , nome : \"Manzoni\" }, titolo : \"I promessi sposi\" , nato_a : { nome : \"Milano\" , nazione : \"Italia\" } }; let { autore : { cognome , nome }, titolo } = libro ; console . log ( cognome ); //Alessandro console . log ( nome ); //Manzoni console . log ( titolo ); //I promessi sposi let { titolo : t2 } = libro ; console . log ( t2 ); ////I promessi sposi let s = \"\" ; //questa sintassi \u00e8 per l'assegnamento ({ titolo : s } = libro ); Con gli array questo metodo dell'assegnamento \u00e8 pi\u00f9 semplice let temperature = [ 1 , 3 , 6 , 9 , 8 , 5 , 4 , - 1 ] let [ h00 , h3 , h6 , h9 , h12 , h15 , h18 , h21 ] = temperature ; console . log ( `Temp. alle h06:00 ${ h6 } \u2103; alle h18:00 ${ h18 } \u2103` ); //------------------------------------------------------------------------- let t = 0 ; [ t ] = temperature ; console . log ( t ); //1, ottengo la temperatura alla prima posizione //Estraggo il 4 elemento [,,, t ] = temperature ; //temperature[3] console . log ( t ); //9 let v = [ 1 , 2 ]; let [,, z = 0 ] = v ; console . log ( z ); //0 // in questo caso con l'operatore \"...\" (rest) creo un sottoarray con le sole temperature dalle 9 in poi let [,,,... dalle_9_in_poi ] = temperature for ( temp of dalle_9_in_poi ) console . log ( temp ); //9 8 5 4 -1","title":"Destructuring"},{"location":"javascript/#lezione-17_1","text":"","title":"Lezione 17"},{"location":"javascript/#map-object","text":"L'oggetto Map \u00e8 una collezione di elementi chiave / valore . Qualsiasi valore (sia oggetti che valori primitivi) pu\u00f2 essere utilizzato come chiave o come valore. Qualche metodo applicabile all'oggetto Map : set(key, value) : Aggiunge un elemento all'oggetto Map specificando la chiave di accesso e il valore has(key) : Ritorna un boolean true/false in base al risultato della ricerca di un elemento con una particolare key . get(key) : Ritorna il valore corrispondente alla chiave key delete(key) : Elimina l'elemento con la chiave key clear() : Elimina tutto il contenuto dalla mappa Propriet\u00e0 dell'oggetto Map : size : Ritorna il numero di elementi in una mappa //Creo un nuovo oggeto Map vuoto let capitali = new Map (); //Il metodo set(key, value) aggiunge elementi indicando una coppia chiave valore capitali . set ( \"Italia\" , \"Roma\" ); capitali . set ( \"Francia\" , \"Parigi\" ); console . log ( capitali ); //Map(2) {\"Italia\" => \"Roma\", \"Francia\" => \"Parigi\"} console . log ( capitali . size ); //2 //Il punto di forza di Map \u00e8 che posso ricercare certi valori attraverso la Key nazione_richiesta = prompt ( \"Quale nazione?\" ); //Francia if ( capitali . has ( nazione_richiesta ) ){ console . log ( `La capitale \u00e8 ${ capitali . get ( nazione_richiesta ) } ` ); } //La capitale \u00e8 Parigi else { console . log ( \"Nazione non trovata\" ); } capitali . clear (); console . log ( capitali ); //Map(0) {} Posso aggiungere diversi elementi con la notazione ad array, anzi direi a Matrice visto che ogni elemento \u00e8 formato da una coppia chiave/valore //Fornisco al costruttore di Map() come parametro un oggetto iterabile let capitali = new Map ([ [ \"Italia\" , \"Roma\" ], [ \"Francia\" , \"Parigi\" ], [ \"Inghilterra\" , \"Londra\" ] ]); nazione_richiesta = prompt ( \"Quale nazione vuoi eliminare?\" ); //Se nazione_richiesta \u00e8 tra quelle specificate nell'oggetto <capitali> la eliminer\u00e0 if ( capitali . has ( nazione_richiesta ) ){ capitali . delete ( nazione_richiesta ); console . log ( ` ${ nazione_richiesta } eliminata ...` ); } else { console . log ( \"Nazione non trovata\" ); } Posso inserire qualsiasi tipo di elemento in un oggetto di tipo Map. //Creo un oggetto di tipo Map e identificativo \"listino\" vuoto let listino = new Map (); //Creo un oggetto che utilizzer\u00f2 come chiave dell'oggetto listino let prodotto = { codice : 100 , descrizione : { breve : \"bla bla\" , lunga : \"bla bla bla bla\" } } //Creo un oggetto che utilizzer\u00e0\u00ec\u00f2 come valore dell'oggetto listino let prezzo = { costo_base : 145 , sconto : 5 , metodi_pagamento : { cash : true , carta : true , paypal : false } } //Aggiungo un elemento all'oggetto listino. //Prodotto e prezzo sono due oggetti diversi listino . set ( prodotto , prezzo ); if ( listino . has ( prodotto ) ) { valore = listino . get ( prodotto ); console . log ( valore . costo_base ); //145 if ( valore . metodi_pagamento . carta ){ console . log ( \"Pagabile con carta di credito\" ); //Pagabile con carta di credito } }","title":"Map Object"},{"location":"javascript/#iterazione-map-object","text":"Il metodo key() restituisce un iteratore sulle chiavi let capitali = new Map ([ [ \"Italia\" , \"Roma\" ], [ \"Francia\" , \"Parigi\" ], [ \"Inghilterra\" , \"Londra\" ] ]); //iterare sugli elementi for ( let elemento of capitali ) { console . log ( elemento ); } //elemento[0]=nazione, [1]=capitale /* [\"Italia\", \"Roma\"] [\"Francia\", \"Parigi\"] [\"Inghilterra\", \"Londra\"] */ //iterare sulle chiavi //key() restituisce un iteratore sulle chiavi for ( let chiave of capitali . keys ()) { console . log ( chiave ); } /* Italia Francia Inghilterra */ Esempio di iterazione applicando il destructuring: let listino = new Map (); //Chiave let prodotto = { codice : 100 , descrizione : { breve : \"bla bla\" , lunga : \"bla bla bla bla\" } } //Valore let prezzo = { costo_base : 145 , sconto : 5 , metodi_pagamento : { cash : true , carta : true , paypal : false } } listino . set ( prodotto , prezzo ); //iterare sugli elementi, applico il destructuring for ( let [ chiave , valore ] of listino ) //listino.entries()) { console . log ( chiave ); } //Restituisce prodotto /* {codice: 100, descrizione: {\u2026}} codice: 100 descrizione: {breve: \"bla bla\", lunga: \"bla bla bla bla\"} */","title":"Iterazione Map Object"},{"location":"javascript/#lezione-18_1","text":"","title":"Lezione 18"},{"location":"javascript/#set","text":"L'oggetto Set permette di memorizzare valori unici di qualunque tipo, che siano valori primitivi o riferimenti ad oggetti. Gli oggetti Set sono collezioni di valori, quindi \u00e8 possibile iterare i valori nel loro ordine di inserimento. Un valore in un Set pu\u00f2 occorrere solo una volta; \u00e8 quindi unico nella collezione. A differenza di un semplice array presenta le seguenti differenze: Un oggetto Set rifiuta elementi duplicati. E' utile quindi per raggruppare elementi in una lista univoca Non consente un accesso indicizzato cio\u00e8 per posizione come negli array Non si applicano i metodi applicabili agli array ma metodi simili all'oggetto Map Vale la property size e i metodi has() e clear() , add() simili per l'oggetto Map let nazioni = new Set ([ \"Italia\" , \"Francia\" , \"Inghilterra\" ]); nazioni . add ( \"Ungheria\" ); //Metodo per aggiungere un elemento //La lista degli elementi rimane inalterata poich\u00e8 l'elemento <Francia> \u00e8 gi\u00e0 presente nazioni . add ( \"Francia\" ); for ( let nazione of nazioni ) { console . log ( nazione );} /* Italia Francia Inghilterra Ungheria */","title":"Set"},{"location":"javascript/#conversione-di-un-oggetto-map-set-in-un-array","text":"Per la conversione di un Oggetto Map / Set in un array \u00e8 possibile sfruttare l'operatore \"...\" (rest). Questo operatore in generale si applica ad ogni elemento iterabile e restituisce un array di elementi derivati dall'iterazione sull'iteratore selezionato let nazioni = new Set ([ \"Italia\" , \"Francia\" , \"Inghilterra\" ]); nazioni . add ( \"Ungheria\" ); //Metodo per aggiungere un elemento //l'operatore \"...\" \u00e8 anche detto spread operator //In questo caso andr\u00e0 ad iterare ogni elemento di <nazioni> aggiungendolo all'array <vNazioni> let arrayNazioni = [... nazioni ]; //arrayNazioni adesso \u00e8 un array ottenuto da un oggetto Set console . log ( arrayNazioni [ 2 ]);","title":"Conversione di un Oggetto Map / Set in un Array"},{"location":"javascript/#lezione-19_1","text":"","title":"Lezione 19"},{"location":"javascript/#dom-manipulation","text":"Quando programmi pagine web e app, una delle cose pi\u00f9 comuni che vorrai fare \u00e8 manipolare in qualche modo la struttura del documento. Questo di solito viene fatto utilizzando il Document Object Model (DOM), un insieme di API per il controllo dell'HTML e delle informazioni di stile che fa un uso intenso dell'oggetto Document. In questo articolo vedremo come utilizzare il DOM in dettaglio, insieme ad altre API interessanti che possono alterare il tuo ambiente in modi interessanti. I browser web sono software molto complicati con molte parti mobili, molte delle quali non possono essere controllate o manipolate da uno sviluppatore web che utilizza JavaScript. Potresti pensare che tali limitazioni siano una brutta cosa, ma i browser sono bloccati per buone ragioni, principalmente incentrate sulla sicurezza. Immagina se un sito Web potesse accedere alle tue password memorizzate o ad altre informazioni sensibili e accedere ai siti Web come se fossi tu.. Nonostante i limiti, le API Web ci danno ancora accesso a molte funzionalit\u00e0 che ci consentono di fare molte cose con le pagine web. Window \u00e8 la scheda del browser in cui viene caricata una pagina web; questo \u00e8 rappresentato in JavaScript dall'oggetto Window . Usando i metodi disponibili su questo oggetto puoi fare cose come restituire le dimensioni della finestra (vedi Window.innerWidth e Window.innerHeight ), manipolare il documento caricato in quella finestra, memorizzare i dati specifici di quel documento sul lato client (ad esempio usando un database locale o un altro meccanismo di archiviazione), collegare un gestore di eventi alla finestra corrente e altro ancora. Il navigatore rappresenta lo stato e l'identit\u00e0 del browser (ovvero lo user-agent) cos\u00ec come esiste sul web. In JavaScript, questo \u00e8 rappresentato dall'oggetto Navigator . Puoi utilizzare questo oggetto per recuperare elementi come la lingua preferita dell'utente, un flusso multimediale dalla webcam dell'utente, ecc. Il documento (rappresentato dal DOM nei browser) \u00e8 la pagina effettiva caricata nella finestra ed \u00e8 rappresentato in JavaScript dall'oggetto Document . \u00c8 possibile utilizzare questo oggetto per restituire e manipolare le informazioni sull'HTML e il CSS che compongono il documento, ad esempio ottenere un riferimento a un elemento nel DOM , modificarne il contenuto del testo, applicarvi nuovi stili, creare nuovi elementi e aggiungerli a l'elemento corrente come figli, o addirittura eliminarlo del tutto. In questo articolo ci concentreremo principalmente sulla manipolazione del DOM. DOM - Document Object Model Il documento attualmente caricato in ciascuna delle schede del browser \u00e8 rappresentato da un modello di oggetti (document object model). E' rappresentato tramita una \"struttura ad albero\" creata dal browser che consente di accedere facilmente alla struttura HTML dai linguaggi di programmazione. Fonte: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents Per la manipolazione del DOM ci torna utile il paradigma di programmazione orientato agli oggetti di Javascript. Infatti il DOM non \u00e8 altro che un enorme oggetto con diverse property e metodi console . log ( document . all ); //stampa tutti i nodi all'interno della pagina htmlconsole.log(document.body); console . log ( document . head ); //Stampa l'oggetto <head> console . log ( document . body ); //Stampa l'oggetto <body>","title":"Dom Manipulation"},{"location":"javascript/#lezione-20_1","text":"","title":"Lezione 20"},{"location":"javascript/#dom-selettori","text":"Per manipolare un elemento all'interno del DOM, \u00e8 necessario prima selezionarlo e memorizzare un riferimento ad esso all'interno di una variabile. In questo esempio selezioneremo l'elemento h1 e successivamente applicheremo dello style all'elemento, colorandolo di rosso <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > DOM: Document Object Model </ h1 > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > let h1 = document . querySelector ( \"h1\" ); h1 . style . color = 'red' ; </ script > </ body > </ html >","title":"DOM - Selettori"},{"location":"javascript/#metodi-di-selezione-di-elementi-html","text":"Vediamo i metodi per selezionare gli elementi in JS. - document.getElementById(myID) : Selziona tutti gli elementi con un particolare id = \"myID\" - document.getElementsByClassName(myClassName) : Selziona tutti gli elementi che appartengono a una particolare classe, class = \"myClassName\" - document.getElementsByTagName(\"tag\") : Selziona tutti gli elementi che hanno particolare \"tag\" HTML - document.querySelector(any) : Selziona la prima occorrenza dell' elemento spcecificato attraverso la classe , l' id oppure il tag . - Selezione attraverso la classe: Si usa il simbolo \".\" seguito dal nome della classe, esempio: \".myClassName\" - Selezione attraverso l'id: Si usa il simbolo \"#\" seguito dal nome della classe, esempio: \"#myID\" - Selezione attraverso il tag HTML: \"h1\" - document.querySelectorAll : Selziona tutti gli elementi spcecificati attraverso la classe , l' id oppure il tag . Valgono le stesse regole di selezione viste per il querySelector <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < h1 > La manipolazione </ h1 > < ul > < li id = \"FRIST-ELEM\" > elemento UNO </ li > < li class = \"myClass\" > elemento DUE </ li > < li class = \"myClass\" > elemento TRE </ li > </ ul > < script > document . getElementById ( \"FRIST-ELEM\" ); //Selezione di \"elemento UNO\" document . getElementsByClassName ( \"myClass\" ); //Selezione di \"elemento DUE\", \"elemento TRE\" document . getElementsByClassName ( \"myClass\" )[ 0 ]; //Selezione di \"elemento DUE\" document . getElementsByTagName ( \"h1\" ); //Selezione di \"DOM: Document Object Manipulation\", \"La manipolazione\" // document.querySelector document . querySelector ( \".myClass\" ); //Selezione di \"elemento DUE\" document . querySelector ( \"#FRIST-ELEM\" ); //Selezione di \"elemento UNO\" document . querySelector ( \"h1\" ); //Selezione di \"DOM: Document Object Manipulation\" // document.querySelectorAll document . querySelectorAll ( \".myClass\" ); //Selezione di \"elemento DUE\", \"elemento TRE\" document . querySelectorAll ( \"#FRIST-ELEM\" ); //Selezione di \"elemento UNO\" document . querySelectorAll ( \"h1\" ); ////Selezione di \"DOM: Document Object Manipulation\", \"La manipolazione\" //last-child & nth-child(i) document . querySelector ( 'li:last-child' ); //li:last-child seleziona l'ultimo elemento <li> document . querySelector ( 'li:nth-child(2)' ). style . color = 'brown' ; //li:nth-child(i) seleziona l'i-esimo elemento <li> </ script > </ body > </ html > E' possibile utilizzare l'operatore [index] per indicizzare la collezione di elementi HTML selezionati. Nell'esempio di sopra infatti ho selezionato soltanto \"elemento DUE\" utilizzando document.getElementsByClassName(\"myClass\")[0] . Quando ci sono pi\u00f9 elementi selezionati vengono create delle collezioni di oggetti. Nel caso si utilizzi querySelectorAll verr\u00e0 restituita una collezione NodeList che dal punto di vista di Javascript \u00e8 un array. Se tuttavia utilizzassi come selettore ad esempio getElementsByTagName verrebbe restituito un HTML Collection che non \u00e8 un array e se volessi usarlo come tale sarebbe necessaria una conversione let myLI = document . querySelectorAll ( \"li\" )[ 0 ]; /* myLI <li id=\u200b\"FRIST-ELEM\">\u200b\u2026\u200b</li>\u200b */ console . log ( typeof myLI ); //object //NODE LIST let myLIAll = document . querySelectorAll ( \"li\" ); console . log ( myLIAll ); //\u00e8 una collezione \"NodeList\", un array /* NodeList(3) [li#FRIST-ELEM, li.myClass, li.myClass] 0: li#FRIST-ELEM 1: li.myClass 2: li.myClass length: 3 __proto__: NodeList */ //Essendo un array posso applicare tutti i metodi applicabili agli array myLIAll . forEach (( elem , index ) => { //il metodo \"textContent\" assegna un valore testuale all'elemento, cambia il testo elem . textContent = 'nuovo testo in li' ; }); //HTML COLLECTION let MyH1All = document . getElementsByTagName ( \"h1\" ); console . log ( MyH1All ); //HTMLCollection(2) [h1, h1] -> NON E' UN ARRAY, Attenzione!! //Posso convertirlo in array utilizzando \"Array.from\" const listaArray = Array . from ( MyH1All ); console . log ( listaArray ); /* (2) [h1, h1] 0: h1 1: h1 length: 2 */ //A questo punto posso utilizzare tutte le propriet\u00e0 degli array listaArray . forEach (( elem , index ) => { elem . style . color = 'red' ; }); //Posso usare anche un ciclo iterativo standard for ( let i = 0 ; i < listaArray . length ; i += 2 ) { //Cambia il colore del background dell'elemento <h1> in giallo listaArray [ i ]. style . background = 'yellow' ; }","title":"Metodi di selezione di elementi html"},{"location":"javascript/#lezione-21_1","text":"","title":"Lezione 21"},{"location":"javascript/#dom-child-e-parent","text":"Data la struttura ad albero del DOM \u00e8 semplificato l'accesso ad elementi figli o padri di un dato elemento children : Accede agli elementi figli parentElement : Accede all'elemento padre <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < h1 > La manipolazione </ h1 > < ul > < li id = \"FRIST-ELEM\" > elemento UNO </ li > < li class = \"myClass\" > elemento DUE </ li > < li class = \"myClass\" > elemento TRE </ li > </ ul > < script > const ul = document . querySelector ( 'ul' ); //rappresenta tutti gli <li> contenuti come HTML collection console . log ( ul . children ); //HTMLCollection(3) [li#FRIST-ELEM, li.myClass, li.myClass, FRIST-ELEM: li#FRIST-ELEM] console . log ( ul . parentElement ); //Seleziona l'elemento parente quindi il <body> console . log ( ul . parentElement . parentElement ); //Seleziona l'elemento <html> cio\u00e8 il \"nonno\" //Rappresenta i figli in una NodeList (ottimo) ma considera come elementi anche eventuali elementi di formatazione //Poich\u00e8 gli <li> sono rappresentati a capo, uno sotto l'altro ci sono altri 4 elementi che rappresentano l'elemento \"a capo\" console . log ( ul . childNodes ); //NodeList(7) [text, li#FRIST-ELEM, text, li.myClass, text, li.myClass, text] </ script > </ body > </ html >","title":"Dom - Child e Parent"},{"location":"javascript/#dom-manipolazione-dello-stile-degli-elementi-html","text":"La manipolazione statica dello stile degli elementi HTML non ha molto senso. Infatti \u00e8 possibile assegnare uno stile gi\u00e0 con CSS. Ha invece senso una manipolazione dinamica ovvero al verificarsi di un particolare evento classList permette di applicare dinamicamente una classe gi\u00e0 definita in formato CSS ma ancora non applicata a nessun elemento. Javascript funziona da ponte tra un elemento HTML e uno style CSS. E' infatti possibile aggiungere e rimuovere dinamicamente una classe da un elemento per aggiungere o rimuovere dello stile da quel dato elemento. classList.add(\"myClassName\") : Aggiunge la classe myClassName all'elemento selezionato classList.remove(\"myClassName\") : Rimuove la classe myClassName all'elemento selezionato classList.toggle(\"myClassName\") : Esegue il toggle della classe myClassName all'elemento selezionato, aggiungendola se non \u00e8 attiva e rimuovendola se \u00e8 attiva. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeFirstLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < h1 > La manipolazione </ h1 > < ul > < li id = \"FRIST-ELEM\" > elemento UNO </ li > < li class = \"myClass\" > elemento DUE </ li > < li class = \"myClass\" > elemento TRE </ li > </ ul > < script > var tag = document . getElementById ( \"FRIST-ELEM\" ); //Aggiungo la classe <classeFirstLi> all'elemento html associato a <tag>. //Aggiungo quindi anche tutte le proprit\u00e0 annesse alla classe <classeFirstLi>. tag . classList . add ( \"classeFirstLi\" ); //Applico lo stile all'elemento \"elemento UNO\" //Rimuovo la classe <classeFirstLi> tag . classList . remove ( \"classeFirstLi\" ); //Rimuovo lo stile all'elemento \"elemento UNO\" //Toggle della classe <classeFirstLi>. // Rimuovo la classe <classeFirstLi> se \u00e8 attiva, la aggiungo se non \u00e8 attiva tag . classList . toggle ( \"classeFirstLi\" ); //Applico lo stile all'elemento \"elemento UNO\" tag . classList . toggle ( \"classeFirstLi\" ); //Rimuovo lo stile all'elemento \"elemento UNO\" tag . classList . toggle ( \"classeFirstLi\" ); //Applico lo stile all'elemento \"elemento UNO\" </ script > </ body > </ html >","title":"DOM - Manipolazione dello stile degli elementi html"},{"location":"javascript/#lezione-22_1","text":"","title":"Lezione 22"},{"location":"javascript/#dom-manipolazione-del-testo-degli-elementi-html","text":"textContent La propriet\u00e0 textContent dell'interfaccia Node rappresenta il contenuto del testo di un nodo e dei suoi discendenti innerText La propriet\u00e0 innerText dell'interfaccia HTMLElement rappresenta il contenuto di testo \"renderizzato\" di un nodo e dei suoi discendenti. Come getter, approssima il testo che l'utente otterrebbe se evidenziasse il contenuto dell'elemento con il cursore e poi lo copiasse negli appunti. Nota: innerText \u00e8 facilmente confuso con Node.textContent , ma ci sono differenze importanti tra i due. Fondamentalmente, innerText \u00e8 a conoscenza dell'aspetto renderizzato del testo, mentre textContent non lo \u00e8. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeFirstLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < p > Lorem ipsum, dolor sit amet consectetur adipisicing elit. < strong > Doloremque, modi? </ strong ></ p > < script > var p = document . querySelector ( \"p\" ); //<textContent> //<textContent> restituisce una stringa del testo contenuto dell'elemento // convertendo anche il contenuto di eventuali elementi figli in puro testo console . log ( p . textContent ); //\"Lorem ipsum, dolor sit amet consectetur adipisicing elit. Doloremque, modi?\" //E' possibile cambiare la stringa del tag selezionato semplicemente con l'assegnazione p . textContent = \"lorem ps htigh manulip ase travit\" ; console . log ( p . textContent ); //\"lorem ps htigh manulip ase travit\" //<innerHTML> //<innerHTML> restituisce l'elemento HTML mantenendo la formattazione HTML console . log ( p . innerHTML ); //\"Lorem ipsum, dolor sit amet consectetur adipisicing elit. <strong>Doloremque, modi?</strong>\" //Con <innerHTML> \u00e8 possibile inserire tag HTML p . innerHTML = \"<strong>ciao</strong>\" ; console . log ( p . innerHTML ); //<strong>ciao</strong>\" </ script > </ body > </ html >","title":"DOM - Manipolazione del testo degli elementi html"},{"location":"javascript/#dom-manipolazione-degli-attributi-html","text":"getAttribute e setAttribute sono metodi di lettura e scrittura di attributi di elementi html. getAttribute ( \"attribute\" ); //ritorna il valore dell'attributo \"attribute\" setAttribute ( \"attribute\" , \"value\" ); //Assegna il valore \"value\" all'attributo \"attribute\" Nell'esempio seguente cambier\u00f2 l'immagine di un elemento <img> e il link di un elemento <a> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeFirstLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < div > < img src = \"https://www.corriere.it/methode_image/2020/04/09/Spettacoli/Foto%20Spettacoli%20-%20Trattate/MILANO_20100328_CORSERA_43_0_0-k9PF-U3180411917161aAH-656x492@Corriere-Web-Sezioni.jpg\" > </ div > < div > < a href = \"https://www.google.com/maps\" > link </ a > </ div > < script > //Modifico l'immagine modificandone l'attributo <src> //Seleziono l'elemento \"img\" var img = document . querySelector ( \"img\" ); //<getAttribute(\"attribute\")> restituisce il valore dell'attributo passato come argomento. img . getAttribute ( \"src\" ); // \"https://www.corriere.it/methode_image/2020/04/09/Spettacoli/Foto%20Spettacoli%20-%20Trattate/MILANO_20100328_CORSERA_43_0_0-k9PF-U3180411917161aAH-656x492@Corriere-Web-Sezioni.jpg\" //<setAttribute(\"attribute\", \"value\")> consente di cambiare il valore di un attributo img . setAttribute ( \"src\" , \"https://www.pensalibero.it/wp-content/uploads/2010/02/chopin1.jpg\" ); //ho cambiato l'immagine img . getAttribute ( \"src\" ); //https://www.pensalibero.it/wp-content/uploads/2010/02/chopin1.jpg //Modifico il link, modificandone l'attributo <href> //Seleziono l'elemento \"a\" var a = document . querySelector ( \"a\" ); //<getAttribute(\"attribute\")> restituisce il valore dell'attributo passato come argomento. a . getAttribute ( \"href\" ); //\"https://www.google.com/maps\" //<setAttribute(\"attribute\", \"value\")> consente di cambiare il valore di un attributo a . setAttribute ( \"href\" , \"https://mail.google.com\" ); //Ho cambiato il link a . getAttribute ( \"href\" ); //\"https://mail.google.com\" </ script > </ body > </ html >","title":"DOM - Manipolazione degli attributi html"},{"location":"javascript/#lezione-23_1","text":"","title":"Lezione 23"},{"location":"javascript/#dom-creazione-di-un-elemento","text":"In un documento HTML, il metodo document.createElement() crea l'elemento HTML specificato da tagName o un HTMLUnknownElement se tagName non viene riconosciuto. Nell'esempio successivo creeremo un elemento <li> e lo piazzeremo in coda ad una <ul> gi\u00e0 esistente. Faremo uso anche del metodo appendChild() e del metodo createTextNode() Il metodo Node.appendChild() aggiunge un nodo alla fine dell'elenco di figli di un nodo genitore specificato. Se il figlio dato \u00e8 un riferimento a un nodo esistente nel documento, appendChild() lo sposta dalla sua posizione corrente alla nuova posizione (non \u00e8 necessario rimuovere il nodo dal suo nodo padre prima di aggiungerlo ad un altro nodo). A questo link c'\u00e8 un'importante discussione tra l'uso di createTextNode() e textContent : https://stackoverflow.com/questions/31643204/textnode-or-textcontent <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < script > //creo un elemento <li> vuoto const myLi = document . createElement ( 'li' ); console . log ( myLi ); //<li></li> //Inserisco del testo nell'elemento <li> myLi . textContent = 'Elemento QUATTRO' ; console . log ( myLi ); //<li><Elemento QUATTRO/li> //Aggiungo in coda l'elemento <li> a <ul> document . querySelector ( 'ul' ). appendChild ( myLi ); //Aggiungo una classe.. e lo stile annesso myLi . className = \"classeLastLi\" ; </ script > </ body > </ html >","title":"DOM - Creazione di Un elemento"},{"location":"javascript/#dom-rimpiazzo-di-un-elemento","text":"Il metodo Node.replaceChild () sostituisce un nodo figlio all'interno del nodo (genitore) specificato. Notare l'ordine degli argomenti idiosincratico (nuovo prima del vecchio). ChildNode.replaceWith () potrebbe essere pi\u00f9 facile da leggere e utilizzare. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < script > //Creo un nuovo <li> const nuovoLi = document . createElement ( 'li' ); //Aggiungo del testo dentro <li> nuovoLi . appendChild ( document . createTextNode ( 'nuovo li' )); // equivale a \"nuovoLi.textContent = 'nuovo li';\" //Seleziono l'elemento che voglio rimpiazzare const vecchioLi = document . getElementsByTagName ( 'li' )[ 1 ]; //Selziono l'elemento padre dell'elemento che voglio rimpiazzare */ const ul = document . querySelector ( 'ul' ); //replaceChild(new,old) permette di rimpiazzare un elemento figlio //specificando come parametri il nuovo elemento e il vecchio elemento (quello da rimpiazzare) ul . replaceChild ( nuovoLi , vecchioLi ); </ script > </ body > </ html >","title":"DOM - Rimpiazzo di un elemento"},{"location":"javascript/#dom-eliminazione-di-un-elemento","text":"Il metodo Node.removeChild () rimuove un nodo figlio dal DOM e restituisce il nodo rimosso. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < script > /** Si possono cancellare i figli attraverso il padre */ /** Seleziono il padre */ const ulParent = document . querySelector ( 'ul' ); /** Seleziono tutti gli <li> e li metto in un contenitore che sar\u00e0 un array di <li> */ const listitem = document . querySelectorAll ( 'li' ); console . log ( listitem ); ulParent . removeChild ( listitem [ 2 ]); //rimuovo \"Elemento TRE\" //Rimuove tutti gli elementi <child> //La property <firstChild> restituisce il primo elemento \"child\" e \"null\" se non ci sono elementi child while ( ulParent . firstElementChild ){ ulParent . removeChild ( ulParent . firstElementChild ); } </ script > </ body > </ html > Property firstChild : La propriet\u00e0 di sola lettura Node.firstChild restituisce il primo figlio del nodo nell'albero o null se il nodo non ha figli. Se il nodo \u00e8 un documento, restituisce il primo nodo nell'elenco dei suoi figli diretti.","title":"DOM - ELiminazione di un elemento"},{"location":"javascript/#lezione-24_1","text":"","title":"Lezione 24"},{"location":"javascript/#dom-events","text":"Vengono trasmessi eventi per notificare al codice eventi accaduti. Ogni evento \u00e8 rappresentato da un oggetto basato su un 'interfaccia Event e pu\u00f2 avere campi e / o funzioni personalizzati aggiuntivi utilizzati per ottenere ulteriori informazioni su quanto accaduto. Gli eventi possono rappresentare qualsiasi cosa, dalle interazioni utente di base alle notifiche automatiche di eventi che accadono nel modello di rendering. Alla pagina: https://developer.mozilla.org/en-US/docs/Web/Events E' possibile consultare i cos\u00ecdetti Standard Events , eventi comuni ad ogni tipo di browser definiti dalla specifica standard Web.","title":"DOM Events"},{"location":"javascript/#metodo-addeventlistener","text":"Il metodo EventTarget addEventListener() imposta una funzione che verr\u00e0 chiamata ogni volta che l'evento specificato viene consegnato all'elemento di destinazione. I target comuni sono Element, Document, e Window, ma la destinazione pu\u00f2 essere qualsiasi oggetto che supporti eventi (come XMLHttpRequest). addEventListener() funziona aggiungendo una funzione o un oggetto che implementa EventListener all'elenco di listener di eventi per il tipo di evento specificato sul EventTarget sul quale \u00e8 chiamato. target . addEventListener ( type , listener [, options ]); Parametri: - type : Una stringa sensibile al maiuscolo/minuscolo che rappresenta il tipo di evento da assegnare. Alcuni tipi di eventi, click , dblclick , cut , scroll , compositionstart , blur .. - listener : L'oggetto che riceve una notifica (un oggetto che implementa l'interfaccia Event) quando si verifica un evento del tipo specificato. Questo deve essere un oggetto che implementa l'interfaccia EventListener, o una funzione. Vedi Il callback del listener di eventi per i dettagli sul callback stesso. Fonte: https://developer.mozilla.org/it/docs/Web/API/Element/addEventListener#Il_callback_del_listener_di_eventi Vedremo qualche evento attraverso gli esempi: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input id = \"changeColor\" type = \"button\" value = \"OK\" > < script > var input = document . querySelector ( \"#changeColor\" ); //Seleziono il primo <li> var ulChild = document . querySelector ( \"ul\" ). firstElementChild ; //addEventListener(\"eventType\", function) //aggiunge un evento all'elemento <input>. //Al click del mouse sull'elemento <input> viene eseguita la funzione anonima //che in questo caso esegue il toggle della classe \"classeLi\" sul primo elemento <li> input . addEventListener ( \"click\" , function (){ ulChild . classList . toggle ( \"classeLi\" ); }) </ script > </ body > </ html > Vediamo un esempio pi\u00f9 interessante. In questo esempio assegneremo lo stile agli elementi <li> ogni volta che schiacceremo il tasto OK a partire dal primo elemento. Una volta che lo stile \u00e8 applicato a tutti gli elementi, schiacciando nuovamente il tasto andremo a togliere lo stile a tutti gli elementi partendo dal primo. Per applicare e togliere stile utilizzeremo classList.toggle(\"myClassName) gi\u00e0 visto qualche lezione fa. Utilizzeremo anche firstElementChild gi\u00e0 visto e nextElementSibling che restituisce l'elemento successivo a quello attualmente puntato dal figlio. nextElementSibling La propriet\u00e0 di sola lettura NonDocumentTypeChildNode.nextElementSibling restituisce l'elemento immediatamente successivo a quello specificato nell'elenco dei figli del suo genitore o null se l'elemento specificato \u00e8 l'ultimo nell'elenco. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input id = \"changeColor\" type = \"button\" value = \"OK\" > < script > var input = document . querySelector ( \"#changeColor\" ); var ulChild = document . querySelector ( \"ul\" ). firstElementChild ; input . addEventListener ( \"click\" , function (){ if ( ulChild !== null ){ ulChild . classList . toggle ( \"classeLastLi\" ); ulChild = ulChild . nextElementSibling ; } else { ulChild = document . querySelector ( \"ul\" ). firstElementChild ; ulChild . classList . toggle ( \"classeLastLi\" ); ulChild = ulChild . nextElementSibling ; } }) </ script > </ body > </ html > Non \u00e8 necessario schiacciare elementi <input type=\"button\"> . Possono essere utilizzati tutti gli elementi html. In questo esempio associeremo un evento ad ogni elemento <li> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input id = \"changeColor\" type = \"button\" value = \"OK\" > < script > //Seleziono tutti i <li> var listaLi = document . querySelectorAll ( \"li\" ); console . log ( listaLi ); //creo un array di <li> //Itero su ogni <li> for ( var i = 0 ; i < listaLi . length ; i ++ ){ //aggiungo un evento ad ogni li. Premendo sull'elemento <li> si applicher\u00e0/toglier\u00e0 lo style definito da \"classeLastLi\" listaLi [ i ]. addEventListener ( \"click\" , function (){ this . classList . toggle ( \"classeLastLi\" ); }) } </ script > </ body > </ html > this: this in questo caso rappresenta l'elemento i-esimo a cui \u00e8 posizionato il listener cio\u00e8 listaLi[i] . Oltre alla funzione anonima, posso definire anche una funzione esterna al verificarsi di un certo evento. In questo esempio cambieremo il testo al Titolo con un testo inserito dall'utente in una casella testuale <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input type = \"text\" id = \"newTitle\" > < input id = \"changeTitle\" type = \"button\" value = \"Cambia Titolo\" > < script > var input = document . querySelector ( \"#changeTitle\" ); var h1 = document . querySelector ( \"h1\" ); function changeTitle () { testo = document . querySelector ( \"#newTitle\" ); h1 . textContent = testo . value ; } input . addEventListener ( \"click\" , changeTitle ); </ script > </ body > </ html > Nel prossimo esempio avremo una casella di testo in cui sar\u00e0 possibile inserire del testo. Facendo doppio click su un elemento qualsiasi della pagina html andr\u00e0 a cambiare il testo dell'elemento cliccato <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input type = \"text\" id = \"newTitle\" > < script > var listaLI = document . querySelectorAll ( \"li\" ); //crea un array di <li> var h1 = document . querySelector ( \"h1\" ); //seleziono <h1> function changeText () { testo = document . querySelector ( \"#newTitle\" ); this . textContent = testo . value ; this . cla } for ( let i = 0 ; i < listaLI . length ; i ++ ){ listaLI [ i ]. addEventListener ( \"dblclick\" , changeText ); } h1 . addEventListener ( \"dblclick\" , changeText ); </ script > </ body > </ html >","title":"Metodo addEventListener"},{"location":"javascript/#lezione-25_1","text":"","title":"Lezione 25"},{"location":"javascript/#prevent-default","text":"Il metodo preventDefault () dell'interfaccia Event dice al programma utente che se l'evento non viene gestito esplicitamente, la sua azione predefinita non dovrebbe essere eseguita come sarebbe normalmente. L'evento continua a propagarsi come al solito, a meno che uno dei suoi listener di eventi non chiami stopPropagation () o stopImmediatePropagation () , entrambi i quali terminano immediatamente la propagazione. Fonte: https://developer.mozilla.org/it/docs/Web/API/Event/preventDefault Consideriamo il seguente esempio. Al click di ogni link vorrei che venisse stampato per esteso il link nella casella testuale. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > li { margin : 2 px ; } input { margin : 2 px ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > < a href = \"https://www.youtube.com/\" > youtube </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://developer.mozilla.org/en-US/\" > MDN </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://www.google.com/maps\" > maps </ a >< br > < input type = \"text\" > </ li > </ ul > < script > var linkList = document . querySelectorAll ( \"a\" ); for ( let i = 0 ; i < linkList . length ; i ++ ) { linkList [ i ]. addEventListener ( \"click\" , function (){ //this rappresenta l'elemento <a> i-esimo //this.parentElement === <li> //this.parentElement.lastElementChild === <input> input = this . parentElement . lastElementChild ; input . value = this . href ; }); } </ script > </ body > </ html > Se avete provato ad eseguire il codice noterete che al click sull'elemento <a> , la pagina verr\u00e0 rendirizzata sul link corrispondente, in poche parole non funziona. Questo accade perch\u00e8 il comportamento di default di <a> tag \u00e8 quello di saltare alla pagina specificata dall'attributo href . Per inibire il comportamento di default di qualsiasi elemento si utilizza il metodo prevenDefault() applicato all'oggetto ricevuto come parametro (opzionale) dal listener. Normalmente questo oggetto viene indicato con e . Qui sotto riporto l'esempio funzionante. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > li { margin : 2 px ; } input { margin : 2 px ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > < a href = \"https://www.youtube.com/\" > youtube </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://developer.mozilla.org/en-US/\" > MDN </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://www.google.com/maps\" > maps </ a >< br > < input type = \"text\" > </ li > </ ul > < script > var linkList = document . querySelectorAll ( \"a\" ); for ( let i = 0 ; i < linkList . length ; i ++ ) { linkList [ i ]. addEventListener ( \"click\" , function ( e ){ //this rappresenta l'elemento <a> i-esimo //this.parentElement === <li> //this.parentElement.lastElementChild === <input> input = this . parentElement . lastElementChild ; input . value = this . href ; e . preventDefault (); }); } </ script > </ body > </ html >","title":"Prevent Default"},{"location":"javascript/#che-cose-esattamente-loggetto-ricevuto-come-unico-parametro-e","text":"L'interfaccia Event (oggetto \"e\") I gestori degli eventi possono essere assegnati a vari elementi DOM. Quando un dato evento si verifica, un oggetto evento viene creato dinamicamente e passato agli event listener che permettono di gestirlo. L'interfaccia Event del DOM \u00e8 quindi accessibile dalla funzione che gestisce l'evento, alla quale viene passato un oggetto evento come primo e unico argomento ( e ). Fonte: https://developer.mozilla.org/en-US/docs/Web/API/Event //.. console . log ( e ); /** MouseEvent {isTrusted: true, screenX: 196, screenY: 208, clientX: 196, clientY: 105, \u2026} altKey: falsebubbles: truebutton: 0buttons: 0cancelBubble: falsecancelable: trueclientX: 196clientY: 105composed: truectrlKey: falsecurrentTarget: nulldefaultPrevented: falsedetail: 1eventPhase: 0fromElement: nullisTrusted: truelayerX: 196layerY: 105metaKey: falsemovementX: 0movementY: 0offsetX: 149offsetY: 12pageX: 196pageY: 105path: (8) [a, li#ciao.myClass, ul, div, body, html, document, Window]relatedTarget: nullreturnValue: truescreenX: 196screenY: 208shiftKey: falsesourceCapabilities: InputDeviceCapabilities {firesTouchEvents: false}srcElement: atarget: atimeStamp: 125025.42499999981toElement: atype: \"click\"view: Window {window: Window, self: Window, document: document, name: \"\", location: Location, \u2026}which: 1x: 196y: 105__proto__: MouseEvent */ L'oggetto \"Event\" fornisce un sacco di informazioni sulla natura dell'evento scatenato. Al sito: https://developer.mozilla.org/it/docs/Web/API/Event \u00e8 possibile visionare ogni propriet\u00e0 e ogni metodo dell'oggetto Event (e)","title":"Che cos'\u00e8 esattamente l'oggetto ricevuto come unico parametro \"e\"?"},{"location":"javascript/#lezione-26_1","text":"","title":"Lezione 26"},{"location":"javascript/#approfondimento-type-event","text":"Vediamo adesso un'insieme di eventi typeEvent mouse/tastiera tra i pi\u00f9 usati. Ricordo che typeEvent \u00e8 il primo parametro del metodo addEventListener() La lista completa la troviamo al link: https://developer.mozilla.org/it/docs/Web/API/Element HTMLelement . addEventListener ( 'typeEvent' , function (){ //code }); Eventi mouse mousedown : Scatta l'evento al click del mouse sull'elemento mouseup : Scatta l'evento al rilascio del click del mouse sull'elemento mouseover : Scatta l'evento passando sopra l'elemento con il mouse mouseout : Scatta l'evento non appena esco dal campo dall'elemento con il mouse mousemove : Scatta l'evento ogni volta che mi muovo all'interno dell'elemento con il mouse Nell'esempio successivo, utilizzer\u00f2 gli eventi mousemove , mouseout e le propriet\u00e0 offsetX , offsetY dell'oggetto Event passato come argomento al listener utilizzate per restituire la posizione X/Y dell'evento scatenato. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . colorRed { color : red ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < div > < textarea id = \"textAreaEvent\" cols = \"60\" rows = \"30\" > Muovi il mouse all'interno di quest'area </ textarea > < div > < table > < tr > < td > Pos-x: </ td > < td >< input id = \"pos-X\" type = \"text\" ></ td > </ tr > < tr > < td > Pos-y: </ td > < td >< input id = \"pos-Y\" type = \"text\" ></ td > </ tr > </ table > </ div > </ div > < script > var textAreaEvent = document . querySelector ( \"#textAreaEvent\" ); var posX = document . querySelector ( \"#pos-X\" ); var posY = document . querySelector ( \"#pos-Y\" ); textAreaEvent . addEventListener ( \"mousemove\" , function ( e ){ posX . value = e . offsetX ; posY . value = e . offsetY ; posX . classList . remove ( \"colorRed\" ) posY . classList . remove ( \"colorRed\" ) }) textAreaEvent . addEventListener ( \"mouseout\" , function () { posX . classList . add ( \"colorRed\" ) posY . classList . add ( \"colorRed\" ) }) </ script > </ body > </ html > Finch\u00e8 il mouse si muove all'interno della textarea scatter\u00e0 l'evento mousemove che restituir\u00e0 posizione X/Y del mouse. Non appena si esce da textarea scatter\u00e0 l'evento mouseout colorando di rosso il valore della posizione X/Y.","title":"Approfondimento type event"},{"location":"javascript/#aprrofondimento-eventi-tastiera-e-input","text":"File html < body > < h3 > evento JS </ h3 > < div > < p > Lorem ipsum, dolor sit amet consectetur adipisicing elit. < strong > Doloremque, modi? </ strong ></ p > < ul > <!-- #region Importante mettere '#' come valore di href perch\u00e8 evita il comportamento di default del link che come ricordiamo tenderebbe a raggiungere il link specificato da href ma nel caso di un bottone premuto voglio stabilirlo io cosa deve accadere--> < li id = \"ciao\" class = \"myClass\" > elemento UNO < a href = \"#\" > click me </ a ></ li > < li class = \"classe\" > elemento DUE </ li > < li class = \"classe\" > elemento TRE </ li > </ ul > < form id = 'form' action = \"\" > < input id = 'input' type = \"text\" > </ form > </ div > < script src = \"08_mainDOM.js\" ></ script > </ body > </ html > Eventi Tastiera 'keydown': genera un evento alla pressione di ogni tasto digitato 'keyup': genera un evento al rilascio di ogni tasto digitato 'keypress': genera un evento alla pressione di ogni tasto digitato (alcuni tasti speciali non sono considerati) 'focus': genera un evento quando aziono il focus sull'elemento (spesso equivale al click) 'blur': genera un evento quando esco dalla zona di focus dell'elemento 'copy': genera un evento al comando \"ctrl + c\", copia 'paste': genera un evento al comando \"ctrl + v\", incolla L'esempio seguente permette di contare il numero di tasti premuti di due caselle di input \"Nome\" e \"Cognome\" visualizzando il conteggio in una casella testuale \"Tasti Premuti\". Il conteggio si azzera con il focus sulla casella testuale \"Tasti Premuti\". Appare un alert con la scritta \"Non \u00e8 possibile usare la funzione copia!\" quando si tenta di eseguire il comando Ctrl + c (copia) all'interno della casella \"Nome\" o \"Cognome\". Inoltre, abbandonando il focus sulle caselle di input \"Nome\" o \"Cognome\" il testo digitato si colorer\u00e0 di rosso ma non appena torneremo alla digitazione il testo torner\u00e0 di colore nero. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . colorRed { color : red ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < table > < tr > < td > Tasti Premuti: </ td > < td >< input type = \"text\" id = \"pressed-key\" ></ td > </ tr > < tr > < td > Nome: </ td > < td >< input type = \"text\" id = \"name\" ></ td > </ tr > < tr > < td > Cognome: </ td > < td >< input type = \"text\" id = \"cognome\" ></ td > </ tr > </ table > < script > var form = [ document . querySelector ( \"#name\" ), document . querySelector ( \"#cognome\" )] var textPressedKey = document . querySelector ( \"#pressed-key\" ); Tasti Premuti var charInserted = 0 ; //alla pressione di un tasto nei campi \"Nome\" e \"Cognome\" verr\u00e0 aggiornato il conteggio dei caratteri //totali inseriti e tolto lo stile all' elemento che ha scatenato l'evento rimuovendo la classe \"colorRed\" function pressedKey (){ textPressedKey . value = String ( ++ charInserted ); this . classList . remove ( \"colorRed\" ); } //quando viene lasciato il focus dall'elemento viene aggiunto lo stile tramite la classe \"colorRed\" function changeColor (){ this . classList . add ( \"colorRed\" ); } //quando si tenta di lanciare il comando \"copia\" dai campi \"Nome\" e \"Cognome\" si genera un alert di errore function printErrorCopyMessage () { alert ( \"Non \u00e8 possibile usare la funzione copia!\" ); } //quando sposto il focus sull'elemento \"Tasti Premuti\" azzero il conteggio textPressedKey . addEventListener ( \"focus\" , function () { charInserted = 0 ; textPressedKey . value = String ( charInserted ); }) //Aggiungo eventi ai campi \"Nome\" e \"Cognome\" for ( elem of form ){ elem . addEventListener ( \"keydown\" , pressedKey ); elem . addEventListener ( \"blur\" , changeColor ); elem . addEventListener ( \"copy\" , printErrorCopyMessage ); } </ script > </ body > </ html >","title":"Aprrofondimento eventi tastiera e input"},{"location":"javascript/#lezione-27","text":"","title":"Lezione 27"},{"location":"javascript/#argomeni-non-trattati-da-approfondire","text":"Typed Array : Gli array tipizzati JavaScript sono oggetti simili a array che forniscono un meccanismo per leggere e scrivere dati binari grezzi nei buffer di memoria. Come forse gi\u00e0 saprai, gli oggetti Array crescono e si riducono dinamicamente e possono avere qualsiasi valore JavaScript. I motori JavaScript eseguono ottimizzazioni in modo che questi array siano veloci. Utile per curare aspetti delicati come l'Endianess. Fonte: MDN - Typed Array Endianess. In informatica, endianness \u00e8 l'ordine o la sequenza di byte di una parola di dati digitali nella memoria del computer. L'Endianness \u00e8 principalmente espresso come big-endian (BE) o little-endian (LE) . Un sistema big-endian memorizza il byte pi\u00f9 significativo di una parola all'indirizzo di memoria pi\u00f9 piccolo e il byte meno significativo al pi\u00f9 grande. Un sistema little-endian, al contrario, memorizza il byte meno significativo all'indirizzo pi\u00f9 piccolo.L'Endianness pu\u00f2 anche essere usato per descrivere l'ordine in cui i bit vengono trasmessi su un canale di comunicazione, ad esempio, il big-endian in un canale di comunicazione trasmette prima i bit pi\u00f9 significativi. Il bit-endianness \u00e8 usato raramente in altri contesti. I protocolli Internet come TCP e IPV4 utilizzano lo schema little endian mentre i processori Intel utilizzano spesso la notazione big endian . Questo \u00e8 un problema reale da conoscere saper gestire Fonte: Wikipedia - Endianess Regular Expression Le espressioni regolari sono schemi usati per confrontare combinazioni di caratteri nelle stringhe. In JavaScript, le espressioni regolari sono anche oggetti. Questi pattern sono usati con i metodi exec() e test() della classe RegExp , e con i metodi match() , matchAll() , replace() , search() , e split() della classe String . Fonte: MDN - Espressioni_Regolari Moduli Fonte: MDN - JavaScript modules Eventi/Manipolazione DOM (programmazione asincrona, promis) Dom Manipulation Quando scrivi pagine web e app, una delle cose pi\u00f9 comuni che vorrai fare \u00e8 manipolare in qualche modo la struttura del documento. Questo di solito viene fatto utilizzando il Document Object Model (DOM), un insieme di API per il controllo dell'HTML e delle informazioni di stile che fa un uso intenso dell'oggetto Document. In questo articolo vedremo come utilizzare il DOM in dettaglio, insieme ad alcune altre API interessanti che possono alterare il tuo ambiente in modi interessanti. Fonte: MDN - Manipulating documents Javascript async function Una funzione asincrona \u00e8 una funzione dichiarata con la parola chiave asincrona. Le funzioni asincrone sono istanze del costruttore AsyncFunction e al loro interno \u00e8 consentita la parola chiave await. Le parole chiave async e await consentono di scrivere un comportamento asincrono basato sulla promessa in uno stile pi\u00f9 pulito, evitando la necessit\u00e0 di configurare esplicitamente catene di promesse. Fonte: MDN - async function Libreria JQuery jQuery \u00e8 una libreria JavaScript per applicazioni web, distribuita come software libero, distribuito sotto i termini della Licenza MIT. Nasce con l'obiettivo di semplificare la selezione, la manipolazione, la gestione degli eventi e l'animazione di elementi DOM in pagine HTML, nonch\u00e9 semplificare l'uso di funzionalit\u00e0 AJAX, la gestione degli eventi e la manipolazione dei CSS. Le sue caratteristiche permettono agli sviluppatori JavaScript di astrarre le interazioni a basso livello con i contenuti delle pagine HTML. L'approccio di tipo modulare di jQuery consente la creazione semplificata di applicazioni web e contenuti dinamici versatili. Nel 2020, jQuery risulta la libreria JavaScript pi\u00f9 utilizzata in Internet, ovvero \u00e8 presente nel 74,4% dei primi 10 milioni di siti Internet pi\u00f9 popolari secondo W3Techs. Fonte: Wikipedia - JQuery","title":"Argomeni non trattati / da approfondire"},{"location":"javascript/#fonti","text":"Risorse gratuite - Exploring JS: JavaScript books for programmers - MDN Video-Corsi gratuiti: - fcamuso - Corso Javascript (ES6) ITA - Andrea Tommasello - corso Javascript - 2019 italiano","title":"Fonti"},{"location":"javascript/#-","text":"","title":"--------------------------------------------------------------------------"},{"location":"javascript/#approndimenti-pt1","text":"","title":"APPRONDIMENTI PT.1"},{"location":"javascript/#-_1","text":"","title":"--------------------------------------------------------------------------"},{"location":"javascript/#nodejs","text":"Node.js Cos'\u00e8 node Install node Prima applicazione nodejs Non esiste l'oggetto window global objects Modules Creiamo un modulo Moduli built-in Modulo path Modulo OS Modulo File System Eventi Modulo HTTP Approfondimenti Passare dei parametri esterni My first IO sync My first IO async Filtered","title":"Node.js"},{"location":"javascript/#cose-node","text":"Node \u00e8 un programma c++ che include l'engine javascript V8 di Chrome javascript che ti permette di programmare il server con Javascript","title":"Cos'\u00e8 node"},{"location":"javascript/#install-node","text":"Verifica se hai gi\u00e0 installato node node --version Se il comando node non \u00e8 riconosciuto significa che lo hai installato, quindi installalo da qui Lancia nuovamente: node --version A questo punto dovrebbe rispondere con la versione appena installata: v14.15.4","title":"Install node"},{"location":"javascript/#prima-applicazione-nodejs","text":"Crea un file .js ad esempio app.js e scrivi codice javascript function sayHello ( name ){ console . log ( name ); } sayHello ( 'simone' ); Adesso, digitando da terminale: node app.js Vedrai: simone node eseguir\u00e0 direttamente il codice sul terminale. Il programma di node trasferir\u00e0 il codice all'engine V8 il quale poi verr\u00e0 tradotto in c++ per essere letto dalla macchina (?almeno credo?)","title":"Prima applicazione nodejs"},{"location":"javascript/#non-esiste-loggetto-window","text":"non esiste l'oggetto globale window poich\u00e8 fa parte del runtime environment che si ha nei browser console . log ( window ); ReferenceError: window is not defined In nodejs l'oggetto globale si chiama global ed \u00e8 condiviso e accessibile ovunque","title":"Non esiste l'oggetto window"},{"location":"javascript/#global-objects","text":"Hai accesso a tutte le funzionalit\u00e0 definite da javascript grazie all'oggetto global global . console . log (); global . setTimeout (); global . clearTimeout (); global . setInterval (); global . clearInterval (); L'oggetto global \u00e8 implicito quindi puoi sempre ometterlo console . log (); setTimeout (); clearTimeout (); setInterval (); clearInterval (); Locale o globale? //Javascript nel tuo browser //Globale var message = '' ; In Javascript \u00e8 una variabile globale , poich\u00e8 viene aggiunta all'oggetto window . In node questa assume uno scope locale al file. In altre parole non viene aggiunta all'oggetto global //nodejs //Locale var message = '' ; console . log ( global . message ); //undefined Attenzione che, dichiarando una variabile, assume uno scope locale al file contrariamente a quanto accadeva con Javascript. Infatti con Javascript una variabile","title":"global objects"},{"location":"javascript/#modules","text":"Il concetto di modulo serve proprio a incapsulare la definizione di variabili, classi e quantaltro evitando quindi eventuali problemi di conflitto tra calssi o variabili che verrebbero brutalmente sovraiscritti. nel concetto di nodejs, ogni file \u00e8 considerato un modulo Se si parla di OOP, si potrebbe dire che all'interno di ogni file tutti gli oggetti sono privati al container che \u00e8 il file. Se vuoi utilizzare ed esportare dei dati esternamente devi renderli pubblici esplicitamente Ogni applicazione nodejs ha un modulo main Per adesso non abbiamo ancora definito un modulo node ma a breve lo faremo. module \u00e8 un oggetto richiamabile esattamente come global o window nel caso di javascript all'interno di un browser console . log ( module ); /** * Module { id: '.', path: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app', exports: {}, parent: null, filename: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\app.js', loaded: false, children: [], paths: [ 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\node_modules', 'C:\\\\Users\\\\node_modules', 'C:\\\\node_modules' ] } */","title":"Modules"},{"location":"javascript/#creiamo-un-modulo","text":"In questo esempio creeremo un modulo, quindi un file js chiamato logger.js . In questo file definiremo una funzione e una variabile ed esporteremo la funzione esternamente. In realt\u00e0 dovremmo parlare di metodo poich\u00e8 di fatto \u00e8 appartenente al modulo logger.js che \u00e8 racchiuso in un oggetto var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports . log = log ; //module.exports.url = url; Nel file app.js andremo a richiamare l'oggetto restituito //require ritorna l'oggetto esportato dal modulo var logger = require ( './logger' ); console . log ( logger ); /** * { log: [Function: log] } */ la variabile logger ritorna ci\u00f2 che esporta il modulo logger.js infatti stampando module da logger.js avremo: var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports . log = log ; console . log ( module ); //module.exports.url = url; /* Module { id: '.', path: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app', exports: { log: [Function: log] }, parent: null, filename: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\logger.js', loaded: false, children: [], paths: [ 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\node_modules', 'C:\\\\Users\\\\node_modules', 'C:\\\\node_modules' ] } */ la property exports \u00e8 l'oggetto esportato esternamente. Ad ogni modo, adesso posso usare il metodo log del modulo logger . /*logger.js*/ var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports . log = log ; /*app.js*/ //require ritorna l'oggetto esportato dal modulo var logger = require ( './logger' ); logger . log ( 'ciao' ); >node .\\app.js ciao E' buona norma utilizzare il qualificatore const per i moduli importati questo perch\u00e8 non vogliamo in nessun modo che vengano sovraiscritti erroneamente. Se accidentalmente si prova a cambiare il valore di una costante, viene sollevato un errore a runtime /*app.js*/ //require ritorna l'oggetto esportato dal modulo const logger = require ( './logger' ); logger . log ( 'ciao' ); di sotto vedrai come esportare la funzione log in quanto funzione e non come metodo di un oggetto /*logger.js*/ var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports = log ; /*app.js*/ //require ritorna l'oggetto esportato dal modulo var log = require ( './logger' ); log ( 'ciao' ); >node .\\app.js ciao Stampiamo in questo caso cosa esporta il modulo logger /*logger.js*/ var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports = log ; console . log ( module ); /* Module { id: '.', exports: [Function: log], parent: null, filename: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\logger.js', loaded: false, children: [], paths: [ 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\node_modules', 'C:\\\\Users\\\\node_modules', 'C:\\\\node_modules' ] } */","title":"Creiamo un modulo"},{"location":"javascript/#moduli-built-in","text":"Sulla pagina ufficiale di node.js puoi trovare la sezione relativa alla documentazione .","title":"Moduli built-in"},{"location":"javascript/#modulo-path","text":"Nel prossimo esempio useremo il modulo path che fornisce delle utility per lavorare con file e directory. Utilizzeremo in particolare il metodo parse() Il metodo parse() restituisce un oggetto le cui propriet\u00e0 rappresentano elementi significativi del percorso. L'oggetto ritorna le seguenti propriet\u00e0: dir <string> root <string> base <string> name <string> ext <string> Vediamo un esempio: const path = require ( 'path' ); const pathObj = path . parse ( './app.js' ); console . log ( pathObj ); /** * { root: '', dir: '.', base: 'app.js', ext: '.js', name: 'app' } */","title":"Modulo path"},{"location":"javascript/#modulo-os","text":"La documentazione del modulo os la trovi qui In questo esempio vedremo come usare il modulo os e in particolare i metodi totalmem() e freemem() che restituiscono informazioni rispettivamente sulla memoria totale di sistema e la memoria libera const os = require ( 'os' ); const totalMemory = os . totalmem (); const freeMemory = os . freemem (); console . log ( 'Total Memory ' + totalMemory ); console . log ( `Free Memory: ${ freeMemory } ` ); /** * Total Memory 8502140928 * Free Memory: 4154499072 */","title":"Modulo OS"},{"location":"javascript/#modulo-file-system","text":"Puoi trovare l'intera documentazione qui . In particolare vedremo il metodo fs.readdirSync(path[, options]) e il metodo fs.readdir(path[, options], callback) Metodo sincrono readdirSync() . Ritorna un array di elementi contenuti al path passato come parametro. E' un metodo sincrono! I metodi sincroni sono anche detti bloccanti in quanto impegnano la CPU per tutto il tempo necessario al completamento dell'attivit\u00e0 impedendo al codice di proseguire e servire le altre attivit\u00e0. Questo \u00e8 il funzionamento tipico della programmazione procedurale sincrona const fs = require ( 'fs' ); //Metodo sincrono const files = fs . readdirSync ( './' ); console . log ( files ); Metodo asincrono readdir() . Ritorna (attraverso la callback) un array di elementi contenuti al path passato come primo parametro. Esegue la callback passata come secondo parametro. I metodi asincroni sono anche detti non-bloccanti in quanto impegnano la CPU solo al momento di partenza dell'attivit\u00e0. In questo caso il codice pu\u00f2 proseguire con le altre attivit\u00e0. Una volta che il metodo avr\u00e0 concluso l'attivit\u00e0, verr\u00e0 eseguita una cos\u00ecdetta \"callback\" una funzione in grado di comunicare se il risultato \u00e8 andato a buon fine oppure no. In una funzione \"callback\", il primo parametro rappresenta l'errore (eventuale), il secondo parametro rappresenta il valore di ritorno del metodo. Nel caso della readdir() rappresenta l'array di file contenuti al path specificato come primo parametro della readdir() const fs = require ( 'fs' ); //Metodo asincrono fs . readdir ( './' , function ( err , files ){ if ( err ) console . log ( 'Error' , err ); else console . log ( 'Result' , files ); }); /* Result [ 'app.js', 'logger.js' ] */ Simuliamo un errore: const fs = require ( 'fs' ); //Metodo asincrono fs . readdir ( 'aaaaa' , function ( err , files ){ if ( err ) console . log ( 'Error' , err ); else console . log ( 'Result' , files ); }); /* Error [Error: ENOENT: no such file or directory, scandir 'C:\\Users\\Di Ricco\\Google Drive\\Intecs\\Saleri\\Appunti-nodejs\\first-app\\aaaaa'] { errno: -4058, code: 'ENOENT', syscall: 'scandir', path: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\aaaaa' } */","title":"Modulo File System"},{"location":"javascript/#eventi","text":"La documentazione sugli eventi, in particolare la classe EventEmitter la puoi trovare qui Per poter far scattare un evento hai bisgono di: - emitter.on() : Il metodo on() si mette in ascolto dell'evento passato come primo parametro. Questa pratica in inglese si chiama \"to register a listener\". Inolte in questa fase stabilisci cosa fare quando l'evento scatta tramite una callback. - emitter.emit() : Il metodo emit() fa scattare un evento. Quando scatta torna al listener come callback. //events ritorna una classe, la classe degli eventi const EventEmitter = require ( 'events' ); //in questo modo ho istanziato un oggetto della classe EventEmitter, chiamando il suo costruttore senza nessun parametro const emitter = new EventEmitter (); //Register a listener. //devi registrare un listener prima che l'evento scatti. //E' un po' come abilitare l'interrupt per un particolare evento nei sistemi embedded e implementare l'ISR emitter . on ( 'messageLogged' , function (){ console . log ( 'listener called' ) }) //Raise an event //L'evento pu\u00f2 scattare solo dopo che \u00e8 stato registrato il listener. emitter . emit ( 'messageLogged' ); E' possibile ritornare un parametro al listener. Normalmente questo parametro viene passato come oggetto per maggiore chiarezza. La funzione di callback si aspetta un parametro. Vediamo un esempio: const EventEmitter = require ( 'events' ); const emitter = new EventEmitter (); //Register a listener. emitter . on ( 'messageLogged' , function ( eventArg ){ console . log ( 'listener called' , eventArg ) }) //Raise an event emitter . emit ( 'messageLogged' , { id : 1 , url : 'https://' }); /* listener called { id: 1, url: 'https://' } */ Puoi usare anche la sintassi \"arrow function\" const EventEmitter = require ( 'events' ); const emitter = new EventEmitter (); //Register a listener. emitter . on ( 'messageLogged' , ( eventArg ) => { console . log ( 'listener called' , eventArg ) }) //Raise an event emitter . emit ( 'messageLogged' , { id : 1 , url : 'https://' }); Normalmente gli eventi possono scattare da ogni modulo ma vorresti averne il controllo sul tuo main module. Vedremo adesso come mettersi in ascolto da eventi che possono scattare da altri moduli facendo uso delle classi /*logger.js*/ const EventEmitter = require ( 'events' ); var url = 'http://mylogger.io/log' ; //\"Logger\" contiene tutti i metodi e le propriet\u00e0 di \"EventEmitter\" class Logger extends EventEmitter { log ( message ) { //send an HTTP request console . log ( message ); //Raise an event this . emit ( 'messageLogged' , { id : 1 , url : 'https://' }); } } module . exports = Logger ; /*app.js*/ const Logger = require ( './logger' ); const logger = new Logger (); //Register a listener. logger . on ( 'messageLogged' , ( eventArg ) => { console . log ( 'listener called' , eventArg ) }) logger . log ( 'message' ); /* message listener called { id: 1, url: 'https://' } */","title":"Eventi"},{"location":"javascript/#modulo-http","text":"Se lanci questa applicazione con node.js const http = require ( 'http' ); const server = http . createServer (); server . on ( 'connection' , ( socket ) => { console . log ( 'New connection' ); }) server . listen ( 3000 ); console . log ( 'Listening on port 3000..' ); e poi dal tuo browser digiti localhost:3000 vedrai stampato New connection const http = require ( 'http' ); const server = http . createServer (( req , res ) => { if ( req . url === '/' ){ res . write ( 'hello world' ); res . end (); } if ( req . url === '/api/courses' ){ res . write ( JSON . stringify ([ 1 , 2 , 3 ])); res . end (); } }); server . listen ( 3000 ); console . log ( 'Listening on port 3000..' );","title":"Modulo HTTP"},{"location":"javascript/#approfondimenti","text":"Alcuni riferimenti utili: puoi imparare node su nodeschoold . Cliccando su learnyounode Ti suggerir\u00e0 di scaricare tramite npm un simpatico software per l'apprendimento di node. puoi imparare le nuoe features di es6 su es6 features","title":"Approfondimenti"},{"location":"javascript/#passare-dei-parametri-esterni","text":"Eseguiremo l'esercizio baby-steps suggerito da learnyounode /*baby-steps.js*/ const argArray = process . argv ; let sum = 0 ; argArray . forEach ( ( element , index ) => { if ( index >= 2 ) sum += Number ( element ); }); console . log ( sum ); Esegui ad esempio: node .\\baby-steps.js 1 2 3 Vedrai: 6","title":"Passare dei parametri esterni"},{"location":"javascript/#my-first-io-sync","text":"Nel prossimo esempio leggeremo un file di testo e stamperemo il numero di caratteri a capo . Faremo uso del modulo fs e del metodo readFileSync() per la lettura dei file in modo sincrono const fs = require ( 'fs' ); const buf = fs . readFileSync ( './myFile.txt' ); const str = buf . toString (); const strArr = str . split ( '\\n' ); console . log ( buf ); console . log ( str ); console . log ( strArr ); console . log ( strArr . length - 1 ); /* <Buffer 63 69 61 6f 20 0a 61 20 0a 74 75 74 74 69 0a 71 75 61 6e 74 69> ciao a tutti quanti [ 'ciao ', 'a ', 'tutti', 'quanti' ] 3 */ Di default readFileSync() resistutisce un oggetto della classe Buffer che puoi approfondire direttamente sulla documentazione di nodejs. In pratica comunque resitituisce i caratteri decodificandoli in binario attraverso utf8 che \u00e8 equivalente al codice ASCII. Se vuoi verificare, basta tu prenda una tabella ASCII e tu legga il valore esadecimale per ogni lettera. Questo sistema potrebbe essere molto interessante per la comunicazione con un microcontrollore. Se vuoi tuttavia convertire direttamente in stringa puoi specificare il tipo di codifica utf8 come secondo parametro. Il codice si semplifica e diventa const fs = require ( 'fs' ); const str = fs . readFileSync ( './myFile.txt' , 'utf8' ); const strArr = str . split ( '\\n' ); console . log ( str ); console . log ( strArr ); console . log ( strArr . length ); /* ciao a tutti quanti [ 'ciao ', 'a ', 'tutti', 'quanti' ] 3 */","title":"My first IO sync"},{"location":"javascript/#my-first-io-async","text":"In questo esempio vedremo invece lo stesso esempio ma utilizzando la programmazione asincrona e quindi tramite il metodo readFile() . Questo metodo non ritorna niente, il suo output \u00e8 in realt\u00e0 la funzione di callback passata come secondo parametro che viene chiamata solo quando si \u00e8 raggiunto un risultato const fs = require ( 'fs' ); console . log ( 'before' ); fs . readFile ( './myFile.txt' , 'utf8' , ( err , data ) => { //fs.readFile('./myFile.txt', 'utf8', function(err, data){ console . log ( data ); console . log ( data . split ( '\\n' ). length - 1 ); }) console . log ( 'after' ); /* before after ciao a tutti quanti 3 */ Attenzione Quello che devi notare \u00e8 che con questo sistema, al contrario del sistema sincrono, l'evoluzione del programma continua una volta chiamato il metodo readFile() . Per questo ho inserito console.log('before'); e console.log('after'); , per dimostrare in output che il risultato non \u00e8 quello atteso In genere conviene sempre fare il check di eventuali errori. Poich\u00e8 la callback come primo parametro riceve anche un errore segnalandoci se qualcosa \u00e8 andato storto, \u00e8 buona norma utilizzarlo per sollevare un'eccezione attraverso throw oppure qualsiasi altra operazione desiderata const fs = require ( 'fs' ); console . log ( 'before' ); fs . readFile ( './myFile.txt' , 'utf8' , ( err , data ) => { if ( err ) throw err console . log ( data ); console . log ( data . split ( '\\n' ). length - 1 ); }) console . log ( 'after' ); /* before after ciao a tutti quanti 3 */","title":"My first IO async"},{"location":"javascript/#filtered","text":"In questo esempio vedrai come stampare il contenuto dei file all'interno di una directory con una particolare estensione. Il path e l'estensione vengono passati come parametri esterni allo script /*05-filtered-ls.js*/ const fs = require ( 'fs' ); const path = require ( 'path' ); const dir = process . argv [ 2 ]; const ext = process . argv [ 3 ]; fs . readdir ( dir , ( err , files ) => { files . forEach (( elem )=>{ if ( path . extname ( elem ) == ext ) console . log ( elem ) }) }) Otterrai: >node 05-filtered-ls.js ./ .js 01-hello-node.js 02-baby-steps.js 03-my-first-io-async.js 04-my-first-io.js 05-filtered-ls.js Puoi renderlo migliore.. In questo esempio utilizzero il metodo filter e passer\u00f2 l'estensione del file senza dover specificare il . const fs = require ( 'fs' ); const path = require ( 'path' ); const dir = process . argv [ 2 ]; const ext = `. ${ process . argv [ 3 ] } ` ; fs . readdir ( dir , ( err , files ) => { if ( err ) throw err ; const filesFiltered = files . filter (( file ) => path . extname ( file ) === ext ); filesFiltered . forEach (( file ) => console . log ( file )); });","title":"Filtered"},{"location":"javascript/#-_2","text":"","title":"--------------------------------------------------------------------------"},{"location":"javascript/#approndimenti-pt2","text":"","title":"APPRONDIMENTI PT.2"},{"location":"javascript/#-_3","text":"","title":"--------------------------------------------------------------------------"},{"location":"javascript/#promise","text":"Puoi trovare degli approfondimenti utili sull'argomento qua: MDN Gli oggetti Promise sono usati per computazioni in differita e asincrone. Una Promise rappresenta un'operazione che non \u00e8 ancora completata, ma lo sar\u00e0 in futuro. new Promise ( function ( resolve , reject ) { ... }); Una promise accetta come argomento una funzione che ha due parametri: resolve e reject . Tale funzione viene chiamata immediatamente dall'implementazione della Promise, passando i due argomenti resolve e reject , che sono due funzioni. Le due funzioni resolve e reject , quando chiamate, risolvono o rigettano la promise. L'esecutore inizia del lavoro (solitamente asincrono), e, una volta completato, chiama resolve per risolvere la promise, o reject se c'\u00e8 stato qualche errore. Se un errore viene sollevato nella funzione di esecuzione (executor) la promise viene rigettata. Una Promise consente di associare degli handlers con il successo o il fallimento di un'azione asincrona. Questo in pratica consente di utilizzare dei metodi asincroni di fatto come se fossero sincroni. Una Promise pu\u00f2 presentarsi in uno dei seguenti stati: pending (attesa): stato iniziale, n\u00e9 soddisfatto n\u00e9 respinto. fulfilled (soddisfatto): significa che l'operazione si \u00e8 conclusa con sucesso. rejected (respinto): significa che l'operazione \u00e0 fallita. Una promise in pending pu\u00f2 evolvere sia in fulfilled , sia in rejected con la possibilit\u00e0 in entrambi i casi di passare valori. Quando accade una di queste situazioni, vengono chiamati gli handler associati che sono stati accodati dal metodo then della promise. Poich\u00e8 i metodi .then e .catch restituiscono delle promise , \u00e8 possibile concatenarli tramite l'operazione di composition .","title":"Promise"},{"location":"javascript/#un-esempio-semplice","text":"In questo esempio creo una promise in cui chiamer\u00f2 la funzione setTimeout() . Una volta che setTimeout() sar\u00e0 completata la promise entrer\u00e0 nello stato fulfilled ritornando un messaggio di successo rappresentato dal parametro della funzione resolve() . Poich\u00e8 mi aspetto che non ci siano errori in questa situazione, ho aggiunto una variabile esterna in modo da simulare una qualsiasi condizione di errore. Con la variabile booleana ForceRejected forzo la promise ad entrare nello stato di rejected , ritornando il valore identificato dal parametro della funzione reject() . Una volta che la Promise ha terminato ed \u00e8 passata da pending a fulfilled \u00e8 possibile restituire il risultato tramite il metodo .then della Promise . Tale metodo accetta come parametro una callbackc che come parametro ha il valore passato da resolve() . Allo stesso modo, quando la Promise ha terminato ed \u00e8 passata da pending a rejected viene restituito il valore passato a reject() alla callback del metodo catch() const ForceRejected = false ; console . log ( \"Inizio\" ); let myFirstPromise = new Promise (( resolve , reject ) => { if ( ForceRejected ) { reject ( \"Error\" ); } else { setTimeout ( function (){ resolve ( \"Success!\" ); }, 1000 ); } }); myFirstPromise . then (( successMessage ) => { console . log ( \"Yee! \" + successMessage ); }). catch (( errorMessage ) => { console . log ( \"...! \" + errorMessage ); }) console . log ( \"Fine\" ); Il risultato sar\u00e0: Inizio Fine Yee! Success! Se esegui il codice con const ForceRejected = true; avrai come risultato: Inizio Fine ...! Error Nota che ho inserito anche due extra-stampe Inizio , Fine per evidenziare che il processo \u00e8 asincrono e quindi continua la sua esecuzione nel mentre che la Promise cerca di evolvere da pending a fulfilled o rejected","title":"Un esempio semplice"},{"location":"javascript/#-_4","text":"","title":"--------------------------------------------------------------------------"},{"location":"javascript/#approndimenti-pt3","text":"","title":"APPRONDIMENTI PT.3"},{"location":"javascript/#-_5","text":"","title":"--------------------------------------------------------------------------"},{"location":"javascript/#approfondimento-hoisting_1","text":"Differenza tra var , let , const , blocchi di codici, funzioni etc.. Puoi trovare un approfondimento qui","title":"Approfondimento Hoisting"},{"location":"javascript/#approfondimento-oggetti","text":"Modo alternativo per inizializzare un oggetto let fsName = 'simone' ; let lsName = 'diricco' ; let user = { fsName , lsName }; console . log ( user ); //{ fsName: 'simone', lsName: 'diricco' } In questo caso l'oggeto prende come key il nome della variabile let fsName = 'simone' ; let lsName = 'diricco' ; let user = { fsName , lsName }; console . log ( user ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user [ 'lsName' ]); //diricco console . log ( user . fsName ); //simone let user2 = { [ 'fs' + 'Name' ] : fsName , lsName }; console . log ( user ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user2 [ 'fsName' ]); //simone console . log ( user2 . lsName ); //diricco Con la notazione ['nomeKey] ho il vantaggio di poter valutare delle espressioni stringhe Per verificare se esiste unar propriet\u00e0 all'interno di un oggetto: let fsName = 'simone' ; let lsName = 'diricco' ; let user = { fsName , lsName }; console . log ( 'fsName' in user ); //true","title":"Approfondimento Oggetti"},{"location":"javascript/#approfondimento-moduli","text":"CommonJS require / exports Con require posso importare tutto ci\u00f2 che desidero appartenente a moduli esterni //main.js let a = require ( './module1' ); console . log ( a ) Con module.exports posso esportare cio\u00e8 che desidero di un modulo //module1.js let a = 10 ; module . exports = a ; Mandando in esecuzione main.js otterremo la stampa di a , il cui valore \u00e8 prelevato dal modulo module1.js . E' lo stesso identico concetto di include in c++ solo che in questo caso l'esportazione e l'importazione non \u00e8 a livello di file ma a livello proprio di funzionalit\u00e0, oggetti, classi etc.. Vediamo un esempio pi\u00f9 completo //main.js let math = require ( './math' ); console . log ( math . sum ( 20 , 30 )); console . log ( math . sub ( 20 , 30 )); console . log ( math . mul ( 20 , 30 )); console . log ( math . div ( 20 , 30 )); //math.js let sum = function ( x , y ){ return x + y ; } let div = function ( x , y ){ return x / y ; } let mul = function ( x , y ){ return x * y ; } let sub = function ( x , y ){ return x - y ; } module . exports = { sum , div , mul , sub }","title":"Approfondimento Moduli"},{"location":"javascript/#packages","text":"NPM Installiamo ad esempio il pacchetto prompt-sync tramite npm install prompt-sync . Verr\u00e0 scaricato una cartella node_modules Questo pacchetto serve per l'acquisizione di dati da tastiera. Vediamo un esempio: let prompt = require ( 'prompt-sync' )(); let number = prompt ( 'Insert a number: ' ); console . log ( number );","title":"Packages"},{"location":"javascript/#approfondimento-this","text":"this si riferisce sempre all'oggetto referenziato al quale il metodo fa riferimento let printName = function (){ return this . fsName + ' ' + this . lsName ; } let user1 = { fsName : 'mario' , lsName : 'rossi' , printName } let user2 = { fsName : 'matteo' , lsName : 'bianchi' , printName } console . log ( user1 . printName ()); //mario rossi console . log ( user2 . printName ()); //matteo bianchi Vediamo un alrto esercizio let listProducts = { \"0001\" : { name : 'PC' , price : 12.45 }, \"0002\" : { name : 'smth' , price : 13.45 }, \"0002\" : { name : 'tast' , price : 2.45 }, \"0003\" : { name : 'Monit' , price : 12.35 }, \"0004\" : { name : 'mous' , price : 124.45 } } let store = { listProducts , print : function (){ for ( let item in this . listProducts ){ console . log ( this . listProducts [ item ]. name ); console . log ( this . listProducts [ item ]. price ); console . log ( '------------------------' ); } } } store . print (); /* PC 12.45 ------------------------ tast 2.45 ------------------------ Monit 12.35 ------------------------ mous 124.45 ------------------------ */ Un altro esempio che usa il costruttore in modo da poter utilizzare un oggetto come modello e poter istanziare delle copie del modello dell'oggetto function User ( fsName , lsName , email ){ this . fsName = fsName , this . lsName = lsName , this . email = email this . name = function (){ return this . fsName + ' ' + this . lsName ; } } let user1 = new User ( 'sim' , 'dir' , 'em@em.it' ); console . log ( user1 ); console . log ( user1 . name ()); /* User { fsName: 'sim', lsName: 'dir', email: 'em@em.it', name: [Function (anonymous)] } sim dir */ Reference data type Al contrario delle strutture dati primitive, con le strutture dati referenziate come array o oggetti, l'assegnamento tra strutture dati referenziate effettua una copia solo dell'indirizzo a cui \u00e8 allocato il nome della struttura referenziata il che \u00e8 diverso dall'eseguire una copia del valore come accade con le strutture dati primitive. Questo significa che in fase di assegnamento tra due oggetti o array poich\u00e8 copio l'indirizzo dell'oggetto o array, di fatto ho ottenuto due oggetti che puntano alla stessa struttura dati. Se modifico uno, modifico anche l'altro.. Vediamo un esempio.. let user1 = { fsname : 'mario' , lsname : 'rossi' } let user2 = user1 ; console . log ( user1 ); //{ fsname: 'mario', lsname: 'rossi' } console . log ( user2 ); //{ fsname: 'mario', lsname: 'rossi' } user2 . fsname = 'Luigi' ; console . log ( user1 ); //{ fsname: 'Luigi', lsname: 'rossi' } console . log ( user2 ); //{ fsname: 'Luigi', lsname: 'rossi' } user1 . email = 'em@em.it' ; console . log ( user1 ); //{ fsname: 'Luigi', lsname: 'rossi', email: 'em@em.it' } console . log ( user2 ); //{ fsname: 'Luigi', lsname: 'rossi', email: 'em@em.it' }","title":"Approfondimento THIS"},{"location":"javascript/#costruttori-prefdefiniti-javascript","text":"Object, String, Boolean, Number, Array RegExp, Function, Error, Symbol, Date let user = new Object (); Questo significa che anche i dati primitivi sono implementati in javascript come oggetti e quindi avranno propriet\u00e0 e metodi! ecco perch\u00e8 puoi fare str.lenght oppure str.toUpperCase() oppure nmb.toFixed() Non \u00e8 possibile modificare tuttavia metodi e propriet\u00e0 di un dato primitivo! Attenzione! Anche gli Array sono particolari oggetti estesi","title":"Costruttori prefdefiniti javascript"},{"location":"javascript/#for-of","text":"","title":"for .. of"},{"location":"javascript/#for-in","text":"","title":"for .. in"},{"location":"javascript/#memoization","text":"","title":"Memoization"},{"location":"javascript/#come-fare-una-copia-profonda-tra-oggetti","text":"Sappiamo che l'assegnamento standard effetua solo una copia dei riferimenti e questo equivale a creare un oggetto che punta alla stessa struttura dati. il metodo Object.assig() invece effettua una copia profonda dell'oggetto passato come parametro restituendo di fatto un oggetto copia let user1 = { fsName : 'simone' , lsName : 'diricco' }; let user2 = Object . assign ({}, user1 ); //deep copy console . log ( user1 ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user2 ); //{ fsName: 'simone', lsName: 'diricco' } user2 . lsName = 'rossi' ; console . log ( user1 ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user2 ); //{ fsName: 'simone', lsName: 'rossi' }","title":"Come fare una copia profonda tra oggetti?"},{"location":"javascript/#proprieta-associate-ai-dati-e-propriera-associate-allaccesso","text":"","title":"propriet\u00e0 associate ai dati e proprier\u00e0 associate all'accesso"},{"location":"javascript/#get-set_1","text":"let square = { x : 10 , //propriet\u00e0 di accesso get area (){ return this . x * this . x ; } }; console . log ( square . x ); //10 console . log ( square . area ); //100 square . x = 20 ; console . log ( square . x ); //20 console . log ( square . area ); //400 square . area = 23 ; console . log ( square . x ); //20 //La propriet\u00e0 area non viene modificata console . log ( square . area ); //400 let square = { x : 10 , //propriet\u00e0 di accesso get area (){ return this . x * this . x ; }, set area ( val ){ this . x = Math . sqrt ( val ); } }; console . log ( square . x ); //10 console . log ( square . area ); //100 square . area = 25 ; console . log ( square . x ); //5 //La propriet\u00e0 area non viene modificata console . log ( square . area ); //25","title":"get &amp; set"},{"location":"javascript/#arrow-functions","text":"Sintassi funzioni function sum ( x , y ){ return x + y ; } //anonymous fucntions let sum2 = function ( x , y ){ return x + y ; } //Arrow functions let sum3 = ( x , y ) => { return x + y ; } //arrow functions with 1 argument let square = x => { return x * x ; } //arrow functions with 1 argument //compact let square2 = x => x * x ;","title":"Arrow functions"},{"location":"javascript/#high-order-functions","text":"//funzione identit\u00e0 let id = x => x ; let sum = ( x , y ) => x + y ; //Funzione di ordine superiore //poich\u00e8 accetta come argomento una funzione e ritorna una funzione id ( sum )( 4 , 5 );","title":"High Order Functions"},{"location":"javascript/#array-filter","text":"let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //test \u00e8 una funzione che decido in fase di invocazione let filter = ( array , test ) => { let result = []; for ( let item of array ) if ( test ( item )){ result . push ( item ) } return result ; } //ritorno un array con l'elemento 'simone' se \u00e8 presente console . log ( filter ( array , x => x == 'simone' )); //ritorno un array con gli elementi che contengono una 'a' console . log ( filter ( array , x => x . search ( \"a\" ) >= 0 ));","title":"Array filter"},{"location":"javascript/#array-map","text":"let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //test \u00e8 una funzione che decido in fase di invocazione let filter = ( array , test ) => { let result = []; for ( let item of array ) if ( test ( item )){ result . push ( item ) } return result ; } let map = ( array , trans ) => { let result = []; for ( let item of array ){ result . push ( trans ( item )); } return result ; } console . log ( map ( array , x => x . toUpperCase ())); //[ 'SIMONE', 'CIAO', 'MATTEO', 'ALESSANDRO' ]","title":"Array map"},{"location":"javascript/#array-reduce","text":"let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //test \u00e8 una funzione che decido in fase di invocazione let filter = ( array , test ) => { let result = []; for ( let item of array ) if ( test ( item )){ result . push ( item ) } return result ; } let map = ( array , trans ) => { let result = []; for ( let item of array ){ result . push ( trans ( item )); } return result ; } let reduce = ( array , combine , start ) => { let current = start ; for ( let item of array ){ current = combine ( current , item ) } return current ; } let count = map ( array , x => x . length ); let totCount = reduce ( count , ( a , b ) => a + b , 0 ); console . log ( count ); //[ 6, 4, 6, 10 ] console . log ( totCount ); //26","title":"Array reduce"},{"location":"javascript/#gli-array-possiedono-gia-come-metodi-filer-map-reduce","text":"Gli array possiedono gi\u00e0 come metodi filer, map, reduce array . map (); array . filter (); array . reduce (); E funzionano allo stesso modo di come li abbiamo implementati noi. Vediamo adesso come combinare queste funzioni let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //conta le lettere totali degli elementi che contengono una 'a' console . log ( //['ciao', 'matteo', 'alessandro']; array . filter ( item => { return item . search ( 'a' ) >= 0 ; }) //[ 4, 6, 10 ] . map ( item => { return item . length ; }) //20 . reduce (( a , b ) => { return a + b ; }) ); //20","title":"Gli array possiedono gi\u00e0 come metodi filer, map, reduce"},{"location":"javascript/#qualche-chicca-sugli-array","text":"","title":"Qualche chicca sugli Array"},{"location":"javascript/#arrrayof-arrayfrom","text":"let numbers = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 ]; console . log ( numbers . length ); //10 let numbers1 = Array . of ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 ); console . log ( numbers1 ); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 0] let numberString = \"1234567890\" ; let numbers2 = Array . from ( numberString ); console . log ( numbers2 ); //['1', '2', '3', '4','5', '6', '7', '8','9', '0'] let numbers3 = Array . from ( numberString , value => parseInt ( value )); console . log ( numbers3 ); //[1, 2, 3, 4, 5,6, 7, 8, 9, 0] let numbers4 = Array . from ( numbers3 , value => value + 1 ); console . log ( numbers4 ); //[2, 3, 4, 5, 6,7, 8, 9, 10, 1]","title":"Arrray.of, Array.from"},{"location":"javascript/#concat-every-some","text":"let array1 = [ 1 , 2 , 3 , 4 , 5 ]; let array2 = [ 6 , 7 , 8 , 9 , 0 ]; console . log ( array1 . concat ( array2 )); //[1, 2, 3, 4, 5,6, 7, 8, 9, 0] //ogni elemento deve soddisfare la condizione console . log ( array1 . every ( value => typeof value === \"number\" )); //true //almeno un elemento deve soddisfare la condizione console . log ( array1 . some ( value => typeof value === \"number\" )); //true","title":"concat, every, some"},{"location":"javascript/#find-filter-foreach-includes-indexof","text":"let users = [ \"Cosimo\" , \"Simone\" , \"mario\" , \"maria\" , \"giuseppe\" , \"asinello\" ]; //find console . log ( users . find ( value => value == \"mario\" )); //mario //find //ritorna un elemento dell'array console . log ( users . find ( value => value . search ( \"g\" ) == 0 )); //giuseppe //filter //ritorna un array console . log ( users . filter ( value => value . search ( \"a\" ) == 0 )); //[ 'asinello' ] /* COSIMO SIMONE MARIO MARIA GIUSEPPE ASINELLO */ //forEach users . forEach ( value => { console . log ( value . toLocaleUpperCase ()); }) //includes console . log ( users . includes ( \"pippo\" )); //false console . log ( users . includes ( \"Simone\" )); //true //indexOf console . log ( users . indexOf ( \"Simone\" )); //1 console . log ( users . indexOf ( \"maria\" )); //3","title":"find, filter, forEach, includes, indexOf"},{"location":"javascript/#push-pop-shift-unshift","text":"let numbers = [ 1 , 2 , 3 , 4 ]; //push //ritorna la lunghezza dell'array console . log ( numbers . push ( 17 )); //5 console . log ( numbers ); //[ 1, 2, 3, 4, 17 ] //pop //ritorna l'elemento rimosso console . log ( numbers . pop ( 4 )); //17 console . log ( numbers ); //[ 1, 2, 3, 4 ] //shift //ritorna l'elemento rimosso console . log ( numbers . shift ()); //1 console . log ( numbers ); //[ 2, 3, 4 ] //unshift //ritorna la lunghezza dell'array console . log ( numbers . unshift ( 23 )); //4 console . log ( numbers ); //[ 23, 2, 3, 4 ]","title":"push, pop, shift, unshift"},{"location":"javascript/#sort-splice-slice","text":"let users = [ \"Cosimo\" , \"Luigi\" , \"Mario\" , \"Alessio\" , \"Matteo\" ]; console . log ( users ); //[ 'Cosimo', 'Luigi', 'Mario', 'Alessio', 'Matteo' ] //sort //Consente l'ordinamento degli elementi dell'array //L'argomento specifica la condizione di ordinamento //modifica l'array console . log ( users . sort ( compare )); //[ 'Alessio', 'Cosimo', 'Luigi', 'Mario', 'Matteo' ] function compare ( a , b ) { if ( a < b ) { return - 1 ; } else if ( a > b ) { return 1 ; } else { return 0 ; } } users = [ \"Cosimo\" , \"Luigi\" , \"Mario\" , \"Alessio\" , \"Matteo\" ]; //splice(x, y) //elimina y elementi a partire da una posizione x //modifica l'array users . splice ( 2 , 1 ); console . log ( users ); //[ 'Cosimo', 'Luigi', 'Alessio', 'Matteo' ] //splice //puoi anche aggiungere elementi //modifica l'array users . splice ( 2 , 0 , \"giuseppia\" , \"antonio\" ); console . log ( users ); //[ 'Cosimo', 'Luigi', 'giuseppia', 'antonio', 'Alessio', 'Matteo' ] users = [ \"Cosimo\" , \"Luigi\" , \"Mario\" , \"Alessio\" , \"Matteo\" ]; //slice //ritorna un sub-array let subArray = users . slice ( 0 , 2 ); console . log ( subArray ); //[ 'Cosimo', 'Luigi' ]","title":"sort, splice, slice"},{"location":"javascript/#settimeout-setinterval","text":"la setTimeout() chiama la funzione passata come argomento dopo un certo valore di tempo specificato come argomento. La setInterval() invece chiama la funzione passata come argomento periodicamente con il periodo specificato come argomento //setTimeout() setTimeout (() => { console . log ( 'start' ); }, 1000 ); let i = 0 ; //setTimeout() setInterval (() => { console . log ( i ++ ); }, 1000 ); /* start 0 1 2 3 4 5 */","title":"setTimeout(), setInterval()"},{"location":"javascript/#eventi-asincroni","text":"// ----------------------------------> t // x x const fs = require ( 'fs' ); //chiamata asincrona.. //viene passato un path e una callback, una funzione //la callback viene chiamata una volta che la lettura \u00e8 completata //readFile restituisce un buffer fs . readFile ( './data.txt' , function ( err , data ){ console . log ( data . toString ()); }); console . log ( 'end!!' ); /* end!! hello! */","title":"Eventi Asincroni"},{"location":"javascript/#promise-resolve-reject-then","text":"const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise ( function ( resolve , reject ){ fs . readFile ( fileName , function ( err , data ){ if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let file = readFile ( './data.txt' ); console . log ( file ); //Promise { <pending> } //metodo .then della Promise //Come primo parametro accetta una funzione che viene invocata se la Promise evolve in resolve //Come secondo parametro accetta una funzione che viene invocata se la Promise evolve in reject file . then ( function ( data ){ console . log ( data . toString ()); //hello! }, function ( err ){ console . log ( err ) }) Vediamo lo stesso esempio ma con qualche console.log() const fs = require ( 'fs' ); console . log ( 'start' ); //1 //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ console . log ( 'readFIle() inizio esecuzione' ); //3 return new Promise ( function ( resolve , reject ){ console . log ( \"promise(), prima dell'invocazione del metodo async readFile\" ); //4 fs . readFile ( fileName , function ( err , data ){ console . log ( \"promise(), esecuzione callback del metodo async readFile\" ); //8 if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } console . log ( \"Prima dell'invocazione di readFile()\" ); //2 let file = readFile ( './data.txt' ); console . log ( file ); //Promise { <pending> } //5 console . log ( \"Dopo l'invocazione di readFile()\" ); //6 //metodo .then della Promise //Come primo parametro accetta una funzione che viene invocata se la Promise evolve in resolve //Come secondo parametro accetta una funzione che viene invocata se la Promise evolve in reject console . log ( \".then(), invocazione del metodo della Promise\" ); //7 file . then ( function ( data ){ console . log ( \".then(), esecuzione del metodo della Promise\" ); //9 console . log ( data . toString ()); //hello! //10 }, function ( err ){ console . log ( err ) }) /* start Prima dell'invocazione di readFile() readFIle() inizio esecuzione promise(), prima dell'invocazione del metodo async readFile Promise { <pending> } Dopo l'invocazione di readFile() .then(), invocazione del metodo della Promise promise(), esecuzione callback del metodo async readFile .then(), esecuzione del metodo della Promise hello! */","title":"Promise, resolve, reject, then"},{"location":"javascript/#async-await","text":"Vediamo lo stesso esempio di prima inserendo la chiamata a readFile in un contesto di chiamata asincrona const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let main = async function (){ console . log ( 'start' ); readFile ( './data.txt' ). then ( data => { console . log ( data . toString ()); }); console . log ( 'end' ); } main (); /* start end hello! */ Se per\u00f2 sfruttiamo anche la parola chiave await const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let main = async function (){ console . log ( 'start' ); await readFile ( './data.txt' ). then ( data => { console . log ( data . toString ()); }) console . log ( 'end' ); } main (); Oppure, visto che ritorna una Promise , posso anche fare cos\u00ec: const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let main = async function (){ console . log ( 'start' ); let data = await readFile ( './data.txt' ); console . log ( data . toString ()); console . log ( 'end' ); } main (); In questo modo ottengo un comportamento sequenziale del codice Vediamo un esempio pi\u00f9 completo const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } function wait ( time ){ return new Promise (( resolve , reject ) => { setTimeout (() => { resolve () }, time ); }) } let main = async function (){ console . log ( 'start' ); console . log ( 'attendi 5 sec..' ); await wait ( 5000 ); console . log ( 'sono passati 5 sec' ); let data = await readFile ( './data.txt' ); console . log ( 'attendi 5 sec..' ); await wait ( 5000 ); console . log ( 'sono passati 5 sec' ); console . log ( data . toString ()); console . log ( 'end' ); } main (); /* start attendi 5 sec.. sono passati 5 sec attendi 5 sec.. sono passati 5 sec hello! end */","title":"Async, Await"},{"location":"javascript/#promiseall-e-promiserace","text":"Le Promise.all() accettano come parametro un array di Promise function wait ( time , string ){ return new Promise (( resolve , reject ) => { setTimeout (() => { resolve ( string ) }, time ); }) } //Pormise.all() //Cercano come argomento un array di Promise Promise . all ([ wait ( 1000 , 1 ), wait ( 2000 , 2 ), wait ( 3000 , 3 )]). then ( value => { console . log ( value ); }) /* [ 1, 2, 3 ] */ Dopo 3 secondi stampa a video [ 1, 2, 3 ] cio\u00e8 il valore delle Promise dopo che tutte sono state risolte. La Promise.race() invece ritorna il valore della Promise che viene risolta per prima function wait ( time , string ){ return new Promise (( resolve , reject ) => { setTimeout (() => { resolve ( string ) }, time ); }) } //Pormise.all() //Cercano come argomento un array di Promise Promise . race ([ wait ( 1000 , 1 ), wait ( 2000 , 2 ), wait ( 3000 , 3 )]). then ( value => { console . log ( value ); })","title":"Promise.all() e Promise.race()"},{"location":"javascript/#set-e-map","text":"let set = new Set (); set . add ( 56 ); set . add ( 'test' ); set . add ( '34' ); //con i set \u00e8 possibile aggiungere univocamente un valore //questo significa che aggiungendo pi\u00f9 volte lo stesso valore non avr\u00e0 effetto set . add ( 34 ); set . add ( 34 ); set . add ( 34 ); console . log ( set . size ); //4 let set = new Set ([ 32 , '45' , 5 , 6 , 7 , 8 , 8 , 8 ]); console . log ( set . size ); //6 set . delete ( 32 ); console . log ( set . size ); //5 console . log ( set . has ( 6 )); //true console . log ( '-----' ); set . forEach (( value , key , set ) => { console . log ( value ); console . log ( key ); console . log ( set . size ); console . log ( '-----' ); }) /** ----- 45 45 5 ----- 5 5 5 ----- 6 6 5 ----- 7 7 5 ----- 8 8 5 ----- */ E' possibile convertire un set in un array con lo spread operator. let set = new Set ([ 32 , '45' , 5 , 6 , 7 , 8 , 8 , 8 ]); let array = [... set ]; console . log ( array ); //[ 32, '45', 5, 6, 7, 8 ] In questo caso l'array non conterr\u00e0 elementi duplicati. E' quindi possibile usare il set per rimuovere i duplicati all'interno di un array function deleteDuplicates ( items ){ return [... new Set ( items )]; } console . log ( deleteDuplicates ([ 0 , 1 , 2 , 3 , 3 , 3 , 3 , 4 , 5 , 6 , 7 , 7 , 7 , 7 ])); //[0, 1, 2, 3, 4, 5, 6, 7]","title":"Set e Map"},{"location":"javascript/#map","text":"let map = new Map () map . set ( 'user1' , 'Cosimo' ); map . set ( 'user2' , 'Simone' ); console . log ( map ); //Map(2) { 'user1' => 'Cosimo', 'user2' => 'Simone' } console . log ( map . get ( 'user1' )); //Cosimo console . log ( map . has ( 'user1' )); //true map . delete ( 'user2' ); console . log ( map . has ( 'user2' )); //false map . clear (); //svuota la mappa console . log ( map . size ); //0 let map = new Map ([[ 'key1' , 1 ], [ 'key2' , 2 ]]); console . log ( map . get ( 'key1' )); //1 map . forEach (( value , key ) => { console . log ( key , value ); }) /* key1 1 key2 2 */","title":"Map"},{"location":"javascript/READMEV2/","text":"Javascript Lezione 01 Prerequisiti al corso Prima di iniziare questo modulo, assicurati di avere una buona familiarit\u00e0 con HTML . Approccio al corso In questo corso vedrai: 1. Javascript orientato alla programmazione web front-end per realizzare semplici script lato client nonch\u00e8 per interagire con elementi html/css di una pagina web. 2. Javascript orientato alla programmazione web back-end per l'interazione con il sistema operativo di una macchina fisica. In questo caso avrai bisogno di Node.js Strumenti Necessari Per questo corso avrai bisogno di: 1. un web browser come Google Chrome . Un browser web contiene tutto il necessario per eseguire Javascript lato client 2. un editor di testo come Visual Studio Code . 3. Node.js , una runtime environment di javascript per poter eseguire script lato server nonch\u00e8 sulla propria macchina fisica. Javascript, ECMA-Script? ECMAScript (o ES) \u00e8 la specifica tecnica del linguaggio comunemente noto come Javascript, standardizzata e mantenuta da ECMA International nell'ECMA-262 ed ISO/IEC 16262. La specifica \u00e8 in continuo aggiornamento e di pari passo anche i runtime environment come i browser web o Nodejs devono poter essere allineati. Qui puoi trovare una tabella aggiornata delle funzionalit\u00e0 coperte da ogni browser web per versione di ECMAScript In questo corso tratteremo in maniera approfondita ES6. Lezione 02 Primo script all'interno del browser web Come integro codice javascript all'interno di una pagina html? Javascript all'interno del tag script E' possibile inserire codice Javascript direttamente all'interno della pagina html tramite il tag <script> . <!--File index.html--> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script > //Stampa \"ciao mondo\" direttamente nella pagina html document . write ( \"ciao mondo\" ); </ script > </ body > </ html > Javascript all'interno di un file .js E' possibile creare un collegamento con un file esterno con estensione .js che rappresenter\u00e0 il file contente codice Javascript. <!--File index.html--> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script src = \"main.js\" ></ script > </ body > </ html > //File main.js //Stampa \"ciao mondo\" direttamente nella pagina html document . write ( \"ciao mondo\" ); Primo script Javascript con node.js Crea un file .js ad esempio main.js e scrivi: console . log ( 'hello' ); Da terminale digita: node main.js Vedrai stampato sul terminale: hello Console Come abbiamo gi\u00e0 visto, il metodo log() di Console stampa un messaggio a video sul terminale in Node.js. Utilizzando il browser, verr\u00e0 effettuata la stampa di un messaggio all'interno della web console del browser. <!--File index.html--> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script > //Stampa \"ciao mondo\" direttamente nella pagina html console . log ( \"ciao mondo\" ); </ script > </ body > </ html > Riporto qualche comando (metodo) aggiuntivo della console: console . log ( 'Ciao a tutti' ); //stampa sulla console console . warn ( 'Avvertimento' ); //Genera un warning console . error ( 'questo \u00e8 un errore' ); //Genera un errore console . table ({ name : 'simone' }); //Stampa in formato tabella console . clear (); //Pulisce la console Una lista di tutti i metodi applicabili all'oggetto si trova alla pagina MDN - Console Alert & prompt alert(messaggio) mostra una finestra di avviso contenente il testo specificato prompt() mostra una finestra di dialogo che consente all'utente di inserire del testo e memorizzarlo in una variabile del programma <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script > //Salva l'input ricevuto in una variabile cio\u00e8 un contenitore testuale myName = prompt ( 'Come ti chiami?' ); alert ( \"Il tuo nome \u00e8 ..\" ); //Stampa il valore testuale contenuto nella variabile alert ( myName ); </ script > </ body > </ html > Approfondimenti sul metodo alert() dell'oggetto Window li trovate su MDN - Window.alert() mentre approfondimenti sul metodo prompt() dell'oggetto Window li trovate su MDN - Window.prompt() Commenti // comment : per commenti inline /* comment */ : per commenti su linee multiple //inline comment /* multi line comment */ Introduzione al DOM Nativamente supportato dai browser per modificare gli elementi di un documento HTML, DOM \u00e8 un modo per accedere e aggiornare dinamicamente il contenuto, la struttura e lo stile dei documenti. Wikipedia - Document Object Model Hai gi\u00e0 visto: document . write ( \"ciao mondo\" ); Il \"comando\" document.write() \u00e8 in realt\u00e0 un oggetto Javscript document a cui si applica un metodo write() ovvero una funzione richiamabile solo nel contesto di un particolare oggetto (DOM = Document Object Model). Introduzione alla libreria JQuery Vediamo anche come aggiungere librerie esterne, per aggiungere quindi funzionalit\u00e0 al linguaggio standard. Installeremo JQuery perch\u00e8 \u00e8 una libreria popolare molto utilizzata proprio per la manipolazione del DOM ovvero degli elementi html. Scarica JQuery e copialo nella root del progetto, dopodich\u00e8 dovrai creare un collegamento al file attarverso: < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > Una volta scaricato il file \u00e8 necessario copiarlo nella root del progetto e creare un collegamento al file html. Vediamo alcune funzionalit\u00e0 base offerte della libreria JQuery per la manipolazione del DOM. Le approfondiremo quando necessario pi\u00f9 avanti nel corso $() : Selettore di elementi html. E' possibile selezionare un elemento tramite il suo id , la sua classe , un attributo .. Alcuni metodi: val() : legge/scrive l'attributo value dell'elemento html selezionato click(functionName) : aggiunge l'evento click all'elemento selezionato e chiama la funzione functionName Vediamo un esempio: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table { border : 1 px dashed black } </ style > </ head > < body > < table > < tr > < td > Nome </ td > < td > < input type = \"text\" id = \"myName\" > </ td > </ tr > < tr > < td > Nuovo Nome </ td > < td > < input type = \"text\" id = \"new-name\" > </ td > </ tr > </ table > < input type = \"button\" value = \"OK\" id = \"btn-ok\" > <!-- Collegamento alla libreria JQuery.--> < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function cambiaNome (){ //Seleziono l'elemento con id \"new-name\" e ne prelevo il valore con il metodo \"val()\" //Memorizzo il risultato in una variabile di nome \"nuovoNome\" nuovoNome = $ ( \"#new-name\" ). val (); //Assegno all'elemento con id \"myName\" il valore associato alla variabile \"nuovoNome\" $ ( \"#myName\" ). val ( nuovoNome ); //Pulisco il contenuto del valore dell'elemento con id \"new-name\" $ ( \"#new-name\" ). val ( \"\" ); } //Associo all'elemento con id \"btn-ok\" un evento. //Al click sull'elemento con id \"btn-ok\" scatta la funzione \"cambiaNome\" $ ( \"#btn-ok\" ). click ( cambiaNome ) </ script > </ body > </ html > ATTENZIONE: Il simbolo $ \u00e8 un alias che sta per jQuery . Puoi quindi utilizzare jQuery al posto di $ qualora il simbolo $ fosse utilizzato per unn'altra definizione DOM ed Eventi Appena la pagina html viene eseguita il browser parte con la costruzione del DOM per metterlo a disposizione di Javascript. Nel contempo potrebbe tuttavia scattare l'evento $(\"#btn-ok\").click(cambiaNome) e mandare in errore il programma. Per evitare che questo accada \u00e8 necessario abilitari gli eventi solo dopo che la costruzione del DOM \u00e8 avvenuta con successo. Per far cio' si utilizza una funzione anonima con la seguente sintassi $ ( function (){ //evento }); Riscrivendo il codice abbiamo: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table { border : 1 px dashed black } </ style > </ head > < body > < table > < tr > < td > Nome </ td > < td > < input type = \"text\" id = \"myName\" > </ td > </ tr > < tr > < td > Nuovo Nome </ td > < td > < input type = \"text\" id = \"new-name\" > </ td > </ tr > </ table > < input type = \"button\" value = \"OK\" id = \"btn-ok\" > <!-- Collegamento alla libreria JQuery.--> < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function cambiaNome (){ nuovoNome = $ ( \"#new-name\" ). val (); //Assegno all'elemento con id \"myName\" il valore associato alla variabile \"nuovoNome\" $ ( \"#myName\" ). val ( nuovoNome ); //Pulisco il contenuto del valore dell'elemento con id \"new-name\" $ ( \"#new-name\" ). val ( \"\" ); } //L'evento sar\u00e0 pronto a scattare soltanto quando la struttura del DOM sar\u00e0 preparata $ ( function (){ $ ( \"#btn-ok\" ). click ( cambiaNome ) }); </ script > </ body > </ html > Altri metodi equivalenti: $ (). ready ( function (){ //event }) $ ( document ). ready ( function () { //event }) $ ( window ). ready ( function () { //event }) Variabili Javascript Le variabili sono utilizzate per rappresentare valori attraverso un nome simbolico chiamato identificatore . Le variabili in JavaScript hanno un tipo, ma a differenza di altri linguaggi fortemente tipizzati, Javascript utilizza i tipi per valore e non per variabile. Questo meccanismo prende il nome di tipizzazione dinamica . var cognome = 'Rossi' ; let nome = 'Mario' ; const eta = 25 ; pi = 3.14 ; Esistono tre tipi di keyword per la dichiarazione di variabili/costanti in JS. var : Per variabili sia locali che globali. let : Per variabili locali. const : Per variabili locali immutabili E' possibile inoltre dichiarare una variabile senza nessuna keyword , in questo caso sar\u00e0 l'interprete ad assegnare a tale variabile il qualificatore attraverso il meccanismo dell' auto-global variable declaration Alcune regole per dichiarazione di variabili Non \u00e8 possibile utilizzare: un numero, un # , una @ come inizio del nome di una variabile. E' accettanto invece il simbolo $ come identificatore, le keyword native di JS come: function , if , delete , new , while .. In javascript \u00e8 convenzione utilizzare la notazione camelCase per la rappresentazione di variabili composte da due o pi\u00f9 parole Vediamo qualche esempio: //Sintassi alternativa per dichiarare pi\u00f9 variabili costanti const na = 3 , pigreco = 3.14 ; _iou = 0 ; $yui = 78 ; u - 1 = 45 ; //ERROR!! 1 T = 1 ; //ERROR!! Tipi di dati in JS ECMAScript definisce sette tipi primitivi: Sei tipi di dato che sono primitives : Boolean . true e false. null . Una parola chiave che denota un oggetto nullo. undefined . Una propriet\u00e0 il cui valore non \u00e8 stato definito. Number . 42 oppure 3.14159. String . \"Salve\" Symbol . Un tipo di dato la cui istanza \u00e8 unica e immutabile. Object . NOTA: typeof \u00e8 una propriet\u00e0 di Javascript che ritorna il tipo di un oggetto o una variabile. Tipi Primitivi Javascript assegna il tipo a una variabile in modo dinamico ovvero in fase di dichiarazione della stessa. Vediamo degli esempi const nome = 'simone' ; const cognome = \"Di Ricco\" ; const nome_cognome = ` ${ nome } ${ cognome } ` ; const temp = - 1.5 ; //Number const isMaggiorenne = true ; //Boolean const value = null ; //Number const cognome = undefined ; //Undefined const mySymbol = Symbol (); //Undefined const persona = { //Object nome : 'simone' , eta : 25 , isMarry : true } Standard built-in Object Sono oggetti predefiniti e accessibili a livello globale, di uso comune in JavaScript. Hanno propriet\u00e0 e metodi built-in che servono ad eseguire operazioni comuni per l\u2019accesso e la modifica dei dati che contengono. Oggetti Fondamentali Oggetti generali di Javascrpt, sui quali sono basati tutti gli altri oggetti. Rappresentano oggetti, funzioni ed errori. Object Function Boolean Symbol Error EvalError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ATTENZIONE: Se un reference type (array o oggetto) \u00e8 dichiarato const non significa che non \u00e8 possibile modificare i campi all'interno ma solo che non posso cambiare la natura del reference type. Il nome di un reference type rappresenta solo l'indirizzo in memoria della struttura. const myObj { nome : 'simone' , cognome : 'di ricco' , eta : 34 } myObj . nome = 'luca' ; //OK myOby = 5 ; //ERROR, con const un <oggetto> non pu\u00f2 diventare dinamicamente un <number> let myObj2 { ram : 4 , rom : 5 , anno : 2010 } myObj2 . ram = 6 ; //OK myObj2 = 18 ; //OK con let un <oggetto> pu\u00f2 tramutarsi dinamicamente in un <number> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Approfondimento Null - undefined - NaN undefined : Si verifica quando un oggetto o una variabile non assume nessun valore null : E' un valore attributo in fase di programmazione per identificare che un dato oggetto o variabile non assume nessun valore. Differisce da undefined poich\u00e8 null \u00e8 previsto deliberatamente in fase di programmazione NaN : Viene restituito quando l'espressione numerica valutata non restituisce un Number Esempio 1: console . log ( null === undefined ); //false Nota: Per controllare gli stati di null e undefined \u00e8 possibile utilizzare direttamente le keyword null e undefined come nell'esempio sopra illustrato. La stessa cosa non vale per NaN . In questo caso si utilizza IsNaN() . //Attenzione console . log ( NaN != NaN ); //true !!!! Stringhe Una stringa \u00e8 un tipo di dato formato da zero o pi\u00f9 caratteri racchiusi tra virgolette doppie \" \" , singole ' ' o tramite accento grave. \u00c8 possibile chiamare qualsiasi metodo dell'oggetto String su una stringa. const saluto = 'Ciao a tutti' ; //Stringa multi-line. Attenzione all'apice -accento grave- var fraseFilosofica = `Il mattino ha l'oro in bocca. La sera no` ; Opearotri, Propriet\u00e0 e Metodi su stringhe Operatori + : Uninione/concatenazione di stringhe. [ index ] : Indicizzazione di una stringa come array di caratteri, in sola lettura <, > : operatori di confronto tra stringhe. Ritornano un boolean , true/false {} : Interpolazione di stringhe const nome = \"marco\" ; const cognome = \"rossi\" ; console . log ( nome + \" \" + cognome ); //marco rossi // 0,1,2,3,4 //const cognome = \"r o s s i\"; console . log ( cognome [ 1 ]); //\"o\" console . log ( nome > cognome ); //true Approfondimento Interpolazioni di stringhe Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. E' possibile utilizzare espressioni all'interno di un unica stringa. Per far cio' si ricorre all'interpolazione di stringhe molto comune anche in altri linguaggi di programmazione. La sintassi prevede di usare SOLO l'accento grave e per le espressioni da valutare, l'operatore $ seguito dall'espressione racchiusa tra le parentesi graffe { } let index = 0 ; //La variabile \"index\" viene valuta console . log ( ` ${ index } ciao` ); //0 index = index + 1 ; console . log ( ` ${ index } ciao` ); //1 Le stringhe sono immutabili !! LE STRINGHE SONO IMMUTABILI IN JAVASCRIPT !! Questo significa che dal punto di vista semantico le stringhe non possono essere trattate come array di caratteri e di fatto non \u00e8 possibile applicare alle stringhe i metodi applicabili agli array. var saluto = \"ciao\" saluto [ 2 ] = 'Z' ; //Attenzione! LE STRINGHE SONO IMMUTABILI console . log ( saluto ); //ciao L'unico modo per cambiare un carattere all'interno di una stringa \u00e8 distruggere l'intera stringa e ricostruirne un'altra con il carattere modificato tramite assegnamento. Non \u00e8 possibile tuttavia modificre direttamente il singolo carattere di una stringa. var saluto = \"ciao\" saluto [ 2 ] = '2' ; console . log ( saluto ); //ciao saluto = \"super ciao\" console . log ( saluto ); //super ciao Propriet\u00e0 La propiet\u00e0 .lenght restituisce il numero di caratteri presenti nella stringa. const nome = \"marco\" ; console . log ( nome . lenght ); //5 console . log ( \"ciao\" . lenght ); //4 Metodi Vediamo adesso diversi metodi applicabili alle stringhe. Pi\u00f9 avanti, quando tratteremo gli oggetti capiremo meglio la terminologia metodo/propriet\u00e0/operatore. Per adesso \u00e8 importante capirne gli esempi applicativi e imparare ad usare le stringhe per intuirne le potenzialit\u00e0. toUpperCase() : - Parametri : - Tipo di Ritorno : String - Descrizione : Ritorna la stringa in caratteri maiuscoli console . log ( \"simOne di rIcco\" . toUpperCase ()); //SIMONE DI RICCO toLowerCase() : - Parametri : - Tipo di Ritorno : String - Descrizione :Ritorna la stringa in caratteri minuscoli console . log ( \"SimOne di rICco\" . toLowerCase ()); //simone di ricco charAt(index) : - Parametri : index ( Number ) - Tipo di Ritorno : String - Descrizione : Restituisce il carattere all'interno della stringa corrispondente all'indice index (Ottenibile anche tramite l'indicizzazione [ ]) console . log ( \"JaVascript\" . charAt ( 3 )); //a substring(indexStart, indexEnd) : - Parametri : indexStart ( Number ), indexEnd ( Number ) - Tipo di Ritorno : String - Descrizione : Ritorna la porzione di stringa compresa tra indexStart incluso e indexEnd escluso. console . log ( \"JaVascript language\" . substring ( 0 , 10 )); //JaVascript endsWith(param) - Parametri : param ( String ) - Tipo di Ritorno : boolean - Descrizione :ritorna un boolean se la stringa termina o meno con la stringa param console . log ( \"myPdfFile.pdf\" . endsWith ( \"pdf\" )); //true console . log ( \"01110000011\" . endsWith ( \"10\" )); //false startsWith(string) : - Parametri : param ( String ) - Tipo di Ritorno : boolean - Descrizione :ritorna un boolean (true/false) se la stringa inizia o meno con la stringa param console . log ( \"01110000011\" . startsWith ( \"0111\" )); //true .includes(param1, ?param2) : - Parametri : param1 ( String ), param2 ( Number ), - Tipo di Ritorno : boolean - Descrizione : cerca la stringa param1 a partire dall'indice opzionale param2 , ritorna true o false. Se param2 \u00e8 omesso cerca param1 in tutta la stringa console . log ( \"JaVascript is programming language\" . includes ( \"is\" )); //true console . log ( \"JaVascript is programming language\" . includes ( \"is\" , 16 )); //false indexOf(param1, ?param2) : - Parametri : param1 ( String ), param2 ( Number ), - Tipo di Ritorno : Number - Descrizione : Cerca la prima occorrenza della stringa param1 a partire dall'indice opzionale param2 . Restituisce l'indice della posizione di param1 . Se non trova param1 nella stringa restituisce -1. Se param2 \u00e8 omesso cerca param1 in tutta la stringa a partire dall'inizio della stringa. console . log ( \"0011010111000110\" . indexOf ( \"111\" )); //7 console . log ( \"0011010111000110\" . indexOf ( \"111\" , 10 )); //-1 lastIndexOf(param1, param2) : - Parametri : param1 ( String ), param2 ( Number ), - Tipo di Ritorno : Number - Descrizione : Cerca l'ultima occorrenza della stringa param1 vincolato dall'indice limite param2 . Restituisce l'indice della posizione di param1 . Se param2 \u00e8 omesso cerca param1 in tutta la stringa a partire dalla fine della stringa. padEnd(param1, param2) : - Parametri : param1 ( Number ), param2 ( String ), - Tipo di Ritorno : String - Descrizione : Riempie la stringa fino a una lunghezza massima di param1 , aggiungendo come riempitivo in coda la stringa param2 console . log ( \"100\" . padEnd ( 5 , \"-\" )); //100-- console . log ( \"100000\" . padEnd ( 5 , \"-\" )); //100000 console . log ( \"\" . padEnd ( 5 , \"-\" )); //----- padStart(param1, param2) : - Parametri : param1 ( Number ), param2 ( String ) - Tipo di Ritorno : String - Descrizione : Riempie la stringa fino a una lunghezza massima di param1 , aggiungendo come riempitivo in testa la stringa param2 console . log ( \"120\" . padStart ( 5 , \"0\" )); //00120 console . log ( \"9040\" . padStart ( 5 , \"0\" )); //09040 console . log ( \"2\" . padStart ( 5 , \"0\" )); //00002 repeat(param) : - Parametri : param ( Number ) - Tipo di Ritorno : String - Descrizione : Replica la stringa un numero di volte specificato da param console . log ( \"0\" . repeat ( 32 )); //00000000000000000000000000000000 console . log ( \"*-\" . repeat ( 8 )); //*-*-*-*-*-*-*-*- replace(param1, param2) : - Parametri : param1 ( String ), param2 ( String ) - Tipo di Ritorno : String - Descrizione : Sostituisce la prima occorennza della stringa param1 con la stringa param2 . Funziona anche se param1 \u00e8 un'espressione regolare. console . log ( \"Ciao a tutto il mondo\" . replace ( \"o\" , \"0\" )); //Cia0 a tutto il mondo //Uso interessante del metodo replace() con un'espressione regolare. /o/g >>> cerca tutte le occorrenze //di \"o\". Nota che \"g\" sta per \"global\" cio\u00e8 tutte console . log ( \"Ciao a tutto il mondo\" . replace ( /o/g , \"0\" )); //Cia0 a tutt0 il m0nd0 search(param) : - Parametri : param ( String ) - Tipo di Ritorno : Number - Descrizione : cerca la prima occorenza di param e restituisce l'indece della posizione. Funziona anche se param \u00e8 un'espressione regolare. console . log ( \"Ciao a tutto il mondo\" . search ( \"mondo\" )); //16 console . log ( \"Ciao a tutto il mondo\" . search ( \"ill\" )); //-1 slice(indexStart, indexEnd) : - Parametri : indexStart ( Number ), indexEnd ( Number ) - Tipo di Ritorno : String - Descrizione : Restituisce una sottostringa tra indexStart e indexEnd console . log ( \"DRCSMN91L22E715Q\" . slice ( 6 , 8 )); //91 split(separatore, ?max) : - Parametri : separatore ( String ), max ( Number ) - Tipo di Ritorno : Array of String - Descrizione : Pu\u00f2 essere utilizzato per raggruppare delle stringhe sottoforma di array contenute in un unica grande stringa e separate tramite un separatore. Crea quindi un array di stringhe contenente porzioni di stringa derivate dalla stringa a cui \u00e8 applicato il metodo separate dal carattere (o i caratteri) come indicato nel parametro separatore . Il secondo parametro, opzionale, indica il numero massimo di elementi dell'array. const myArray = \"Ciao a tutto il mondo\" . split ( \" \" ); console . log ( myArray ); //(5) [\"Ciao\", \"a\", \"tutto\", \"il\", \"mondo\"] console . log ( myArray [ 3 ]); //il const myArray2 = \"Ciao a tutto il mondo\" . split ( \" \" , 3 ); console . log ( myArray2 ); //(3) [\"Ciao\", \"a\", \"tutto\"] trim() : - Parametri : - Tipo di Ritorno : String - Descrizione : rimuove gli spazi all'inizio e alla fine di una stringa console . log ( \"#\" + \" Ciao a tutto il mondo \" . trim () + \"#\" ); //#Ciao a tutto il mondo# trimLeft() : - Parametri : - Tipo di Ritorno : String - Descrizione : rimuove gli spazi in testa a una stringa. console . log ( \"#\" + \" Ciao a tutto il mondo \" . trimLeft () + \"#\" ); //#Ciao a tutto il mondo # trimRight() : - Parametri : - Tipo di Ritorno : String - Descrizione : rimuove gli spazi in coda a una stringa console . log ( \"#\" + \" Ciao a tutto il mondo \" . trimRight () + \"#\" ); //# Ciao a tutto il mondo# Lezione 08 Conta parole Il seguente esempio conta le parole inserite in un certo input testuale. Faremo uso dell'evento keypress che scatta ad ogni tasto premuto e del metodo su stringa split() <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > Conta parole </ h1 > < table > < td > Testo: </ td > < tr > < td >< textarea cols = \"30\" rows = \"10\" id = \"myText\" ></ textarea ></ td > </ tr > < tr > < td > Parole nel testo: </ td > </ tr > < tr > < td >< input type = \"text\" id = \"word-count\" ></ td > </ tr > </ table > <!-- Collegamento alla libreria JQuery.--> < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function contaParole (){ //Prelievo il valore dell'elemento con id=\"myText\" lo converto a stringa e lo assegno alla variabile testoInserito let testoInserito = String ( $ ( \"#myText\" ). val ()); //Prelievo la propriet\u00e0 lenght di un array formato da parole separate da spazi. //ATTENZIONE. NON FUNZIONA CON I DOPPI SPAZI let conteggioParole = ( testoInserito . split ( \" \" ). length ); $ ( \"#word-count\" ). val ( conteggioParole ) } $ ( function (){ $ ( \"#myText\" ). keypress ( contaParole ) }); </ script > </ body > </ html > Lezione 09 Approfondimento - Rappresentazione numerica in Javascript Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso Numeri in Fixed Point Per il tipo nativo Number Javascript utilizza 64 bit per la memorizzazione in ram sia per i numeri interi sia per i numeri decimali a \"virgola fissa\" (fixed point). Vengono utilizzati 53 bit per la parte intera e i restanti 9 per la parte decimale anche se un numero \u00e8 intero. Il numero intero (safe) pi\u00f9 grande rappresentabile in JS \u00e8 MAX_SAFE_INTEGER . MAX_SAFE_INTEGER : E' il numero intero pi\u00f9 grande a cui posso applicare un incremento in modo affidabile. Il metodo isSafeInteger() applicato all'oggetto Number ritorna un boolean che indica se il numero \u00e8 safe oppure no console . log ( Number . MAX_SAFE_INTEGER ); //9007199254740991 /* (property) NumberConstructor.MAX_SAFE_INTEGER: number The value of the largest integer n such that n and n + 1 are both exactly representable as a Number value. The value of Number.MAX_SAFE_INTEGER is 9007199254740991 2^53 \u2212 1. */ let n1 = Number . MAX_SAFE_INTEGER ; //OK, safe console . log ( Number . isSafeInteger ( n1 )); //true let n2 = Number . MAX_SAFE_INTEGER + 1 ; //OK, safe console . log ( Number . isSafeInteger ( n2 )); //true let n3 = Number . MAX_SAFE_INTEGER + 1 //NO, non safe, il risultato non \u00e8 affidabile console . log ( Number . isSafeInteger ( n3 )); //false Numeri in Floating Point La rappresentazione dei numeri in \"virgola mobile\" (floating point) Javascript utilizza lo standard IEEE 754 //MAX_VALUE rappresenta il pi\u00f9 grande numero rappresentabile in virogla mobile console . log ( Number . MAX_VALUE ); //1.7976931348623157e+308 //Attenzione!! console . log ( 0.1 + 0.2 == 0.3 ); //false console . log ( 0.1 + 0.2 ); //0.30000000000000004 Lo standard IEE754 rappresenta i numeri reali e come tale \u00e8 necessario conoscere ed evitare alcune pratiche di cattivo utilizzo dei numeri reali. In generale con i numeri reali \u00e8 da evitare l'utilizzo di espressioni di uguglianza. E' possibile tuttavia trasformare un'espressione di uguaglianza esatta con un'espressione di \"vicinanza\" definendo un'accuratezza in questo modo: const accuracy = 0.0000001 ; console . log ( ( 0.1 + 0.2 ) - 0.3 < accuracy ); //true Il pi\u00f9 piccolo valore rappresentabile (vicino allo zero) in floating point \u00e8: console . log ( Number . MIN_VALUE ); //5e-324 E' bene ricordare che la rappresentazione dei numeri con lo standard IEEE 754 \u00e8 su scala logaritimica quindi non lineare. Questo significa che posso rappresentare numeri estremamente grandi e numeri estremamente piccoli ma la distanza tra due numeri diventa sempre pi\u00f9 grande (e quindi meno accurata) mano a mano che i numeri diventano grandi e diventa pi\u00f9 piccola (quindi pi\u00f9 accurata) mano a mano che i numeri diventano piccoli Not A Number NaN Javascript restituisce NaN quando valuta che un'espressione non pu\u00f2 essere svolta e darebbe errore. console . log ( 10 / \"ciao\" ); //NaN console . log ( 0 / 0 ); //NaN E' buona norma evitare NaN in special modo per quelle espressioni numeriche non prevedibili o che ricevono valori dall'esterno. La funzione isNaN() restituisce un boolean se un dato valore risulta o meno un NaN. let myVar = 12 / 0.9 ; if ( ! isNaN ( myVar ) ) { console . log ( myVar ); } Lezione 10 Approfondimento - Codifica caratteri Javascript Questa parte per adesso potrebbe essere troppo approfondita, \u00e8 possibile saltarla senza pregiudicare il corso ASCII ASCII (acronimo di American Standard Code for Information Interchange, Codice Standard Americano per lo Scambio di Informazioni) \u00e8 un codice per la codifica di caratteri. Lo standard ASCII \u00e8 stato pubblicato dall'American National Standards Institute (ANSI) nel 1968 Con US-ASCII si intende un sistema di codifica dei caratteri a 7 bit, comunemente utilizzato nei calcolatori, proposto dall'ingegnere dell'IBM Bob Bemer nel 1961, e successivamente accettato come standard dall'ISO, con il nome di ISO/IEC 646. Alla specifica iniziale basata su codici di 7 bit fecero seguito negli anni molte proposte di estensione ad 8 bit e quindi 256 caratteri, con lo scopo di raddoppiare il numero di caratteri rappresentabili. Nei PC IBM si fa per l'appunto uso di una di queste estensioni, ormai standard de facto, chiamata extended ASCII o high ASCII. In questo ASCII esteso, i caratteri aggiunti sono vocali accentate, simboli semigrafici e altri simboli di uso meno comune. I caratteri di ASCII esteso sono codificati nei cosiddetti codepage. Ogni paese present\u00f2 la sua proposta di ASCII esteso per rappresentare e codificare tutti i caratteri aggiuntivi relativi alla lingua creando non pochi problemi di comunicazione tra continenti. C'era quindi bisogno di uno standard nuovo e unico per tutto il mondo. Nasce quindi l'UNICODE. Wikipedia - ASCII Unicode Unicode \u00e8 stato creato per risolvere i limiti dei tradizionali schemi di codifica dei caratteri Ad esempio , sebbene i caratteri definiti nella ISO 8859-1 siano ampiamente utilizzati in paesi diversi, spesso si verifica incompatibilit\u00e0 tra paesi diversi. Molti metodi di codifica tradizionali hanno un problema comune, ovvero consentono ai computer di gestire un ambiente bilingue (di solito utilizzando lettere latine e le loro lingue native), ma non possono supportare un ambiente multilingue allo stesso tempo (riferendosi a una situazione in cui pi\u00f9 lingue possono essere mescolate contemporaneamente). Unicode era stato originariamente pensato come una codifica a 16 bit (quattro cifre esadecimali) che dava la possibilit\u00e0 di codificare 65.535 (2^16 -1) caratteri. Tanto si riteneva essere sufficiente per rappresentare i caratteri impiegati in tutte le lingue scritte del mondo. Ora invece lo standard Unicode, che tendenzialmente \u00e8 perfettamente allineato con la norma ISO/IEC 10646, prevede una codifica fino a 21 bit e supporta un repertorio di codici numerici che possono rappresentare circa un milione di caratteri. Ci\u00f2 appare sufficiente a coprire anche i fabbisogni di codifica di scritti del patrimonio storico dell'umanit\u00e0, nelle diverse lingue e negli svariati sistemi di segni utilizzati. Al 2009, solo una piccolissima parte di questa disponibilit\u00e0 di codici \u00e8 assegnata. Per lo sviluppo dei codici sono infatti previsti 17 \"piani\" (\"planes\", in inglese), da 00 a 10hex, ciascuno con 65.536 posizioni (quattro cifre esadecimali), ma solo i primi tre e gli ultimi tre piani sono ad oggi assegnati[2], e di questi il primo, detto anche BMP, \u00e8 praticamente sufficiente a coprire tutte le lingue pi\u00f9 usate. Concretamente, questo repertorio di codici numerici \u00e8 serializzato mediante diversi schemi di ricodifica, che consentono l'uso di codici pi\u00f9 compatti per i caratteri usati pi\u00f9 di frequente. \u00c8 previsto l'uso di codifiche con unit\u00e0 da 8 bit (byte), 16 bit (word) e 32 bit (double word), descritte rispettivamente come UTF-8, UTF-16 e UTF-32. UTF-8 \u00e8 di fatto lo standard successore di ASCII, perfettamente compatibile mentre javascript utilizza l'UTF-16 consentendo di rappresentare un numero elevato di caratteri, 655536. Ci\u00f2 non significa che per le codifiche UTF-8 e UTF-16 non sia possibile rappresentare tutti i caratteri unicode ma a causa della codifica potrebbe non essere conveniente in certe situazioni utilizzare UTF-8 anzich\u00e8 UTF-16. In certe situazioni infatti UTF-8 potrebbe aver bisogno di 3 byte per rappresentare un certo carattere mentre UTF-16 soltanto 2. Dipende dalla frequenza e natura dei caratteri. Si rirprenda il template html: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > </ body > </ html > Alla riga < meta charset = \"UTF-8\" > E' indicata la codifica necessaria per la trasmissione e visualizzazione corretta dei caratteri. Wikipedia - Unicode Wikibooks - Unicode/Character reference/0000-0FFF Caratteri di Escape Il backslash \\ indica la presenza di un carattere escape che non sarebbe possibile inserire direttamente con un editor di testo poich\u00e8 verrebbe interpretato come un comando. Vediamo qualche carattere di escape: \\n : a capo \\t : tab \\b : Backspace \\r : Carriage return \\\\ : Backslash \\' : Single quote \\\" : Double quote Introdotti gli escape \u00e8 possibile vedere come inserire un carattere UNICODE tramite il suo codice identificatico: \\u{codice_unicode} let str = \"\\u{1234}\" ; // \u1234 === 1234 codice unicode, 1 carattere console . log ( str ); console . log ( str , str . lenght ); //\u1234, 1 //Attenzione!! la codifica UTF-16 non raggiunge direttamnte il carattere stampato qui di seguito //Utilizza quindi 2 caratteri Javascript let str = \"\\u{1F600}\" ; // \ud83d\ude00 === 1F600 codice unicode, 2 caratteri console . log ( str , str . lenght ); //\ud83d\ude00, 2 Posso risalire al codice unicode tramite il metodo charCodeAt(index) che restituisce il codice unicode del carattere specificato da index . let str = \"\\u{1F600}\" ; // \ud83d\ude00 === 1F600 codice unicode 2 caratteri console . log ( str ); //\ud83d\ude00 console . log ( str . charCodeAt ( 0 ), strCharCodeAt ( 1 )); //55357 56832 C'\u00e8 anche il metodo che pi\u00f9 completo charCodePointAt(index) che restituisce il codice unicode che inizia da index . Questo \u00e8 necessario per quei caratteri che non possono essere rappresentati da UTF-16 e che quindi sono necessari \"due caratteri\" Javascript let str = \"\\u{1F600}\" ; // \ud83d\ude00 === 1F600 codice unicode 2 caratteri console . log ( str ); //\ud83d\ude00 console . log ( str . codePointAt ( 0 )); // 128512 === 1F600 Posso usare l'unicode anche per il nome di variabili! Da evitare. var \\ u { 1 f68 } = 2017 ; // \u1f68 Lezione 11 Type conversion JavaScript \u00e8 un linguaggio con tipi assegnati dinamicamente. Questo significa che non si va a specificare il tipo di dato che una variabile conterr\u00e0 quando viene dichiarata e anche che il tipo di un dato viene convertito automaticamente a seconda delle necessit\u00e0 durante l'esecuzione dello script. Nelle espressioni che coinvolgono valori numerici e stringhe con l'operatore + JavaScript converte i valori numerici in stringhe (conversione implicita). Vediamo come formalizzare questi concetti e distinguere tra conversioni esplicite e implicite. Conversione esplicita E' una pratica di buona programmazione far riferimento a conversioni esplicite come trattamento di errori o ricezione dati dall'esterno anche quando \"sembra\" che non sia necessario. La conversione esplicita forza un tipo e previene in molti casi errori di mal interpretazione dei dati. Vediamo alcune soluzioni disponibili per la conversione esplicita tra tipi in Javascript. String(value) : converte value (qualsiasi tipo) in un tipo String value.toString() : metodo che converte value in una stringa (equivalente a String(value) ) Number(value) : converte value in un tipo Number parseInt(value) - converte value in un tipo Number e ritorna la parte intera parseInt(value) - converte value in un tipo Number e ritorna la parte frazionaria //Number to string - String(value) let value = 45 ; String ( value ); //ritorna la stringa '45' //Boolean to string - String(value) let value2 = false ; String ( value2 ); //ritorna la stringa 'false' //Metodo alternativo - toString(); let value3 = false ; ( value3 ). toString (); //ritorna la stringa 'false' //String to number - Number(string) let string = '45' ; Number ( string ); //ritorna il numero 45 //Boolean to number - Number(string) let myBool = true ; Number ( myBool ); //1ritorna il numero 1 parseInt ( '100.31' ); //100 parseFloat ( '100.31' ); //31 Conversione implicita Anche se \u00e8 sconsigliato affidarsi alle conversioni implicite, cio\u00e8 quelle che Javascript effettua implicitamente incontrando in una espressione due o pi\u00f9 valori appartenenti a tipi diversi, \u00e8 bene conoscerle per difendersi e saperle trattare. In alcuni semplici casi non \u00e8 comunque sbagliato utilizzarle. Riporto un esempio qui sotto: // Type coercion const nome = 'marco' ; const cognome = 'rossi' ; const eta = 20 ; const sposato = false ; console . log ( nome + ' ' + cognome + ' ha ' + eta + ' anni. ' + '\u00e9 sposato? ' + sposato ); /* Console: --------------- marco rossi ha 20 anni. E' sposato? false */ Notiamo che la variabile eta \u00e8 stata convertita da tipo numero a tipo stringa e la variabile sposato \u00e8 stata convertita da boolean a stringa in modo implicito da javascript. Queste sono conversioni effettuate in modo automatico da javascript poich\u00e8 nella stessa espressione si trovano tipi diversi. Lezione 12 Operatori matematici Vediamo alcuni operatori matematici direttamente con un esempio: /* operatori matematici */ const questAnno = 2020 ; const etaMarco = 25 ; const etaStefano = 22 ; const nascitaMarco = questAnno - etaMarco ; const nascitaStefano = questAnno - etaStefano ; console . log ( nascitaMarco ); //1995 console . log ( nascitaStefano ); //1998 console . log ( 5 * 2 ); //10 console . log ( 5 / 2 ); //2.5 // Modulo: resto della divisione intera console . log ( 7 % 4 ); //3 Pre e post incremento/decremento L'operatore di incremento incrementa (aggiunge uno a) il suo operando e restituisce un valore. ++x / --x : pre incremento/decremento restituisce il valore dopo l'incremento x++ / x-- : post incremento/decremento restituisce il valore prima di incrementare Pre e post incremento/decremento rilevano una differenza solo in caso di valutazione di un'espressione. Se troviamo Pre e post incremento/decremento isolati in un singolo statement (come spesso accade) risultano equivalenti. //Pre incremento x = 0 ; y = ++ x ; //y=1, x=1 //Post incremento x = 0 ; y = x ++ ; //y=0, x=1 x = 0 ; x ++ ; //x=1 // in questo caso \u00e8 equivalente a ++x x = 0 ; ++ x ; //x=1 // in questo caso \u00e8 equivalente a x++ La lista di tutti gli operatori aritmetici la troviamo alla pagina: MDN - Operatori Aritmetici Oggetto MATH In JS \u00e8 possibile utilizzare funzioni matematiche avanzate tramite l'oggetto Math . Vediamo alcune tra le pi\u00f9 comuni: Math.round(value) : Ritorna l'arrotondamento di value al numero pi\u00f9 vicino Math.ceil(value) : Ritorna l' arrotondamento di value per eccesso Math.floor(value) : Ritorna l' arrotondamento di value per difetto Math.trunc(value) : Ritorna il troncamento di value Math.sqrt(value) : Ritorna la radice quadrata di value Math.abs(value) : Ritorna il valore assoluto di value Math.pow(base, exp) : Ritorna l'esponenziale: base^exp Math.min(value1, value2, value3, ..) : Ritorna il minimo valore tra i parametri indicati tra gli argomenti Math.max(value1, value2, value3, ..) : Ritorna il massimo valore tra i parametri indicati tra gli argomenti Math.random() : Ritorna un numero random decimale nel range 0 - 1 Esempio: //Math.PI console . log ( Math . PI ); //stampa del numero pi greco: 3,14.. Math . round ( 42.1 ); //42 Math . round ( 42.5 ); //43 Math . round ( 42.7 ); //43 Math . ceil ( 42.1 ); //43 Math . ceil ( 42.5 ); //43 Math . ceil ( 42.7 ); //43 Math . floor ( 42.1 ); //42 Math . floor ( 42.5 ); //42 Math . floor ( 42.7 ); //42 Math . sqrt ( 25 ); //5 Math . sqrt ( 42.5 ); //6. Math . abs ( - 25 ); //25 Math . abs ( 42.5 ); //42.5 Math . pow ( 2 , 5 ); //32 ( 2 ** 5 ); //32 === 2^5 >> equivalente a Math.pow(2, 5); Math . pow ( 5 , 3 ); //125 Math . min ( 2 , 5 , - 2 , 6 ); //-2 Math . max ( 2 , 5 , - 2 , 6 ); //6 Math . random (); //0.234514378429 Math . trunc ( 12.78899 ); //12 La seguente riga di codice genera un numero casuale da 0 a 100. console . log ( Math . round (( Math . reandom () * 100 ))); //45 Lezione 13 Equazione di II grado Il seguente script calcola le soluzioni reali di un'equazione di secondo grado. Stampa \"Soluzioni immaginarie\" se le soluzioni non sono reali <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table { border : 2 px solid gray ; padding : 5 px ; border-radius : 10 px ; } body { font-size : 20 px ; } . cofficient { text-align : right ; } # resolve { height : 30 px ; } </ style > </ head > < body > < h1 > Equazione di II grado </ h1 > < table > < tr > < td > < input type = \"text\" placeholder = \"a\" class = \"cofficient\" id = \"a\" > x < sup > 2 </ sup > + < input type = \"text\" placeholder = \"b\" class = \"cofficient\" id = \"b\" > x + < input type = \"text\" placeholder = \"c\" class = \"cofficient\" id = \"c\" > = 0 </ td > </ tr > < tr > < td >< input type = \"button\" value = \"Risolvi\" id = \"resolve\" ></ td > </ tr > < tr > < td > < input type = \"text\" placeholder = \"---\" id = \"ris-1\" > x < sub > 1 </ sub > </ td > </ tr > < tr > < td > < input type = \"text\" placeholder = \"---\" id = \"ris-2\" > x < sub > 2 </ sub > </ td > </ tr > </ table > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function ResolveEqIIgrado (){ //Prelievo il valore dell'elemento con id=\"myText\" lo converto a stringa e lo assegno alla variabile testoInserito let a = Number ( $ ( \"#a\" ). val ()); let b = Number ( $ ( \"#b\" ). val ()); let c = Number ( $ ( \"#c\" ). val ()); let delta = Math . sqrt ( b ** 2 - 4 * a * c ); if ( isNaN ( delta )) { $ ( \"#ris-1\" ). val ( \"Soluzioni immaginarie\" ); $ ( \"#ris-2\" ). val ( \"Soluzioni immaginarie\" ); } else { let ris1 = ( - b - delta ) / ( 2 * a ); let ris2 = ( - b + delta ) / ( 2 * a ); $ ( \"#ris-1\" ). val ( String ( ris1 )); $ ( \"#ris-2\" ). val ( String ( ris2 )); } } $ ( function (){ $ ( \"#resolve\" ). click ( ResolveEqIIgrado ) }); </ script > </ body > </ html > Lezione 14 Operator Precedence La precedenza degli operatori determina la priorit\u00e0 in cui gli operatori vengono valutati. Gli operatori con precedenza pi\u00f9 alta sono valutati prima degli operatori con precedenza pi\u00f9 bassa. La lista completa di tutti gli operatori con le rispettive precedenze la troviamo qua: MDN - Operator Precedence Da notare che l'operatore ( ) ha la priorit\u00e0 pi\u00f9 alta e quindi la precedenza su tutti gli operatori. Questo significa che per forzare la precedenza, esattamente come per la matematica \u00e8 possibile sfruttare le parentesi ( ) . Regola di buona programmazione: Non \u00e8 mai una buona pratica di programmazione lasciare espressioni troppo complesse prive di parentesi anche se sono rispettate dal punto di vista semantico tutte le precedenze previste. Le parentesi, oltre a forzare la precedenza, offrono visivamente una chiarezza maggiore, evitando di commettere errori banali di svista. /* Operatore precedence */ /* Calcolo eta' media */ const questAnno = 2020 ; const maggiorenne = 18 ; const nascitaMarco = 1996 ; const nascitaLuca = 2006 ; /* l'operatore \"-\" ha precedenza sull'operatore \">\" quindi l'espressione \u00e8 svolta correttamente da sinistra verso destra La sottrazione verr\u00e0 quindi svolta prima dell'operatore \">\" */ let isMaggiorenne = questAnno - nascitaMarco > maggiorenne console . log ( isMaggiorenne ); //true let isMaggiorenne = questAnno - nascitaMarco > maggiorenne console . log ( isMaggiorenne ); //false //Grouping const etaMarco = questAnno - nascitaMarco ; //24 const etaLuca = questAnno - nascitaLuca ; //14 // In questo caso poich\u00e8 la divisione ha precedenza sulla somma \u00e8 necessario forzare la priorit\u00e0 inserendo le parentesi // Calcolo et\u00e0 media console . log ( ( etaMarco + nascitaLuca ) / 2 ); //19 Associativit\u00e0 L'associativit\u00e0 specifica in che modo vengono eseguite le elaborazioni a parit\u00e0 di operatore. Mentre la precedenza valuta la priorit\u00e0, l'associativit\u00e0 valuta la modalit\u00e0 di esecuzione. Quasi tutti gli operatori hanno un'associativit\u00e0 left-to-right ovvero, l'elaborazione \u00e8 da sinistra verso destra esattamente come per la matematica. Alla pagina MDN - Operator Precedence si trova una tabella riassuntiva che mostra priorit\u00e0/associativit\u00e0 per ogni operatore. //Associativit\u00e0 del'operatore +. L'operatore + vale sia da somma che da concatenazione stringa for ( let i = 0 , j = 5 ; i <= j ; i ++ , j -- ){ document . writeln ( i + j + \" \" ); //5//5//5 } for ( let i = 0 , j = 5 ; i <= j ; i ++ , j -- ){ document . writeln ( i + ( j + \" \" ) ); //05//14//23 } Operatori di assegnamento L'operatore di assegnazione semplice = viene utilizzato per assegnare un valore a una variabile. L'operazione di assegnazione restituisce il valore assegnato. \u00c8 possibile concatenare l'operatore di assegnazione per assegnare un singolo valore a pi\u00f9 variabili (multiple assignment). //Multiple assignement // E' possibile dichiarare due variabili contemporaneamente let x , y ; /*Molto importante! L'operatore \"= \u00e8 un operatore da destra a sinistra */ x = y = ( 2 * 7 ) * 3 - 5 ; // 9 * 3 - 5 // 27 - 5 // 22 console . log ( x ); //22 console . log ( y ); //22 Molto utilizzati sono anche gli operatori di assegnamento composto come: +=, -=, *=, /= .. Hanno una sintassi molto chiara e compatta. Vengono utilizzati nei casi in cui \u00e8 necessario elaborare anche il valore della variabile a sinistra contrariamente all'operatore di assegnamento semplice = che ignora e distrugge il valore contenuto a sinistra. let x = 10 ; x *= 2 ; // x = x * 2 console . log ( x ); //20 x /= 2 ; // x = x / 2 console . log ( x ); //10 Lezione 15 Operatori Logici Gli operatori logici < , <= , == , > , >= , != .. trattano l'espressione come un espressione logica e ritornano un valore booleano. Sono spesso utilizzati nel controllo di condizioni in costruttti if o cicli while , for e tutti i costrutti condizionali e iterativi inerenti. console . log ( 1 >= 5 ); //false //Per le stringhe si segue un ordine lessicografico console . log ( \"ciao\" < \"pasta\" ); //true console . log ( 12 != 5 ); / / / true Nota - Operatore di uguaglianza: == Vs === Entrambi sono operatori logici di uguaglianza. === : Uguaglianza forte , valuta l'uguaglianza dell'espressione valutanto il tipo e il contenuto. == : Uguaglianza debole , valuta l'uguaglianza dell'espressione valutanto il contenuto effettuando prima una conversione di tipo. /* === */ console . log ( 5 === 5 ); //true console . log ( 15 === \"15\" ); //false -> sono tipi di dati diversi, il primo \u00e8 un numero, il secondo \u00e8 una stringa console . log ( null === undefined ); //false -> sono tipi di dati diversi. /* == */ console . log ( 5 == 5 ); //true console . log ( 15 == \"15\" ); //true!! -> sono tipi di dati diversi, il primo \u00e8 un numero, il secondo \u00e8 una stringa ma il contenuto \u00e8 lo stesso console . log ( false == 0 ); //true!! -> entrambi hanno un valore falsy anche se il tipo \u00e8 diverso console . log ( null == undefined ); //true!! -> entrambi hanno un valore falsy anche se il tipo \u00e8 diverso In generale l'uguaglianza forte \u00e8 da preferire per essere sicuri di effettuare quindi anche un controllo sul tipo e rendere pi\u00f9 semplice l'individuazione di errori run-time spesso causati da conversioni implicite di Javascript. Logica Booleana Trattano l'espressione come un'espressione logica e permettono la concatenazione di espressioni con pi\u00f9 operatori logici. Ritornano un valore booleano: TRUE , FALSE . Vediamo i principali: AND : condition1 && condition2 : Ritorna true se entrambe condition1 e condition2 risultano true . OR : condition1 || condition2 : Ritorna true se almeno una tra condition1 e condition2 risulta true . NOT : !condition1 : Inverte il risultato logico di condition1 . console . log ( ( 1 >= 5 ) || ( \"ciao\" < \"pasta\" ) ); //true console . log ( ( \"ciao\" < \"pasta\" ) && ( 12 == 5 ) ); //false Approfondimento - Short evalutation Se un' espressione logica risulta necessariamente true o false le elaborazioni concatenate non vengono elaborate. true || expr : expr non viene valutata false && expr : expr non viene valutata Esempio: console . log ( ( 1 < 2 ) || ( \"ciao\" < \"pasta\" ) ); //true, (\"ciao\" < \"pasta\") non viene valutata console . log ( ( 12 == 5 ) && ( \"c\" < \"p\" ) ); //false, (\"c\" < \"p\") non viene valutata Truthy e falsy I valori truthy e falsy sono quei valori considerati rispettivamente sempre veri o falsi o per meglio dire che ritornano sempre un boolean: true/false . Valori truthy: 1 , \"content\" .. Valori falsy: undefined , null , 0 , \"\" , NaN Vedremo adesso come mettere in pratica questi concetti attraverso l'uso di costrutti condizionali e iterativi. Lezione 16 Control Structure if/else La struttura di controllo if/else esegue un'istruzione o un blocco di istruzioni se una condizione specificata come argomento di if risulta true . Se la condizione risulta false si eseguono le istruzioni del ramo else MDN - if...else if ( condition1 ) { //code } else if ( condition2 ) { //code } else { //code } La condizione espressa come argomento di if \u00e8 trattata come un'espressione logica e quindi ritorna un boolean: true/false . /*Utilizzo di operatori logici combinati al costrutto if/else*/ const maggioreEta = 18 ; const etaLuca = 10 ; if ( etaLuca > maggioreEta ) { console . log ( \"Luca \u00e8 maggiorenne\" ); } else { console . log ( \"Luca non \u00e8 maggiorenne\" ); } /* Luca non \u00e8 maggiorenne */ /* Boolean logic, trattano l'espressione come logica AND -> && : ritorna TRUE se tutte le condizioni sono VERE OR -> || : ritorna TRUE se una condizione \u00e8 VERE NOT -> ! : inverte il risultato dell'espressione logica */ const nome = \"Luca\" ; const eta = 15 ; if ( eta <= 13 ) { console . log ( nome + \" \u00e8 un bambino\" ); } else if ( eta > 13 && eta <= 20 ) { console . log ( nome + \" \u00e8 un ragazzo\" ); } else { console . log ( nome + \" \u00e8 un adulto\" ); } /* Luca \u00e8 un ragazzo */ Ternary Operator Il Ternary Operator \u00e8 un costrutto condizionale inline. L'operatore condizionale (ternary) \u00e8 l'unico operatore JavaScript che necessit\u00e0 di tre operandi. Questo operatore \u00e8 frequentemente usato al posto del comando if per la sua sintassi concisa e perch\u00e9 fornisce direttamente un espressione valutabile. MDN - Operatore condizionale (ternary) (condition) ? (steatement1) : (steatement2); : Se condition risulta true verr\u00e0 eseguito steatement1 altrimenti steatement2 . /* Ternary Operator */ var nome = \"Marco\" ; var eta = \"17\" ; eta >= 18 ? console . log ( nome + \" pu\u00f2 guidare\" ) : console . log ( nome + \" non pu\u00f2 guidare\" ); /* Marco non pu\u00f2 guidare */ E' da preferire il ternary operator nei casi in cui si hanno due semplici statemeant da eseguire condizionati da un'espressione altrettanto semplice. In questo caso risulta chiaro ed elegante. Switch statemeant L'ultimo costrutto condizionale \u00e8 switch . Il comando switch valuta un espressione, confronta il valore dell'espressione con ciascuna delle clausole case ed esegue i comandi (statements) associati alla clausola (case) che verifica il confronto. MDN - switch switch ( key ) { case value1 : //code break ; case value2 : //code break ; default : //code break ; } Esempio: /* switch statemeant*/ const sport = \"calcio\" ; switch ( sport ) { case \"calcio\" : console . log ( \"Amo giocare a calcio\" ); break ; case \"tennis\" : console . log ( \"Amo giocare a tennis\" ); break ; default : console . log ( \"non amo nessuno sportf\" ); break ; } /* Console: --------------- Amo giocare a calcio */ In che occasioni si usa \u00e8 preferibile utilizzare il costrutto switch ? E' da preferire quando si hanno opzioni multiple di una un unico key (un tipo di dato qualsiasi) da valutare e tutte le opzioni sono omogenee. In questo caso risulta chiaro e leggibile. Nel prossimo esempio lo switch/case \u00e8 trasformato in un if/else . /* switch statemeant*/ const nome = \"Matteo\" ; const eta = 15 ; switch ( true ) { case ( eta <= 13 ) : console . log ( nome + \" \u00e8 un bambino\" ); break ; case ( eta > 13 && eta <= 20 ) : console . log ( nome + \" \u00e8 un ragazzo\" ); break ; default : console . log ( nome + \" \u00e8 un adulto\" ); break ; } /* Matteo \u00e8 un ragazzo */ In questo caso lo switch/case risulta meno chiaro di un if/else . E' importante fin da subito saper utilizzare i costrutti giusti per la situazione giusta. Lezione 17 while loop L'istruzione while crea un ciclo che esegue un'istruzione specificata fintanto che la condizione di test restituisce true . La condizione viene valutata prima di eseguire l'istruzione. MDN - while while ( condition ) { //code } Esempio: let contatore = 1 ; while ( contatore < 5 ) { console . log ( contatore ); contatore ++ ; } /* 1 2 3 4 */ In un qualsiasi costrutto iterativo \u00e8 sempre bene tenere in considerazione: - La condizione da verificare - l'evento che altera, ad ogni ciclo, la condizione da verificare. Il programmatore si deve assicurare che prima o poi la condizione diventi falsa altrimenti rischia di creare un loop infinito causando un crash del browser. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > LOOP INFINITO </ h1 > < script > /*Loop Infinito - DA EVITARE! */ var infinito = 0 ; while ( infinito < 10 ) { console . log ( infinito ); } </ script > </ body > </ html > Altro esempio di un ciclo iterativo applicato a una stringa con while : var parola = \"ciao\" ; var contatore = 0 ; while ( contatore < parola . length ) { // 0 < 4 // 1 < 4 // 2 < 4 // 3 < 4 console . log ( parola [ contatore ]); // c // i // a // o contatore ++ ; // 1 // 2 // 3 // 4 } /* parola.lenght -> restituisce il numero delle lettere che compongono la stringa parola parola[contatore] -> restituisce il contenuto relativo all'indice \"contaotore\" Output: c i a o */ do-while loop L'istruzione do ... while crea un ciclo che esegue un'istruzione specificata finch\u00e9 la condizione di test non restituisce false. La condizione viene valutata dopo l'esecuzione dell'istruzione, determinando l'esecuzione dell'istruzione specificata almeno una volta. MDN - do...while do { //code } while ( condition ); let j = 0 ; do { j ++ ; console . log ( j ); } while ( j < 5 ); console . log ( j ); /* Console: --------------- 0 1 2 3 4 */ Il do-while loop \u00e8 molto simile al while loop ma differisce nel punto in cui valuta la condizione sotto test. Qui sotto riporto un esempio dello stesso loop realizzato prima con while e poi con do-while. //while let i = 5 ; //la condizione \u00e8 falsa, non eseguo il corpo del loop while ( i < 5 ){ i ++ ; console . log ( i ); } console . log ( i ); /* 5 */ //do-while let j = 5 ; do { j ++ ; console . log ( j ); } while ( j < 5 ); //la condizione \u00e8 falsa ma ho eseguito una volta il corpo del loop console . log ( j ); /* Console: --------------- 6 6 */ do...while esegue il ciclo almeno una volta mentre while pu\u00f2 anche non eseguire mai il corpo. do...while \u00e8 meno utilizzato rispetto while ma pu\u00f2 comunque essere utilizzato in strutture iterative sempre in esecuzione come quella di selezione di un men\u00f9 grafico a opzioni multiple. Lezione 18 for loop L'istruzione for crea un ciclo che consiste di tre espressioni opzionali, racchiuse tra parentesi tonde ( ) e separate da punto e virgola, seguite da un'istruzione (di solito un'istruzione di blocco) da eseguire nel ciclo. MDN - for for ( inizializzazione ; condizione ; incremento / decremento ){ //code } Esempio: for ( let contatore = 1 ; contatore < 5 ; contatore ++ ){ console . log ( contatore ); } /* 1 2 3 4 */ Nota : la variabile \"contatore\", poich\u00e8 \u00e8 creata all'interno del ciclo for vive all'interno del ciclo. Al di fuori del ciclo non \u00e8 conosciuta. Vediamo anche un altro esempio precedentemente svolto con while : /* For Loop */ const nome = \"Marco\" ; for ( let i = 0 ; i < nome . length ; i ++ ){ // 0 < 4 // 1 < 4 // 2 < 4 // 3 < 4 // 4 < 5 // console . log ( nome [ i ]); // M // a // r // c // o } /* M a r c o */ Approfondimento: I cicli in cui sono note a priori il numero di iterazioni sono sono detti \"enumerativi\". Per questi cicli la struttura pi\u00f9 adatta \u00e8 certamente il for . I cicli si dicono invece \"indefiniti\" quando a priori non \u00e8 noto il numero esatto di iterazioni. Per questi cicli la struttura pi\u00f9 adatta \u00e8 il while o il do-while . Gli esempi riportati fino ad ora sono tutti cicli enumerativi. Notiamo infatti che la struttura for risulta pi\u00f9 chiara e compatta ed \u00e8 quindi da preferire. break & coninue All'interno del corpo di loop statemeant for / while / do... while \u00e8 possible invocare i comandi: continue , break . - continue : Salta all'iterazione successiva ignorando le istruzioni successive - break : Esce dal loop. Vediamo l'uso attraverso un esempio //NO continue NO break for ( let i = 0 ; i < 5 ; i ++ ){ if ( i === 2 ){ console . log ( 'QUESTO \u00c8 2' ); } console . log ( i ); } /* Console: --------------- 0 1 QUESTO \u00c8 2 2 3 4 */ //<conitnue> salta all'iterazione successiva for ( let i = 0 ; i < 5 ; i ++ ){ if ( i === 2 ){ console . log ( 'QUESTO \u00c8 2' ); continue } console . log ( i ); } /* 0 1 QUESTO \u00c8 2 3 4 */ //<break> esce dal ciclo for ( let i = 0 ; i < 5 ; i ++ ){ if ( i === 2 ){ console . log ( 'QUESTO \u00c8 2' ); break ; } console . log ( i ); } /* 0 1 QUESTO \u00c8 2 */ Approfondimento break: E' possibile uscire da loop innestati facendo uso di un'etichetta. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table td { text-align : center ; border : 1 px dashed black ; padding : 10 px ; margin-bottom : 10 px ; } </ style > </ head > < body > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > document . write ( \"<table>\" ); myLoop : for ( let i = 1 ; i <= 10 ; i ++ ) { document . write ( \"<tr>\" ); for ( let j = 1 ; j <= 10 ; j ++ ) { document . write ( \"<td>\" + \"A\" + \"</td>\" ); if ( j * i == 20 ) break myLoop ; } document . write ( \"</tr>\" ); } document . write ( \"</table>\" ); </ script > </ body > </ html > Lezione 19 Function Le funzioni sono tra i blocchi di programmazione fondamentali in JavaScript. Una funzione \u00e8 una procedura JavaScript \u2014 un gruppo di istruzioni ( statement ) che esegue un compito o calcola un valore. La definizione di funzione ( o dichiarazione di funzione, o istruzione di funzione ) consiste della parola chiave function , seguita da: il nome della funzione. una lista di argomenti per la funzione, chiusi tra due parentesi e separati da una virgola. le istruzioni JavaScript che definiscono la funzione, chiuse tra due parentesi graffe, { }. MDN - Funzioni //Dichiarazione o definizione di una funzione function name ( param1 , param2 , ? param3 ) { //code } //Chiamata name ( param1 , param2 ); Esempio: /* Function with arguments */ function salutoCompleanno ( nome , anni ){ console . log ( \"ciao \" + nome + \", auguri per i tuoi \" + anni + \" anni!\" ); } salutoCompleanno ( \"Francesco\" , 22 ); //ciao Francesco, auguri per i tuoi 22 anni! Nota: L'ordine dei parametri \u00e8 importante! Nota2: Il passaggio dei parametri \u00e8 sempre per valore intendendo che al momento della chiamata della funzione, si esegue una copia dei parametri. Non vengono quindi elaborati direttamente i valori passati a una funzione Parametri di default Alcuni parametri possono essere opzionali. In fase di chiamata possono quindi essere passati dei valori a tali parametri opppure no. In caso non venga passato un valore a tali parametri assumeranno all'interno della funzione un cos\u00ecdetto valore di default . Per inserire un valore di default e quindi rendere il parametro opzionale basta assegnare ad esso un valore in fase di dichiarazione della funzione. Vediamo un esempio: function salutoCompleanno ( nome , anni = 0 ){ if ( anni === 0 ){ console . log ( \"ciao \" + nome + \", auguri per il tuo compleanno!\" ); } else { console . log ( \"ciao \" + nome + \", auguri per i tuoi \" + anni + \" anni!\" ); } } salutoCompleanno ( \"Francesco\" , 22 ); //ciao Francesco, auguri per i tuoi 22 anni! salutoCompleanno ( \"Mario\" ); //ciao Mario, auguri per il tuo compleanno! NOTA: E' buona norma passare parametri in modo che i primi siano obbligatori e gli altri opzionali anche se tutto \u00e8 consentito ma di fatto in fase di chiamata della funzione i parametri passati sono interpretati a partire dal primo. Ricorda che conta solo l'ordine dei parametri e non l'identificativo utilizzato Ritorno di una funzione Una funzione pu\u00f2 restituire un valore con il comando return /* Return Keword */ function quadrato ( numero ){ return ( numero * numero ); } console . log ( quadrato ( 5 ) ); //25 E' preferibile che una funzione esegua un'elaborazione interna e che ritorni un valore invece di salvare il risultato all'interno di variabili esterne globali. In questo modo \u00e8 possibile riutilizzare la funzione ovunque e non renderla dipendente dal codice. E' quindi indispensabile l'utilizzo del return Note Una funzione ammette un solo return che termina l'esecuzione della funzione. Eventuali linee di codice dopo il return verranno ignorate. Lezione 20 Funzioni - Passaggio di oggetti e array Il passaggio di oggetti e array come parametri ad una funzione avviene per riferimento . Dal momento che viene passato il nome dell'oggetto e dell'array che corrisponde all'indirizzo puntatore dei dati contenuti, viene effettuata la copia dell'indirizzo e non dell'intero oggetto/array contenente i dati interni. In sostanza \u00e8 possibile accedere e modificare i dati dell'array o oggetto passato!! //Metodo Object - Gli oggetti sono passati per riferimento const annoAttuale = 2020 ; const objPersona = { nome : \"simone\" , eta : 24 , titolo : \"laurea\" , annoNascita : 1994 } aggiornaEta ( objPersona , annoAttuale ); console . log ( objPersona . eta ); //26 function aggiornaEta ( obj , anno ){ obj . eta = anno - obj . annoNascita ; console . log () } //Metodo Array - Gli array sono passati per riferimento const arrayPersona = [ \"simone\" , //0 24 , //1 \"laurea\" , //2 1994 //3 ]; aggiornaEta2 ( arrayPersona , annoAttuale ); console . log ( arrayPersona [ 1 ]); //26 function aggiornaEta2 ( array , anno ){ array [ 1 ] = anno - array [ 3 ]; console . log ( array ); } Funzioni - Ritorno di un oggetto o un array Una funzione in Javascript pu\u00f2 avere come tipo di ritorno anche un oggetto o un array //Metodo Oggetto let objRisultatoEqIIgrado = objCalcolaRisultatoEqIIgrado ( 1 , 5 , - 1 ); console . log ( \"Risultato 1: \" + objRisultatoEqIIgrado . x1 ); console . log ( \"Risultato 2: \" + objRisultatoEqIIgrado . x2 ); function objCalcolaRisultatoEqIIgrado ( a , b , c ){ let delta = Math . sqrt ( b * b - 4 * a * c ); let ris1 = ( - b + delta ) / 2 ; let ris2 = ( - b - delta ) / 2 ; //Ritorno un oggetto return { x1 : ris1 , x2 : ris2 }; } //Metodo Array let arrayRisultatoEqIIgrado = arrayCalcolaRisultatoEqIIgrado ( 1 , 6 , - 1 ); console . log ( \"Risultato 1: \" + arrayRisultatoEqIIgrado [ 0 ]); console . log ( \"Risultato 2: \" + arrayRisultatoEqIIgrado [ 1 ]); function arrayCalcolaRisultatoEqIIgrado ( a , b , c ){ let delta = Math . sqrt ( b * b - 4 * a * c ); let ris1 = ( - b + delta ) / 2 ; let ris2 = ( - b - delta ) / 2 ; //Ritorno un oggetto return [ ris1 , ris2 ]; } Approfondimento funzioni - Oggetto Arguments Facendo uso di arguments \u00e8 possibile passare un numero indefinito di parametri. arguments raggruppa gli argomenti in un oggetto collezione di elementi. L'oggetto arguments permette di utilizzare la propriet\u00e0 lenght , l'indicizzazione [ ] ma non \u00e8 un array e quindi non si possono applicare i metodi applicabili agli array. arguments non si specifica nella definizione di una funzione tra i parametri poich\u00e8 \u00e8 un oggetto riconosciuto nel contesto stesso della funzione //arguments \u00e8 un oggetto riconosciuto all'interno della definizione della funzione function somma (){ let ris = 0 ; for ( let index = 0 ; index < arguments . length ; index ++ ) { ris += arguments [ index ]; } console . log ( arguments ); return ris ; } console . log ( somma ( 1 , 4 )); //5 console . log ( somma ( 1 , 4 , 6 , 0 , 3 , 1 , 2 )); //17 console . log ( somma ()); //0 Approfondimento funzioni - Parametri Rest La sintassi dei rest parameter permette di rappresentare un indefinito numero di argomenti come un array. A differenza dell'oggetto arguments in questo caso gli argomenti \"restanti\" sono rappresentati e raggruppati in un array ed \u00e8 possibile quindi utilizzare ogni metodo applicabile agli arrays. Si specificano i rest parameter all'interno della definizione di una funzione come ultimo parametro attraverso l'operatore rest ... ... : Operatore rest MDN - Rest parameters function calcola ( a , b , ... altriParam ){ ris = a + b ; //Il forEach(param1, param2) ha due parametri. Il primo \u00e8 una funzione che a sua volta accetta i parametri //opzionali (valore, indice, array) in questo caso dell'array altriParam passato come argomento a calcola. //this in questo caso rappresenta il fatto che voglio ritornare il valore all'interno del contesto di ris altriParam . forEach ( controllaEsomma , this ); return ris ; } function controllaEsomma ( valore , indice , array ){ if ( valore < 100 ) { //this riesce a raggiungere il contesto di \"ris\" della funzione calcola this . ris += valore ; } } console . log ( calcola ( 1 , 4 )); //5 console . log ( calcola ( 1 , 4 , 6 , 100 , 3 , 1 , 2 )); //17 console . log ( calcola ( 1 , 2 )); //0 Approfondimento Introduzione forEach / this forEach() \u00e8 un metodo applicabile agli array. E' una struttura iterativa cheesegue una funzione fornita una volta per ogni elemento dell'array a cui si applica il metodo. La funzione riceve dall'array tre parametri opzionali in ordine: value, index, array ovvero il valore dell'elemento dell'array a cui si applica il metodo, l'indice dell'elemento e l'array stesso. myArray . forEach ( myFunc ); function myFunc ( value , index , array ){ //code; } Nell'esempio di sopra: altriParam . forEach ( controllaEsomma , this ); Esegue la funzione controllaEsomma per ogni elemento dell'array. function controllaEsomma ( valore , indice , array ){ if ( valore < 100 ) { //this riesce a raggiungere il contesto di \"ris\" della funzione calcola this . ris += valore ; } } L'identificatore this , come il forEach stesso verranno approfonditi pi\u00f9 avanti. Per adesso ci basta sapere che this consente di raggiungere un oggetto utilizzato come callback (valore di ritorno). Osservazione: Se dichiariamo la variabile \"ris\" con let o var ritorna NaN . Approfondimento: MDN - var Lezione 21 Approfondimento Funzioni ricorsive Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. La funzioni ricorsive sono funzioni che richiamano se stesse all'interno del corpo. Questa tecnica fornisce un modo per scomporre problemi complicati in problemi semplici che sono pi\u00f9 facili da risolvere. Con le funzioni ricorsive si costruiscono algoritmi potenti. function x ( contatore ){ if ( contatore > 5 ){ return ; //Terminatore, } else { x ( ++ contatore ); //passo ricorsivo console . log ( contatore ); } } x ( 0 ); /* 6 5 4 3 2 1 */ Nell'esempio di sopra al primo passo ricorsivo x(++contatore) non eseguo console.log(contatore); che rimane pending nello stack. Cos\u00ec anche per gli altri passi successivi finch\u00e8 la condizione dell' if diventa true e l'ultima funzione ritorna. A questo punto lo statemeant console.log(contatore); rimasto pending viene eseguito e cos\u00ec via i precedenti. fino al ritorno dell'intera funzione Osservazioni: - Se nulla limita il meccanismo di chiamate a funzione con una serie di ritorni a cascata, lo stack si riempie e il browser va in crash con l'errore Maximum call stack size exceeded . - E' un meccanismo che rallenta parecchio l'applicazione quando il passo ricorsivo diverge. Approfondimento Function expression Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. La parola chiave function pu\u00f2 essere utilizzata per definire una funzione all'interno di un'espressione. var media = function ( a , b ){ //funzione anonima return ( a + b ) / 2 ; }; console . log ( media ( 4 , 9 )); var fattoriale = function fatt ( n ){ if ( n === 0 ){ return 1 ; } else { return n * ( fatt ( n - 1 )); } } console . log ( fattoriale ( 4 )); //24 Approfondimento Hoisting Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. Per comprendere l'hoisting \u00e8 necessario introdurre il meccanismo di parsing dell'interprete javascript. Prima di eseguire lo script, il parser dell'interprete Javascript scansiona tutto il codice per risolvere i valori da assegnare agli identificatori ed esegue molte altre operazioni function esterna () { function interna (){ return \"interna1\" ; } return interna (); function interna (){ return \"interna2\" ; } } console . log ( esterna () ); //interna2 Nell'esempio di sopra, poich\u00e8 la funzione interna() \u00e8 stata definita due volte, il parser sovraiscrive la prima definizione con la seconda! Tutto cambia se utilizzo le function expression function esterna () { var interna = function (){ return \"interna1\" ; } return interna (); var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //interna1 In questo caso poich\u00e8 non sono definizioni di funzione ma variabili la seconda variabile non viene valutata poich\u00e8 \u00e8 codice irraggiungibile. In questo caso si segue un andamento lineare del codice anche detto paradigma imperativo. Nel caso invece di chiamate a funzione il paradigma si dice funzionale. Altro controesempio: function esterna () { return interna (); var interna = function (){ return \"interna1\" ; } var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //ERROR. interna() non \u00e8 riconosciuto perch\u00e8 non \u00e8 stato dichiarato l'identificaore Con il paradigma funzionale invece non ci sono problemi: function esterna () { return interna (); function interna (){ return \"interna1\" ; } function interna (){ return \"interna2\" ; } } console . log ( esterna () ); //interna2 Approfondimento Differenza tra undefined e not defined Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. Anche se sembra un uso improprio del vocabolario, c'\u00e8 una differenza tra una variabile undefined e un errore dell'interprete dovuto a una variabile not defined . undefined : L'interprete trova la definizione della variabile ma non trova nessun valore associato a tale variabile. Non genera un errore not defined : l'interprete non trova da nessuna parte nel codice l'identificatore. Genera un errore function esterna () { return interna ; var interna = function (){ return \"interna1\" ; } var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //undefined, l'interprete sa cos'\u00e8 ma non \u00e8 stata definita a quel punto del codice function esterna () { return y ; var interna = function (){ return \"interna1\" ; } var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //ERROR. y is not defined. L'interprete non sa cosa sia y, ben diverso Approfondimento IIFI Immediatly invoked function expression Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. Sebbene introdurre funzioni aiuti a scrivere moduli indipendenti si rischia di inondare il contesto globale di nomi di funzioni. Il pattern IIFE (Immediately Invoked Function Expression) aiuta in tal senso. Le IIFI functions sono funzioni che vengono eseguite al momento della definizione. Non necessitano quindi della chiamata. ( function name (){ //code })(); Esempio: //Questa \u00e8 una funzione standard, NON IIFI. Viene eseguita solo alla chiamata function stampaLogo (){ console . log ( 'myLogo' ); } stampaLogo (); //in questa linea eseguo la funzione /* */ //Questa \u00e8 una funzione IIFI. Viene eseguita al momento. //(function name(){})(); ( function stampaLogo (){ console . log ( 'myLogo' ); })(); //eseguo qui la funzione IIFI Esempio 2: ( //operatore di raggruppamento: cio' che e' all'interno e' una espressione function iife () { var a = 222 ; console . log ( \"parto da sola!! \" + a ); } ) //fine espressione (); //operatore di chiamata di funzione //forma alternativa ( function iife () { var a = 444 ; console . log ( \"parto da sola!! \" + a ); } () ); iife (); //errore! iife come identificatore non esiste nel contesto globale Paradigma di programmazione Javascript Javascript \u00e8 un linguaggio multiparadigma, consente quindi il paradigma imperativo, quello funzionale e il paradigma object oriented in un unico linguaggio. Non esiste il miglior paradigma in assoluto ma esista il paradigma migliore per la situazione migliore. Lezione 22 Scope Lo scope \u00e8 l'attuale contesto di esecuzione. Il contesto in cui i valori e le espressioni sono \"visibili\" o possono essere referenziati. Se una variabile o un'altra espressione non \u00e8 \"nell'ambito corrente\", non \u00e8 disponibile per l'uso. Gli ambiti possono anche essere stratificati in una gerarchia, in modo che gli ambiti figlio abbiano accesso agli ambiti padre, ma non viceversa. Una funzione funge da chiusura, closure in JavaScript e quindi crea uno scope, in modo che (ad esempio) non sia possibile accedere a una variabile definita esclusivamente all'interno della funzione dall'esterno della funzione o da altre funzioni. MDN - Scope Esempio: /* Scope */ /* Gloabl variable -> Riconosciuta da tutto il programma */ let var1 = 1 ; function function1 (){ /* Local variable -> ricnosciuta solo nel blocco di codice tra le parentesi {} in cui \u00e8 stata dichiarata*/ let var2 = 10 ; //qui nasce var2 console . log ( var2 ); } //qui muore var2 function1 (); console . log ( var1 ); //var1 is defined, var1 is global console . log ( var2 ); //var2 is not defined /* Console: --------------- 10 1 Uncaught ReferenceError: var2 is not defined */ Vediamo un esempio molto pi\u00f9 complesso: /* Scope */ /* Gloabl variable -> Riconosciuta da tutto il programma */ let var1 = 1 ; function function1 (){ /* Local variable -> ricnosciuta solo nel blocco di codice tra le parentesi {} in cui \u00e8 stata dichiarata*/ let var2 = 10 ; //qui nasce var2 console . log ( \"var2 function1 : \" + var2 ); } //qui muore var2 function function2 (){ /* Local variable -> ricnosciuta solo nel blocco di codice tra le parentesi {} in cui \u00e8 stata dichiarata*/ let var2 = 20 ; //qui nasce var2 ma \u00e8 diversa rispetto a quella di prima, \u00e8 una nuova var2 console . log ( \"var2 function2 : \" + var2 ); console . log ( \"var1: \" + var1 ); //\u00e8 riconosciuta anche var1 perch\u00e8 \u00e8 stata dichiarata in un blocco pi\u00f9 esterno for ( let var3 = 0 ; var3 < 1 ; var3 ++ ) { console . log ( \"var3: \" + var3 ); console . log ( \"var2 function2: \" + var2 ); //\u00e8 riconosciuta anche var2 perch\u00e8 \u00e8 stata dichiarata in un blocco pi\u00f9 esterno console . log ( \"var1: \" + var1 ); //\u00e8 riconosciuta anche var1 perch\u00e8 \u00e8 stata dichiarata in un blocco pi\u00f9 esterno } //qui muore var3 } //qui muore var2 function1 (); function2 (); console . log ( \"var1: \" + var1 ); //OK console . log ( \"var3: \" + var3 ); //non riconosciuta console . log ( \"var2: \" + var2 ); //non riconosciuta /* Console: --------------- var2 function1 : 10 var2 function2 : 20 var1: 1 var3: 0 var2 function2: 20 var1: 1 var1: 1 Uncaught ReferenceError: var3 is not defined */ Visibilit\u00e0 di variabili Lo 'scope' di una variabile (visibilita' di una variabile) e' la sezione di codice in cui essa e' visibile ed in Javascript e' regolato con l'uso delle funzioni. NB: non confondere lo scope con il context (contesto) che indica invece l'oggetto per il quale una funzione viene eseguita ( this ). Per una funzione visibile a livello globale cioe' non contenuta in alcun oggetto questo in realta' esiste e coincide con 'window'. La distinzione e' tra visibilita' globale, locale e di blocco. Visibilit\u00e0 Globale (global scope) E' quella che ha come riferimento l'intero codice. Sono le variabili/oggetti dichiarate all'esterno di qualunque funzione usate in una funzione senza var/let . In generale la visibilita' globale e' da evitare Esempio: var x = 100 ; function f_bad () { //modifica la variabile esterna potenzialmente all'insaputa di chi la chiama x = 2 ; } console . log ( \"Prima di invocare f_bad() \" + x ); //x = 100 f_bad (); //modifica x, da evitare console . log ( \"Dopo f_bad() \" + x ); //x = 2 L'obiettivo delle funzioni \u00e8 proprio racchiudere il codice in blocchi riutilizzabili. Se modificano/dipendono da variabili esterne/globali questo concetto viene a meno. Per risolvere questa cosa: x = 100 ; //versione corretta di f function f_good () { //dichiarazione di una variabile LOCALE (x) distinta da quella globale var x = 2 ; var y = 200 ; } console . log ( \"Prima di invocare f_good() \" + x ); // x = 100 f_good (); console . log ( \"Dopo f_good() \" + x ); // x = 100, Ok console . log ( y ); //errore: y not defined; visibile solo a f_good in esecuzione Scope Chaining Una varibaile \u00e8 visibile ai blocchi interni (figli) ma non ai contenitori (padre). I blocchi interni (figli) ereditano tutto dai loro contenitori (padri) ma i padri non conoscono i segreti dei figli ovvero non possono conoscere le variabili/oggetti dichiarati dei figli. var x = 2 ; //FUNZIONI ANNIDATE (nested) function esterna () { var x = 999 ; // dichiaro una nuova \"x\" diversa da quella globale interna (); //Accedo alla \"x\" esterna tramite il contest. <window> \u00e8 il contesto esterno, \u00e8 il contenitore di tutto window . x = 18 ; //interna accede anche allo scope di esterna ma non il viceversa function interna () { //code } } Visibilit\u00e0 a livello di blocco (block scope) La visibilit\u00e0 \u00e8 racchiusa da i delimitatori { } Per mantenere la visibilit\u00e0 a livello di blocco \u00e8 necesario usare let , var mantiene soltanto lo scope locale a livello di funzione ma non di blocco { } let : Mantiene lo scope delle variabili sia a livello locale (all'interno di una funzione) sia livello di blocco ovvero tra i delimitatori { } var : Mantiene lo scope delle variabili solo a livello locale (all'interno di una funzione) ma non a livello di blocco ovvero tra i delimitatori { } //\"var\" non mantiene la visibilit\u00e0 di blocco var x = 5 ; if ( Math . random () > 0.5 ) { var x = 100 ; } else { var x = 200 } console . log ( \"La x ora vale: \" + x ); //100 o 200!! ATTENZIONE, //\"let\" mantiene la visibilit\u00e0 di blocco x = 5 ; if ( Math . random () > 0.5 ) { let x = 100 ; } else { let x = 200 } console . log ( \"La x globale vale ancora: \" + x ); //5, ok Approfondimento - Closure di una funzione Si ricordi: Una funzione funge da chiusura, closure in JavaScript e quindi crea uno scope, in modo che (ad esempio) non sia possibile accedere a una variabile definita esclusivamente all'interno della funzione dall'esterno della funzione o da altre funzioni Applichiamo questo concetto ad un esempio pratico. La funzione: setInterval( param1, param2 ) : param1 \u00e8 una funzione, param2 rappresenta un intervallo di tempo espresso in ms . La funzione setInterval() chiama la funzione param1 ogni param2 ms . function chiamaMessaggio ( messaggio ){ setInterval ( function (){ writeln ( messaggio );}, 1000 ); //uso una funzione anonima } chiamaMessaggio ( \"il sistema \u00e8 in fase di spegnimento..\" ); Ho utilizzato il concetto di closure (e quindi dell'ereditariet\u00e0 delle variabili/oggetti padre->figlio) di una funzione per passare un parametro alla funzione (parametro) di setInterval() Esempio 2: function chiamaMessaggio2 ( ilMessaggio , volte ) { let timer = setInterval ( function () { writeln ( ilMessaggio + \" \" + volte + \" secondi...\" ); -- volte ; if ( volte < 1 ) { clearInterval ( timer ); writeln ( \"Boom!\" );} } , 1000 ) } chiamaMessaggio2 ( \"Sistem Shutdown in \" , 5 ); Approfondimento: Le funzioni che ricevono come parametri altre funzioni o ritornano altre funzioni prendono il nome di High orderd function Lezione 23 Array Gli array sono aggragatori di dati utilizzati per raggruppare elementi appartenenti alla stessa famiglia ed accedere ad uno di essi in lettura o scrittura in modo semplice. Ogni elemento dell'array \u00e8 raggiungibile tramite un numero detto indice . L'indice indica la posizione dell'elemento nell'array. La propriet\u00e0 lenght restituisce il numero degli elementi in un array // Dichiarazione e inizializzazione // 0 1 2 const elementi = [ \"elemento1\" , \"elemento2\" , \"element03\" ]; console . log ( elementi ); //(3) [\"elemento1\", \"elemento2\", \"element03\"] console . log ( elementi [ 1 ]); //elemento2 console . log ( elementi . lenght ); //3 elementi [ 2 ] = \"Silicio\" ; console . log ( elementi ); //(3) [\"elemento1\", \"elemento2\", \"Silicio\"] // Solo dichiarazione const mammiferi = []; Altre sintassi (meno utilizzate ma valide): //Array vuoto let vuoto1 = new Array (); let vuoto2 = Array (); let vuoto3 = []; //da preferire let v1 = Array ( 100 ); //100 elementi pre allocati let v2 = Array ( '100' ); //1 elemento stringa, crea confusione let v3 = new Array ( 31 , 8 , 2017 ); //meno consigliata let arr3 = [ 31 , 8 , 2017 ]; //sintassa pi\u00f9 chiara Alcuni esempi: const mammiferi = [ \"tigre\" , \"scoiattolo\" , \"orso\" ]; mammiferi [ mammiferi . length ] = \"volpe\" ; // === mammiferi[3] = \"volpe\", aggiunge in coda un elemento console . log ( mammiferi ); //(4) [\"tigre\", \"scoiattolo\", \"orso\", \"volpe\"] mammiferi [ 10 ] = \"cinghiale\" ; //aggiunge \"cinghiale\" al decimo elemento e riempie con elementi vuoti i restanti console . log ( mammiferi , mammiferi . lenght ); //(11) [\"tigre\", \"scoiattolo\", \"orso\", \"volpe\", empty \u00d7 6, \"cinghiale\"] 11 mammiferi . lenght = 20 ; console . log ( mammiferi , mammiferi . lenght ); //(11) [\"tigre\", \"scoiattolo\", \"orso\", \"volpe\", empty \u00d7 6, \"cinghiale\", lenght: 20] 20 //Iterazione sugli elementi dell'array for ( let i = 0 ; i < mammiferi . length ; i ++ ){ if ( mammiferi [ i ] != undefined ){ console . log ( i + \": \" + mammiferi [ i ]); } else { console . log ( i + \": \" + \"non \u00e8 un mammifero\" ); } } /* 0: tigre 1: scoiattolo 2: orso 3: volpe 4: non \u00e8 un mammifero 5: non \u00e8 un mammifero 6: non \u00e8 un mammifero 7: non \u00e8 un mammifero 8: non \u00e8 un mammifero 9: non \u00e8 un mammifero 10: cinghiale */ Matrix Della famiglia degli array ci sono anche le matrici che non sono altro che array di array. const social = [ [ \"facebook\" , \"instagram\" ], [ \"whatsapp\" , \"telegram\" ], [ \"tiktok\" , \"snapchat\" ], ]; console . log ( social ); console . log ( social [ 1 ][ 1 ]); console . log ( social [ 2 ][ 0 ]); /* Console: --------------- Esercizio 2 (3) [Array(2), Array(2), Array(2)] 0: (2) [\"facebook\", \"instagram\"] 1: (2) [\"whatsapp\", \"telegram\"] 2: (2) [\"tiktok\", \"snapchat\"] telegram tiktok */ Lezione 24 Array - Metodi base Qualche metodo base applicabile agli array in javascript: push(elem) : aggiunge l'elemento elem in coda all'array. Restituisce il numero di elementi dell'array. pop() : rimuove l'ultimo elemento dall'array. Restituisce l'elemento che ha tolto. array.unshift(elem) : aggiunge l'elemento elem in testa all'array. Restituisce il numero di elementi dell'array array.shift() : rimuove il primo elemento dall'array. Restituisce l'elemento che ha tolto indexOf(elem) : Restituisce l'indice dell' elemento elem nell'array. Se non lo trova restituisce -1 slice(startIndex, endIndex); : Restituisce un array derivato dall'array a cui si applica il metodo filtrando gli elementi nel range ( startIndex incluso, endIndex escluso). .concat(array2); : Restituisce un array che \u00e8 la concatenazione dell'array a cui si applica il metodo e array2 splice(startIndex, nToDelete, elem1, elem2, ...); : Restituisce un array derivato dall'array a cui si applica il metodo aggiungendo elem1 , elem2 , .. a partire da startIndex ed eliminando i primi nToDelete elementi a partire da startIndex . Se non specifico i parametri elem1 , elem2 , .. semplicemente elimina gli elementi nToDelete a partire da startIndex . fill(value, indexStart, indexEnd) : Inserisce value all'interno dell'array tra i parametri opzionali indexStart e indexEnd . Omettendo indexStart e indexEnd riempie tuttto l'array con value join() : Trasforma un array in stringa reverse() : Inverte l'ordine degli elementi sort() : Ordinamento lessicografico degli elementi. Ogni elemento viene quindi trattato come una stringa e poi ordinato secondo la precedenza definita dalla rappresentazione in UTF-8 (ASCII) //push const colori = [ \"rosso\" , \"verde\" , \"giallo\" ]; console . log ( colori ); //(3) [\"rosso\", \"verde\", \"giallo\"] let newArrayLenght = colori . push ( \"blu\" ); //push ritorna il numero degli elementi dell'array console . log ( colori , newArrayLenght ); //(4) [\"rosso\", \"verde\", \"giallo\", \"blu\"] 4 //pop console . log ( colori ); //(4) [\"rosso\", \"verde\", \"giallo\", \"blu\"] let lastElement = colori . pop (); //pop ritorna l'elemento che ha tolto console . log ( colori , lastElement ); //(3) [\"rosso\", \"verde\", \"giallo\"] \"blu\" //unshift console . log ( colori ); //[\"rosso\", \"verde\", \"giallo\"] newArrayLenght = colori . unshift ( \"gialletto\" ); //unshift ritorna il numero degli elementi dell'array console . log ( colori , newArrayLenght ); //(4) [\"gialletto\", \"rosso\", \"verde\", \"giallo\"] 4 //shift console . log ( colori ); //(4) [\"gialletto\", \"rosso\", \"verde\", \"giallo\"] let firstElement = colori . shift (); //shift ritorna l'elemento che ha tolto console . log ( colori , firstElement ); //(3) [\"rosso\", \"verde\", \"giallo\"] \"gialletto\" //indexOf console . log ( colori ); //(3) [\"rosso\", \"verde\", \"giallo\"] let indexElem = colori . indexOf ( \"verde\" ); console . log ( indexElem ); //1 //slice // 0 1 2 3 4 const social = [ \"facebook\" , \"instagram\" , \"whatsapp\" , \"telegram\" , \"snapchat\" ]; const messaggi = social . slice ( 2 , 4 ); console . log ( messaggi ); //(2) [\"whatsapp\", \"telegram\"] //concat const numeriBassi = [ 1 , 2 , 3 ]; const numeriAlti = [ 100 , 200 , 300 ]; const tuttiNumeri = numeriBassi . concat ( numeriAlti ); console . log ( tuttiNumeri ); //(6) [1, 2, 3, 100, 200, 300] //splice //poich\u00e8 il secondo parametro \u00e8 0, aggiunger\u00e0 a partire dall'indice 3 i parametri 50, 60, 70 tuttiNumeri . splice ( 3 , 0 , 50 , 60 , 70 ); //poich\u00e8 il secondo parametro \u00e8 0 console . log ( tuttiNumeri ); //(9) [1, 2, 3, 50, 60, 70, 100, 200, 300] //poich\u00e8 il secondo parametro \u00e8 3, sostituir\u00e0 50, 60, 70 con -50, -60, -70 tuttiNumeri . splice ( 3 , 3 , - 50 , - 60 , - 70 ); console . log ( tuttiNumeri ); //(9) [1, 2, 3, -50, -60, -70, 100, 200, 300] //fill() const myArr = [ 1 , 2 , 4 , 1 , 5 , 5 , 7 ]; myArr . fill ( 0 , 1 , 3 ); console . log ( myArr ); //(7) [1, 0, 0, 1, 5, 5, 7] //join() const paroleTesto = [ \"ciao\" , \" \" , \"a\" , \" \" , \"tutti\" ]; console . log ( paroleTesto ); //(5) [\"ciao\", \" \", \"a\", \" \", \"tutti\"] conole . log ( parole . Testo . join ()); // ciao, ,a, ,tutti //reverse() const numeriDispari = [ 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 ]; console . log ( numeriDispari ); //(10 [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] console . log ( numeriDispari . reverse ()); //(10) [19, 17, 15, 13, 11, 9, 7, 5, 3, 1] //sort() - ATTENZIONE console . log ( numeriDispari . sort ()); //(10) [1, 11, 13, 15, 17, 19, 3, 5, 7, 9] Lezione 25 Arrays - forEach() forEach() \u00e8 un metodo applicabile agli array utilizzato per l'iterazione. forEach ( function ( value , index , array ){ /*code*/ }); Riceve come parametro una funzione detta anonima poich\u00e8 non ha un nome. La funzione riceve tre parametri opzionali, in ordine value , index , array che, dell'array a cui \u00e8 applicato il metodo, rappresentano rispettivamente l'elemento, l'indice e l'array stesso. Viene invocata la funzione anonima per ogni elemento (forEach) presente nell'array. const frutta = [ \"mela\" , \"pera\" , \"banana\" ]; stampaArray ( frutta ); function stampaArray ( arr ) { //i parametri della funzione anonima del forEach sono opzionali e, essendo parametri posso //dare un nome simbolico qualsiasi arr . forEach ( function ( elemento , indice , a ) { console . log ( indice + \": \" + a [ indice ] ); } ); } /* 0: mela 1: pera 2: banana */ Arrays - map() map() \u00e8 un metodo applicabile agli array utilizzato per l'iterazione. map ( function ( value , index , array ){ /*code*/ }); Itera ogni elemento dell'array e ritorna un array. E' utile quindi all'elaborazione e costruzione di un nuovo array a partire da quello a cui si applica il metodo. Riceve come parametro una funzione detta anonima poich\u00e8 non ha un nome. La funzione riceve tre parametri opzionali, in ordine value , index , array che, dell'array a cui \u00e8 applicato il metodo, rappresentano rispettivamente l'elemento, l'indice e l'array stesso. Viene invocata la funzione anonima per ogni elemento (forEach) presente nell'array. const fruits = [ 'mela' , 'pera' , 'banana' ]; //In questo caso newFruits sar\u00e0 identico a fruits. Ho effettuato una copia const newFruits = fruits . map ( function ( value , index ){ return value ; }) console . log ( newFruits ); //(3) [\"mela\", \"pera\", \"banana\"] //In questo caso newFruits2 sar\u00e0 un array contenente 0, 1, 2 poich\u00e8 ritorna l'indice const newFruits2 = fruits . map ( function ( value , index ){ return index ; }) console . log ( newFruits2 ); //3) [0, 1, 2] Funzioni freccia (lambda) Oltre alla sintassi espressa tramite funzione anonima esiste anche una sintassi diversa espressa tramite l'operatore freccia => . Ogni funzione anonima pu\u00f2 essere espressa tramite l'operatore freccia, questo tipo di funzione prende il nome di funzione lambda . ( param1 , param2 , ..) => { /*code*/ }; //function(param1, param2, ..{/*code*/} //Esempi con forEach() e map() map ( ( value , index , array ) => { /*code*/ } ); forEach ( ( value , index , array ) => { /*code*/ }); Nota: - I parametri vanno sempre espressi tra parentesi. Se si ha necessit\u00e0 solo del primo parametro le parentesi possono essere omesse. - In generale il corpo della funzione lambda va tra le parentesi graffe { } . Se il corpo ha un'istruzione inline, le parentesi graffe possono essere omesse. Esempio interessante: //casuali \u00e8 un array di 30 numeri inter casuali const numeriCasuali = []; for ( let i = 0 ; i < 10 ; i ++ ) { numeriCasuali . push ( Math . floor ( Math . random () * 100 ) ) ;} console . log ( numeriCasuali ); //32, 54, 33, 91, 4, 25, 46, 37, 73, 2] //calcola il resto della divisione per 7 dei numeri casuali //e crea con questi un nuovo array const isPari = numeriCasuali . map ( ( elemento , indice , a ) => Boolean ( ! ( elemento % 2 )) ); console . log ( isPari ); //[true, true, false, false, true, false, true, false, false, true] Array - Metodi avanzati filter( (value,index,array) => {/*CONDITION*/} ); : Ritorna un array risultato del filtraggio gli elementi dell'array a cui si applica il metodo che restituiscono true nella CONDITION some ( (value,index,array) => {/*CONDITION*/} ); : Ritorna un booleano se c'\u00e8 almeno un elemento nell'array che restituisce true alla CONDITION every ( (value,index,array) => {/*CONDITION*/} ); Ritorna true (ritorna n boolean) se c'\u00e8 almeno un elemento nell'array che restituisce true alla CONDITION reduce ((accumulatore, value,index,array) => {/*CONDITION*/}, startValueAccumulatore); : Ritorna il numero di elementi che soddisfano la CONDITION . Ha due parametri: il primo \u00e8 una funzione freccia che riceve a sua volta 4 parametri in ordine: accumulatore , value , index , array , il secondo, startValueAccumulatore \u00e8 il valore di partenza dell'accumulatore, opzionale. Se non si specifica il valore di partenza dell'accumulatore startValueAccumulatore viene assegnato come valore il primo elemento. let casuali = []; for ( let i = 0 ; i < 20 ; i ++ ) { casuali . push ( Math . floor ( Math . random () * 100 ) ) ;} let diversiDaZero = casuali . filter ( elemento => elemento !== 0 ); console . log ( diversiDaZero ); if ( diversiDaZero . some ( elemento => elemento > 4 ) ) { console . log ( \"Trovato almento un resto maggiore di zero\" );} let quanti = diversiDaZero . reduce ( ( conta , elemento ) => elemento > 4 ? conta + 1 : conta , 0 ); console . log ( quanti ); //19 let totale = diversiDaZero . reduce ( ( somma , elemento ) => somma + elemento ); console . log ( totale ); //1057 /* [37, 67, 31, 88, 55, 45, 26, 21, 32, 2, 20, 62, 79, 48, 85, 53, 33, 97, 92, 84] Trovato almento un resto maggiore di zero 19 1057 */ Lezione 26 Introduzione agli Object JavaScript \u00e8 progettato su un semplice paradigma basato su oggetti. Un oggetto \u00e8 una raccolta di propriet\u00e0 e una propriet\u00e0 \u00e8 un'associazione tra un nome (o chiave) e un valore. Il valore di una propriet\u00e0 pu\u00f2 essere una funzione, nel qual caso la propriet\u00e0 \u00e8 nota come metodo. Oltre agli oggetti predefiniti nel browser, \u00e8 possibile definire i propri oggetti. Questo capitolo descrive come utilizzare oggetti, propriet\u00e0, funzioni e metodi e come creare i propri oggetti. Gli oggetti in JavaScript, proprio come in molti altri linguaggi di programmazione, possono essere paragonati agli oggetti nella vita reale. Il concetto di oggetti in JavaScript pu\u00f2 essere compreso con oggetti tangibili della vita reale. In JavaScript, un oggetto \u00e8 un'entit\u00e0 autonoma, con propriet\u00e0 e tipo. Confrontalo con una tazza, per esempio. Una tazza \u00e8 un oggetto, con propriet\u00e0. Una tazza ha un colore, un disegno, un peso, un materiale di cui \u00e8 composta, ecc. Allo stesso modo, gli oggetti JavaScript possono avere propriet\u00e0 che definiscono le loro caratteristiche. Fonte: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#:~:text=JavaScript%20is%20designed%20on%20a,is%20known%20as%20a%20method. Sono un tipo di data-structure che rappresenta elementi tramite una coppia chiave/valore . Si accede al valore tramite il nome dell'oggetto e la sua property cio\u00e8 l'identificativo della chiave. const object = { key1 : value1 , key2 : value2 , key3 : value3 } SI chiama modello per prototipazione. Cio\u00e8 un modello creato che andremo ad arricchire e modificare nel corso del codice dinamicamente. Un oggetto in js \u00e8 una collezione di coppe identificatore: valore Esempio // Dichiarazione di un oggetto, prototipo const persona = { nome : \"Simone\" , eta : 23 , citta : \"Lucca\" } //accesso ai dati //Modo 1 persona . nome ; //Simone, (=== persona[\"nome\"]) //Modo2 persona [ \"citta\" ]; //Lucca, (=== persona.citta) //modifica di un valore dell'oggetto persona . nome = \"Luigi\" ; //Eliminazione della property <citta> dall'oggetto delete persona . citta ; console . log ( persona ); /* persona = { nome: \"Luigi\", eta: 23 } */ La creazione/dichiarazione di un oggetto con propriet\u00e0 e metodi (vedremo pi\u00f9 avanti) viene anche detto prototipo. Il prototipo \u00e8 un modello base dell'oggetto che pu\u00f2 essere arricchito o modificato nel corso del programma dinamicamente Posso creare un oggetto inizialmente vuoto e aggiungere gli elementi successivamente //Dichiaro un oggetto vuoto, modo 1 - preferibile var persona = {}; //Dichiaro un oggetto vuoto, modo 2 var computer = new Object ; //Inserisco elementi in un oggetto inizialmente vuoto persona . nome = \"billy\" ; persona . hobby = \"scacchi\" ; computer . ram = \"4Gb\" ; computer . rom = \"1Tb\" ; Di seguito mostro un esempio di un oggetto pi\u00f9 complicato. In realt\u00e0 \u00e8 un array di oggetti var post = [ // index: 0 { username : \"Billy\" , like : 4 , commenti : [ \"figo!\" , \"ottimo\" , \"bleah\" ] }, // index: 1 { username : \"thebest95\" , like : 0 , commenti : [ \"fighissimo\" , \"buono\" , \"buonissimo\" ] } ] console . log ( post ); /* Console: --------------- (2) [{\u2026}, {\u2026}] 0: commenti: (3) [\"figo!\", \"ottimo\", \"bleah\"] like: 4 username: \"Billy\" __proto__: Object 1: commenti: (3) [\"fighissimo\", \"buono\", \"buonissimo\"] like: 0 username: \"thebest95\" __proto__: Object length: 2 __proto__: Array(0) */ //Aggiungo un commento al primo elemento, cio\u00e8 all'oggetto cui corrisponde username \"Billy\" post [ 0 ]. commenti . push ( \"Fantastico!\" ); console . log ( post ); /* Console: --------------- (2) [{\u2026}, {\u2026}] 0: commenti: (3) [\"figo!\", \"ottimo\", \"bleah\",\"Fantastico!\"] like: 4 username: \"Billy\" __proto__: Object 1: commenti: (3) [\"fighissimo\", \"buono\", \"buonissimo\"] like: 0 username: \"thebest95\" __proto__: Object length: 2 __proto__: Array(0) */ Javascript OOP Javascript Lezione 01 Prerequisiti al corso Approccio al corso Strumenti Necessari Javascript, ECMA-Script? Lezione 02 Primo script all'interno del browser web Javascript all'interno del tag script Javascript all'interno di un file .js Primo script Javascript con node.js Console Alert & prompt Commenti Introduzione al DOM Introduzione alla libreria JQuery DOM ed Eventi Variabili Javascript Alcune regole per dichiarazione di variabili Tipi di dati in JS Tipi Primitivi Standard built-in Object Oggetti Fondamentali Approfondimento Null - undefined - NaN Stringhe Opearotri, Propriet\u00e0 e Metodi su stringhe Operatori Approfondimento Interpolazioni di stringhe Le stringhe sono immutabili Propriet\u00e0 Metodi Lezione 08 Conta parole Lezione 09 Approfondimento - Rappresentazione numerica in Javascript Numeri in Fixed Point Numeri in Floating Point Not A Number NaN Lezione 10 Approfondimento - Codifica caratteri Javascript ASCII Unicode Caratteri di Escape Lezione 11 Type conversion Conversione esplicita Conversione implicita Lezione 12 Operatori matematici Pre e post incremento/decremento Oggetto MATH Lezione 13 Equazione di II grado Lezione 14 Operator Precedence Associativit\u00e0 Operatori di assegnamento Lezione 15 Operatori Logici Logica Booleana Approfondimento - Short evalutation Truthy e falsy Lezione 16 Control Structure if/else Ternary Operator Switch statemeant Lezione 17 while loop do-while loop Lezione 18 for loop break & coninue Lezione 19 Function Parametri di default Ritorno di una funzione Lezione 20 Funzioni - Passaggio di oggetti e array Funzioni - Ritorno di un oggetto o un array Approfondimento funzioni - Oggetto Arguments Approfondimento funzioni - Parametri Rest Approfondimento Introduzione forEach / this Lezione 21 Approfondimento Funzioni ricorsive Approfondimento Function expression Approfondimento Hoisting Approfondimento Differenza tra undefined e not defined Approfondimento IIFI Immediatly invoked function expression Paradigma di programmazione Javascript Lezione 22 Scope Visibilit\u00e0 di variabili Visibilit\u00e0 Globale (global scope) Scope Chaining Visibilit\u00e0 a livello di blocco (block scope) Approfondimento - Closure di una funzione Lezione 23 Array Matrix Lezione 24 Array - Metodi base Lezione 25 Arrays - forEach() Arrays - map() Funzioni freccia (lambda) Array - Metodi avanzati Lezione 26 Introduzione agli Object Javascript OOP Lezione 01 OOP Object Oriented Programming Lezione 02 Introduzione ai Metodi Lezione 03 Costruttore Lezione 04 Ereditariet\u00e0 Lezione 05 Ereditariet\u00e0 - Shadowing Ereditariet\u00e0 classica Lezione 06 THIS Object - Variabili Statiche (condivise) Lezione 07 Introduzione For In Oggetto Date() Lezione 08 Classi Lezione 09 Classi assegnanili a variabili Get / Set try-catch Lezione 10 Derivazione di classi , ereditariet\u00e0 Lezione 11 Ereditariet\u00e0 classi Pt 2 Lezione 12 Approfondimento - Symbols Lezione 13 Approfondimento - Iterables/Iterator Costrutto for - of Lezione 14 Approfondimento - Funzioni Generatrici Lezione 15 Approfondimento - Esempio (For .. of) custom Lezione 16 Destructuring Lezione 17 Map Object Iterazione Map Object Lezione 18 Set Conversione di un Oggetto Map / Set in un Array Lezione 19 Dom Manipulation Lezione 20 DOM - Selettori Metodi di selezione di elementi html Lezione 21 Dom - Child e Parent DOM - Manipolazione dello stile degli elementi html Lezione 22 DOM - Manipolazione del testo degli elementi html DOM - Manipolazione degli attributi html Lezione 23 DOM - Creazione di Un elemento DOM - Rimpiazzo di un elemento DOM - ELiminazione di un elemento Lezione 24 DOM Events Metodo addEventListener Lezione 25 Prevent Default Che cos'\u00e8 esattamente l'oggetto ricevuto come unico parametro \"e\"? Lezione 26 Approfondimento type event Aprrofondimento eventi tastiera e input Lezione 27 Argomeni non trattati / da approfondire Fonti APPRONDIMENTI PT.1 Node.js Cos'\u00e8 node Install node Prima applicazione nodejs Non esiste l'oggetto window global objects Modules Creiamo un modulo Moduli built-in Modulo path Modulo OS Modulo File System Eventi Modulo HTTP Approfondimenti Passare dei parametri esterni My first IO sync My first IO async Filtered APPRONDIMENTI PT.2 Promise Un esempio semplice APPRONDIMENTI PT.3 Approfondimento Hoisting Approfondimento Oggetti Approfondimento Moduli Packages Approfondimento THIS Costruttori prefdefiniti javascript for .. of for .. in Memoization Come fare una copia profonda tra oggetti? propriet\u00e0 associate ai dati e proprier\u00e0 associate all'accesso get & set Arrow functions High Order Functions Array filter Array map Array reduce Gli array possiedono gi\u00e0 come metodi filer, map, reduce Qualche chicca sugli Array Arrray.of, Array.from concat, every, some find, filter, forEach, includes, indexOf push, pop, shift, unshift sort, splice, slice setTimeout(), setInterval() Eventi Asincroni Promise, resolve, reject, then Async, Await Promise.all() e Promise.race() Set e Map Map Lezione 01 OOP Object Oriented Programming Si ricordi la frase di apertura di questo corso: In informatica JavaScript \u00e8 un linguaggio di programmazione orientato agli oggetti e agli eventi... Ma che cos'\u00e8 un linguaggio di programmazione orientato agli oggetti? In informatica, la programmazione orientata agli oggetti (in inglese object-oriented programming, in acronimo OOP) \u00e8 un paradigma di programmazione che permette di definire oggetti software in grado di interagire gli uni con gli altri attraverso lo scambio di messaggi. Particolarmente adatta nei contesti in cui si possono definire delle relazioni di interdipendenza tra i concetti da modellare (contenimento, uso, specializzazione), un ambito che pi\u00f9 di altri riesce a sfruttare i vantaggi della programmazione ad oggetti \u00e8 quello delle interfacce grafiche. Tra gli altri vantaggi della programmazione orientata agli oggetti: essa fornisce un supporto naturale alla modellazione software degli oggetti del mondo reale o del modello astratto da riprodurre; permette una pi\u00f9 facile gestione e manutenzione di progetti di grandi dimensioni; l'organizzazione del codice sotto forma di classi favorisce la modularit\u00e0 e il riuso di codice. Fonte: https://it.wikipedia.org/wiki/Programmazione_orientata_agli_oggetti Ma non esiste solo il paradigma di programmazione orientato agli oggetti. Altri due paradigmi di programmazione sono il paradigma di programmazione procedurale e il paradigma di programmazione imperativa Programmazione Procedurale In informatica la programmazione procedurale \u00e8 un paradigma di programmazione che consiste nel creare dei blocchi di codice sorgente, identificati da un nome e racchiusi da dei delimitatori, che variano a seconda del linguaggio di programmazione; questi sono detti anche sottoprogrammi (in inglese subroutine), procedure o funzioni, a seconda del linguaggio e dei loro ruoli all'interno del linguaggio stesso. Il nome deriva dal linguaggio COBOL, che \u00e8 stato il primo ad utilizzare questo concetto. Questi blocchi possono essere dotati di parametri, cio\u00e8 variabili locali i cui valori vengono forniti o passati dall'esterno del blocco di codice ed eventualmente esportati; esistono due tipi di parametri: quelli di tipo valore e quelli di tipo variabile; nei primi viene passato un valore che, se modificato, non viene comunque salvato al termine del sottoprogramma; nel tipo variabile invece, viene comunicato l'indirizzo della cella di memoria (ad es.tramite un puntatore) al quale troviamo l'informazione, che pu\u00f2 quindi essere modificata effettivamente e permanentemente. All'interno di un sottoprogramma possono essere generalmente definite o dichiarate delle variabili locali, che vengono deallocate al termine del sottoprogramma stesso; il loro contenuto viene quindi perso se non salvato o trasmesso altrimenti. In Linguaggio C esiste solo la function, che pu\u00f2 o meno restituire valori; lo stesso dicasi per il Java ed il PHP; i blocchi sono racchiusi tra parentesi graffe. Questo tipo di paradigma \u00e8 tipico per la programmazione di sistemi embedded. Fonte: https://it.wikipedia.org/wiki/Programmazione_procedurale Programmazione imperativa In informatica, la programmazione imperativa \u00e8 un paradigma di programmazione secondo cui un programma viene inteso come un insieme di istruzioni (dette anche direttive o comandi), ciascuna delle quali pu\u00f2 essere pensata come un \"ordine\" che viene impartito alla macchina virtuale del linguaggio di programmazione utilizzato. Da un punto di vista sintattico, i costrutti di un linguaggio imperativo sono spesso identificati da verbi all'imperativo. L'approccio imperativo \u00e8 l'approccio dominante in programmazione. Nello studio dei linguaggi di programmazione, si definisce il concetto di paradigma di programmazione, ovvero un insieme di regole e strutture che definiscono un tipo di linguaggio basandosi esclusivamente sulle sue strutture, e quindi non sulle sue caratteristiche peculiari legate all'implementazione dello stesso (es. le parole chiave). Sono di tipo imperativo la grande maggioranza dei (sotto-)paradigmi di programmazione (per esempio la programmazione procedurale, la programmazione strutturata, la programmazione orientata agli oggetti e cos\u00ec via) e la grande maggioranza dei linguaggi (per esempio ALGOL, Ada, BASIC, Fortran, Pascal, PHP eccetera). Fonte: https://it.wikipedia.org/wiki/Programmazione_imperativa Javascript \u00e8 un linguaggio di programmazione che si presta molto bene a tutti e tre i paradigmi. Adesso approfondiremo il paradigma di programmazione orientato agli oggetti concludendo con la definizione di classe Lezione 02 Introduzione ai Metodi Si ricordi che con Javascript \u00e8 possibile definire delle funzioni assegnabili a variabili, \u00e8 quindi possibile definire delle funzioni assegnabili a una property. In questo caso si parla di metodi Metodo: Funzione applicabile a un oggetto. Non ha senso al di fuori del contesto dell'oggetto in cui \u00e8 stata definita var persona = { nome : \"Simone\" , dataDiNascita : 1995 , sesso : \"maschio\" , isMarried : false , famiglia : [ \"Anotinio\" , \"Giovanni\" , \"Alice\" ], calcolaEta : function (){ return 2020 - this . dataDiNascita ; } } console . log ( persona . calcolaEta ()); //25 Nella definizione di un metodo (una funzione all'interno di un oggetto), this rappresenta l'oggetto stesso. E' quindi necessario per poter prelevare ed elaborare le property interne dell'oggetto che ricordiamo sono accessibili solo attraverso il nome dell'oggetto. Nella definizione di un metodo non posso accedere direttamente alle property senza invocare this l'interprete solleverebbere un'eccezione poich\u00e8 non riconoscerebbe l'identificatore invocato. var persona = { nome : \"Simone\" , dataDiNascita : 1995 , sesso : \"maschio\" , isMarried : false , famiglia : [ \"Anotinio\" , \"Giovanni\" , \"Alice\" ], calcolaEta : function (){ return 2020 - dataDiNascita ; } } console . log ( persona . calcolaEta ()); //dataDiNascita is not defined Nota: la keyword this ha anche altri significati che dipendono dal contesto in cui \u00e8 chiamato. Posso invocare un metodo anche per definire una nuova propriet\u00e0 dell'oggetto: const persona = { nome : \"Simone\" , dataDiNascita : 1995 , sesso : \"maschio\" , isMarried : false , famiglia : [ \"Anotinio\" , \"Giovanni\" , \"Alice\" ], calcolaEta : function (){ return 2020 - this . dataDiNascita ; } } //Verr\u00e0 aggiunta la property \"eta\" all'oggetto persona . eta = persona . calcolaEta (); console . log ( persona ); /* Console: --------------- {nome: \"Simone\", dataDiNascita: 1995, sesso: \"maschio\", isMarried: false, famiglia: Array(3), \u2026} calcolaEta: \u0192 () dataDiNascita: 1995 eta: 25 famiglia: (3) [\"Anotinio\", \"Giovanni\", \"Alice\"] isMarried: false nome: \"Simone\" sesso: \"maschio\" __proto__: Object */ Vediamo un altro esempio: let libro = { titolo : \"Fondazione\" , pagine : 571 } let autorePreferito = { cognome : \"Asimov\" , nome : \"Isaac\" , // E' possibile definire una property tra gli apici doppi \"nameProperty\" //in modo da forzare a valutarla come identificatore. //Infatti in questo caso il nome libro-preferito non sarebbe accettata come sintassi a causa del \"-\" //E' comunque da EVITARE \"libro-preferito\" : { titolo : \"L`uomo del bicentenario\" , pagine : 288 }, //Riferimento all'oggetto \"libro\" esterno. Attenzione! //E' un riferimento non \u00e8 una copia. Se modifico questa property di questo oggetto (autorePreferito) //modifico anche l'oggetto libro e viceversa. bestSeller : libro , } //Per accedere alla propriet\u00e0 \"libro-preferito\" devo per necessariamente utilizzare la notazione con le []. La notazione ///con \".\" non pu\u00f2 andare bene. //Ecco perch\u00e8 \u00e8 necessario evitare questi nomi con caratteri non validi cosnole . log ( autorePreferito [ \"libro-preferito\" ]. pagine ); console . log ( autorePreferito . bestSeller . titolo ); autorePreferito . bestSeller . pagine = 1000 ; console . log ( libro . pagine ); //1000, ATTENZIONE Come abbiamo visto in questo esempio, specificando come property un altro oggetto, questo viene passato per riferimento e non viene fatta una copia. La libreria JQuery pu\u00f2 aiutarci in questo. let libro = { titolo : \"Fondazione\" , pagine : 571 } let autorePreferito = { cognome : \"Asimov\" , nome : \"Isaac\" , //in questo caso sono necessari i doppi apici (o singoli) perch\u00e8 scrivendo libro-preferito lo tratterebbe com espressione. E' comunque da EVITARE \"libro-preferito\" : { titolo : \"L`uomo del bicentenario\" , pagine : 288 }, //in questo caso \u00e8 JQuery che si occupa di restituire una copia dell'oggetto bestSeller : jQuery . extend ( true , {}, libro ) } console . log ( autorePreferito [ \"libro-preferito\" ]. pagine ); //288 console . log ( autorePreferito . bestSeller . titolo ); //Fondazione autorePreferito . bestSeller . pagine = 1000 ; console . log ( libro . pagine ); //571 La funzione jQuery.extend(true, {}, object) effettua la copia ricorsiva di tutti elementi dell'oggetto specificato come terzo parametro. Lezione 03 Costruttore Partendo dall'esempio della lezione precedente, riporto un esempio completo di come creare un nuovo oggetto partendo dal prototipo. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > let libro = { titolo : \"\" , pagine : 0 } let autorePreferito = { cognome : \"\" , nome : \"\" , libroPreferito : { titolo : \"\" , pagine : 0 }, //JQuery.extend() restituisce una copia dell'oggetto bestSeller : jQuery . extend ( true , {}, libro ) } console . log ( autorePreferito . cognome ); console . log ( autorePreferito . nome ); console . log ( autorePreferito . libroPreferito . titolo ); console . log ( autorePreferito . libroPreferito . pagine ); console . log ( autorePreferito . bestSeller . titolo ); console . log ( autorePreferito . bestSeller . pagine ); //Chiamata al costruttore libro = new LibroConstructor ( \"Il ritorno all'isola\" , 301 ); //Chiamata al costruttore autorePreferito = new Autore ( \"Isaac\" , \"Asimov\" , \"L`uomo del bicentenario\" , 288 , libro ); //Modo alternativo /* autorePreferito = new Autore( \"Isaac\", \"Asimov\", \"L`uomo del bicentenario\", 288, new LibroConstructor ( \"Il ritorno all'isola\", 301 ) ); */ //Funzione costruttore function Autore ( cognome , nome , titolo , pagine , bestSeller ) { //stato interno this . cognome = cognome ; this . nome = nome ; this . libroPreferito = { titolo , pagine }; //this.libroPreferito = {titolo: titolo,pagine: pagine}; this . bestSeller = jQuery . extend ( true , {}, bestSeller ); } function LibroConstructor ( titolo , pagine ){ this . titolo = titolo ; this . pagine = pagine ; } console . log ( autorePreferito . cognome ); console . log ( autorePreferito . nome ); console . log ( autorePreferito . libroPreferito . titolo ); console . log ( autorePreferito . libroPreferito . pagine ); console . log ( autorePreferito . bestSeller . titolo ); console . log ( autorePreferito . bestSeller . pagine ); /* \"\" \"\" \"\" 0 \"\" 0 Isaac Asimov L`uomo del bicentenario 288 Il ritorno all'isola 301 */ </ script > </ body > </ html > Il costruttore \u00e8 una funzione che riceve come parametri i valori delle property e costruisce (ritorna) un oggetto. Notare l'uso del new necessario per l'invocazione del costruttore e del this ripetuto per ogni property necessario per stabilire il contesto dell'oggetto che viene creato dal costruttore. Vediamo adesso l'aggiunta di metodi all'esempio di sopra: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > let libro = { titolo : \"\" , pagine : 0 } function LibroConstructor ( titolo , pagine ){ this . titolo = titolo ; this . pagine = pagine ; } let autorePreferito = { cognome : \"\" , nome : \"\" , libroPreferito : { titolo : \"\" , pagine : 0 }, bestSeller : jQuery . extend ( true , {}, libro ) } function Autore ( cognome , nome , titolo , pagine , bestSeller ) { //stato interno this . cognome = cognome ; this . nome = nome ; this . libroPreferito = { titolo , pagine }; //this.libroPreferito = {titolo: titolo,pagine: pagine}; this . bestSeller = jQuery . extend ( true , {}, bestSeller ); //metodi this . getSchedaBestSeller = function () { let stringa = this . bestSeller . titolo + \"\\n\" + this . bestSeller . pagine ; let stringaConCornicetta = \"*\" . repeat ( 10 ) + \"\\n\" + \"BestSeller\" + \"\\n\" + \"-\" . repeat ( 10 ) + \"\\n\" + stringa + \"\\n\" + \"*\" . repeat ( 10 ); return stringaConCornicetta ; } this . getSchedaAutore = function () { let stringa = this . cognome + \"\\n\" + this . nome + \"\\n\" + this . libroPreferito . titolo + \"\\n\" + this . libroPreferito . pagine ; let stringaConCornicetta = \"*\" . repeat ( 10 ) + \"\\n\" + \"Scheda\" + \"\\n\" + \"-\" . repeat ( 10 ) + \"\\n\" + stringa + \"\\n\" + \"*\" . repeat ( 10 ); return stringaConCornicetta ; } } //Creo una collezione di oggetti, cio\u00e8 un array di oggetti let schedario = [ new Autore ( \"Runny\" , \"Ted\" , \"Lo sguardo del principe\" , 212 , new LibroConstructor ( \"Il mio viaggio\" , 272 ) ), new Autore ( \"Buld\" , \"Frank\" , \"I segreti di tutti\" , 302 , new LibroConstructor ( \"Il mio segreto\" , 180 ) ) ]; //Aggiungo in coda un nuovo oggetto schedario . push ( new Autore ( \"Tuy\" , \"malek\" , \"La voglia di te\" , 167 , new LibroConstructor ( \"la voglia di niente\" , 134 ) ) ); //itero ogni elemento dell'array e chiamo i metodi for ( let autore of schedario ) { console . log ( autore . getSchedaAutore () ); console . log ( autore . getSchedaBestSeller () ); } /* ********** Scheda ---------- Runny Ted Lo sguardo del principe 212 ********** ********** BestSeller ---------- Il mio viaggio 272 ********** ********** Scheda ---------- Buld Frank I segreti di tutti 302 ********** ********** BestSeller ---------- Il mio segreto 180 ********** ********** Scheda ---------- Tuy malek La voglia di te 167 ********** ********** BestSeller ---------- la voglia di niente 134 ********** */ </ script > </ body > </ html > Lezione 04 Ereditariet\u00e0 JavaScript confonde un po' gli sviluppatori che hanno esperienza di linguaggi basati sulle classi (come Java o C++), poich\u00e8 \u00e8 un linguaggio dinamico e non fornisce un'implementazione di class (la keyword class \u00e8 introdotto in ES2015, ma \u00e8 zucchero sintattico, Javascript rimarr\u00e0 basato sui prototipi). In termini di ereditariet\u00e0, Javascript ha solo un costrutto: gli oggetti. Ogni oggetto ha un link interno ad un altro oggetto chiamato prototype. Questo oggetto prototype ha a sua volta un suo prototype, e cos\u00ec via finch\u00e9 si raggiunge un oggetto con property null. null, per definizione, non ha un prototype, ed agisce come link finale nella catena di prototipi. Quasi tutti gli oggetti in Javascript sono istanze di Object, che risiede in cima alla catena dei prototipi. Nonostante questo sia considerato spesso come una debolezza di Javascript, il modello di ereditariet\u00e0 prototipale \u00e8 invece pi\u00f9 potente del modello classico. Per esempio, \u00e8 banale costruire un classico modello sul modello prototipale, mentre il contrario \u00e8 molto pi\u00f9 difficile. Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Inheritance_and_the_prototype_chain Supponiamo di aver creato un oggetto con certe propriet\u00e0 e metodi e di voler creare un altro oggetto con le stesse propiet\u00e0 e gli stessi metodi ed altre propriet\u00e0/metodi speifiche. Una soluzione, per quello che conosciamo adesso, si ha banalmente con un copia e incolla dell'oggetto modello (prototipo) aggiungendo poi le caratteristiche aggiuntive. Il concetto dell'ereditariet\u00e0 evita questa procedura di copia incolla non solo perch\u00e8 sarebbe una ripetizione ma anche, soprattutto, perch\u00e8 gli errori con i copia e incolla diventano intracciabili. Se \u00e8 stato individuato un errore nell'oggetto A, \u00e8 necessario riportare tutte le modifiche anche negli altri oggetti di cui si \u00e8 effettuata la copia manuale .. non \u00e8 il massimo. Per parlare di ereditariet\u00e0 dobbiamo parlare di gerarchia padre/figlio. Un figlio \u00e8 un oggetto che contiene tutte le caratteristiche del padre ovvero ne eredita le propriet\u00e0. Si parla anche di modello is-a Immaginiamo di avere questo modello piramidale: Animali Mammiferi Cane Gatto Volpe L'oggetto Volpe \u00e8 un (is-a) Mammifero , un Mammifero \u00e8 un (is-a) Animale . Secondo questo modello \u00e8 possibile costruire degli oggetti molto dettagliati semplicemente sfruttando le propriet\u00e0 ereditate Vediamo come si costruisce un oggetto con propriet\u00e0 ereditate //persona \u00e8 l'oggetto <padre> let persona = { nome : \"\" }; //Creo l'oggetto fantozzi. //fantozzi \u00e8 un oggetto che ha come prototipo l'oggetto persona. //fantozzi is-a persona let fantozzi = Object . create ( persona ); //persona e il prototipo di fantozzi sono la stesso oggetto console . log ( persona === Object . getPrototypeOf ( fantozzi )); => true //Per accedere in scrittura alle propriet\u00e0 ereditate si utilizza il metodo getPrototypeOf() //applicabile agli oggetti Object . getPrototypeOf ( fantozzi ). nome = \"Fantozzi\" ; //non avrei potuto scrivere direttamente \"fantozzi.nome\" perch\u00e8 avrebbe creato una propriet\u00e0 locale //poich\u00e8 <nome> non \u00e8 una propriet\u00e0 dell'oggetto \"fantozzi\" ma dell'oggetto \"persona\" //e quindi una propriet\u00e0 ereditata \u00e8 necessario il metodo getPrototypeOf() per distinguere in scrittura //le propriet\u00e0 locali da quelle ereditate. //In lettura, se non ci sono conflitti (vedremo pi\u00f9 avanti), //non importa specificare getPrototypeOf() perch\u00e8 il costrutto cerca prima tra le propriet\u00e0 locali //la propriet\u00e0 <nome>, se non \u00e8 presente la si cerca tra gli oggetti padre e quindi tra le property ereditate //In questo caso non la trover\u00e0 tra le propriet\u00e0 locali ma tra quelle ereditate console . log ( fantozzi . nome ); //Fantozzi //In questo caso aggiungo una propriet\u00e0 locale fantozzi . nome = \"il super sfigato\" ; //La proprit\u00e0 locale ha la precedenza. La propriet\u00e0 locale maschera quella ereditata //Shadowing console . log ( fantozzi . nome ); //il super sfigato //Per accedere in lettura alla propriet\u00e0 <nome> ereditata devo necessariamente utilizzare il //getPrototypeOf() console . log ( Object . getPrototypeOf ( fantozzi ). nome ); ATTENZIONE!! Il metodo create non crea una copia. let fantozzi = Object . create ( persona ); l'oggetto fantozzi non \u00e8 una copia dell'oggetto persona . Il figlio (fantozzi) condivide le stesse property del padre(persona). Se modifico le property del figlio (fantozzi) le trovo modificate anche nell'oggetto padre (persona) proprio perch\u00e8 condividono le stesse variabili, lo stesso spazio in memoria. Questo \u00e8 da tenere in considerazione! Lezione 05 Ereditariet\u00e0 - Shadowing Lo shadowing \u00e8 un meccanismo di mascheramento/oscuramento di property ereditate con la definizione di property locali Esempio let persona = { nome : \"\" , cognome : \"\" , Etichetta : function () //Stringhe template. Iniziano con $. Prima vengono valutate poi il valore viene sostituito e notare gli acccenti gravi { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } }; //L'oggetto persona diventa il prototipo dell'oggetto fantozzi let fantozzi = Object . create ( persona ); //Metodo hasOwnProperty(\"property\"): ritorna <true> se l'oggetto a cui si applica il metodo //ha come propriet\u00e0 diretta (non ereditata) \"property\", quella indicata come parametro. console . log ( fantozzi . hasOwnProperty ( \"nome\" )); //false //In questo caso constrollo se \"nome\" appartiene al padre console . log ( Object . getPrototypeOf ( fantozzi ). hasOwnProperty ( \"nome\" )); //true cosnole . log ( fantozzi . nome ); //non ancora inizializzata ma la variabile viene trovata come propriet\u00e0 ereditata //Accedo in scrittura alle propriet\u00e0 ereditate Object . getPrototypeOf ( fantozzi ). nome = \"Ugo\" ; Object . getPrototypeOf ( fantozzi ). cognome = \"Fantozzi\" ; //Creo una propriet\u00e0 locale fantozzi . nome = \"e io chi sono??\" ; //Accedo in lettura alla propriet\u00e0 locale console . log ( fantozzi . nome ); //e io chi sono?? //Accedo in lettura alla propriet\u00e0 ereditata console . log ( Object . getPrototypeOf ( fantozzi ). nome ); //Ugo //Posso eliminare una property tramite il comando <delete> ma solo tra quelle locali delete fantozzi . nome ; //A questo punto rimane solo la property <name> ereditata console . log ( fantozzi . nome ); //Ugo //Shadowing: Meccanismo di mascheramento/oscuramento di property ereditate con la definizione di //prperty locali //Chiamo il metodo Etichetta dell'oggetto fantozzi eredietato dall'oggetto persona console . log ( \"1: \" + fantozzi . Etichetta () ); //Oscuro il metodo <Etichetta> ereditato dal metodo <Etichetta> definito localmente -> shadowing fantozzi . Etichetta = function () { return \"il sottoposto per eccellenza\" ;} console . log ( \"2: \" + fantozzi . Etichetta ()); //Variante ... //Un po' complessa. //Definisco un metodo locale che utilizza il metodo ereditato. //il this fa riferimento all'oggetto in cui si definisce il metodo quindi \"fantozzi\" fantozzi . Etichetta = function () { return Object . getPrototypeOf ( this ). Etichetta () + \" detto il sottoposto\" ;} console . log ( \"3: \" + fantozzi . Etichetta ()); //le propriet\u00e0 del prototipo sono CONDIVISE. //Se modifico una propiet\u00e0 in un figlio ereditata da una propriet\u00e0 del padre, //la ritrovo modificata anche nel padre e negli altri figli del padre, cio\u00e8 nei \"fratelli\" //Questo non \u00e8 lo stesso meccanismo del C/C#/Java let filini = Object . create ( persona ); Object . getPrototypeOf ( filini ). cognome = \"Filini\" ; console . log (( \"4: \" + fantozzi . cognome ); //Filini, ATTTT!! Metodo hasOwnProperty() : ritorna se l'oggetto a cui si applica il metodo ha come propriet\u00e0 diretta (non ereditata) \"property\", quella indicata come parametro. Cosniderazione: Il padre di tutti gli oggetti \u00e8 proprio \"Object\" Ricorda: Con il metodo create() non creo una copia dell'oggetto, cio\u00e8 un'istanza del prototipo, ma instauro solo un rapporto di condivisione Ereditariet\u00e0 classica Per ereditariet\u00e0 classica si intende il meccanismo con il quale Javascript permette la crazione di istanze di oggetti a partire da un prototipo. Nell'esempio vedremo come realizzare una copia dato un prototipo Vediamo finalmente il metodo per creare una fottuta copia //Prototipo function Persona ( nome , cognome ) { //stato interno //Ogni istanza avr\u00e0 la sua copia di cognome e nome this . cognome = cognome ; this . nome = nome ; //ogni istanza avr\u00e0 la sua copia di etichetta this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } //chiamata al costruttore let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ) //gli oggetti fantozzi e filini hanno le loro copie distinte //delle variabili dello stato interno console . log ( \"1: \" + fantozzi . etichetta ()); cosnole . log ( \"2: \" + filini . etichetta ()); cosnole . log `3: ${ fantozzi . etichetta === filini . etichetta } ` ); //false Lezione 06 THIS In questi esempi cercheremo di capire la funzione di this in Javascript a seconda dei contesti. function Persona ( nome , cognome ) { //stato interno this . cognome = cognome ; this . nome = nome ; console . log ( this === window ); //true this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } //Attenzione, qua non utilizzo il costruttore. //this punta all'oggetto <window> (cio\u00e8 il padre del DOM). //Il risultato \u00e8 che le property <nome>, <cognme> diventano a tutti gli effetti variabili globali //poich\u00e8 <window> \u00e8 un oggetto implicito Persona ( \"\" , \"zzzzzz\" ); //cognome \u00e8 una variabile globale, window.cognome === cognome console . log ( cognome ); //zzzzzz Se invece utilizzo il costruttore dell'oggetto.. function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; console . log ( this === window ); //false this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } //Utilizzo il costruttore per creare due istanze dell'oggetto \"Persona\", \"fantozzi\", \"filini\" let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); //Adesso le variabili (property) <nome>, <cognome> sono visibili solo nel contesto degli oggetti \"fantozzi\" e \"filini\" //e accessibili solo tramite l'opertore \".\" console . log ( cognome ); //cognome is not defined. console . log ( fantozzi . cognome ); //Fantozzi. console . log ( filini . cognome ); //Filini. Quando this \u00e8 all'interno della definizione di un metodo, fa riferimento all'oggetto per cui si definisce il metodo. Nota: Non posso definire una variabile locale \"local_var\" senza far uso di this . Non sar\u00e0 disponibile nelle istanze degli oggetti ma solo nel constesto della chiamata funzione e quindi non nel contesto della chiamata a costruttore. Vediamo un esempio function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; let local_var = 999 ; //ATTENZIONE!! Non ha senso nel contesto di chiamata a costruttore //ogni istanza avr\u00e0 la sua copia di etichetta this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); console . log ( fantozzi . local_var ); //undefined console . log ( fantozzi . cognome ); //Fantozzi. console . log ( filini . cognome ); //Filini. Object - Variabili Statiche (condivise) In generale, le variabili statiche sono variabili condivise. Nel contesto di un oggetto, per creare delle variabili statiche cio\u00e8 condivise tra tutte le istanze si ottiene attraverso il metodo prototype function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); //dichairo una variabile (property) \"s\", \"ETA_MIN\" statica cio\u00e8 condivisa tra tutte le istanze create attravero il modello //dell'oggetto \"Persona\" Persona . prototype . s = \"ciao\" ; Persona . prototype . ETA_MIN = { value : 18 } ; console . log ( fantozzi . s ); //ciao console . log ( filini . s ); //ciao console . log ( fantozzi . ETA_MIN ); //{value: 18} console . log ( filini . ETA_MIN ); //{value: 18} //Posso dichiarare anche un metodo condiviso Persona . prototype . etichettaCondivisa = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } console . log ( `3: ${ fantozzi . etichetta === filini . etichetta } ` ); //false console . log ( `4: ${ fantozzi . etichettaCondivisa === filini . etichettaCondivisa } ` ); //true Vediamo un ultimo esempio: function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); Persona . prototype . s = \"ciao\" ; console . log ( fantozzi . s ); //ciao console . log ( filini . s ); //ciao //Se voglio accedere in scrittura ad una property condivisa tramite un figlio, dobbiamo al solito modo //utilizzare getPrototypeOf() Object . getPrototypeOf ( fantozzi ). s = \"amor\" ; console . log ( fantozzi . s ); //amor console . log ( filini . s ); //amor //Definisco una property locale a fantozzi fantozzi . s = \"mare\" ; console . log ( fantozzi . s ); //mare console . log ( filini . s ); //amor Lezione 07 Introduzione For In for-in \u00e8 un metodo utilizzato per iterare sulle property degli oggetti tramite l'identificativo delle chiavi. Vedremo pi\u00f9 avanti cosa sta dietro a un costrutto cos\u00ec semplice e potente for ( const x in object ){ //code } const Persona = { name : 'Simone' , eta : 23 , hobby : 'Tennis' } for ( const x in Persona ) { console . log ( '+++++++++++++++' ); console . log ( x ); //Itero sulle chiavi console . log ( typeof x ); //x \u00e8 una stringa //non posso utilizzare Persona.x poich\u00e8 x \u00e8 una stringa. //Posso comunque utilizzare la notazione Persona[x] che in questo i torna comodo console . log ( Persona [ x ]); //Itero sui valori console . log ( Persona . x ); //Itero sui valori console . log ( '+++++++++++++++' ); } /* +++++++++++++++ name string Simone +++++++++++++++ +++++++++++++++ eta string 23 +++++++++++++++ +++++++++++++++ hobby string Tennis +++++++++++++++ */ Oggetto Date() Un oggetto interessante \u00e8 l'oggetto Date() . Javascript permette di gestire in modo semplice il tempo, la data, l'ora acquisendo dati dalla rete. //Chiamata al costruttore Date() con parametri di default let oggi = new Date (); console . log ( oggi ); /* Console: --------------- Wed Nov 11 2020 17:13:04 GMT+0100 (Ora standard dell\u2019Europa centrale) */ //Passaggio di parametri al costruttore Date() let compleannoMio = new Date ( '07-22-1991-09:30:12' ); //Modi alternativi let compleannoMario = new Date ( '07/22/1991' ); let compleannoGiovanni = new Date ( 'July 22 1991' ); console . log ( 'compleannoMio: ' + compleannoMio ); console . log ( 'compleannoMario: ' + compleannoMario ); console . log ( 'compleannoGiovanni: ' + compleannoGiovanni ); /* Console: --------------- compleannoMio: Mon Jul 22 1991 09:30:12 GMT+0200 (Ora legale dell\u2019Europa centrale) compleannoMario: Mon Jul 22 1991 00:00:00 GMT+0200 (Ora legale dell\u2019Europa centrale) compleannoGiovanni: Mon Jul 22 1991 00:00:00 GMT+0200 (Ora legale dell\u2019Europa centrale) */ Essendo Date() un oggetto ci sono diversi metodi get associati a questo oggetto come: getFullYear() : Ritorna l'anno getMonth() : Ritorna il mese a partire da 0, 0 = GEN, 1 = FEB getDate() : Ritorna il giorno del mese corrente, range [1 - 31] getDay() : Ritorna il giorno della settimana a partire da 0, 0 = DOM, 1 = LUN getHours() : Ritornano le ore getMinutes() : Ritornano i minuti getSeconds() : Ritornano i secondi getMilliseconds() : Ritornano i millisecondi getTime() : he getTime() method returns the number of milliseconds between midnight of January 1, 1970 and the specified date ... Ma anche metodi analoghi di set come: - setFullYear(year) - setMonth(month) - setHours(h, m, s) - .. //Metodi get let myData = new Date (); console . log ( 'getFullYear: ' + myData . getFullYear ()); console . log ( 'getMonth: ' + myData . getMonth ()); console . log ( 'getDate: ' + myData . getDate ()); console . log ( 'getDay: ' + myData . getDay ()); console . log ( 'getHours: ' + myData . getHours ()); console . log ( 'getMinutes: ' + myData . getMinutes ()); console . log ( 'getSeconds: ' + myData . getSeconds ()); console . log ( 'getMilliseconds: ' + myData . getMilliseconds ()); console . log ( 'getTime: ' + myData . getTime ()); /* Console: --------------- getFullYear: 2020 getMonth: 10 getDate: 12 getDay: 4 getHours: 10 getMinutes: 27 getSeconds: 50 getMilliseconds: 336 getTime: 1605173270336 */ //Metodi set let compleannoMario = new Date ( 'April 02 2002' ); console . log ( 'compleannoMario: ' + compleannoMario ); /* Console: --------------- compleannoMario: Tue Apr 02 2002 00:00:00 GMT+0200 (Ora legale dell\u2019Europa centrale) */ compleannoMario . setFullYear ( '1991' ); compleannoMario . setMonth ( 9 ); compleannoMario . setHours ( 12 , 45 , 09 ); console . log ( 'compleannoMario: ' + compleannoMario ); /* Console: --------------- compleannoMario: Wed Oct 02 1991 12:45:09 GMT+0100 (Ora standard dell\u2019Europa centrale) */ Nota: Se creto un'istanza dell'oggetto Date() senza parametri, verr\u00e0 invocato il costruttore con parametri di default. Di default Date() restituisce l'ora e la data locale fornita dalla rete. Quindi l'oggetto appena creato far\u00e0 riferimento all'ora corrente, un dato dinamico. Lezione 08 Classi Le classi JavaScript, introdotte in ECMAScript 2015, sono principalmente zucchero sintattico sull'esistente ereditariet\u00e0 prototipale di JavaScript. La sintassi non introduce un nuovo modello di eredit\u00e0 orientata agli oggetti in JavaScript. Le classi sono di fatto delle \"funzioni speciali\", e cos\u00ec come puoi definire function expressions e function declarations, la sintassi per la classe ha due componenti: class expressions e class declarations. Non \u00e8 lo stesso concetto di classe definita come ad esempio per il linguaggio C++. class Persona { } let Fantozzi = new Persona (); cosnole . log ( typeof ( Fantozzi )); //Object //Dietro il meccanismo di classe c'\u00e8 di fatto il concetto di prototipo/funzione cosnole . log ( typeof ( Persona )); //function Vediamo un esempio pi\u00f9 completo class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } } //non passo nessun parametro quindi utilizzer\u00e0 i valori di default let Fantozzi = new Persona (); cosnole . log ( Fantozzi . nome ); //sconosciuto Note: - Con questa definizione di classe non esiste tuttavia un meccanismo che possa rendere privati i dati come nel concetto di classe che si avrebbe nel c++. - Non \u00e8 possibile un meccanismo di overload dei costruttori , non possono quindi coesistere pi\u00f9 costruttori. E' ammesso un solo costruttore per classe. Tuttavia ogni istanza creata avr\u00e0 i dati separati class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } } //non passo nessun parametro quindi utilizzer\u00e0 i valori di default let Fantozzi = new Persona (); console . log ( Fantozzi . nome ); //sconosciuto let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); console . log ( Fantozzi . nome ); //Ugo let Filini = new Persona ( \"Filini\" , \"Silvio\" ); console . log ( Filini . nome ); //Silvio console . log ( Fantozzi . nome ); //Ugo Ampliamo la classe con l'aggiunta di metodi: class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } } let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); let Filini = new Persona ( \"Filini\" , \"Silvio\" ); cosnole . log ( Fantozzi . etichetta ); cosnole . log ( Filini . Etichetta ); cosnole . log ( Fantozzi . etichetta === Filini . Etichetta ); //false Aggiunta di metodi condivisi class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } //metodo condiviso tra tutte le istanze static etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } //metodo separato per ogni istanza etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } } let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); let Filini = new Persona ( \"Filini\" , \"Silvio\" ); //Assegno dei \"value\" alle property della classe Persona . cognome = \"Liberti\" ; Persona . nome = \"Franco\" ; //il metodo Filini.etichetta \u00e8 il metodo locale alla classe Filini. //Prende il nome di \"Metodo di istanza\" console . log ( \"Metodo di istanza: \" + Filini . etichetta () ); //Metodo di istanza: Egr. Sig. Silvio Filini //il metodo Persona.etichetta \u00e8 il metodo condiviso tra tutte le istanze della classe Persona. //Prende il nome di \"Metodo di classe\" console . log ( \"Metodo di classe: \" + Persona . etichetta () ); //Metodo di classe: Egr. Sig. Franco Liberti Vediamo un esempio in cui posso sfruttare le variabili statiche. In questo esempio, ogni volta che creo un'istanza della classe Persona, incremento una variabile statica che indicher\u00e0 alla fine quante istanze ho creato class Persona { constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; //ogni volta che creo un'istanza della classe Persoan, si icrementa la variabile \"conta\" //Nota <conta> \u00e8 stata aggiunta dopo la creazione della classe Persona Persona . conta ++ ; } static personeCreate () { return Persona . conta ;} etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } } //Resetto il conteggio Persona . conta = 0 ; let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); let Filini = new Persona ( \"Filini\" , \"Silvio\" ); console . log ( Persona . conta ); //2 console . log ( Persona . personeCreate () ); //2 Lezione 09 Classi assegnanili a variabili Posso assegnare una classe ad una variabile esattamente come per gli oggetti, le funzioni.. //questa \u00e8 una classe anonima let Punto = class { constructor ( x , y ) { this . x = x ; this . y = y ;} } let p = new Punto ( 10 , - 30 ); console . log ( p . y ); //-30 p . x = \"paperino\" ; //non viene fatto nessun controllo semantico console . log ( p . x ); //paperino Get / Set Non c'\u00e8 un modo di definire x e y private con un meccanismo simile alle property private per le classi definite dal linguaggio C++ tuttavia esiste un sistema che ci aiuta a nascondere le variabili interne, get/set . //PuntoIQ \u00e8 una classe che assegna punti solo nel primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } } try { //poich\u00e8 questo punto non appartiene al primo quadrante si verifica l'eccezione e salta al catch let p = new PuntoIQ ( 10 , - 30 ); } catch ( eccezione ) { console . log ( eccezione ); } try-catch Nota il sistema try-catch . Con tale sistema \u00e8 possibile tentare l'esecuzione del codice presente nel corpo di try . Se va a buon fine si prosegue altrimenti si esegue il corpo del catch . Per stabilire se il codice presente nel try va o meno a buon fine si utilizza la keyword throw . Nella classe PuntoIQ infatti se i dati passati al costruttore sono minori di zero si passa un'eccezione attravero throw , l'eccezione in questo caso \u00e8 semplicemente la stringa \"Non nel primo quadrante\" che viene passata al catch try { //prova ad eseguire il codice. Se il codice presenta un'eccezione salta al catch } catch ( eccezione ){ //esegui eccezione } Riprendiamo con il concetto di get/set //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } //Per accedere a questa propriet\u00e0 devo usare \"_x\", //\u00e8 di fatto un sistema di costrizione dell'utilizzatore della classe a NON usare questa property this . _x = x ; //Per accedere a questa propriet\u00e0 devo usare \"_y\", //\u00e8 di fatto un sistema di costrizione dell'utilizzatore della classe a NON usare questa property this . _y = y ; } //Le keyword \"get\" definisce di fatto un metodo che pu\u00f2 essere richiamato con la nomenclatura //utilizzata per le propriet\u00e0. Posso quindi richiamare il metodo x tramite <punto.x> //get definisce un metodo di lettura quindi posso leggere la property \"x\" //nascondendo la \"vera\" property definita sopra tramite \"_x\" get x () { return this . _x ; } //Le keyword \"set\" definisce come \"get un metodo che pu\u00f2 essere richiamato con la nomenclatura //utilizzata per le propriet\u00e0. Posso quindi richiamare il metodo x tramite <punto.x> //get definisce un metodo di scrittura quidni posso scrivere la property \"x\" //nascondendo la \"vera\" property definita sopra \"_x\" set x ( valore ) { this . _x = valore ; } } try { var p = new PuntoIQ ( 10 , 30 ); //Ok } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 10, _y: 30} try { p . x = 56 ; // === p._x = 56 } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 56, _y: 30} try { p . _x = 12 ; // L'utilizzatore della classe sta bypassando il metodo \"ufficiale\" tramite get/set } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 12, _y: 30} Passare attravero get/set \u00e8 utile per poter eseguire controlli avanzati e restituire un errore in caso di fallimento. Vediamo di estendere la classe di sopra aggiungendo un controllo in fase di set //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore ) ){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } } try { var p = new PuntoIQ ( 10 , 30 ); //Ok } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 10, _y: 30} try { p . x = \"dodici\" ; // === p._x = 56 } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //Non \u00e8 un numero Lezione 10 Derivazione di classi , ereditariet\u00e0 Il meccanismo di derivazione delle classi ovvero la costruzione di una classe figlia a partire da una classe padre aggiungendo una specializzazione \u00e8 noto anche come meccanismo di ereditariet\u00e0 e si ottiene semplicemente la keyword extends . Abbiamo gi\u00e0 visto come \u00e8 implementato questo concetto negli oggetti in Javascript. Per quanto riguarda le classi si ricordi che \u00e8 solo \"zucchero sintattico\" quindi il meccanismo sotto sar\u00e0 il medesimo. //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore ) ){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } } class PuntoIQColorato extends PuntoIQ { } La lasse \"PuntoIQColorato\" \u00e8 derivata dalla classe madre PuntoIQ ma accede a a tutte le strutture interne della classe madre. Vediamo di estendere la classe definita sopra con altri metodi: //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore )){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } //\"distanza(altro)\", applicato a un oggetto A <PuntoIQ> calcola la distanza tra //l'oggetto a cui si applica il metodo (oggetto A) e un altro oggetto ricevuto come argomento //<altro> che dovr\u00e0 essere un oggetto della classe <PuntoIQ> distanza ( altro ){ //\"A instanceof B\" ritorna true se A \u00e8 un'istanza di B //Viene quindi fatto un controllo per essere sicuri di aver ricevuto un oggetto compatibile if ( altro instanceof PuntoIQ ){ //formula distanza tra due punti return ( Math . sqrt ( Math . pow ( this . x - altro . x , 2 ) + Math . pow ( this . y - altro . y , 2 ) ) ); } else { throw \"Il parametro attuale `altro` non \u00e8 un punto\" ; } } } class PuntoIQColorato extends PuntoIQ { } let p1 = new PuntoIQ ( 5 , 5 ); let p2 = new PuntoIQ ( 10 , 10 ); cosnole . log ( p1 . distanza ( p2 ) ); //7.07... //un oggetto della classe <PuntoIQColorato> \u00e8 identico a un oggetto della classe <PuntoIQ> let pc = new PuntoIQColorato ( 100 , 100 ); console . log ( \"Punto Colorato: \" + pc . x ); //La classe figlia PuntoIQColorato passa il controllo if (altro instanceof PuntoIQ) Poich\u00e8 \u00e8 figlia //di PuntoIQ cosnole . log ( pc . distanza ( p2 ) ); Nella prossima lezione aggiungeremo elementi specifici della classe PuntoIQColorato Lezione 11 Ereditariet\u00e0 classi Pt 2 In questo esempio vedremo aggiungeremo elementi specifici della classe PuntoIQColorato . Utilizzeremo anche il comando super . Un comando usato nella classe figlia per richiamare il costruttore della classe madre //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore )){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } //\"distanza(altro)\", applicato a un oggetto A <PuntoIQ> calcola la distanza tra //l'oggetto a cui si applica il metodo (oggetto A) e un altro oggetto ricevuto come argomento //<altro> che dovr\u00e0 essere un oggetto della classe <PuntoIQ> distanza ( altro ){ //\"A instanceof B\" ritorna true se A \u00e8 un'istanza di B //Viene quindi fatto un controllo per essere sicuri di aver ricevuto un oggetto compatibile if ( altro instanceof PuntoIQ ){ //formula distanza tra due punti return ( Math . sqrt ( Math . pow ( this . x - altro . x , 2 ) + Math . pow ( this . y - altro . y , 2 ) ) ); } else { throw \"Il parametro attuale `altro` non \u00e8 un punto\" ; } } } class PuntoIQColorato extends PuntoIQ { constructor ( x , y , colore ){ //super richiama il costruttore della classe madre //super deve essere sempre il primo statemeant super ( x , y ); this . _colore = colore ; //Potrei accedere ai dati interni della classe madre PuntoIQ tramite ad esempio //this._x = 999; //E' ASSOLUTAMENTE DA EVITARE PERCHE' BYPASSO TUTTI I CONTROLLI SU \"x\" } get colore (){ return this . _colore ; } //Shadowing. //Il metodo \"distanza\" definito qua \u00e8 locale alla classe <PuntoIQColorato> e oscura il metodo ereditato //dalla classe <PuntoIQ> distanza ( altro ){ return 1000 ; } } let p1 = new PuntoIQ ( 5 , 5 ); let p2 = new PuntoIQ ( 10 , 10 ); console . log ( p1 . distanza ( p2 ) ); //7.0... let pc = new PuntoIQColorato ( 100 , 100 , \"blue\" ); console . log ( \"Punto Colorato: \" + pc . x , pc . y , pc . colore ); //Punto Colorato: 100 100 blue //Poich\u00e8 il metodo \"distanza\" \u00e8 applicato a <pc> che \u00e8 un <PuntoIQColorato> verr\u00e0 applicato il metodo locale console . log ( pc . distanza ( p2 ) ); //1000 Attenzione: E' buona norma mettere il comando super come primo comando nel costruttore della classe figlia per poter permettere al costrutto di creare le caratteristiche ereditate correttamente Metodi locali ed ereditati possono coesistere e collaborare. Con super posso richiamare il metodo della classe madre all'interno della classe figlia //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore )){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } //\"distanza(altro)\", applicato a un oggetto A <PuntoIQ> calcola la distanza tra //l'oggetto a cui si applica il metodo (oggetto A) e un altro oggetto ricevuto come argomento //<altro> che dovr\u00e0 essere un oggetto della classe <PuntoIQ> distanza ( altro ){ //\"A instanceof B\" ritorna true se A \u00e8 un'istanza di B //Viene quindi fatto un controllo per essere sicuri di aver ricevuto un oggetto compatibile if ( altro instanceof PuntoIQ ){ //formula distanza tra due punti return ( Math . sqrt ( Math . pow ( this . x - altro . x , 2 ) + Math . pow ( this . y - altro . y , 2 ) ) ); } else { throw \"Il parametro attuale `altro` non \u00e8 un punto\" ; } } } class PuntoIQColorato extends PuntoIQ { constructor ( x , y , colore ){ //super deve essere sempre il primo statemeant super ( x , y ); this . _colore = colore ; } get colore (){ return this . _colore ; } //Shadowing. distanza ( altro ){ //richiamo il metodo \"distanza\" della classe madre return super . distanza ( altro ) + 1000 ; } } let p1 = new PuntoIQ ( 5 , 5 ); let p2 = new PuntoIQ ( 10 , 10 ); console . log ( p1 . distanza ( p2 ) ); //7.0... let pc = new PuntoIQColorato ( 100 , 100 , \"blue\" ); console . log ( \"Punto Colorato: \" + pc . x , pc . y , pc . colore ); //Punto Colorato: 100 100 blue console . log ( pc . distanza ( p2 ) ); //1127.2792206135787 Lezione 12 Approfondimento - Symbols Ogni valore symbol restituito da Symbol() \u00e8 unico. Un valore symbol pu\u00f2 essere utilizzato come identificatore per propriet\u00e0 di un oggetto; questo \u00e8 lo scopo di tale tipo di dati. Il tipo di dati symbol \u00e8 un primitive data type. Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/Symbol //Il simbolo \u00e8 un nuovo tipo che permette di creare valori univoci //Nell'esempio creo due variabili di tipo Symbol(). //I loro valori (che non possiamo stampare) saranno sicuramente diversi let un_simbolo = Symbol (); let un_altro_simbolo = Symbol (); //Posso agire per confronti ma non stampare direttamente i simboli console . log ( un_simbolo === un_altro_simbolo ); //false, sempre console . log ( un_simbolo ); //ERROR GUID: Il GUID (Globally Unique Identifier, identificatore unico globale) \u00e8 un numero pseudo-casuale usato nella programmazione software, per poter distinguere vari oggetti. Il tipo pi\u00f9 noto di GUID \u00e8 l'utilizzo di Microsoft dell'UUID, ideato dalla Open Software Foundation, ma vi sono anche altri usi, come quello all'interno di XML. Fonte: https://it.wikipedia.org/wiki/GUID Vediamo l'utilizzo di un Symbol come identificatore di una propriet\u00e0 di un oggetto let oggetto = { colore : \"giallo\" , peso : 21 , } //creo un nuovo simbolo let check = Symbol (); //aggiungo la property \"check\" \u00e8 un valore \"OK\" oggetto [ check ] = \"OK\" ; console . log ( oggetto [ check ]); //OK La property aggiunta con Symbol \u00e8 nascosta.. let oggetto = { colore : \"giallo\" , peso : 21 , scheda : function () { let s = \"\" ; //Si traduce in: per ogni property presente in questo oggetto.. //Itera sulle property tranne su \"scheda\" //E le concatena in una stringa s = \"colore peso\" for ( x in this ){ if ( x !== \"scheda\" ){ s += x + \" \" ; } } return s ; } } //Posso assegnare un'etichetta al Symbol let check = Symbol ( \"il check\" ); oggetto [ check ] = \"OK\" ; console . log ( oggetto [ check ]); //Una property aggiunta con Symbol \u00e8 nascosta. //Utilizzo il metodo \"scheda\" per stampare tutte le property. //Vedremo che la property \"check\" non apparir\u00e0 console . log ( oggetto . scheda () ); //colore peso //Notare la differenza con la seguente propery aggiunta localmente //check2 \u00e8 una propriet\u00e0 locale e visibile oggetto . check2 = \"YES\" ; console . log ( oggetto . scheda () ); //colore peso check2 Posso generare un metodo attraverso Symbol let report = Symbol (); let oggetto2 = { prodotto : \"xyz\" , //genero il metodo con il simbolo [ report ]() { return this . prodotto ;} } console . log ( oggetto2 [ report ]()); //xyz Posso aggiungere il metodo a posteriori let report = Symbol (); let oggetto2 = { prodotto : \"xyz\" , [ report ]() { return this . prodotto ;} } //Assegno al metodo un nuovo valore oggetto2 [ report ] = function () { return \"Controllo effettuato!\" ;} console . log ( oggetto2 [ report ]()); //Controllo effettuato! Lezione 13 Approfondimento - Iterables/Iterator Un oggetto \u00e8 un iterator quando sa come accedere agli elementi di una collezione uno per volta, conservando l'informazione sulla sua posizione corrente nella sequenza. In Javascript un iterator \u00e8 un oggetto che implementa il metodo next() , il quale ritorna l'elemento successivo della sequenza. Questo metodo ritorna un oggetto con due propriet\u00e0: done e value . Una volta che \u00e8 stato creato, un iterator pu\u00f2 essere utlizzato esplicitamente chiamando pi\u00f9 volte il metodo next() . Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Guida/Iteratori_e_generatori Costrutto for - of Il costrutto for...of crea un ciclo con gli oggetti iterabili (inclusi Array, Map, Set, String, TypedArray, argomenti di oggetti e cos\u00ec via), iterando le istruzioni per ogni valore di ogni propriet\u00e0. for ( elem of collection ) { /*CODE*/ }; Vediamo un esempio: let s = \"ciao\" ; //ciclo tradizionale //for (let i=0; i<s.length; i++) console.log(s[i]); //ciclo che sfrutta un iteratore e il for ... of for ( carattere of s ) console . log ( carattere ); Dietro il meccanismo di un costrutto cos\u00ec potente c'\u00e8 il concetto di Iterables/Iterator e Symbol . Se un oggetto \u00e8 iterabile avr\u00e0 un iteratore. A tale iteratore \u00e8 applicabile il metodo next() che restituisce l'elemento successivo della lista degli elementi. Tale elemento \u00e8 un oggetto con due property: done e value . La property done \u00e8 un boolean che indica se siamo arrivati in fondo alla lista degli elementi iterabili mentre la property value restituisce il valore dell'elemento let s = \"ciao\" ; for ( carattere of s ) console . log ( carattere ); let iteratore = s [ Symbol . iterator ](); cosnole . log ( typeof ( s [ Symbol . iterator ]) ); //function cosnole . log ( typeof ( iteratore ) ); //Object. Questo \u00e8 l'oggetto iteratore //l'iteratore \u00e8 un oggetto formato da due sotto elementi //done -> restituisce true se \u00e8 l'ultimo elemento della lista //value -> rappresenta il valore dell'elemento estratto let elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //c, la prima lettera di \"ciao\" //Se continuiamo con next(), passo all'elemento successivo.. elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //i elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //a elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //o elemento = iteratore . next (); console . log ( elemento . done ); //true console . log ( elemento . value ); //undefined Lezione 14 Approfondimento - Funzioni Generatrici I generatori sono funzioni dalle quali \u00e8 possibile uscire e poi rientrarvi in un secondo momento. Il loro contesto (binding delle variabili) verr\u00e0 salvato all'uscita per quando vi entrer\u00e0 successivamente. La chiamata ad un generatore non viene eseguita immediatamente; la funzione ritorner\u00e0 invece un oggetto iterator . Quando il metodo next() dell'iteratore viene chiamato, il corpo del generatore viene eseguito fino alla prima espressione yield , la quale specifica quale espressione ritornare dall'iteratore oppure, con l'espressione yield , delegare questo valore ad un'altra funzione generatrice. Il metodo next() restituisce un oggetto con propriet\u00e0 value contenente il valore da restituito all'iteratore ed una propriet\u00e0 done che contiene un valore di tipo boolean per indicare se il generatore ha restituito l'ultimo valore. Chiamando il metodo next() con un argomento far\u00e0 riprendere l'esecuzione della funzione generatrice, sostituendo l'istruzione yield in cui l'esecuzione era stata fermata con l'argomento della funzione next() . Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Statements/function function * generatrice () { //la prima volta \u00e8 in attesa ... //che venga chiamato il metodo next() sull'oggetto restituito let n = 10 ; console . log ( n ); yield ; //genera n += 1 ; console . log ( n ); } let obj = generatrice (); //non succede niente. Siamo in attesa di invocare next() obj . next (); //10, si ferma a yield e ritorna ma lo stato dei dati \u00e8 memorizzato obj . next (); //11 obj . next (); // Vediamo un esempio pi\u00f9 interessante: function * generatrice () { let n = 0 ; while ( true ){ n ++ ; console . log ( n ); yield ; } } let obj = generatrice (); obj . next (); //1 obj . next (); //2 obj . next (); //3 yield \u00e8 il \"ritorno\" della funzione generatrice e restituisce un oggetto iterator , un oggetto formato quindi da due property value e done function * generatrice () { let n = 0 ; while ( true ){ n ++ ; yield n ; } } let obj = generatrice (); console . log ( obj . next (). value ); //1 console . log ( obj . next (). value ); //2 console . log ( obj . next (). value ); //3 Lezione 15 Approfondimento - Esempio (For .. of) custom Dopo l'introduzione di Iterator/Iterables e di funzioni generatrici \u00e8 possibile costruire per una classe personale un metodo (for..of) personalizzabile class miaCollezione { //la classe contiene un array constructor () { this . items = []; } //posso aggiungere valori tramite il metodo \"add\" add ( value ) { this . items . push ( value ) } //questo definisce un metodo per il for - of * [ Symbol . iterator ] () { for ( let key in this . items ) { //Se la lunghezza dell'array \u00e8 maggiore di 4, restituisce l'array if ( this . items [ key ]. length > 4 ) yield this . items [ key ]; } } } let o = new miaCollezione (); o . add ( \"rossi\" ); o . add ( \"Bob\" ); o . add ( \"Gialli\" ); //L'elemento Bob non verr\u00e0 stampato perch\u00e8 ha 3 elementi for ( x of o ) { console . log ( x ); } /* rossi Gialli */ Posso aggiungere anche aggiungere una funzione generatrice come metodo per iterare sugli elementi sfruttando il costrutto while e come terminatore del ciclo la property done class miaCollezione { //la classe contiene in realt\u00e0 un array constructor () { this . items = []; } //posso aggiungere valori tramite il metodo \"add\" add ( value ){ this . items . push ( value ) } //questo definisce un metodo per il for - of * [ Symbol . iterator ] (){ for ( let key in this . items ){ //Se la lunghezza dell'array \u00e8 maggiore di 4, restituisce l'array if ( this . items [ key ]. length > 4 ) yield this . items [ key ]; } } * generatrice (){ for ( let key in this . items ){ yield this . items [ key ]; } } } let o = new miaCollezione (); o . add ( \"rossi\" ); o . add ( \"Bobyna\" ); o . add ( \"Gialli\" ); let iterator = o . generatrice (); //itero \"a mano\" tramite la funzione mia generatrice. //E' esattamente il (for.. of ) //Nota < (elemento=iterator.next()).done > equivale a: //elemento = iterator.next() //elemento.done while ( ! ( elemento = iterator . next ()). done ) cosnole . log ( elemento . value ); Lezione 16 Destructuring La sintassi di assegnamento di destrutturazione \u00e8 un'espressione JavaScript che rende possibile estrarre informazioni da array o oggetti in variabili distinte. Le espressioni letterali degli oggetti e degli array forniscono un modo facile per creare ad hoc pacchetti di data. Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment let prodotto = { codice : \"BPX001\" , categoria : \"alimentari\" , prezzo : 1.25 }; //FORMA ABBREVIATA //i valori delle property \"codice\" e \"prezzo\" sono memorizzate in due variabili di nome \"codice\", \"prezzo\" //il nome delle variabili deve coincidere con il nome della property let { codice , prezzo } = prodotto ; /* Equivale a: let codice = prodotto.codice; let prezzo = prodotto.prezzo; */ console . log ( ` ${ codice } - ${ prezzo } ` ); // BPX001 - 1.25 //FORMA ESTESA //E' possibile assegnare un nome alle variabili con l'associazione di un'etichetta let { codice : il_codice , prezzo : il_prezzo } = prodotto ; console . log ( ` ${ il_codice } - ${ il_prezzo } ` ); // BPX001 - 1.25 Il Destructuring funziona con qualsiasi collezione iterabile //il destructuring funziona con gli array let temperature = [ 1 , 3 , 6 , 9 , 8 , 5 , 4 , - 1 ] let [ h00 , h3 , h6 , h9 , h12 , h15 , h18 , h21 ] = temperature ; console . log ( `Temp. alle h06:00 ${ h6 } \u2103; alle h18:00 ${ h18 } \u2103` ); // Temp. alle h06:00 6\u2103; alle h18:00 $4\u2103 Posso utilizzare il destructuring per il ritorno di variabili multiple in una funzione function min_max ( vettore ) { let pos_min = 0 ; let pos_max = 0 ; //immaginiamo qui l`algoritmo che determina le //posizioni dell`elemento minimo e massimo pos_min = 3 ; pos_max = 7 ; return [ pos_min , pos_max ]; } let temperature = [ 1 , 3 , 6 , 9 , 8 , 5 , 4 , - 1 ] let [ h00 , h3 , h6 , h9 , h12 , h15 , h18 , h21 ] = temperature ; console . log ( `Temp. alle h06:00 ${ h6 } \u2103; alle h18:00 ${ h18 } \u2103` ); //Temp. alle h06:00 6\u2103; alle h18:00 4\u2103 //------------------------------------------------------------------------- let [ pos_temp_min , pos_temp_max ] = min_max ( temperature ); console . log ( `Temperatura minima alle ${ 3 * pos_temp_min } ` ); //Temperatura minima alle 9 console . log ( `Temperatura massima alle ${ 3 * pos_temp_max } ` ); //Temperatura massima alle 21 Si pu\u00f2 scavare anche dentro oggetti senza esagerare troppo let libro = { autore : { cognome : \"Alessandro\" , nome : \"Manzoni\" }, titolo : \"I promessi sposi\" , nato_a : { nome : \"Milano\" , nazione : \"Italia\" } }; let { autore : { cognome , nome }, titolo } = libro ; console . log ( cognome ); //Alessandro console . log ( nome ); //Manzoni console . log ( titolo ); //I promessi sposi let { titolo : t2 } = libro ; console . log ( t2 ); ////I promessi sposi let s = \"\" ; //questa sintassi \u00e8 per l'assegnamento ({ titolo : s } = libro ); Con gli array questo metodo dell'assegnamento \u00e8 pi\u00f9 semplice let temperature = [ 1 , 3 , 6 , 9 , 8 , 5 , 4 , - 1 ] let [ h00 , h3 , h6 , h9 , h12 , h15 , h18 , h21 ] = temperature ; console . log ( `Temp. alle h06:00 ${ h6 } \u2103; alle h18:00 ${ h18 } \u2103` ); //------------------------------------------------------------------------- let t = 0 ; [ t ] = temperature ; console . log ( t ); //1, ottengo la temperatura alla prima posizione //Estraggo il 4 elemento [,,, t ] = temperature ; //temperature[3] console . log ( t ); //9 let v = [ 1 , 2 ]; let [,, z = 0 ] = v ; console . log ( z ); //0 // in questo caso con l'operatore \"...\" (rest) creo un sottoarray con le sole temperature dalle 9 in poi let [,,,... dalle_9_in_poi ] = temperature for ( temp of dalle_9_in_poi ) console . log ( temp ); //9 8 5 4 -1 Lezione 17 Map Object L'oggetto Map \u00e8 una collezione di elementi chiave / valore . Qualsiasi valore (sia oggetti che valori primitivi) pu\u00f2 essere utilizzato come chiave o come valore. Qualche metodo applicabile all'oggetto Map : set(key, value) : Aggiunge un elemento all'oggetto Map specificando la chiave di accesso e il valore has(key) : Ritorna un boolean true/false in base al risultato della ricerca di un elemento con una particolare key . get(key) : Ritorna il valore corrispondente alla chiave key delete(key) : Elimina l'elemento con la chiave key clear() : Elimina tutto il contenuto dalla mappa Propriet\u00e0 dell'oggetto Map : size : Ritorna il numero di elementi in una mappa //Creo un nuovo oggeto Map vuoto let capitali = new Map (); //Il metodo set(key, value) aggiunge elementi indicando una coppia chiave valore capitali . set ( \"Italia\" , \"Roma\" ); capitali . set ( \"Francia\" , \"Parigi\" ); console . log ( capitali ); //Map(2) {\"Italia\" => \"Roma\", \"Francia\" => \"Parigi\"} console . log ( capitali . size ); //2 //Il punto di forza di Map \u00e8 che posso ricercare certi valori attraverso la Key nazione_richiesta = prompt ( \"Quale nazione?\" ); //Francia if ( capitali . has ( nazione_richiesta ) ){ console . log ( `La capitale \u00e8 ${ capitali . get ( nazione_richiesta ) } ` ); } //La capitale \u00e8 Parigi else { console . log ( \"Nazione non trovata\" ); } capitali . clear (); console . log ( capitali ); //Map(0) {} Posso aggiungere diversi elementi con la notazione ad array, anzi direi a Matrice visto che ogni elemento \u00e8 formato da una coppia chiave/valore //Fornisco al costruttore di Map() come parametro un oggetto iterabile let capitali = new Map ([ [ \"Italia\" , \"Roma\" ], [ \"Francia\" , \"Parigi\" ], [ \"Inghilterra\" , \"Londra\" ] ]); nazione_richiesta = prompt ( \"Quale nazione vuoi eliminare?\" ); //Se nazione_richiesta \u00e8 tra quelle specificate nell'oggetto <capitali> la eliminer\u00e0 if ( capitali . has ( nazione_richiesta ) ){ capitali . delete ( nazione_richiesta ); console . log ( ` ${ nazione_richiesta } eliminata ...` ); } else { console . log ( \"Nazione non trovata\" ); } Posso inserire qualsiasi tipo di elemento in un oggetto di tipo Map. //Creo un oggetto di tipo Map e identificativo \"listino\" vuoto let listino = new Map (); //Creo un oggetto che utilizzer\u00f2 come chiave dell'oggetto listino let prodotto = { codice : 100 , descrizione : { breve : \"bla bla\" , lunga : \"bla bla bla bla\" } } //Creo un oggetto che utilizzer\u00e0\u00ec\u00f2 come valore dell'oggetto listino let prezzo = { costo_base : 145 , sconto : 5 , metodi_pagamento : { cash : true , carta : true , paypal : false } } //Aggiungo un elemento all'oggetto listino. //Prodotto e prezzo sono due oggetti diversi listino . set ( prodotto , prezzo ); if ( listino . has ( prodotto ) ) { valore = listino . get ( prodotto ); console . log ( valore . costo_base ); //145 if ( valore . metodi_pagamento . carta ){ console . log ( \"Pagabile con carta di credito\" ); //Pagabile con carta di credito } } Iterazione Map Object Il metodo key() restituisce un iteratore sulle chiavi let capitali = new Map ([ [ \"Italia\" , \"Roma\" ], [ \"Francia\" , \"Parigi\" ], [ \"Inghilterra\" , \"Londra\" ] ]); //iterare sugli elementi for ( let elemento of capitali ) { console . log ( elemento ); } //elemento[0]=nazione, [1]=capitale /* [\"Italia\", \"Roma\"] [\"Francia\", \"Parigi\"] [\"Inghilterra\", \"Londra\"] */ //iterare sulle chiavi //key() restituisce un iteratore sulle chiavi for ( let chiave of capitali . keys ()) { console . log ( chiave ); } /* Italia Francia Inghilterra */ Esempio di iterazione applicando il destructuring: let listino = new Map (); //Chiave let prodotto = { codice : 100 , descrizione : { breve : \"bla bla\" , lunga : \"bla bla bla bla\" } } //Valore let prezzo = { costo_base : 145 , sconto : 5 , metodi_pagamento : { cash : true , carta : true , paypal : false } } listino . set ( prodotto , prezzo ); //iterare sugli elementi, applico il destructuring for ( let [ chiave , valore ] of listino ) //listino.entries()) { console . log ( chiave ); } //Restituisce prodotto /* {codice: 100, descrizione: {\u2026}} codice: 100 descrizione: {breve: \"bla bla\", lunga: \"bla bla bla bla\"} */ Lezione 18 Set L'oggetto Set permette di memorizzare valori unici di qualunque tipo, che siano valori primitivi o riferimenti ad oggetti. Gli oggetti Set sono collezioni di valori, quindi \u00e8 possibile iterare i valori nel loro ordine di inserimento. Un valore in un Set pu\u00f2 occorrere solo una volta; \u00e8 quindi unico nella collezione. A differenza di un semplice array presenta le seguenti differenze: Un oggetto Set rifiuta elementi duplicati. E' utile quindi per raggruppare elementi in una lista univoca Non consente un accesso indicizzato cio\u00e8 per posizione come negli array Non si applicano i metodi applicabili agli array ma metodi simili all'oggetto Map Vale la property size e i metodi has() e clear() , add() simili per l'oggetto Map let nazioni = new Set ([ \"Italia\" , \"Francia\" , \"Inghilterra\" ]); nazioni . add ( \"Ungheria\" ); //Metodo per aggiungere un elemento //La lista degli elementi rimane inalterata poich\u00e8 l'elemento <Francia> \u00e8 gi\u00e0 presente nazioni . add ( \"Francia\" ); for ( let nazione of nazioni ) { console . log ( nazione );} /* Italia Francia Inghilterra Ungheria */ Conversione di un Oggetto Map / Set in un Array Per la conversione di un Oggetto Map / Set in un array \u00e8 possibile sfruttare l'operatore \"...\" (rest). Questo operatore in generale si applica ad ogni elemento iterabile e restituisce un array di elementi derivati dall'iterazione sull'iteratore selezionato let nazioni = new Set ([ \"Italia\" , \"Francia\" , \"Inghilterra\" ]); nazioni . add ( \"Ungheria\" ); //Metodo per aggiungere un elemento //l'operatore \"...\" \u00e8 anche detto spread operator //In questo caso andr\u00e0 ad iterare ogni elemento di <nazioni> aggiungendolo all'array <vNazioni> let arrayNazioni = [... nazioni ]; //arrayNazioni adesso \u00e8 un array ottenuto da un oggetto Set console . log ( arrayNazioni [ 2 ]); Lezione 19 Dom Manipulation Quando programmi pagine web e app, una delle cose pi\u00f9 comuni che vorrai fare \u00e8 manipolare in qualche modo la struttura del documento. Questo di solito viene fatto utilizzando il Document Object Model (DOM), un insieme di API per il controllo dell'HTML e delle informazioni di stile che fa un uso intenso dell'oggetto Document. In questo articolo vedremo come utilizzare il DOM in dettaglio, insieme ad altre API interessanti che possono alterare il tuo ambiente in modi interessanti. I browser web sono software molto complicati con molte parti mobili, molte delle quali non possono essere controllate o manipolate da uno sviluppatore web che utilizza JavaScript. Potresti pensare che tali limitazioni siano una brutta cosa, ma i browser sono bloccati per buone ragioni, principalmente incentrate sulla sicurezza. Immagina se un sito Web potesse accedere alle tue password memorizzate o ad altre informazioni sensibili e accedere ai siti Web come se fossi tu.. Nonostante i limiti, le API Web ci danno ancora accesso a molte funzionalit\u00e0 che ci consentono di fare molte cose con le pagine web. Window \u00e8 la scheda del browser in cui viene caricata una pagina web; questo \u00e8 rappresentato in JavaScript dall'oggetto Window . Usando i metodi disponibili su questo oggetto puoi fare cose come restituire le dimensioni della finestra (vedi Window.innerWidth e Window.innerHeight ), manipolare il documento caricato in quella finestra, memorizzare i dati specifici di quel documento sul lato client (ad esempio usando un database locale o un altro meccanismo di archiviazione), collegare un gestore di eventi alla finestra corrente e altro ancora. Il navigatore rappresenta lo stato e l'identit\u00e0 del browser (ovvero lo user-agent) cos\u00ec come esiste sul web. In JavaScript, questo \u00e8 rappresentato dall'oggetto Navigator . Puoi utilizzare questo oggetto per recuperare elementi come la lingua preferita dell'utente, un flusso multimediale dalla webcam dell'utente, ecc. Il documento (rappresentato dal DOM nei browser) \u00e8 la pagina effettiva caricata nella finestra ed \u00e8 rappresentato in JavaScript dall'oggetto Document . \u00c8 possibile utilizzare questo oggetto per restituire e manipolare le informazioni sull'HTML e il CSS che compongono il documento, ad esempio ottenere un riferimento a un elemento nel DOM , modificarne il contenuto del testo, applicarvi nuovi stili, creare nuovi elementi e aggiungerli a l'elemento corrente come figli, o addirittura eliminarlo del tutto. In questo articolo ci concentreremo principalmente sulla manipolazione del DOM. DOM - Document Object Model Il documento attualmente caricato in ciascuna delle schede del browser \u00e8 rappresentato da un modello di oggetti (document object model). E' rappresentato tramita una \"struttura ad albero\" creata dal browser che consente di accedere facilmente alla struttura HTML dai linguaggi di programmazione. Fonte: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents Per la manipolazione del DOM ci torna utile il paradigma di programmazione orientato agli oggetti di Javascript. Infatti il DOM non \u00e8 altro che un enorme oggetto con diverse property e metodi console . log ( document . all ); //stampa tutti i nodi all'interno della pagina htmlconsole.log(document.body); console . log ( document . head ); //Stampa l'oggetto <head> console . log ( document . body ); //Stampa l'oggetto <body> Lezione 20 DOM - Selettori Per manipolare un elemento all'interno del DOM, \u00e8 necessario prima selezionarlo e memorizzare un riferimento ad esso all'interno di una variabile. In questo esempio selezioneremo l'elemento h1 e successivamente applicheremo dello style all'elemento, colorandolo di rosso <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > DOM: Document Object Model </ h1 > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > let h1 = document . querySelector ( \"h1\" ); h1 . style . color = 'red' ; </ script > </ body > </ html > Metodi di selezione di elementi html Vediamo i metodi per selezionare gli elementi in JS. - document.getElementById(myID) : Selziona tutti gli elementi con un particolare id = \"myID\" - document.getElementsByClassName(myClassName) : Selziona tutti gli elementi che appartengono a una particolare classe, class = \"myClassName\" - document.getElementsByTagName(\"tag\") : Selziona tutti gli elementi che hanno particolare \"tag\" HTML - document.querySelector(any) : Selziona la prima occorrenza dell' elemento spcecificato attraverso la classe , l' id oppure il tag . - Selezione attraverso la classe: Si usa il simbolo \".\" seguito dal nome della classe, esempio: \".myClassName\" - Selezione attraverso l'id: Si usa il simbolo \"#\" seguito dal nome della classe, esempio: \"#myID\" - Selezione attraverso il tag HTML: \"h1\" - document.querySelectorAll : Selziona tutti gli elementi spcecificati attraverso la classe , l' id oppure il tag . Valgono le stesse regole di selezione viste per il querySelector <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < h1 > La manipolazione </ h1 > < ul > < li id = \"FRIST-ELEM\" > elemento UNO </ li > < li class = \"myClass\" > elemento DUE </ li > < li class = \"myClass\" > elemento TRE </ li > </ ul > < script > document . getElementById ( \"FRIST-ELEM\" ); //Selezione di \"elemento UNO\" document . getElementsByClassName ( \"myClass\" ); //Selezione di \"elemento DUE\", \"elemento TRE\" document . getElementsByClassName ( \"myClass\" )[ 0 ]; //Selezione di \"elemento DUE\" document . getElementsByTagName ( \"h1\" ); //Selezione di \"DOM: Document Object Manipulation\", \"La manipolazione\" // document.querySelector document . querySelector ( \".myClass\" ); //Selezione di \"elemento DUE\" document . querySelector ( \"#FRIST-ELEM\" ); //Selezione di \"elemento UNO\" document . querySelector ( \"h1\" ); //Selezione di \"DOM: Document Object Manipulation\" // document.querySelectorAll document . querySelectorAll ( \".myClass\" ); //Selezione di \"elemento DUE\", \"elemento TRE\" document . querySelectorAll ( \"#FRIST-ELEM\" ); //Selezione di \"elemento UNO\" document . querySelectorAll ( \"h1\" ); ////Selezione di \"DOM: Document Object Manipulation\", \"La manipolazione\" //last-child & nth-child(i) document . querySelector ( 'li:last-child' ); //li:last-child seleziona l'ultimo elemento <li> document . querySelector ( 'li:nth-child(2)' ). style . color = 'brown' ; //li:nth-child(i) seleziona l'i-esimo elemento <li> </ script > </ body > </ html > E' possibile utilizzare l'operatore [index] per indicizzare la collezione di elementi HTML selezionati. Nell'esempio di sopra infatti ho selezionato soltanto \"elemento DUE\" utilizzando document.getElementsByClassName(\"myClass\")[0] . Quando ci sono pi\u00f9 elementi selezionati vengono create delle collezioni di oggetti. Nel caso si utilizzi querySelectorAll verr\u00e0 restituita una collezione NodeList che dal punto di vista di Javascript \u00e8 un array. Se tuttavia utilizzassi come selettore ad esempio getElementsByTagName verrebbe restituito un HTML Collection che non \u00e8 un array e se volessi usarlo come tale sarebbe necessaria una conversione let myLI = document . querySelectorAll ( \"li\" )[ 0 ]; /* myLI <li id=\u200b\"FRIST-ELEM\">\u200b\u2026\u200b</li>\u200b */ console . log ( typeof myLI ); //object //NODE LIST let myLIAll = document . querySelectorAll ( \"li\" ); console . log ( myLIAll ); //\u00e8 una collezione \"NodeList\", un array /* NodeList(3) [li#FRIST-ELEM, li.myClass, li.myClass] 0: li#FRIST-ELEM 1: li.myClass 2: li.myClass length: 3 __proto__: NodeList */ //Essendo un array posso applicare tutti i metodi applicabili agli array myLIAll . forEach (( elem , index ) => { //il metodo \"textContent\" assegna un valore testuale all'elemento, cambia il testo elem . textContent = 'nuovo testo in li' ; }); //HTML COLLECTION let MyH1All = document . getElementsByTagName ( \"h1\" ); console . log ( MyH1All ); //HTMLCollection(2) [h1, h1] -> NON E' UN ARRAY, Attenzione!! //Posso convertirlo in array utilizzando \"Array.from\" const listaArray = Array . from ( MyH1All ); console . log ( listaArray ); /* (2) [h1, h1] 0: h1 1: h1 length: 2 */ //A questo punto posso utilizzare tutte le propriet\u00e0 degli array listaArray . forEach (( elem , index ) => { elem . style . color = 'red' ; }); //Posso usare anche un ciclo iterativo standard for ( let i = 0 ; i < listaArray . length ; i += 2 ) { //Cambia il colore del background dell'elemento <h1> in giallo listaArray [ i ]. style . background = 'yellow' ; } Lezione 21 Dom - Child e Parent Data la struttura ad albero del DOM \u00e8 semplificato l'accesso ad elementi figli o padri di un dato elemento children : Accede agli elementi figli parentElement : Accede all'elemento padre <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < h1 > La manipolazione </ h1 > < ul > < li id = \"FRIST-ELEM\" > elemento UNO </ li > < li class = \"myClass\" > elemento DUE </ li > < li class = \"myClass\" > elemento TRE </ li > </ ul > < script > const ul = document . querySelector ( 'ul' ); //rappresenta tutti gli <li> contenuti come HTML collection console . log ( ul . children ); //HTMLCollection(3) [li#FRIST-ELEM, li.myClass, li.myClass, FRIST-ELEM: li#FRIST-ELEM] console . log ( ul . parentElement ); //Seleziona l'elemento parente quindi il <body> console . log ( ul . parentElement . parentElement ); //Seleziona l'elemento <html> cio\u00e8 il \"nonno\" //Rappresenta i figli in una NodeList (ottimo) ma considera come elementi anche eventuali elementi di formatazione //Poich\u00e8 gli <li> sono rappresentati a capo, uno sotto l'altro ci sono altri 4 elementi che rappresentano l'elemento \"a capo\" console . log ( ul . childNodes ); //NodeList(7) [text, li#FRIST-ELEM, text, li.myClass, text, li.myClass, text] </ script > </ body > </ html > DOM - Manipolazione dello stile degli elementi html La manipolazione statica dello stile degli elementi HTML non ha molto senso. Infatti \u00e8 possibile assegnare uno stile gi\u00e0 con CSS. Ha invece senso una manipolazione dinamica ovvero al verificarsi di un particolare evento classList permette di applicare dinamicamente una classe gi\u00e0 definita in formato CSS ma ancora non applicata a nessun elemento. Javascript funziona da ponte tra un elemento HTML e uno style CSS. E' infatti possibile aggiungere e rimuovere dinamicamente una classe da un elemento per aggiungere o rimuovere dello stile da quel dato elemento. classList.add(\"myClassName\") : Aggiunge la classe myClassName all'elemento selezionato classList.remove(\"myClassName\") : Rimuove la classe myClassName all'elemento selezionato classList.toggle(\"myClassName\") : Esegue il toggle della classe myClassName all'elemento selezionato, aggiungendola se non \u00e8 attiva e rimuovendola se \u00e8 attiva. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeFirstLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < h1 > La manipolazione </ h1 > < ul > < li id = \"FRIST-ELEM\" > elemento UNO </ li > < li class = \"myClass\" > elemento DUE </ li > < li class = \"myClass\" > elemento TRE </ li > </ ul > < script > var tag = document . getElementById ( \"FRIST-ELEM\" ); //Aggiungo la classe <classeFirstLi> all'elemento html associato a <tag>. //Aggiungo quindi anche tutte le proprit\u00e0 annesse alla classe <classeFirstLi>. tag . classList . add ( \"classeFirstLi\" ); //Applico lo stile all'elemento \"elemento UNO\" //Rimuovo la classe <classeFirstLi> tag . classList . remove ( \"classeFirstLi\" ); //Rimuovo lo stile all'elemento \"elemento UNO\" //Toggle della classe <classeFirstLi>. // Rimuovo la classe <classeFirstLi> se \u00e8 attiva, la aggiungo se non \u00e8 attiva tag . classList . toggle ( \"classeFirstLi\" ); //Applico lo stile all'elemento \"elemento UNO\" tag . classList . toggle ( \"classeFirstLi\" ); //Rimuovo lo stile all'elemento \"elemento UNO\" tag . classList . toggle ( \"classeFirstLi\" ); //Applico lo stile all'elemento \"elemento UNO\" </ script > </ body > </ html > Lezione 22 DOM - Manipolazione del testo degli elementi html textContent La propriet\u00e0 textContent dell'interfaccia Node rappresenta il contenuto del testo di un nodo e dei suoi discendenti innerText La propriet\u00e0 innerText dell'interfaccia HTMLElement rappresenta il contenuto di testo \"renderizzato\" di un nodo e dei suoi discendenti. Come getter, approssima il testo che l'utente otterrebbe se evidenziasse il contenuto dell'elemento con il cursore e poi lo copiasse negli appunti. Nota: innerText \u00e8 facilmente confuso con Node.textContent , ma ci sono differenze importanti tra i due. Fondamentalmente, innerText \u00e8 a conoscenza dell'aspetto renderizzato del testo, mentre textContent non lo \u00e8. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeFirstLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < p > Lorem ipsum, dolor sit amet consectetur adipisicing elit. < strong > Doloremque, modi? </ strong ></ p > < script > var p = document . querySelector ( \"p\" ); //<textContent> //<textContent> restituisce una stringa del testo contenuto dell'elemento // convertendo anche il contenuto di eventuali elementi figli in puro testo console . log ( p . textContent ); //\"Lorem ipsum, dolor sit amet consectetur adipisicing elit. Doloremque, modi?\" //E' possibile cambiare la stringa del tag selezionato semplicemente con l'assegnazione p . textContent = \"lorem ps htigh manulip ase travit\" ; console . log ( p . textContent ); //\"lorem ps htigh manulip ase travit\" //<innerHTML> //<innerHTML> restituisce l'elemento HTML mantenendo la formattazione HTML console . log ( p . innerHTML ); //\"Lorem ipsum, dolor sit amet consectetur adipisicing elit. <strong>Doloremque, modi?</strong>\" //Con <innerHTML> \u00e8 possibile inserire tag HTML p . innerHTML = \"<strong>ciao</strong>\" ; console . log ( p . innerHTML ); //<strong>ciao</strong>\" </ script > </ body > </ html > DOM - Manipolazione degli attributi html getAttribute e setAttribute sono metodi di lettura e scrittura di attributi di elementi html. getAttribute ( \"attribute\" ); //ritorna il valore dell'attributo \"attribute\" setAttribute ( \"attribute\" , \"value\" ); //Assegna il valore \"value\" all'attributo \"attribute\" Nell'esempio seguente cambier\u00f2 l'immagine di un elemento <img> e il link di un elemento <a> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeFirstLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < div > < img src = \"https://www.corriere.it/methode_image/2020/04/09/Spettacoli/Foto%20Spettacoli%20-%20Trattate/MILANO_20100328_CORSERA_43_0_0-k9PF-U3180411917161aAH-656x492@Corriere-Web-Sezioni.jpg\" > </ div > < div > < a href = \"https://www.google.com/maps\" > link </ a > </ div > < script > //Modifico l'immagine modificandone l'attributo <src> //Seleziono l'elemento \"img\" var img = document . querySelector ( \"img\" ); //<getAttribute(\"attribute\")> restituisce il valore dell'attributo passato come argomento. img . getAttribute ( \"src\" ); // \"https://www.corriere.it/methode_image/2020/04/09/Spettacoli/Foto%20Spettacoli%20-%20Trattate/MILANO_20100328_CORSERA_43_0_0-k9PF-U3180411917161aAH-656x492@Corriere-Web-Sezioni.jpg\" //<setAttribute(\"attribute\", \"value\")> consente di cambiare il valore di un attributo img . setAttribute ( \"src\" , \"https://www.pensalibero.it/wp-content/uploads/2010/02/chopin1.jpg\" ); //ho cambiato l'immagine img . getAttribute ( \"src\" ); //https://www.pensalibero.it/wp-content/uploads/2010/02/chopin1.jpg //Modifico il link, modificandone l'attributo <href> //Seleziono l'elemento \"a\" var a = document . querySelector ( \"a\" ); //<getAttribute(\"attribute\")> restituisce il valore dell'attributo passato come argomento. a . getAttribute ( \"href\" ); //\"https://www.google.com/maps\" //<setAttribute(\"attribute\", \"value\")> consente di cambiare il valore di un attributo a . setAttribute ( \"href\" , \"https://mail.google.com\" ); //Ho cambiato il link a . getAttribute ( \"href\" ); //\"https://mail.google.com\" </ script > </ body > </ html > Lezione 23 DOM - Creazione di Un elemento In un documento HTML, il metodo document.createElement() crea l'elemento HTML specificato da tagName o un HTMLUnknownElement se tagName non viene riconosciuto. Nell'esempio successivo creeremo un elemento <li> e lo piazzeremo in coda ad una <ul> gi\u00e0 esistente. Faremo uso anche del metodo appendChild() e del metodo createTextNode() Il metodo Node.appendChild() aggiunge un nodo alla fine dell'elenco di figli di un nodo genitore specificato. Se il figlio dato \u00e8 un riferimento a un nodo esistente nel documento, appendChild() lo sposta dalla sua posizione corrente alla nuova posizione (non \u00e8 necessario rimuovere il nodo dal suo nodo padre prima di aggiungerlo ad un altro nodo). A questo link c'\u00e8 un'importante discussione tra l'uso di createTextNode() e textContent : https://stackoverflow.com/questions/31643204/textnode-or-textcontent <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < script > //creo un elemento <li> vuoto const myLi = document . createElement ( 'li' ); console . log ( myLi ); //<li></li> //Inserisco del testo nell'elemento <li> myLi . textContent = 'Elemento QUATTRO' ; console . log ( myLi ); //<li><Elemento QUATTRO/li> //Aggiungo in coda l'elemento <li> a <ul> document . querySelector ( 'ul' ). appendChild ( myLi ); //Aggiungo una classe.. e lo stile annesso myLi . className = \"classeLastLi\" ; </ script > </ body > </ html > DOM - Rimpiazzo di un elemento Il metodo Node.replaceChild () sostituisce un nodo figlio all'interno del nodo (genitore) specificato. Notare l'ordine degli argomenti idiosincratico (nuovo prima del vecchio). ChildNode.replaceWith () potrebbe essere pi\u00f9 facile da leggere e utilizzare. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < script > //Creo un nuovo <li> const nuovoLi = document . createElement ( 'li' ); //Aggiungo del testo dentro <li> nuovoLi . appendChild ( document . createTextNode ( 'nuovo li' )); // equivale a \"nuovoLi.textContent = 'nuovo li';\" //Seleziono l'elemento che voglio rimpiazzare const vecchioLi = document . getElementsByTagName ( 'li' )[ 1 ]; //Selziono l'elemento padre dell'elemento che voglio rimpiazzare */ const ul = document . querySelector ( 'ul' ); //replaceChild(new,old) permette di rimpiazzare un elemento figlio //specificando come parametri il nuovo elemento e il vecchio elemento (quello da rimpiazzare) ul . replaceChild ( nuovoLi , vecchioLi ); </ script > </ body > </ html > DOM - ELiminazione di un elemento Il metodo Node.removeChild () rimuove un nodo figlio dal DOM e restituisce il nodo rimosso. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < script > /** Si possono cancellare i figli attraverso il padre */ /** Seleziono il padre */ const ulParent = document . querySelector ( 'ul' ); /** Seleziono tutti gli <li> e li metto in un contenitore che sar\u00e0 un array di <li> */ const listitem = document . querySelectorAll ( 'li' ); console . log ( listitem ); ulParent . removeChild ( listitem [ 2 ]); //rimuovo \"Elemento TRE\" //Rimuove tutti gli elementi <child> //La property <firstChild> restituisce il primo elemento \"child\" e \"null\" se non ci sono elementi child while ( ulParent . firstElementChild ){ ulParent . removeChild ( ulParent . firstElementChild ); } </ script > </ body > </ html > Property firstChild : La propriet\u00e0 di sola lettura Node.firstChild restituisce il primo figlio del nodo nell'albero o null se il nodo non ha figli. Se il nodo \u00e8 un documento, restituisce il primo nodo nell'elenco dei suoi figli diretti. Lezione 24 DOM Events Vengono trasmessi eventi per notificare al codice eventi accaduti. Ogni evento \u00e8 rappresentato da un oggetto basato su un 'interfaccia Event e pu\u00f2 avere campi e / o funzioni personalizzati aggiuntivi utilizzati per ottenere ulteriori informazioni su quanto accaduto. Gli eventi possono rappresentare qualsiasi cosa, dalle interazioni utente di base alle notifiche automatiche di eventi che accadono nel modello di rendering. Alla pagina: https://developer.mozilla.org/en-US/docs/Web/Events E' possibile consultare i cos\u00ecdetti Standard Events , eventi comuni ad ogni tipo di browser definiti dalla specifica standard Web. Metodo addEventListener Il metodo EventTarget addEventListener() imposta una funzione che verr\u00e0 chiamata ogni volta che l'evento specificato viene consegnato all'elemento di destinazione. I target comuni sono Element, Document, e Window, ma la destinazione pu\u00f2 essere qualsiasi oggetto che supporti eventi (come XMLHttpRequest). addEventListener() funziona aggiungendo una funzione o un oggetto che implementa EventListener all'elenco di listener di eventi per il tipo di evento specificato sul EventTarget sul quale \u00e8 chiamato. target . addEventListener ( type , listener [, options ]); Parametri: - type : Una stringa sensibile al maiuscolo/minuscolo che rappresenta il tipo di evento da assegnare. Alcuni tipi di eventi, click , dblclick , cut , scroll , compositionstart , blur .. - listener : L'oggetto che riceve una notifica (un oggetto che implementa l'interfaccia Event) quando si verifica un evento del tipo specificato. Questo deve essere un oggetto che implementa l'interfaccia EventListener, o una funzione. Vedi Il callback del listener di eventi per i dettagli sul callback stesso. Fonte: https://developer.mozilla.org/it/docs/Web/API/Element/addEventListener#Il_callback_del_listener_di_eventi Vedremo qualche evento attraverso gli esempi: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input id = \"changeColor\" type = \"button\" value = \"OK\" > < script > var input = document . querySelector ( \"#changeColor\" ); //Seleziono il primo <li> var ulChild = document . querySelector ( \"ul\" ). firstElementChild ; //addEventListener(\"eventType\", function) //aggiunge un evento all'elemento <input>. //Al click del mouse sull'elemento <input> viene eseguita la funzione anonima //che in questo caso esegue il toggle della classe \"classeLi\" sul primo elemento <li> input . addEventListener ( \"click\" , function (){ ulChild . classList . toggle ( \"classeLi\" ); }) </ script > </ body > </ html > Vediamo un esempio pi\u00f9 interessante. In questo esempio assegneremo lo stile agli elementi <li> ogni volta che schiacceremo il tasto OK a partire dal primo elemento. Una volta che lo stile \u00e8 applicato a tutti gli elementi, schiacciando nuovamente il tasto andremo a togliere lo stile a tutti gli elementi partendo dal primo. Per applicare e togliere stile utilizzeremo classList.toggle(\"myClassName) gi\u00e0 visto qualche lezione fa. Utilizzeremo anche firstElementChild gi\u00e0 visto e nextElementSibling che restituisce l'elemento successivo a quello attualmente puntato dal figlio. nextElementSibling La propriet\u00e0 di sola lettura NonDocumentTypeChildNode.nextElementSibling restituisce l'elemento immediatamente successivo a quello specificato nell'elenco dei figli del suo genitore o null se l'elemento specificato \u00e8 l'ultimo nell'elenco. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input id = \"changeColor\" type = \"button\" value = \"OK\" > < script > var input = document . querySelector ( \"#changeColor\" ); var ulChild = document . querySelector ( \"ul\" ). firstElementChild ; input . addEventListener ( \"click\" , function (){ if ( ulChild !== null ){ ulChild . classList . toggle ( \"classeLastLi\" ); ulChild = ulChild . nextElementSibling ; } else { ulChild = document . querySelector ( \"ul\" ). firstElementChild ; ulChild . classList . toggle ( \"classeLastLi\" ); ulChild = ulChild . nextElementSibling ; } }) </ script > </ body > </ html > Non \u00e8 necessario schiacciare elementi <input type=\"button\"> . Possono essere utilizzati tutti gli elementi html. In questo esempio associeremo un evento ad ogni elemento <li> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input id = \"changeColor\" type = \"button\" value = \"OK\" > < script > //Seleziono tutti i <li> var listaLi = document . querySelectorAll ( \"li\" ); console . log ( listaLi ); //creo un array di <li> //Itero su ogni <li> for ( var i = 0 ; i < listaLi . length ; i ++ ){ //aggiungo un evento ad ogni li. Premendo sull'elemento <li> si applicher\u00e0/toglier\u00e0 lo style definito da \"classeLastLi\" listaLi [ i ]. addEventListener ( \"click\" , function (){ this . classList . toggle ( \"classeLastLi\" ); }) } </ script > </ body > </ html > this: this in questo caso rappresenta l'elemento i-esimo a cui \u00e8 posizionato il listener cio\u00e8 listaLi[i] . Oltre alla funzione anonima, posso definire anche una funzione esterna al verificarsi di un certo evento. In questo esempio cambieremo il testo al Titolo con un testo inserito dall'utente in una casella testuale <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input type = \"text\" id = \"newTitle\" > < input id = \"changeTitle\" type = \"button\" value = \"Cambia Titolo\" > < script > var input = document . querySelector ( \"#changeTitle\" ); var h1 = document . querySelector ( \"h1\" ); function changeTitle () { testo = document . querySelector ( \"#newTitle\" ); h1 . textContent = testo . value ; } input . addEventListener ( \"click\" , changeTitle ); </ script > </ body > </ html > Nel prossimo esempio avremo una casella di testo in cui sar\u00e0 possibile inserire del testo. Facendo doppio click su un elemento qualsiasi della pagina html andr\u00e0 a cambiare il testo dell'elemento cliccato <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input type = \"text\" id = \"newTitle\" > < script > var listaLI = document . querySelectorAll ( \"li\" ); //crea un array di <li> var h1 = document . querySelector ( \"h1\" ); //seleziono <h1> function changeText () { testo = document . querySelector ( \"#newTitle\" ); this . textContent = testo . value ; this . cla } for ( let i = 0 ; i < listaLI . length ; i ++ ){ listaLI [ i ]. addEventListener ( \"dblclick\" , changeText ); } h1 . addEventListener ( \"dblclick\" , changeText ); </ script > </ body > </ html > Lezione 25 Prevent Default Il metodo preventDefault () dell'interfaccia Event dice al programma utente che se l'evento non viene gestito esplicitamente, la sua azione predefinita non dovrebbe essere eseguita come sarebbe normalmente. L'evento continua a propagarsi come al solito, a meno che uno dei suoi listener di eventi non chiami stopPropagation () o stopImmediatePropagation () , entrambi i quali terminano immediatamente la propagazione. Fonte: https://developer.mozilla.org/it/docs/Web/API/Event/preventDefault Consideriamo il seguente esempio. Al click di ogni link vorrei che venisse stampato per esteso il link nella casella testuale. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > li { margin : 2 px ; } input { margin : 2 px ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > < a href = \"https://www.youtube.com/\" > youtube </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://developer.mozilla.org/en-US/\" > MDN </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://www.google.com/maps\" > maps </ a >< br > < input type = \"text\" > </ li > </ ul > < script > var linkList = document . querySelectorAll ( \"a\" ); for ( let i = 0 ; i < linkList . length ; i ++ ) { linkList [ i ]. addEventListener ( \"click\" , function (){ //this rappresenta l'elemento <a> i-esimo //this.parentElement === <li> //this.parentElement.lastElementChild === <input> input = this . parentElement . lastElementChild ; input . value = this . href ; }); } </ script > </ body > </ html > Se avete provato ad eseguire il codice noterete che al click sull'elemento <a> , la pagina verr\u00e0 rendirizzata sul link corrispondente, in poche parole non funziona. Questo accade perch\u00e8 il comportamento di default di <a> tag \u00e8 quello di saltare alla pagina specificata dall'attributo href . Per inibire il comportamento di default di qualsiasi elemento si utilizza il metodo prevenDefault() applicato all'oggetto ricevuto come parametro (opzionale) dal listener. Normalmente questo oggetto viene indicato con e . Qui sotto riporto l'esempio funzionante. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > li { margin : 2 px ; } input { margin : 2 px ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > < a href = \"https://www.youtube.com/\" > youtube </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://developer.mozilla.org/en-US/\" > MDN </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://www.google.com/maps\" > maps </ a >< br > < input type = \"text\" > </ li > </ ul > < script > var linkList = document . querySelectorAll ( \"a\" ); for ( let i = 0 ; i < linkList . length ; i ++ ) { linkList [ i ]. addEventListener ( \"click\" , function ( e ){ //this rappresenta l'elemento <a> i-esimo //this.parentElement === <li> //this.parentElement.lastElementChild === <input> input = this . parentElement . lastElementChild ; input . value = this . href ; e . preventDefault (); }); } </ script > </ body > </ html > Che cos'\u00e8 esattamente l'oggetto ricevuto come unico parametro \"e\"? L'interfaccia Event (oggetto \"e\") I gestori degli eventi possono essere assegnati a vari elementi DOM. Quando un dato evento si verifica, un oggetto evento viene creato dinamicamente e passato agli event listener che permettono di gestirlo. L'interfaccia Event del DOM \u00e8 quindi accessibile dalla funzione che gestisce l'evento, alla quale viene passato un oggetto evento come primo e unico argomento ( e ). Fonte: https://developer.mozilla.org/en-US/docs/Web/API/Event //.. console . log ( e ); /** MouseEvent {isTrusted: true, screenX: 196, screenY: 208, clientX: 196, clientY: 105, \u2026} altKey: falsebubbles: truebutton: 0buttons: 0cancelBubble: falsecancelable: trueclientX: 196clientY: 105composed: truectrlKey: falsecurrentTarget: nulldefaultPrevented: falsedetail: 1eventPhase: 0fromElement: nullisTrusted: truelayerX: 196layerY: 105metaKey: falsemovementX: 0movementY: 0offsetX: 149offsetY: 12pageX: 196pageY: 105path: (8) [a, li#ciao.myClass, ul, div, body, html, document, Window]relatedTarget: nullreturnValue: truescreenX: 196screenY: 208shiftKey: falsesourceCapabilities: InputDeviceCapabilities {firesTouchEvents: false}srcElement: atarget: atimeStamp: 125025.42499999981toElement: atype: \"click\"view: Window {window: Window, self: Window, document: document, name: \"\", location: Location, \u2026}which: 1x: 196y: 105__proto__: MouseEvent */ L'oggetto \"Event\" fornisce un sacco di informazioni sulla natura dell'evento scatenato. Al sito: https://developer.mozilla.org/it/docs/Web/API/Event \u00e8 possibile visionare ogni propriet\u00e0 e ogni metodo dell'oggetto Event (e) Lezione 26 Approfondimento type event Vediamo adesso un'insieme di eventi typeEvent mouse/tastiera tra i pi\u00f9 usati. Ricordo che typeEvent \u00e8 il primo parametro del metodo addEventListener() La lista completa la troviamo al link: https://developer.mozilla.org/it/docs/Web/API/Element HTMLelement . addEventListener ( 'typeEvent' , function (){ //code }); Eventi mouse mousedown : Scatta l'evento al click del mouse sull'elemento mouseup : Scatta l'evento al rilascio del click del mouse sull'elemento mouseover : Scatta l'evento passando sopra l'elemento con il mouse mouseout : Scatta l'evento non appena esco dal campo dall'elemento con il mouse mousemove : Scatta l'evento ogni volta che mi muovo all'interno dell'elemento con il mouse Nell'esempio successivo, utilizzer\u00f2 gli eventi mousemove , mouseout e le propriet\u00e0 offsetX , offsetY dell'oggetto Event passato come argomento al listener utilizzate per restituire la posizione X/Y dell'evento scatenato. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . colorRed { color : red ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < div > < textarea id = \"textAreaEvent\" cols = \"60\" rows = \"30\" > Muovi il mouse all'interno di quest'area </ textarea > < div > < table > < tr > < td > Pos-x: </ td > < td >< input id = \"pos-X\" type = \"text\" ></ td > </ tr > < tr > < td > Pos-y: </ td > < td >< input id = \"pos-Y\" type = \"text\" ></ td > </ tr > </ table > </ div > </ div > < script > var textAreaEvent = document . querySelector ( \"#textAreaEvent\" ); var posX = document . querySelector ( \"#pos-X\" ); var posY = document . querySelector ( \"#pos-Y\" ); textAreaEvent . addEventListener ( \"mousemove\" , function ( e ){ posX . value = e . offsetX ; posY . value = e . offsetY ; posX . classList . remove ( \"colorRed\" ) posY . classList . remove ( \"colorRed\" ) }) textAreaEvent . addEventListener ( \"mouseout\" , function () { posX . classList . add ( \"colorRed\" ) posY . classList . add ( \"colorRed\" ) }) </ script > </ body > </ html > Finch\u00e8 il mouse si muove all'interno della textarea scatter\u00e0 l'evento mousemove che restituir\u00e0 posizione X/Y del mouse. Non appena si esce da textarea scatter\u00e0 l'evento mouseout colorando di rosso il valore della posizione X/Y. Aprrofondimento eventi tastiera e input File html < body > < h3 > evento JS </ h3 > < div > < p > Lorem ipsum, dolor sit amet consectetur adipisicing elit. < strong > Doloremque, modi? </ strong ></ p > < ul > <!-- #region Importante mettere '#' come valore di href perch\u00e8 evita il comportamento di default del link che come ricordiamo tenderebbe a raggiungere il link specificato da href ma nel caso di un bottone premuto voglio stabilirlo io cosa deve accadere--> < li id = \"ciao\" class = \"myClass\" > elemento UNO < a href = \"#\" > click me </ a ></ li > < li class = \"classe\" > elemento DUE </ li > < li class = \"classe\" > elemento TRE </ li > </ ul > < form id = 'form' action = \"\" > < input id = 'input' type = \"text\" > </ form > </ div > < script src = \"08_mainDOM.js\" ></ script > </ body > </ html > Eventi Tastiera 'keydown': genera un evento alla pressione di ogni tasto digitato 'keyup': genera un evento al rilascio di ogni tasto digitato 'keypress': genera un evento alla pressione di ogni tasto digitato (alcuni tasti speciali non sono considerati) 'focus': genera un evento quando aziono il focus sull'elemento (spesso equivale al click) 'blur': genera un evento quando esco dalla zona di focus dell'elemento 'copy': genera un evento al comando \"ctrl + c\", copia 'paste': genera un evento al comando \"ctrl + v\", incolla L'esempio seguente permette di contare il numero di tasti premuti di due caselle di input \"Nome\" e \"Cognome\" visualizzando il conteggio in una casella testuale \"Tasti Premuti\". Il conteggio si azzera con il focus sulla casella testuale \"Tasti Premuti\". Appare un alert con la scritta \"Non \u00e8 possibile usare la funzione copia!\" quando si tenta di eseguire il comando Ctrl + c (copia) all'interno della casella \"Nome\" o \"Cognome\". Inoltre, abbandonando il focus sulle caselle di input \"Nome\" o \"Cognome\" il testo digitato si colorer\u00e0 di rosso ma non appena torneremo alla digitazione il testo torner\u00e0 di colore nero. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . colorRed { color : red ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < table > < tr > < td > Tasti Premuti: </ td > < td >< input type = \"text\" id = \"pressed-key\" ></ td > </ tr > < tr > < td > Nome: </ td > < td >< input type = \"text\" id = \"name\" ></ td > </ tr > < tr > < td > Cognome: </ td > < td >< input type = \"text\" id = \"cognome\" ></ td > </ tr > </ table > < script > var form = [ document . querySelector ( \"#name\" ), document . querySelector ( \"#cognome\" )] var textPressedKey = document . querySelector ( \"#pressed-key\" ); Tasti Premuti var charInserted = 0 ; //alla pressione di un tasto nei campi \"Nome\" e \"Cognome\" verr\u00e0 aggiornato il conteggio dei caratteri //totali inseriti e tolto lo stile all' elemento che ha scatenato l'evento rimuovendo la classe \"colorRed\" function pressedKey (){ textPressedKey . value = String ( ++ charInserted ); this . classList . remove ( \"colorRed\" ); } //quando viene lasciato il focus dall'elemento viene aggiunto lo stile tramite la classe \"colorRed\" function changeColor (){ this . classList . add ( \"colorRed\" ); } //quando si tenta di lanciare il comando \"copia\" dai campi \"Nome\" e \"Cognome\" si genera un alert di errore function printErrorCopyMessage () { alert ( \"Non \u00e8 possibile usare la funzione copia!\" ); } //quando sposto il focus sull'elemento \"Tasti Premuti\" azzero il conteggio textPressedKey . addEventListener ( \"focus\" , function () { charInserted = 0 ; textPressedKey . value = String ( charInserted ); }) //Aggiungo eventi ai campi \"Nome\" e \"Cognome\" for ( elem of form ){ elem . addEventListener ( \"keydown\" , pressedKey ); elem . addEventListener ( \"blur\" , changeColor ); elem . addEventListener ( \"copy\" , printErrorCopyMessage ); } </ script > </ body > </ html > Lezione 27 Argomeni non trattati / da approfondire Typed Array : Gli array tipizzati JavaScript sono oggetti simili a array che forniscono un meccanismo per leggere e scrivere dati binari grezzi nei buffer di memoria. Come forse gi\u00e0 saprai, gli oggetti Array crescono e si riducono dinamicamente e possono avere qualsiasi valore JavaScript. I motori JavaScript eseguono ottimizzazioni in modo che questi array siano veloci. Utile per curare aspetti delicati come l'Endianess. Fonte: MDN - Typed Array Endianess. In informatica, endianness \u00e8 l'ordine o la sequenza di byte di una parola di dati digitali nella memoria del computer. L'Endianness \u00e8 principalmente espresso come big-endian (BE) o little-endian (LE) . Un sistema big-endian memorizza il byte pi\u00f9 significativo di una parola all'indirizzo di memoria pi\u00f9 piccolo e il byte meno significativo al pi\u00f9 grande. Un sistema little-endian, al contrario, memorizza il byte meno significativo all'indirizzo pi\u00f9 piccolo.L'Endianness pu\u00f2 anche essere usato per descrivere l'ordine in cui i bit vengono trasmessi su un canale di comunicazione, ad esempio, il big-endian in un canale di comunicazione trasmette prima i bit pi\u00f9 significativi. Il bit-endianness \u00e8 usato raramente in altri contesti. I protocolli Internet come TCP e IPV4 utilizzano lo schema little endian mentre i processori Intel utilizzano spesso la notazione big endian . Questo \u00e8 un problema reale da conoscere saper gestire Fonte: Wikipedia - Endianess Regular Expression Le espressioni regolari sono schemi usati per confrontare combinazioni di caratteri nelle stringhe. In JavaScript, le espressioni regolari sono anche oggetti. Questi pattern sono usati con i metodi exec() e test() della classe RegExp , e con i metodi match() , matchAll() , replace() , search() , e split() della classe String . Fonte: MDN - Espressioni_Regolari Moduli Fonte: MDN - JavaScript modules Eventi/Manipolazione DOM (programmazione asincrona, promis) Dom Manipulation Quando scrivi pagine web e app, una delle cose pi\u00f9 comuni che vorrai fare \u00e8 manipolare in qualche modo la struttura del documento. Questo di solito viene fatto utilizzando il Document Object Model (DOM), un insieme di API per il controllo dell'HTML e delle informazioni di stile che fa un uso intenso dell'oggetto Document. In questo articolo vedremo come utilizzare il DOM in dettaglio, insieme ad alcune altre API interessanti che possono alterare il tuo ambiente in modi interessanti. Fonte: MDN - Manipulating documents Javascript async function Una funzione asincrona \u00e8 una funzione dichiarata con la parola chiave asincrona. Le funzioni asincrone sono istanze del costruttore AsyncFunction e al loro interno \u00e8 consentita la parola chiave await. Le parole chiave async e await consentono di scrivere un comportamento asincrono basato sulla promessa in uno stile pi\u00f9 pulito, evitando la necessit\u00e0 di configurare esplicitamente catene di promesse. Fonte: MDN - async function Libreria JQuery jQuery \u00e8 una libreria JavaScript per applicazioni web, distribuita come software libero, distribuito sotto i termini della Licenza MIT. Nasce con l'obiettivo di semplificare la selezione, la manipolazione, la gestione degli eventi e l'animazione di elementi DOM in pagine HTML, nonch\u00e9 semplificare l'uso di funzionalit\u00e0 AJAX, la gestione degli eventi e la manipolazione dei CSS. Le sue caratteristiche permettono agli sviluppatori JavaScript di astrarre le interazioni a basso livello con i contenuti delle pagine HTML. L'approccio di tipo modulare di jQuery consente la creazione semplificata di applicazioni web e contenuti dinamici versatili. Nel 2020, jQuery risulta la libreria JavaScript pi\u00f9 utilizzata in Internet, ovvero \u00e8 presente nel 74,4% dei primi 10 milioni di siti Internet pi\u00f9 popolari secondo W3Techs. Fonte: Wikipedia - JQuery Fonti Risorse gratuite - Exploring JS: JavaScript books for programmers - MDN Video-Corsi gratuiti: - fcamuso - Corso Javascript (ES6) ITA - Andrea Tommasello - corso Javascript - 2019 italiano -------------------------------------------------------------------------- APPRONDIMENTI PT.1 -------------------------------------------------------------------------- Node.js Node.js Cos'\u00e8 node Install node Prima applicazione nodejs Non esiste l'oggetto window global objects Modules Creiamo un modulo Moduli built-in Modulo path Modulo OS Modulo File System Eventi Modulo HTTP Approfondimenti Passare dei parametri esterni My first IO sync My first IO async Filtered Cos'\u00e8 node Node \u00e8 un programma c++ che include l'engine javascript V8 di Chrome javascript che ti permette di programmare il server con Javascript Install node Verifica se hai gi\u00e0 installato node node --version Se il comando node non \u00e8 riconosciuto significa che lo hai installato, quindi installalo da qui Lancia nuovamente: node --version A questo punto dovrebbe rispondere con la versione appena installata: v14.15.4 Prima applicazione nodejs Crea un file .js ad esempio app.js e scrivi codice javascript function sayHello ( name ){ console . log ( name ); } sayHello ( 'simone' ); Adesso, digitando da terminale: node app.js Vedrai: simone node eseguir\u00e0 direttamente il codice sul terminale. Il programma di node trasferir\u00e0 il codice all'engine V8 il quale poi verr\u00e0 tradotto in c++ per essere letto dalla macchina (?almeno credo?) Non esiste l'oggetto window non esiste l'oggetto globale window poich\u00e8 fa parte del runtime environment che si ha nei browser console . log ( window ); ReferenceError: window is not defined In nodejs l'oggetto globale si chiama global ed \u00e8 condiviso e accessibile ovunque global objects Hai accesso a tutte le funzionalit\u00e0 definite da javascript grazie all'oggetto global global . console . log (); global . setTimeout (); global . clearTimeout (); global . setInterval (); global . clearInterval (); L'oggetto global \u00e8 implicito quindi puoi sempre ometterlo console . log (); setTimeout (); clearTimeout (); setInterval (); clearInterval (); Locale o globale? //Javascript nel tuo browser //Globale var message = '' ; In Javascript \u00e8 una variabile globale , poich\u00e8 viene aggiunta all'oggetto window . In node questa assume uno scope locale al file. In altre parole non viene aggiunta all'oggetto global //nodejs //Locale var message = '' ; console . log ( global . message ); //undefined Attenzione che, dichiarando una variabile, assume uno scope locale al file contrariamente a quanto accadeva con Javascript. Infatti con Javascript una variabile Modules Il concetto di modulo serve proprio a incapsulare la definizione di variabili, classi e quantaltro evitando quindi eventuali problemi di conflitto tra calssi o variabili che verrebbero brutalmente sovraiscritti. nel concetto di nodejs, ogni file \u00e8 considerato un modulo Se si parla di OOP, si potrebbe dire che all'interno di ogni file tutti gli oggetti sono privati al container che \u00e8 il file. Se vuoi utilizzare ed esportare dei dati esternamente devi renderli pubblici esplicitamente Ogni applicazione nodejs ha un modulo main Per adesso non abbiamo ancora definito un modulo node ma a breve lo faremo. module \u00e8 un oggetto richiamabile esattamente come global o window nel caso di javascript all'interno di un browser console . log ( module ); /** * Module { id: '.', path: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app', exports: {}, parent: null, filename: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\app.js', loaded: false, children: [], paths: [ 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\node_modules', 'C:\\\\Users\\\\node_modules', 'C:\\\\node_modules' ] } */ Creiamo un modulo In questo esempio creeremo un modulo, quindi un file js chiamato logger.js . In questo file definiremo una funzione e una variabile ed esporteremo la funzione esternamente. In realt\u00e0 dovremmo parlare di metodo poich\u00e8 di fatto \u00e8 appartenente al modulo logger.js che \u00e8 racchiuso in un oggetto var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports . log = log ; //module.exports.url = url; Nel file app.js andremo a richiamare l'oggetto restituito //require ritorna l'oggetto esportato dal modulo var logger = require ( './logger' ); console . log ( logger ); /** * { log: [Function: log] } */ la variabile logger ritorna ci\u00f2 che esporta il modulo logger.js infatti stampando module da logger.js avremo: var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports . log = log ; console . log ( module ); //module.exports.url = url; /* Module { id: '.', path: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app', exports: { log: [Function: log] }, parent: null, filename: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\logger.js', loaded: false, children: [], paths: [ 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\node_modules', 'C:\\\\Users\\\\node_modules', 'C:\\\\node_modules' ] } */ la property exports \u00e8 l'oggetto esportato esternamente. Ad ogni modo, adesso posso usare il metodo log del modulo logger . /*logger.js*/ var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports . log = log ; /*app.js*/ //require ritorna l'oggetto esportato dal modulo var logger = require ( './logger' ); logger . log ( 'ciao' ); >node .\\app.js ciao E' buona norma utilizzare il qualificatore const per i moduli importati questo perch\u00e8 non vogliamo in nessun modo che vengano sovraiscritti erroneamente. Se accidentalmente si prova a cambiare il valore di una costante, viene sollevato un errore a runtime /*app.js*/ //require ritorna l'oggetto esportato dal modulo const logger = require ( './logger' ); logger . log ( 'ciao' ); di sotto vedrai come esportare la funzione log in quanto funzione e non come metodo di un oggetto /*logger.js*/ var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports = log ; /*app.js*/ //require ritorna l'oggetto esportato dal modulo var log = require ( './logger' ); log ( 'ciao' ); >node .\\app.js ciao Stampiamo in questo caso cosa esporta il modulo logger /*logger.js*/ var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports = log ; console . log ( module ); /* Module { id: '.', exports: [Function: log], parent: null, filename: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\logger.js', loaded: false, children: [], paths: [ 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\node_modules', 'C:\\\\Users\\\\node_modules', 'C:\\\\node_modules' ] } */ Moduli built-in Sulla pagina ufficiale di node.js puoi trovare la sezione relativa alla documentazione . Modulo path Nel prossimo esempio useremo il modulo path che fornisce delle utility per lavorare con file e directory. Utilizzeremo in particolare il metodo parse() Il metodo parse() restituisce un oggetto le cui propriet\u00e0 rappresentano elementi significativi del percorso. L'oggetto ritorna le seguenti propriet\u00e0: dir <string> root <string> base <string> name <string> ext <string> Vediamo un esempio: const path = require ( 'path' ); const pathObj = path . parse ( './app.js' ); console . log ( pathObj ); /** * { root: '', dir: '.', base: 'app.js', ext: '.js', name: 'app' } */ Modulo OS La documentazione del modulo os la trovi qui In questo esempio vedremo come usare il modulo os e in particolare i metodi totalmem() e freemem() che restituiscono informazioni rispettivamente sulla memoria totale di sistema e la memoria libera const os = require ( 'os' ); const totalMemory = os . totalmem (); const freeMemory = os . freemem (); console . log ( 'Total Memory ' + totalMemory ); console . log ( `Free Memory: ${ freeMemory } ` ); /** * Total Memory 8502140928 * Free Memory: 4154499072 */ Modulo File System Puoi trovare l'intera documentazione qui . In particolare vedremo il metodo fs.readdirSync(path[, options]) e il metodo fs.readdir(path[, options], callback) Metodo sincrono readdirSync() . Ritorna un array di elementi contenuti al path passato come parametro. E' un metodo sincrono! I metodi sincroni sono anche detti bloccanti in quanto impegnano la CPU per tutto il tempo necessario al completamento dell'attivit\u00e0 impedendo al codice di proseguire e servire le altre attivit\u00e0. Questo \u00e8 il funzionamento tipico della programmazione procedurale sincrona const fs = require ( 'fs' ); //Metodo sincrono const files = fs . readdirSync ( './' ); console . log ( files ); Metodo asincrono readdir() . Ritorna (attraverso la callback) un array di elementi contenuti al path passato come primo parametro. Esegue la callback passata come secondo parametro. I metodi asincroni sono anche detti non-bloccanti in quanto impegnano la CPU solo al momento di partenza dell'attivit\u00e0. In questo caso il codice pu\u00f2 proseguire con le altre attivit\u00e0. Una volta che il metodo avr\u00e0 concluso l'attivit\u00e0, verr\u00e0 eseguita una cos\u00ecdetta \"callback\" una funzione in grado di comunicare se il risultato \u00e8 andato a buon fine oppure no. In una funzione \"callback\", il primo parametro rappresenta l'errore (eventuale), il secondo parametro rappresenta il valore di ritorno del metodo. Nel caso della readdir() rappresenta l'array di file contenuti al path specificato come primo parametro della readdir() const fs = require ( 'fs' ); //Metodo asincrono fs . readdir ( './' , function ( err , files ){ if ( err ) console . log ( 'Error' , err ); else console . log ( 'Result' , files ); }); /* Result [ 'app.js', 'logger.js' ] */ Simuliamo un errore: const fs = require ( 'fs' ); //Metodo asincrono fs . readdir ( 'aaaaa' , function ( err , files ){ if ( err ) console . log ( 'Error' , err ); else console . log ( 'Result' , files ); }); /* Error [Error: ENOENT: no such file or directory, scandir 'C:\\Users\\Di Ricco\\Google Drive\\Intecs\\Saleri\\Appunti-nodejs\\first-app\\aaaaa'] { errno: -4058, code: 'ENOENT', syscall: 'scandir', path: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\aaaaa' } */ Eventi La documentazione sugli eventi, in particolare la classe EventEmitter la puoi trovare qui Per poter far scattare un evento hai bisgono di: - emitter.on() : Il metodo on() si mette in ascolto dell'evento passato come primo parametro. Questa pratica in inglese si chiama \"to register a listener\". Inolte in questa fase stabilisci cosa fare quando l'evento scatta tramite una callback. - emitter.emit() : Il metodo emit() fa scattare un evento. Quando scatta torna al listener come callback. //events ritorna una classe, la classe degli eventi const EventEmitter = require ( 'events' ); //in questo modo ho istanziato un oggetto della classe EventEmitter, chiamando il suo costruttore senza nessun parametro const emitter = new EventEmitter (); //Register a listener. //devi registrare un listener prima che l'evento scatti. //E' un po' come abilitare l'interrupt per un particolare evento nei sistemi embedded e implementare l'ISR emitter . on ( 'messageLogged' , function (){ console . log ( 'listener called' ) }) //Raise an event //L'evento pu\u00f2 scattare solo dopo che \u00e8 stato registrato il listener. emitter . emit ( 'messageLogged' ); E' possibile ritornare un parametro al listener. Normalmente questo parametro viene passato come oggetto per maggiore chiarezza. La funzione di callback si aspetta un parametro. Vediamo un esempio: const EventEmitter = require ( 'events' ); const emitter = new EventEmitter (); //Register a listener. emitter . on ( 'messageLogged' , function ( eventArg ){ console . log ( 'listener called' , eventArg ) }) //Raise an event emitter . emit ( 'messageLogged' , { id : 1 , url : 'https://' }); /* listener called { id: 1, url: 'https://' } */ Puoi usare anche la sintassi \"arrow function\" const EventEmitter = require ( 'events' ); const emitter = new EventEmitter (); //Register a listener. emitter . on ( 'messageLogged' , ( eventArg ) => { console . log ( 'listener called' , eventArg ) }) //Raise an event emitter . emit ( 'messageLogged' , { id : 1 , url : 'https://' }); Normalmente gli eventi possono scattare da ogni modulo ma vorresti averne il controllo sul tuo main module. Vedremo adesso come mettersi in ascolto da eventi che possono scattare da altri moduli facendo uso delle classi /*logger.js*/ const EventEmitter = require ( 'events' ); var url = 'http://mylogger.io/log' ; //\"Logger\" contiene tutti i metodi e le propriet\u00e0 di \"EventEmitter\" class Logger extends EventEmitter { log ( message ) { //send an HTTP request console . log ( message ); //Raise an event this . emit ( 'messageLogged' , { id : 1 , url : 'https://' }); } } module . exports = Logger ; /*app.js*/ const Logger = require ( './logger' ); const logger = new Logger (); //Register a listener. logger . on ( 'messageLogged' , ( eventArg ) => { console . log ( 'listener called' , eventArg ) }) logger . log ( 'message' ); /* message listener called { id: 1, url: 'https://' } */ Modulo HTTP Se lanci questa applicazione con node.js const http = require ( 'http' ); const server = http . createServer (); server . on ( 'connection' , ( socket ) => { console . log ( 'New connection' ); }) server . listen ( 3000 ); console . log ( 'Listening on port 3000..' ); e poi dal tuo browser digiti localhost:3000 vedrai stampato New connection const http = require ( 'http' ); const server = http . createServer (( req , res ) => { if ( req . url === '/' ){ res . write ( 'hello world' ); res . end (); } if ( req . url === '/api/courses' ){ res . write ( JSON . stringify ([ 1 , 2 , 3 ])); res . end (); } }); server . listen ( 3000 ); console . log ( 'Listening on port 3000..' ); Approfondimenti Alcuni riferimenti utili: puoi imparare node su nodeschoold . Cliccando su learnyounode Ti suggerir\u00e0 di scaricare tramite npm un simpatico software per l'apprendimento di node. puoi imparare le nuoe features di es6 su es6 features Passare dei parametri esterni Eseguiremo l'esercizio baby-steps suggerito da learnyounode /*baby-steps.js*/ const argArray = process . argv ; let sum = 0 ; argArray . forEach ( ( element , index ) => { if ( index >= 2 ) sum += Number ( element ); }); console . log ( sum ); Esegui ad esempio: node .\\baby-steps.js 1 2 3 Vedrai: 6 My first IO sync Nel prossimo esempio leggeremo un file di testo e stamperemo il numero di caratteri a capo . Faremo uso del modulo fs e del metodo readFileSync() per la lettura dei file in modo sincrono const fs = require ( 'fs' ); const buf = fs . readFileSync ( './myFile.txt' ); const str = buf . toString (); const strArr = str . split ( '\\n' ); console . log ( buf ); console . log ( str ); console . log ( strArr ); console . log ( strArr . length - 1 ); /* <Buffer 63 69 61 6f 20 0a 61 20 0a 74 75 74 74 69 0a 71 75 61 6e 74 69> ciao a tutti quanti [ 'ciao ', 'a ', 'tutti', 'quanti' ] 3 */ Di default readFileSync() resistutisce un oggetto della classe Buffer che puoi approfondire direttamente sulla documentazione di nodejs. In pratica comunque resitituisce i caratteri decodificandoli in binario attraverso utf8 che \u00e8 equivalente al codice ASCII. Se vuoi verificare, basta tu prenda una tabella ASCII e tu legga il valore esadecimale per ogni lettera. Questo sistema potrebbe essere molto interessante per la comunicazione con un microcontrollore. Se vuoi tuttavia convertire direttamente in stringa puoi specificare il tipo di codifica utf8 come secondo parametro. Il codice si semplifica e diventa const fs = require ( 'fs' ); const str = fs . readFileSync ( './myFile.txt' , 'utf8' ); const strArr = str . split ( '\\n' ); console . log ( str ); console . log ( strArr ); console . log ( strArr . length ); /* ciao a tutti quanti [ 'ciao ', 'a ', 'tutti', 'quanti' ] 3 */ My first IO async In questo esempio vedremo invece lo stesso esempio ma utilizzando la programmazione asincrona e quindi tramite il metodo readFile() . Questo metodo non ritorna niente, il suo output \u00e8 in realt\u00e0 la funzione di callback passata come secondo parametro che viene chiamata solo quando si \u00e8 raggiunto un risultato const fs = require ( 'fs' ); console . log ( 'before' ); fs . readFile ( './myFile.txt' , 'utf8' , ( err , data ) => { //fs.readFile('./myFile.txt', 'utf8', function(err, data){ console . log ( data ); console . log ( data . split ( '\\n' ). length - 1 ); }) console . log ( 'after' ); /* before after ciao a tutti quanti 3 */ Attenzione Quello che devi notare \u00e8 che con questo sistema, al contrario del sistema sincrono, l'evoluzione del programma continua una volta chiamato il metodo readFile() . Per questo ho inserito console.log('before'); e console.log('after'); , per dimostrare in output che il risultato non \u00e8 quello atteso In genere conviene sempre fare il check di eventuali errori. Poich\u00e8 la callback come primo parametro riceve anche un errore segnalandoci se qualcosa \u00e8 andato storto, \u00e8 buona norma utilizzarlo per sollevare un'eccezione attraverso throw oppure qualsiasi altra operazione desiderata const fs = require ( 'fs' ); console . log ( 'before' ); fs . readFile ( './myFile.txt' , 'utf8' , ( err , data ) => { if ( err ) throw err console . log ( data ); console . log ( data . split ( '\\n' ). length - 1 ); }) console . log ( 'after' ); /* before after ciao a tutti quanti 3 */ Filtered In questo esempio vedrai come stampare il contenuto dei file all'interno di una directory con una particolare estensione. Il path e l'estensione vengono passati come parametri esterni allo script /*05-filtered-ls.js*/ const fs = require ( 'fs' ); const path = require ( 'path' ); const dir = process . argv [ 2 ]; const ext = process . argv [ 3 ]; fs . readdir ( dir , ( err , files ) => { files . forEach (( elem )=>{ if ( path . extname ( elem ) == ext ) console . log ( elem ) }) }) Otterrai: >node 05-filtered-ls.js ./ .js 01-hello-node.js 02-baby-steps.js 03-my-first-io-async.js 04-my-first-io.js 05-filtered-ls.js Puoi renderlo migliore.. In questo esempio utilizzero il metodo filter e passer\u00f2 l'estensione del file senza dover specificare il . const fs = require ( 'fs' ); const path = require ( 'path' ); const dir = process . argv [ 2 ]; const ext = `. ${ process . argv [ 3 ] } ` ; fs . readdir ( dir , ( err , files ) => { if ( err ) throw err ; const filesFiltered = files . filter (( file ) => path . extname ( file ) === ext ); filesFiltered . forEach (( file ) => console . log ( file )); }); -------------------------------------------------------------------------- APPRONDIMENTI PT.2 -------------------------------------------------------------------------- Promise Puoi trovare degli approfondimenti utili sull'argomento qua: MDN Gli oggetti Promise sono usati per computazioni in differita e asincrone. Una Promise rappresenta un'operazione che non \u00e8 ancora completata, ma lo sar\u00e0 in futuro. new Promise ( function ( resolve , reject ) { ... }); Una promise accetta come argomento una funzione che ha due parametri: resolve e reject . Tale funzione viene chiamata immediatamente dall'implementazione della Promise, passando i due argomenti resolve e reject , che sono due funzioni. Le due funzioni resolve e reject , quando chiamate, risolvono o rigettano la promise. L'esecutore inizia del lavoro (solitamente asincrono), e, una volta completato, chiama resolve per risolvere la promise, o reject se c'\u00e8 stato qualche errore. Se un errore viene sollevato nella funzione di esecuzione (executor) la promise viene rigettata. Una Promise consente di associare degli handlers con il successo o il fallimento di un'azione asincrona. Questo in pratica consente di utilizzare dei metodi asincroni di fatto come se fossero sincroni. Una Promise pu\u00f2 presentarsi in uno dei seguenti stati: pending (attesa): stato iniziale, n\u00e9 soddisfatto n\u00e9 respinto. fulfilled (soddisfatto): significa che l'operazione si \u00e8 conclusa con sucesso. rejected (respinto): significa che l'operazione \u00e0 fallita. Una promise in pending pu\u00f2 evolvere sia in fulfilled , sia in rejected con la possibilit\u00e0 in entrambi i casi di passare valori. Quando accade una di queste situazioni, vengono chiamati gli handler associati che sono stati accodati dal metodo then della promise. Poich\u00e8 i metodi .then e .catch restituiscono delle promise , \u00e8 possibile concatenarli tramite l'operazione di composition . Un esempio semplice In questo esempio creo una promise in cui chiamer\u00f2 la funzione setTimeout() . Una volta che setTimeout() sar\u00e0 completata la promise entrer\u00e0 nello stato fulfilled ritornando un messaggio di successo rappresentato dal parametro della funzione resolve() . Poich\u00e8 mi aspetto che non ci siano errori in questa situazione, ho aggiunto una variabile esterna in modo da simulare una qualsiasi condizione di errore. Con la variabile booleana ForceRejected forzo la promise ad entrare nello stato di rejected , ritornando il valore identificato dal parametro della funzione reject() . Una volta che la Promise ha terminato ed \u00e8 passata da pending a fulfilled \u00e8 possibile restituire il risultato tramite il metodo .then della Promise . Tale metodo accetta come parametro una callbackc che come parametro ha il valore passato da resolve() . Allo stesso modo, quando la Promise ha terminato ed \u00e8 passata da pending a rejected viene restituito il valore passato a reject() alla callback del metodo catch() const ForceRejected = false ; console . log ( \"Inizio\" ); let myFirstPromise = new Promise (( resolve , reject ) => { if ( ForceRejected ) { reject ( \"Error\" ); } else { setTimeout ( function (){ resolve ( \"Success!\" ); }, 1000 ); } }); myFirstPromise . then (( successMessage ) => { console . log ( \"Yee! \" + successMessage ); }). catch (( errorMessage ) => { console . log ( \"...! \" + errorMessage ); }) console . log ( \"Fine\" ); Il risultato sar\u00e0: Inizio Fine Yee! Success! Se esegui il codice con const ForceRejected = true; avrai come risultato: Inizio Fine ...! Error Nota che ho inserito anche due extra-stampe Inizio , Fine per evidenziare che il processo \u00e8 asincrono e quindi continua la sua esecuzione nel mentre che la Promise cerca di evolvere da pending a fulfilled o rejected -------------------------------------------------------------------------- APPRONDIMENTI PT.3 -------------------------------------------------------------------------- Approfondimento Hoisting Differenza tra var , let , const , blocchi di codici, funzioni etc.. Puoi trovare un approfondimento qui Approfondimento Oggetti Modo alternativo per inizializzare un oggetto let fsName = 'simone' ; let lsName = 'diricco' ; let user = { fsName , lsName }; console . log ( user ); //{ fsName: 'simone', lsName: 'diricco' } In questo caso l'oggeto prende come key il nome della variabile let fsName = 'simone' ; let lsName = 'diricco' ; let user = { fsName , lsName }; console . log ( user ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user [ 'lsName' ]); //diricco console . log ( user . fsName ); //simone let user2 = { [ 'fs' + 'Name' ] : fsName , lsName }; console . log ( user ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user2 [ 'fsName' ]); //simone console . log ( user2 . lsName ); //diricco Con la notazione ['nomeKey] ho il vantaggio di poter valutare delle espressioni stringhe Per verificare se esiste unar propriet\u00e0 all'interno di un oggetto: let fsName = 'simone' ; let lsName = 'diricco' ; let user = { fsName , lsName }; console . log ( 'fsName' in user ); //true Approfondimento Moduli CommonJS require / exports Con require posso importare tutto ci\u00f2 che desidero appartenente a moduli esterni //main.js let a = require ( './module1' ); console . log ( a ) Con module.exports posso esportare cio\u00e8 che desidero di un modulo //module1.js let a = 10 ; module . exports = a ; Mandando in esecuzione main.js otterremo la stampa di a , il cui valore \u00e8 prelevato dal modulo module1.js . E' lo stesso identico concetto di include in c++ solo che in questo caso l'esportazione e l'importazione non \u00e8 a livello di file ma a livello proprio di funzionalit\u00e0, oggetti, classi etc.. Vediamo un esempio pi\u00f9 completo //main.js let math = require ( './math' ); console . log ( math . sum ( 20 , 30 )); console . log ( math . sub ( 20 , 30 )); console . log ( math . mul ( 20 , 30 )); console . log ( math . div ( 20 , 30 )); //math.js let sum = function ( x , y ){ return x + y ; } let div = function ( x , y ){ return x / y ; } let mul = function ( x , y ){ return x * y ; } let sub = function ( x , y ){ return x - y ; } module . exports = { sum , div , mul , sub } Packages NPM Installiamo ad esempio il pacchetto prompt-sync tramite npm install prompt-sync . Verr\u00e0 scaricato una cartella node_modules Questo pacchetto serve per l'acquisizione di dati da tastiera. Vediamo un esempio: let prompt = require ( 'prompt-sync' )(); let number = prompt ( 'Insert a number: ' ); console . log ( number ); Approfondimento THIS this si riferisce sempre all'oggetto referenziato al quale il metodo fa riferimento let printName = function (){ return this . fsName + ' ' + this . lsName ; } let user1 = { fsName : 'mario' , lsName : 'rossi' , printName } let user2 = { fsName : 'matteo' , lsName : 'bianchi' , printName } console . log ( user1 . printName ()); //mario rossi console . log ( user2 . printName ()); //matteo bianchi Vediamo un alrto esercizio let listProducts = { \"0001\" : { name : 'PC' , price : 12.45 }, \"0002\" : { name : 'smth' , price : 13.45 }, \"0002\" : { name : 'tast' , price : 2.45 }, \"0003\" : { name : 'Monit' , price : 12.35 }, \"0004\" : { name : 'mous' , price : 124.45 } } let store = { listProducts , print : function (){ for ( let item in this . listProducts ){ console . log ( this . listProducts [ item ]. name ); console . log ( this . listProducts [ item ]. price ); console . log ( '------------------------' ); } } } store . print (); /* PC 12.45 ------------------------ tast 2.45 ------------------------ Monit 12.35 ------------------------ mous 124.45 ------------------------ */ Un altro esempio che usa il costruttore in modo da poter utilizzare un oggetto come modello e poter istanziare delle copie del modello dell'oggetto function User ( fsName , lsName , email ){ this . fsName = fsName , this . lsName = lsName , this . email = email this . name = function (){ return this . fsName + ' ' + this . lsName ; } } let user1 = new User ( 'sim' , 'dir' , 'em@em.it' ); console . log ( user1 ); console . log ( user1 . name ()); /* User { fsName: 'sim', lsName: 'dir', email: 'em@em.it', name: [Function (anonymous)] } sim dir */ Reference data type Al contrario delle strutture dati primitive, con le strutture dati referenziate come array o oggetti, l'assegnamento tra strutture dati referenziate effettua una copia solo dell'indirizzo a cui \u00e8 allocato il nome della struttura referenziata il che \u00e8 diverso dall'eseguire una copia del valore come accade con le strutture dati primitive. Questo significa che in fase di assegnamento tra due oggetti o array poich\u00e8 copio l'indirizzo dell'oggetto o array, di fatto ho ottenuto due oggetti che puntano alla stessa struttura dati. Se modifico uno, modifico anche l'altro.. Vediamo un esempio.. let user1 = { fsname : 'mario' , lsname : 'rossi' } let user2 = user1 ; console . log ( user1 ); //{ fsname: 'mario', lsname: 'rossi' } console . log ( user2 ); //{ fsname: 'mario', lsname: 'rossi' } user2 . fsname = 'Luigi' ; console . log ( user1 ); //{ fsname: 'Luigi', lsname: 'rossi' } console . log ( user2 ); //{ fsname: 'Luigi', lsname: 'rossi' } user1 . email = 'em@em.it' ; console . log ( user1 ); //{ fsname: 'Luigi', lsname: 'rossi', email: 'em@em.it' } console . log ( user2 ); //{ fsname: 'Luigi', lsname: 'rossi', email: 'em@em.it' } Costruttori prefdefiniti javascript Object, String, Boolean, Number, Array RegExp, Function, Error, Symbol, Date let user = new Object (); Questo significa che anche i dati primitivi sono implementati in javascript come oggetti e quindi avranno propriet\u00e0 e metodi! ecco perch\u00e8 puoi fare str.lenght oppure str.toUpperCase() oppure nmb.toFixed() Non \u00e8 possibile modificare tuttavia metodi e propriet\u00e0 di un dato primitivo! Attenzione! Anche gli Array sono particolari oggetti estesi for .. of for .. in Memoization Come fare una copia profonda tra oggetti? Sappiamo che l'assegnamento standard effetua solo una copia dei riferimenti e questo equivale a creare un oggetto che punta alla stessa struttura dati. il metodo Object.assig() invece effettua una copia profonda dell'oggetto passato come parametro restituendo di fatto un oggetto copia let user1 = { fsName : 'simone' , lsName : 'diricco' }; let user2 = Object . assign ({}, user1 ); //deep copy console . log ( user1 ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user2 ); //{ fsName: 'simone', lsName: 'diricco' } user2 . lsName = 'rossi' ; console . log ( user1 ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user2 ); //{ fsName: 'simone', lsName: 'rossi' } propriet\u00e0 associate ai dati e proprier\u00e0 associate all'accesso get & set let square = { x : 10 , //propriet\u00e0 di accesso get area (){ return this . x * this . x ; } }; console . log ( square . x ); //10 console . log ( square . area ); //100 square . x = 20 ; console . log ( square . x ); //20 console . log ( square . area ); //400 square . area = 23 ; console . log ( square . x ); //20 //La propriet\u00e0 area non viene modificata console . log ( square . area ); //400 let square = { x : 10 , //propriet\u00e0 di accesso get area (){ return this . x * this . x ; }, set area ( val ){ this . x = Math . sqrt ( val ); } }; console . log ( square . x ); //10 console . log ( square . area ); //100 square . area = 25 ; console . log ( square . x ); //5 //La propriet\u00e0 area non viene modificata console . log ( square . area ); //25 Arrow functions Sintassi funzioni function sum ( x , y ){ return x + y ; } //anonymous fucntions let sum2 = function ( x , y ){ return x + y ; } //Arrow functions let sum3 = ( x , y ) => { return x + y ; } //arrow functions with 1 argument let square = x => { return x * x ; } //arrow functions with 1 argument //compact let square2 = x => x * x ; High Order Functions //funzione identit\u00e0 let id = x => x ; let sum = ( x , y ) => x + y ; //Funzione di ordine superiore //poich\u00e8 accetta come argomento una funzione e ritorna una funzione id ( sum )( 4 , 5 ); Array filter let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //test \u00e8 una funzione che decido in fase di invocazione let filter = ( array , test ) => { let result = []; for ( let item of array ) if ( test ( item )){ result . push ( item ) } return result ; } //ritorno un array con l'elemento 'simone' se \u00e8 presente console . log ( filter ( array , x => x == 'simone' )); //ritorno un array con gli elementi che contengono una 'a' console . log ( filter ( array , x => x . search ( \"a\" ) >= 0 )); Array map let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //test \u00e8 una funzione che decido in fase di invocazione let filter = ( array , test ) => { let result = []; for ( let item of array ) if ( test ( item )){ result . push ( item ) } return result ; } let map = ( array , trans ) => { let result = []; for ( let item of array ){ result . push ( trans ( item )); } return result ; } console . log ( map ( array , x => x . toUpperCase ())); //[ 'SIMONE', 'CIAO', 'MATTEO', 'ALESSANDRO' ] Array reduce let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //test \u00e8 una funzione che decido in fase di invocazione let filter = ( array , test ) => { let result = []; for ( let item of array ) if ( test ( item )){ result . push ( item ) } return result ; } let map = ( array , trans ) => { let result = []; for ( let item of array ){ result . push ( trans ( item )); } return result ; } let reduce = ( array , combine , start ) => { let current = start ; for ( let item of array ){ current = combine ( current , item ) } return current ; } let count = map ( array , x => x . length ); let totCount = reduce ( count , ( a , b ) => a + b , 0 ); console . log ( count ); //[ 6, 4, 6, 10 ] console . log ( totCount ); //26 Gli array possiedono gi\u00e0 come metodi filer, map, reduce Gli array possiedono gi\u00e0 come metodi filer, map, reduce array . map (); array . filter (); array . reduce (); E funzionano allo stesso modo di come li abbiamo implementati noi. Vediamo adesso come combinare queste funzioni let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //conta le lettere totali degli elementi che contengono una 'a' console . log ( //['ciao', 'matteo', 'alessandro']; array . filter ( item => { return item . search ( 'a' ) >= 0 ; }) //[ 4, 6, 10 ] . map ( item => { return item . length ; }) //20 . reduce (( a , b ) => { return a + b ; }) ); //20 Qualche chicca sugli Array Arrray.of, Array.from let numbers = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 ]; console . log ( numbers . length ); //10 let numbers1 = Array . of ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 ); console . log ( numbers1 ); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 0] let numberString = \"1234567890\" ; let numbers2 = Array . from ( numberString ); console . log ( numbers2 ); //['1', '2', '3', '4','5', '6', '7', '8','9', '0'] let numbers3 = Array . from ( numberString , value => parseInt ( value )); console . log ( numbers3 ); //[1, 2, 3, 4, 5,6, 7, 8, 9, 0] let numbers4 = Array . from ( numbers3 , value => value + 1 ); console . log ( numbers4 ); //[2, 3, 4, 5, 6,7, 8, 9, 10, 1] concat, every, some let array1 = [ 1 , 2 , 3 , 4 , 5 ]; let array2 = [ 6 , 7 , 8 , 9 , 0 ]; console . log ( array1 . concat ( array2 )); //[1, 2, 3, 4, 5,6, 7, 8, 9, 0] //ogni elemento deve soddisfare la condizione console . log ( array1 . every ( value => typeof value === \"number\" )); //true //almeno un elemento deve soddisfare la condizione console . log ( array1 . some ( value => typeof value === \"number\" )); //true find, filter, forEach, includes, indexOf let users = [ \"Cosimo\" , \"Simone\" , \"mario\" , \"maria\" , \"giuseppe\" , \"asinello\" ]; //find console . log ( users . find ( value => value == \"mario\" )); //mario //find //ritorna un elemento dell'array console . log ( users . find ( value => value . search ( \"g\" ) == 0 )); //giuseppe //filter //ritorna un array console . log ( users . filter ( value => value . search ( \"a\" ) == 0 )); //[ 'asinello' ] /* COSIMO SIMONE MARIO MARIA GIUSEPPE ASINELLO */ //forEach users . forEach ( value => { console . log ( value . toLocaleUpperCase ()); }) //includes console . log ( users . includes ( \"pippo\" )); //false console . log ( users . includes ( \"Simone\" )); //true //indexOf console . log ( users . indexOf ( \"Simone\" )); //1 console . log ( users . indexOf ( \"maria\" )); //3 push, pop, shift, unshift let numbers = [ 1 , 2 , 3 , 4 ]; //push //ritorna la lunghezza dell'array console . log ( numbers . push ( 17 )); //5 console . log ( numbers ); //[ 1, 2, 3, 4, 17 ] //pop //ritorna l'elemento rimosso console . log ( numbers . pop ( 4 )); //17 console . log ( numbers ); //[ 1, 2, 3, 4 ] //shift //ritorna l'elemento rimosso console . log ( numbers . shift ()); //1 console . log ( numbers ); //[ 2, 3, 4 ] //unshift //ritorna la lunghezza dell'array console . log ( numbers . unshift ( 23 )); //4 console . log ( numbers ); //[ 23, 2, 3, 4 ] sort, splice, slice let users = [ \"Cosimo\" , \"Luigi\" , \"Mario\" , \"Alessio\" , \"Matteo\" ]; console . log ( users ); //[ 'Cosimo', 'Luigi', 'Mario', 'Alessio', 'Matteo' ] //sort //Consente l'ordinamento degli elementi dell'array //L'argomento specifica la condizione di ordinamento //modifica l'array console . log ( users . sort ( compare )); //[ 'Alessio', 'Cosimo', 'Luigi', 'Mario', 'Matteo' ] function compare ( a , b ) { if ( a < b ) { return - 1 ; } else if ( a > b ) { return 1 ; } else { return 0 ; } } users = [ \"Cosimo\" , \"Luigi\" , \"Mario\" , \"Alessio\" , \"Matteo\" ]; //splice(x, y) //elimina y elementi a partire da una posizione x //modifica l'array users . splice ( 2 , 1 ); console . log ( users ); //[ 'Cosimo', 'Luigi', 'Alessio', 'Matteo' ] //splice //puoi anche aggiungere elementi //modifica l'array users . splice ( 2 , 0 , \"giuseppia\" , \"antonio\" ); console . log ( users ); //[ 'Cosimo', 'Luigi', 'giuseppia', 'antonio', 'Alessio', 'Matteo' ] users = [ \"Cosimo\" , \"Luigi\" , \"Mario\" , \"Alessio\" , \"Matteo\" ]; //slice //ritorna un sub-array let subArray = users . slice ( 0 , 2 ); console . log ( subArray ); //[ 'Cosimo', 'Luigi' ] setTimeout(), setInterval() la setTimeout() chiama la funzione passata come argomento dopo un certo valore di tempo specificato come argomento. La setInterval() invece chiama la funzione passata come argomento periodicamente con il periodo specificato come argomento //setTimeout() setTimeout (() => { console . log ( 'start' ); }, 1000 ); let i = 0 ; //setTimeout() setInterval (() => { console . log ( i ++ ); }, 1000 ); /* start 0 1 2 3 4 5 */ Eventi Asincroni // ----------------------------------> t // x x const fs = require ( 'fs' ); //chiamata asincrona.. //viene passato un path e una callback, una funzione //la callback viene chiamata una volta che la lettura \u00e8 completata //readFile restituisce un buffer fs . readFile ( './data.txt' , function ( err , data ){ console . log ( data . toString ()); }); console . log ( 'end!!' ); /* end!! hello! */ Promise, resolve, reject, then const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise ( function ( resolve , reject ){ fs . readFile ( fileName , function ( err , data ){ if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let file = readFile ( './data.txt' ); console . log ( file ); //Promise { <pending> } //metodo .then della Promise //Come primo parametro accetta una funzione che viene invocata se la Promise evolve in resolve //Come secondo parametro accetta una funzione che viene invocata se la Promise evolve in reject file . then ( function ( data ){ console . log ( data . toString ()); //hello! }, function ( err ){ console . log ( err ) }) Vediamo lo stesso esempio ma con qualche console.log() const fs = require ( 'fs' ); console . log ( 'start' ); //1 //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ console . log ( 'readFIle() inizio esecuzione' ); //3 return new Promise ( function ( resolve , reject ){ console . log ( \"promise(), prima dell'invocazione del metodo async readFile\" ); //4 fs . readFile ( fileName , function ( err , data ){ console . log ( \"promise(), esecuzione callback del metodo async readFile\" ); //8 if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } console . log ( \"Prima dell'invocazione di readFile()\" ); //2 let file = readFile ( './data.txt' ); console . log ( file ); //Promise { <pending> } //5 console . log ( \"Dopo l'invocazione di readFile()\" ); //6 //metodo .then della Promise //Come primo parametro accetta una funzione che viene invocata se la Promise evolve in resolve //Come secondo parametro accetta una funzione che viene invocata se la Promise evolve in reject console . log ( \".then(), invocazione del metodo della Promise\" ); //7 file . then ( function ( data ){ console . log ( \".then(), esecuzione del metodo della Promise\" ); //9 console . log ( data . toString ()); //hello! //10 }, function ( err ){ console . log ( err ) }) /* start Prima dell'invocazione di readFile() readFIle() inizio esecuzione promise(), prima dell'invocazione del metodo async readFile Promise { <pending> } Dopo l'invocazione di readFile() .then(), invocazione del metodo della Promise promise(), esecuzione callback del metodo async readFile .then(), esecuzione del metodo della Promise hello! */ Async, Await Vediamo lo stesso esempio di prima inserendo la chiamata a readFile in un contesto di chiamata asincrona const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let main = async function (){ console . log ( 'start' ); readFile ( './data.txt' ). then ( data => { console . log ( data . toString ()); }); console . log ( 'end' ); } main (); /* start end hello! */ Se per\u00f2 sfruttiamo anche la parola chiave await const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let main = async function (){ console . log ( 'start' ); await readFile ( './data.txt' ). then ( data => { console . log ( data . toString ()); }) console . log ( 'end' ); } main (); Oppure, visto che ritorna una Promise , posso anche fare cos\u00ec: const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let main = async function (){ console . log ( 'start' ); let data = await readFile ( './data.txt' ); console . log ( data . toString ()); console . log ( 'end' ); } main (); In questo modo ottengo un comportamento sequenziale del codice Vediamo un esempio pi\u00f9 completo const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } function wait ( time ){ return new Promise (( resolve , reject ) => { setTimeout (() => { resolve () }, time ); }) } let main = async function (){ console . log ( 'start' ); console . log ( 'attendi 5 sec..' ); await wait ( 5000 ); console . log ( 'sono passati 5 sec' ); let data = await readFile ( './data.txt' ); console . log ( 'attendi 5 sec..' ); await wait ( 5000 ); console . log ( 'sono passati 5 sec' ); console . log ( data . toString ()); console . log ( 'end' ); } main (); /* start attendi 5 sec.. sono passati 5 sec attendi 5 sec.. sono passati 5 sec hello! end */ Promise.all() e Promise.race() Le Promise.all() accettano come parametro un array di Promise function wait ( time , string ){ return new Promise (( resolve , reject ) => { setTimeout (() => { resolve ( string ) }, time ); }) } //Pormise.all() //Cercano come argomento un array di Promise Promise . all ([ wait ( 1000 , 1 ), wait ( 2000 , 2 ), wait ( 3000 , 3 )]). then ( value => { console . log ( value ); }) /* [ 1, 2, 3 ] */ Dopo 3 secondi stampa a video [ 1, 2, 3 ] cio\u00e8 il valore delle Promise dopo che tutte sono state risolte. La Promise.race() invece ritorna il valore della Promise che viene risolta per prima function wait ( time , string ){ return new Promise (( resolve , reject ) => { setTimeout (() => { resolve ( string ) }, time ); }) } //Pormise.all() //Cercano come argomento un array di Promise Promise . race ([ wait ( 1000 , 1 ), wait ( 2000 , 2 ), wait ( 3000 , 3 )]). then ( value => { console . log ( value ); }) Set e Map let set = new Set (); set . add ( 56 ); set . add ( 'test' ); set . add ( '34' ); //con i set \u00e8 possibile aggiungere univocamente un valore //questo significa che aggiungendo pi\u00f9 volte lo stesso valore non avr\u00e0 effetto set . add ( 34 ); set . add ( 34 ); set . add ( 34 ); console . log ( set . size ); //4 let set = new Set ([ 32 , '45' , 5 , 6 , 7 , 8 , 8 , 8 ]); console . log ( set . size ); //6 set . delete ( 32 ); console . log ( set . size ); //5 console . log ( set . has ( 6 )); //true console . log ( '-----' ); set . forEach (( value , key , set ) => { console . log ( value ); console . log ( key ); console . log ( set . size ); console . log ( '-----' ); }) /** ----- 45 45 5 ----- 5 5 5 ----- 6 6 5 ----- 7 7 5 ----- 8 8 5 ----- */ E' possibile convertire un set in un array con lo spread operator. let set = new Set ([ 32 , '45' , 5 , 6 , 7 , 8 , 8 , 8 ]); let array = [... set ]; console . log ( array ); //[ 32, '45', 5, 6, 7, 8 ] In questo caso l'array non conterr\u00e0 elementi duplicati. E' quindi possibile usare il set per rimuovere i duplicati all'interno di un array function deleteDuplicates ( items ){ return [... new Set ( items )]; } console . log ( deleteDuplicates ([ 0 , 1 , 2 , 3 , 3 , 3 , 3 , 4 , 5 , 6 , 7 , 7 , 7 , 7 ])); //[0, 1, 2, 3, 4, 5, 6, 7] Map let map = new Map () map . set ( 'user1' , 'Cosimo' ); map . set ( 'user2' , 'Simone' ); console . log ( map ); //Map(2) { 'user1' => 'Cosimo', 'user2' => 'Simone' } console . log ( map . get ( 'user1' )); //Cosimo console . log ( map . has ( 'user1' )); //true map . delete ( 'user2' ); console . log ( map . has ( 'user2' )); //false map . clear (); //svuota la mappa console . log ( map . size ); //0 let map = new Map ([[ 'key1' , 1 ], [ 'key2' , 2 ]]); console . log ( map . get ( 'key1' )); //1 map . forEach (( value , key ) => { console . log ( key , value ); }) /* key1 1 key2 2 */","title":"Javascript"},{"location":"javascript/READMEV2/#javascript","text":"","title":"Javascript"},{"location":"javascript/READMEV2/#lezione-01","text":"","title":"Lezione 01"},{"location":"javascript/READMEV2/#prerequisiti-al-corso","text":"Prima di iniziare questo modulo, assicurati di avere una buona familiarit\u00e0 con HTML .","title":"Prerequisiti al corso"},{"location":"javascript/READMEV2/#approccio-al-corso","text":"In questo corso vedrai: 1. Javascript orientato alla programmazione web front-end per realizzare semplici script lato client nonch\u00e8 per interagire con elementi html/css di una pagina web. 2. Javascript orientato alla programmazione web back-end per l'interazione con il sistema operativo di una macchina fisica. In questo caso avrai bisogno di Node.js","title":"Approccio al corso"},{"location":"javascript/READMEV2/#strumenti-necessari","text":"Per questo corso avrai bisogno di: 1. un web browser come Google Chrome . Un browser web contiene tutto il necessario per eseguire Javascript lato client 2. un editor di testo come Visual Studio Code . 3. Node.js , una runtime environment di javascript per poter eseguire script lato server nonch\u00e8 sulla propria macchina fisica.","title":"Strumenti Necessari"},{"location":"javascript/READMEV2/#javascript-ecma-script","text":"ECMAScript (o ES) \u00e8 la specifica tecnica del linguaggio comunemente noto come Javascript, standardizzata e mantenuta da ECMA International nell'ECMA-262 ed ISO/IEC 16262. La specifica \u00e8 in continuo aggiornamento e di pari passo anche i runtime environment come i browser web o Nodejs devono poter essere allineati. Qui puoi trovare una tabella aggiornata delle funzionalit\u00e0 coperte da ogni browser web per versione di ECMAScript In questo corso tratteremo in maniera approfondita ES6.","title":"Javascript, ECMA-Script?"},{"location":"javascript/READMEV2/#lezione-02","text":"","title":"Lezione 02"},{"location":"javascript/READMEV2/#primo-script-allinterno-del-browser-web","text":"Come integro codice javascript all'interno di una pagina html?","title":"Primo script all'interno del browser web"},{"location":"javascript/READMEV2/#javascript-allinterno-del-tag-script","text":"E' possibile inserire codice Javascript direttamente all'interno della pagina html tramite il tag <script> . <!--File index.html--> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script > //Stampa \"ciao mondo\" direttamente nella pagina html document . write ( \"ciao mondo\" ); </ script > </ body > </ html >","title":"Javascript all'interno del tag script"},{"location":"javascript/READMEV2/#javascript-allinterno-di-un-file-js","text":"E' possibile creare un collegamento con un file esterno con estensione .js che rappresenter\u00e0 il file contente codice Javascript. <!--File index.html--> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script src = \"main.js\" ></ script > </ body > </ html > //File main.js //Stampa \"ciao mondo\" direttamente nella pagina html document . write ( \"ciao mondo\" );","title":"Javascript all'interno di un file .js"},{"location":"javascript/READMEV2/#primo-script-javascript-con-nodejs","text":"Crea un file .js ad esempio main.js e scrivi: console . log ( 'hello' ); Da terminale digita: node main.js Vedrai stampato sul terminale: hello","title":"Primo script Javascript con node.js"},{"location":"javascript/READMEV2/#console","text":"Come abbiamo gi\u00e0 visto, il metodo log() di Console stampa un messaggio a video sul terminale in Node.js. Utilizzando il browser, verr\u00e0 effettuata la stampa di un messaggio all'interno della web console del browser. <!--File index.html--> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script > //Stampa \"ciao mondo\" direttamente nella pagina html console . log ( \"ciao mondo\" ); </ script > </ body > </ html > Riporto qualche comando (metodo) aggiuntivo della console: console . log ( 'Ciao a tutti' ); //stampa sulla console console . warn ( 'Avvertimento' ); //Genera un warning console . error ( 'questo \u00e8 un errore' ); //Genera un errore console . table ({ name : 'simone' }); //Stampa in formato tabella console . clear (); //Pulisce la console Una lista di tutti i metodi applicabili all'oggetto si trova alla pagina MDN - Console","title":"Console"},{"location":"javascript/READMEV2/#alert-prompt","text":"alert(messaggio) mostra una finestra di avviso contenente il testo specificato prompt() mostra una finestra di dialogo che consente all'utente di inserire del testo e memorizzarlo in una variabile del programma <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script > //Salva l'input ricevuto in una variabile cio\u00e8 un contenitore testuale myName = prompt ( 'Come ti chiami?' ); alert ( \"Il tuo nome \u00e8 ..\" ); //Stampa il valore testuale contenuto nella variabile alert ( myName ); </ script > </ body > </ html > Approfondimenti sul metodo alert() dell'oggetto Window li trovate su MDN - Window.alert() mentre approfondimenti sul metodo prompt() dell'oggetto Window li trovate su MDN - Window.prompt()","title":"Alert &amp; prompt"},{"location":"javascript/READMEV2/#commenti","text":"// comment : per commenti inline /* comment */ : per commenti su linee multiple //inline comment /* multi line comment */","title":"Commenti"},{"location":"javascript/READMEV2/#introduzione-al-dom","text":"Nativamente supportato dai browser per modificare gli elementi di un documento HTML, DOM \u00e8 un modo per accedere e aggiornare dinamicamente il contenuto, la struttura e lo stile dei documenti. Wikipedia - Document Object Model Hai gi\u00e0 visto: document . write ( \"ciao mondo\" ); Il \"comando\" document.write() \u00e8 in realt\u00e0 un oggetto Javscript document a cui si applica un metodo write() ovvero una funzione richiamabile solo nel contesto di un particolare oggetto (DOM = Document Object Model).","title":"Introduzione al DOM"},{"location":"javascript/READMEV2/#introduzione-alla-libreria-jquery","text":"Vediamo anche come aggiungere librerie esterne, per aggiungere quindi funzionalit\u00e0 al linguaggio standard. Installeremo JQuery perch\u00e8 \u00e8 una libreria popolare molto utilizzata proprio per la manipolazione del DOM ovvero degli elementi html. Scarica JQuery e copialo nella root del progetto, dopodich\u00e8 dovrai creare un collegamento al file attarverso: < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > Una volta scaricato il file \u00e8 necessario copiarlo nella root del progetto e creare un collegamento al file html. Vediamo alcune funzionalit\u00e0 base offerte della libreria JQuery per la manipolazione del DOM. Le approfondiremo quando necessario pi\u00f9 avanti nel corso $() : Selettore di elementi html. E' possibile selezionare un elemento tramite il suo id , la sua classe , un attributo .. Alcuni metodi: val() : legge/scrive l'attributo value dell'elemento html selezionato click(functionName) : aggiunge l'evento click all'elemento selezionato e chiama la funzione functionName Vediamo un esempio: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table { border : 1 px dashed black } </ style > </ head > < body > < table > < tr > < td > Nome </ td > < td > < input type = \"text\" id = \"myName\" > </ td > </ tr > < tr > < td > Nuovo Nome </ td > < td > < input type = \"text\" id = \"new-name\" > </ td > </ tr > </ table > < input type = \"button\" value = \"OK\" id = \"btn-ok\" > <!-- Collegamento alla libreria JQuery.--> < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function cambiaNome (){ //Seleziono l'elemento con id \"new-name\" e ne prelevo il valore con il metodo \"val()\" //Memorizzo il risultato in una variabile di nome \"nuovoNome\" nuovoNome = $ ( \"#new-name\" ). val (); //Assegno all'elemento con id \"myName\" il valore associato alla variabile \"nuovoNome\" $ ( \"#myName\" ). val ( nuovoNome ); //Pulisco il contenuto del valore dell'elemento con id \"new-name\" $ ( \"#new-name\" ). val ( \"\" ); } //Associo all'elemento con id \"btn-ok\" un evento. //Al click sull'elemento con id \"btn-ok\" scatta la funzione \"cambiaNome\" $ ( \"#btn-ok\" ). click ( cambiaNome ) </ script > </ body > </ html > ATTENZIONE: Il simbolo $ \u00e8 un alias che sta per jQuery . Puoi quindi utilizzare jQuery al posto di $ qualora il simbolo $ fosse utilizzato per unn'altra definizione","title":"Introduzione alla libreria JQuery"},{"location":"javascript/READMEV2/#dom-ed-eventi","text":"Appena la pagina html viene eseguita il browser parte con la costruzione del DOM per metterlo a disposizione di Javascript. Nel contempo potrebbe tuttavia scattare l'evento $(\"#btn-ok\").click(cambiaNome) e mandare in errore il programma. Per evitare che questo accada \u00e8 necessario abilitari gli eventi solo dopo che la costruzione del DOM \u00e8 avvenuta con successo. Per far cio' si utilizza una funzione anonima con la seguente sintassi $ ( function (){ //evento }); Riscrivendo il codice abbiamo: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table { border : 1 px dashed black } </ style > </ head > < body > < table > < tr > < td > Nome </ td > < td > < input type = \"text\" id = \"myName\" > </ td > </ tr > < tr > < td > Nuovo Nome </ td > < td > < input type = \"text\" id = \"new-name\" > </ td > </ tr > </ table > < input type = \"button\" value = \"OK\" id = \"btn-ok\" > <!-- Collegamento alla libreria JQuery.--> < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function cambiaNome (){ nuovoNome = $ ( \"#new-name\" ). val (); //Assegno all'elemento con id \"myName\" il valore associato alla variabile \"nuovoNome\" $ ( \"#myName\" ). val ( nuovoNome ); //Pulisco il contenuto del valore dell'elemento con id \"new-name\" $ ( \"#new-name\" ). val ( \"\" ); } //L'evento sar\u00e0 pronto a scattare soltanto quando la struttura del DOM sar\u00e0 preparata $ ( function (){ $ ( \"#btn-ok\" ). click ( cambiaNome ) }); </ script > </ body > </ html > Altri metodi equivalenti: $ (). ready ( function (){ //event }) $ ( document ). ready ( function () { //event }) $ ( window ). ready ( function () { //event })","title":"DOM ed Eventi"},{"location":"javascript/READMEV2/#variabili-javascript","text":"Le variabili sono utilizzate per rappresentare valori attraverso un nome simbolico chiamato identificatore . Le variabili in JavaScript hanno un tipo, ma a differenza di altri linguaggi fortemente tipizzati, Javascript utilizza i tipi per valore e non per variabile. Questo meccanismo prende il nome di tipizzazione dinamica . var cognome = 'Rossi' ; let nome = 'Mario' ; const eta = 25 ; pi = 3.14 ; Esistono tre tipi di keyword per la dichiarazione di variabili/costanti in JS. var : Per variabili sia locali che globali. let : Per variabili locali. const : Per variabili locali immutabili E' possibile inoltre dichiarare una variabile senza nessuna keyword , in questo caso sar\u00e0 l'interprete ad assegnare a tale variabile il qualificatore attraverso il meccanismo dell' auto-global variable declaration","title":"Variabili Javascript"},{"location":"javascript/READMEV2/#alcune-regole-per-dichiarazione-di-variabili","text":"Non \u00e8 possibile utilizzare: un numero, un # , una @ come inizio del nome di una variabile. E' accettanto invece il simbolo $ come identificatore, le keyword native di JS come: function , if , delete , new , while .. In javascript \u00e8 convenzione utilizzare la notazione camelCase per la rappresentazione di variabili composte da due o pi\u00f9 parole Vediamo qualche esempio: //Sintassi alternativa per dichiarare pi\u00f9 variabili costanti const na = 3 , pigreco = 3.14 ; _iou = 0 ; $yui = 78 ; u - 1 = 45 ; //ERROR!! 1 T = 1 ; //ERROR!!","title":"Alcune regole per dichiarazione di variabili"},{"location":"javascript/READMEV2/#tipi-di-dati-in-js","text":"ECMAScript definisce sette tipi primitivi: Sei tipi di dato che sono primitives : Boolean . true e false. null . Una parola chiave che denota un oggetto nullo. undefined . Una propriet\u00e0 il cui valore non \u00e8 stato definito. Number . 42 oppure 3.14159. String . \"Salve\" Symbol . Un tipo di dato la cui istanza \u00e8 unica e immutabile. Object . NOTA: typeof \u00e8 una propriet\u00e0 di Javascript che ritorna il tipo di un oggetto o una variabile.","title":"Tipi di dati in JS"},{"location":"javascript/READMEV2/#tipi-primitivi","text":"Javascript assegna il tipo a una variabile in modo dinamico ovvero in fase di dichiarazione della stessa. Vediamo degli esempi const nome = 'simone' ; const cognome = \"Di Ricco\" ; const nome_cognome = ` ${ nome } ${ cognome } ` ; const temp = - 1.5 ; //Number const isMaggiorenne = true ; //Boolean const value = null ; //Number const cognome = undefined ; //Undefined const mySymbol = Symbol (); //Undefined const persona = { //Object nome : 'simone' , eta : 25 , isMarry : true }","title":"Tipi Primitivi"},{"location":"javascript/READMEV2/#standard-built-in-object","text":"Sono oggetti predefiniti e accessibili a livello globale, di uso comune in JavaScript. Hanno propriet\u00e0 e metodi built-in che servono ad eseguire operazioni comuni per l\u2019accesso e la modifica dei dati che contengono.","title":"Standard built-in Object"},{"location":"javascript/READMEV2/#oggetti-fondamentali","text":"Oggetti generali di Javascrpt, sui quali sono basati tutti gli altri oggetti. Rappresentano oggetti, funzioni ed errori. Object Function Boolean Symbol Error EvalError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ATTENZIONE: Se un reference type (array o oggetto) \u00e8 dichiarato const non significa che non \u00e8 possibile modificare i campi all'interno ma solo che non posso cambiare la natura del reference type. Il nome di un reference type rappresenta solo l'indirizzo in memoria della struttura. const myObj { nome : 'simone' , cognome : 'di ricco' , eta : 34 } myObj . nome = 'luca' ; //OK myOby = 5 ; //ERROR, con const un <oggetto> non pu\u00f2 diventare dinamicamente un <number> let myObj2 { ram : 4 , rom : 5 , anno : 2010 } myObj2 . ram = 6 ; //OK myObj2 = 18 ; //OK con let un <oggetto> pu\u00f2 tramutarsi dinamicamente in un <number> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!","title":"Oggetti Fondamentali"},{"location":"javascript/READMEV2/#approfondimento-null-undefined-nan","text":"undefined : Si verifica quando un oggetto o una variabile non assume nessun valore null : E' un valore attributo in fase di programmazione per identificare che un dato oggetto o variabile non assume nessun valore. Differisce da undefined poich\u00e8 null \u00e8 previsto deliberatamente in fase di programmazione NaN : Viene restituito quando l'espressione numerica valutata non restituisce un Number Esempio 1: console . log ( null === undefined ); //false Nota: Per controllare gli stati di null e undefined \u00e8 possibile utilizzare direttamente le keyword null e undefined come nell'esempio sopra illustrato. La stessa cosa non vale per NaN . In questo caso si utilizza IsNaN() . //Attenzione console . log ( NaN != NaN ); //true !!!!","title":"Approfondimento Null - undefined - NaN"},{"location":"javascript/READMEV2/#stringhe","text":"Una stringa \u00e8 un tipo di dato formato da zero o pi\u00f9 caratteri racchiusi tra virgolette doppie \" \" , singole ' ' o tramite accento grave. \u00c8 possibile chiamare qualsiasi metodo dell'oggetto String su una stringa. const saluto = 'Ciao a tutti' ; //Stringa multi-line. Attenzione all'apice -accento grave- var fraseFilosofica = `Il mattino ha l'oro in bocca. La sera no` ;","title":"Stringhe"},{"location":"javascript/READMEV2/#opearotri-proprieta-e-metodi-su-stringhe","text":"","title":"Opearotri, Propriet\u00e0 e Metodi su stringhe"},{"location":"javascript/READMEV2/#operatori","text":"+ : Uninione/concatenazione di stringhe. [ index ] : Indicizzazione di una stringa come array di caratteri, in sola lettura <, > : operatori di confronto tra stringhe. Ritornano un boolean , true/false {} : Interpolazione di stringhe const nome = \"marco\" ; const cognome = \"rossi\" ; console . log ( nome + \" \" + cognome ); //marco rossi // 0,1,2,3,4 //const cognome = \"r o s s i\"; console . log ( cognome [ 1 ]); //\"o\" console . log ( nome > cognome ); //true","title":"Operatori"},{"location":"javascript/READMEV2/#approfondimento-interpolazioni-di-stringhe","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. E' possibile utilizzare espressioni all'interno di un unica stringa. Per far cio' si ricorre all'interpolazione di stringhe molto comune anche in altri linguaggi di programmazione. La sintassi prevede di usare SOLO l'accento grave e per le espressioni da valutare, l'operatore $ seguito dall'espressione racchiusa tra le parentesi graffe { } let index = 0 ; //La variabile \"index\" viene valuta console . log ( ` ${ index } ciao` ); //0 index = index + 1 ; console . log ( ` ${ index } ciao` ); //1","title":"Approfondimento Interpolazioni di stringhe"},{"location":"javascript/READMEV2/#le-stringhe-sono-immutabili","text":"!! LE STRINGHE SONO IMMUTABILI IN JAVASCRIPT !! Questo significa che dal punto di vista semantico le stringhe non possono essere trattate come array di caratteri e di fatto non \u00e8 possibile applicare alle stringhe i metodi applicabili agli array. var saluto = \"ciao\" saluto [ 2 ] = 'Z' ; //Attenzione! LE STRINGHE SONO IMMUTABILI console . log ( saluto ); //ciao L'unico modo per cambiare un carattere all'interno di una stringa \u00e8 distruggere l'intera stringa e ricostruirne un'altra con il carattere modificato tramite assegnamento. Non \u00e8 possibile tuttavia modificre direttamente il singolo carattere di una stringa. var saluto = \"ciao\" saluto [ 2 ] = '2' ; console . log ( saluto ); //ciao saluto = \"super ciao\" console . log ( saluto ); //super ciao","title":"Le stringhe sono immutabili"},{"location":"javascript/READMEV2/#proprieta","text":"La propiet\u00e0 .lenght restituisce il numero di caratteri presenti nella stringa. const nome = \"marco\" ; console . log ( nome . lenght ); //5 console . log ( \"ciao\" . lenght ); //4","title":"Propriet\u00e0"},{"location":"javascript/READMEV2/#metodi","text":"Vediamo adesso diversi metodi applicabili alle stringhe. Pi\u00f9 avanti, quando tratteremo gli oggetti capiremo meglio la terminologia metodo/propriet\u00e0/operatore. Per adesso \u00e8 importante capirne gli esempi applicativi e imparare ad usare le stringhe per intuirne le potenzialit\u00e0. toUpperCase() : - Parametri : - Tipo di Ritorno : String - Descrizione : Ritorna la stringa in caratteri maiuscoli console . log ( \"simOne di rIcco\" . toUpperCase ()); //SIMONE DI RICCO toLowerCase() : - Parametri : - Tipo di Ritorno : String - Descrizione :Ritorna la stringa in caratteri minuscoli console . log ( \"SimOne di rICco\" . toLowerCase ()); //simone di ricco charAt(index) : - Parametri : index ( Number ) - Tipo di Ritorno : String - Descrizione : Restituisce il carattere all'interno della stringa corrispondente all'indice index (Ottenibile anche tramite l'indicizzazione [ ]) console . log ( \"JaVascript\" . charAt ( 3 )); //a substring(indexStart, indexEnd) : - Parametri : indexStart ( Number ), indexEnd ( Number ) - Tipo di Ritorno : String - Descrizione : Ritorna la porzione di stringa compresa tra indexStart incluso e indexEnd escluso. console . log ( \"JaVascript language\" . substring ( 0 , 10 )); //JaVascript endsWith(param) - Parametri : param ( String ) - Tipo di Ritorno : boolean - Descrizione :ritorna un boolean se la stringa termina o meno con la stringa param console . log ( \"myPdfFile.pdf\" . endsWith ( \"pdf\" )); //true console . log ( \"01110000011\" . endsWith ( \"10\" )); //false startsWith(string) : - Parametri : param ( String ) - Tipo di Ritorno : boolean - Descrizione :ritorna un boolean (true/false) se la stringa inizia o meno con la stringa param console . log ( \"01110000011\" . startsWith ( \"0111\" )); //true .includes(param1, ?param2) : - Parametri : param1 ( String ), param2 ( Number ), - Tipo di Ritorno : boolean - Descrizione : cerca la stringa param1 a partire dall'indice opzionale param2 , ritorna true o false. Se param2 \u00e8 omesso cerca param1 in tutta la stringa console . log ( \"JaVascript is programming language\" . includes ( \"is\" )); //true console . log ( \"JaVascript is programming language\" . includes ( \"is\" , 16 )); //false indexOf(param1, ?param2) : - Parametri : param1 ( String ), param2 ( Number ), - Tipo di Ritorno : Number - Descrizione : Cerca la prima occorrenza della stringa param1 a partire dall'indice opzionale param2 . Restituisce l'indice della posizione di param1 . Se non trova param1 nella stringa restituisce -1. Se param2 \u00e8 omesso cerca param1 in tutta la stringa a partire dall'inizio della stringa. console . log ( \"0011010111000110\" . indexOf ( \"111\" )); //7 console . log ( \"0011010111000110\" . indexOf ( \"111\" , 10 )); //-1 lastIndexOf(param1, param2) : - Parametri : param1 ( String ), param2 ( Number ), - Tipo di Ritorno : Number - Descrizione : Cerca l'ultima occorrenza della stringa param1 vincolato dall'indice limite param2 . Restituisce l'indice della posizione di param1 . Se param2 \u00e8 omesso cerca param1 in tutta la stringa a partire dalla fine della stringa. padEnd(param1, param2) : - Parametri : param1 ( Number ), param2 ( String ), - Tipo di Ritorno : String - Descrizione : Riempie la stringa fino a una lunghezza massima di param1 , aggiungendo come riempitivo in coda la stringa param2 console . log ( \"100\" . padEnd ( 5 , \"-\" )); //100-- console . log ( \"100000\" . padEnd ( 5 , \"-\" )); //100000 console . log ( \"\" . padEnd ( 5 , \"-\" )); //----- padStart(param1, param2) : - Parametri : param1 ( Number ), param2 ( String ) - Tipo di Ritorno : String - Descrizione : Riempie la stringa fino a una lunghezza massima di param1 , aggiungendo come riempitivo in testa la stringa param2 console . log ( \"120\" . padStart ( 5 , \"0\" )); //00120 console . log ( \"9040\" . padStart ( 5 , \"0\" )); //09040 console . log ( \"2\" . padStart ( 5 , \"0\" )); //00002 repeat(param) : - Parametri : param ( Number ) - Tipo di Ritorno : String - Descrizione : Replica la stringa un numero di volte specificato da param console . log ( \"0\" . repeat ( 32 )); //00000000000000000000000000000000 console . log ( \"*-\" . repeat ( 8 )); //*-*-*-*-*-*-*-*- replace(param1, param2) : - Parametri : param1 ( String ), param2 ( String ) - Tipo di Ritorno : String - Descrizione : Sostituisce la prima occorennza della stringa param1 con la stringa param2 . Funziona anche se param1 \u00e8 un'espressione regolare. console . log ( \"Ciao a tutto il mondo\" . replace ( \"o\" , \"0\" )); //Cia0 a tutto il mondo //Uso interessante del metodo replace() con un'espressione regolare. /o/g >>> cerca tutte le occorrenze //di \"o\". Nota che \"g\" sta per \"global\" cio\u00e8 tutte console . log ( \"Ciao a tutto il mondo\" . replace ( /o/g , \"0\" )); //Cia0 a tutt0 il m0nd0 search(param) : - Parametri : param ( String ) - Tipo di Ritorno : Number - Descrizione : cerca la prima occorenza di param e restituisce l'indece della posizione. Funziona anche se param \u00e8 un'espressione regolare. console . log ( \"Ciao a tutto il mondo\" . search ( \"mondo\" )); //16 console . log ( \"Ciao a tutto il mondo\" . search ( \"ill\" )); //-1 slice(indexStart, indexEnd) : - Parametri : indexStart ( Number ), indexEnd ( Number ) - Tipo di Ritorno : String - Descrizione : Restituisce una sottostringa tra indexStart e indexEnd console . log ( \"DRCSMN91L22E715Q\" . slice ( 6 , 8 )); //91 split(separatore, ?max) : - Parametri : separatore ( String ), max ( Number ) - Tipo di Ritorno : Array of String - Descrizione : Pu\u00f2 essere utilizzato per raggruppare delle stringhe sottoforma di array contenute in un unica grande stringa e separate tramite un separatore. Crea quindi un array di stringhe contenente porzioni di stringa derivate dalla stringa a cui \u00e8 applicato il metodo separate dal carattere (o i caratteri) come indicato nel parametro separatore . Il secondo parametro, opzionale, indica il numero massimo di elementi dell'array. const myArray = \"Ciao a tutto il mondo\" . split ( \" \" ); console . log ( myArray ); //(5) [\"Ciao\", \"a\", \"tutto\", \"il\", \"mondo\"] console . log ( myArray [ 3 ]); //il const myArray2 = \"Ciao a tutto il mondo\" . split ( \" \" , 3 ); console . log ( myArray2 ); //(3) [\"Ciao\", \"a\", \"tutto\"] trim() : - Parametri : - Tipo di Ritorno : String - Descrizione : rimuove gli spazi all'inizio e alla fine di una stringa console . log ( \"#\" + \" Ciao a tutto il mondo \" . trim () + \"#\" ); //#Ciao a tutto il mondo# trimLeft() : - Parametri : - Tipo di Ritorno : String - Descrizione : rimuove gli spazi in testa a una stringa. console . log ( \"#\" + \" Ciao a tutto il mondo \" . trimLeft () + \"#\" ); //#Ciao a tutto il mondo # trimRight() : - Parametri : - Tipo di Ritorno : String - Descrizione : rimuove gli spazi in coda a una stringa console . log ( \"#\" + \" Ciao a tutto il mondo \" . trimRight () + \"#\" ); //# Ciao a tutto il mondo#","title":"Metodi"},{"location":"javascript/READMEV2/#lezione-08","text":"","title":"Lezione 08"},{"location":"javascript/READMEV2/#conta-parole","text":"Il seguente esempio conta le parole inserite in un certo input testuale. Faremo uso dell'evento keypress che scatta ad ogni tasto premuto e del metodo su stringa split() <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > Conta parole </ h1 > < table > < td > Testo: </ td > < tr > < td >< textarea cols = \"30\" rows = \"10\" id = \"myText\" ></ textarea ></ td > </ tr > < tr > < td > Parole nel testo: </ td > </ tr > < tr > < td >< input type = \"text\" id = \"word-count\" ></ td > </ tr > </ table > <!-- Collegamento alla libreria JQuery.--> < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function contaParole (){ //Prelievo il valore dell'elemento con id=\"myText\" lo converto a stringa e lo assegno alla variabile testoInserito let testoInserito = String ( $ ( \"#myText\" ). val ()); //Prelievo la propriet\u00e0 lenght di un array formato da parole separate da spazi. //ATTENZIONE. NON FUNZIONA CON I DOPPI SPAZI let conteggioParole = ( testoInserito . split ( \" \" ). length ); $ ( \"#word-count\" ). val ( conteggioParole ) } $ ( function (){ $ ( \"#myText\" ). keypress ( contaParole ) }); </ script > </ body > </ html >","title":"Conta parole"},{"location":"javascript/READMEV2/#lezione-09","text":"","title":"Lezione 09"},{"location":"javascript/READMEV2/#approfondimento-rappresentazione-numerica-in-javascript","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso","title":"Approfondimento - Rappresentazione numerica in Javascript"},{"location":"javascript/READMEV2/#numeri-in-fixed-point","text":"Per il tipo nativo Number Javascript utilizza 64 bit per la memorizzazione in ram sia per i numeri interi sia per i numeri decimali a \"virgola fissa\" (fixed point). Vengono utilizzati 53 bit per la parte intera e i restanti 9 per la parte decimale anche se un numero \u00e8 intero. Il numero intero (safe) pi\u00f9 grande rappresentabile in JS \u00e8 MAX_SAFE_INTEGER . MAX_SAFE_INTEGER : E' il numero intero pi\u00f9 grande a cui posso applicare un incremento in modo affidabile. Il metodo isSafeInteger() applicato all'oggetto Number ritorna un boolean che indica se il numero \u00e8 safe oppure no console . log ( Number . MAX_SAFE_INTEGER ); //9007199254740991 /* (property) NumberConstructor.MAX_SAFE_INTEGER: number The value of the largest integer n such that n and n + 1 are both exactly representable as a Number value. The value of Number.MAX_SAFE_INTEGER is 9007199254740991 2^53 \u2212 1. */ let n1 = Number . MAX_SAFE_INTEGER ; //OK, safe console . log ( Number . isSafeInteger ( n1 )); //true let n2 = Number . MAX_SAFE_INTEGER + 1 ; //OK, safe console . log ( Number . isSafeInteger ( n2 )); //true let n3 = Number . MAX_SAFE_INTEGER + 1 //NO, non safe, il risultato non \u00e8 affidabile console . log ( Number . isSafeInteger ( n3 )); //false","title":"Numeri in Fixed Point"},{"location":"javascript/READMEV2/#numeri-in-floating-point","text":"La rappresentazione dei numeri in \"virgola mobile\" (floating point) Javascript utilizza lo standard IEEE 754 //MAX_VALUE rappresenta il pi\u00f9 grande numero rappresentabile in virogla mobile console . log ( Number . MAX_VALUE ); //1.7976931348623157e+308 //Attenzione!! console . log ( 0.1 + 0.2 == 0.3 ); //false console . log ( 0.1 + 0.2 ); //0.30000000000000004 Lo standard IEE754 rappresenta i numeri reali e come tale \u00e8 necessario conoscere ed evitare alcune pratiche di cattivo utilizzo dei numeri reali. In generale con i numeri reali \u00e8 da evitare l'utilizzo di espressioni di uguglianza. E' possibile tuttavia trasformare un'espressione di uguaglianza esatta con un'espressione di \"vicinanza\" definendo un'accuratezza in questo modo: const accuracy = 0.0000001 ; console . log ( ( 0.1 + 0.2 ) - 0.3 < accuracy ); //true Il pi\u00f9 piccolo valore rappresentabile (vicino allo zero) in floating point \u00e8: console . log ( Number . MIN_VALUE ); //5e-324 E' bene ricordare che la rappresentazione dei numeri con lo standard IEEE 754 \u00e8 su scala logaritimica quindi non lineare. Questo significa che posso rappresentare numeri estremamente grandi e numeri estremamente piccoli ma la distanza tra due numeri diventa sempre pi\u00f9 grande (e quindi meno accurata) mano a mano che i numeri diventano grandi e diventa pi\u00f9 piccola (quindi pi\u00f9 accurata) mano a mano che i numeri diventano piccoli","title":"Numeri in Floating Point"},{"location":"javascript/READMEV2/#not-a-number-nan","text":"Javascript restituisce NaN quando valuta che un'espressione non pu\u00f2 essere svolta e darebbe errore. console . log ( 10 / \"ciao\" ); //NaN console . log ( 0 / 0 ); //NaN E' buona norma evitare NaN in special modo per quelle espressioni numeriche non prevedibili o che ricevono valori dall'esterno. La funzione isNaN() restituisce un boolean se un dato valore risulta o meno un NaN. let myVar = 12 / 0.9 ; if ( ! isNaN ( myVar ) ) { console . log ( myVar ); }","title":"Not A Number NaN"},{"location":"javascript/READMEV2/#lezione-10","text":"","title":"Lezione 10"},{"location":"javascript/READMEV2/#approfondimento-codifica-caratteri-javascript","text":"Questa parte per adesso potrebbe essere troppo approfondita, \u00e8 possibile saltarla senza pregiudicare il corso","title":"Approfondimento - Codifica caratteri Javascript"},{"location":"javascript/READMEV2/#ascii","text":"ASCII (acronimo di American Standard Code for Information Interchange, Codice Standard Americano per lo Scambio di Informazioni) \u00e8 un codice per la codifica di caratteri. Lo standard ASCII \u00e8 stato pubblicato dall'American National Standards Institute (ANSI) nel 1968 Con US-ASCII si intende un sistema di codifica dei caratteri a 7 bit, comunemente utilizzato nei calcolatori, proposto dall'ingegnere dell'IBM Bob Bemer nel 1961, e successivamente accettato come standard dall'ISO, con il nome di ISO/IEC 646. Alla specifica iniziale basata su codici di 7 bit fecero seguito negli anni molte proposte di estensione ad 8 bit e quindi 256 caratteri, con lo scopo di raddoppiare il numero di caratteri rappresentabili. Nei PC IBM si fa per l'appunto uso di una di queste estensioni, ormai standard de facto, chiamata extended ASCII o high ASCII. In questo ASCII esteso, i caratteri aggiunti sono vocali accentate, simboli semigrafici e altri simboli di uso meno comune. I caratteri di ASCII esteso sono codificati nei cosiddetti codepage. Ogni paese present\u00f2 la sua proposta di ASCII esteso per rappresentare e codificare tutti i caratteri aggiuntivi relativi alla lingua creando non pochi problemi di comunicazione tra continenti. C'era quindi bisogno di uno standard nuovo e unico per tutto il mondo. Nasce quindi l'UNICODE. Wikipedia - ASCII","title":"ASCII"},{"location":"javascript/READMEV2/#unicode","text":"Unicode \u00e8 stato creato per risolvere i limiti dei tradizionali schemi di codifica dei caratteri Ad esempio , sebbene i caratteri definiti nella ISO 8859-1 siano ampiamente utilizzati in paesi diversi, spesso si verifica incompatibilit\u00e0 tra paesi diversi. Molti metodi di codifica tradizionali hanno un problema comune, ovvero consentono ai computer di gestire un ambiente bilingue (di solito utilizzando lettere latine e le loro lingue native), ma non possono supportare un ambiente multilingue allo stesso tempo (riferendosi a una situazione in cui pi\u00f9 lingue possono essere mescolate contemporaneamente). Unicode era stato originariamente pensato come una codifica a 16 bit (quattro cifre esadecimali) che dava la possibilit\u00e0 di codificare 65.535 (2^16 -1) caratteri. Tanto si riteneva essere sufficiente per rappresentare i caratteri impiegati in tutte le lingue scritte del mondo. Ora invece lo standard Unicode, che tendenzialmente \u00e8 perfettamente allineato con la norma ISO/IEC 10646, prevede una codifica fino a 21 bit e supporta un repertorio di codici numerici che possono rappresentare circa un milione di caratteri. Ci\u00f2 appare sufficiente a coprire anche i fabbisogni di codifica di scritti del patrimonio storico dell'umanit\u00e0, nelle diverse lingue e negli svariati sistemi di segni utilizzati. Al 2009, solo una piccolissima parte di questa disponibilit\u00e0 di codici \u00e8 assegnata. Per lo sviluppo dei codici sono infatti previsti 17 \"piani\" (\"planes\", in inglese), da 00 a 10hex, ciascuno con 65.536 posizioni (quattro cifre esadecimali), ma solo i primi tre e gli ultimi tre piani sono ad oggi assegnati[2], e di questi il primo, detto anche BMP, \u00e8 praticamente sufficiente a coprire tutte le lingue pi\u00f9 usate. Concretamente, questo repertorio di codici numerici \u00e8 serializzato mediante diversi schemi di ricodifica, che consentono l'uso di codici pi\u00f9 compatti per i caratteri usati pi\u00f9 di frequente. \u00c8 previsto l'uso di codifiche con unit\u00e0 da 8 bit (byte), 16 bit (word) e 32 bit (double word), descritte rispettivamente come UTF-8, UTF-16 e UTF-32. UTF-8 \u00e8 di fatto lo standard successore di ASCII, perfettamente compatibile mentre javascript utilizza l'UTF-16 consentendo di rappresentare un numero elevato di caratteri, 655536. Ci\u00f2 non significa che per le codifiche UTF-8 e UTF-16 non sia possibile rappresentare tutti i caratteri unicode ma a causa della codifica potrebbe non essere conveniente in certe situazioni utilizzare UTF-8 anzich\u00e8 UTF-16. In certe situazioni infatti UTF-8 potrebbe aver bisogno di 3 byte per rappresentare un certo carattere mentre UTF-16 soltanto 2. Dipende dalla frequenza e natura dei caratteri. Si rirprenda il template html: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > </ body > </ html > Alla riga < meta charset = \"UTF-8\" > E' indicata la codifica necessaria per la trasmissione e visualizzazione corretta dei caratteri. Wikipedia - Unicode Wikibooks - Unicode/Character reference/0000-0FFF","title":"Unicode"},{"location":"javascript/READMEV2/#caratteri-di-escape","text":"Il backslash \\ indica la presenza di un carattere escape che non sarebbe possibile inserire direttamente con un editor di testo poich\u00e8 verrebbe interpretato come un comando. Vediamo qualche carattere di escape: \\n : a capo \\t : tab \\b : Backspace \\r : Carriage return \\\\ : Backslash \\' : Single quote \\\" : Double quote Introdotti gli escape \u00e8 possibile vedere come inserire un carattere UNICODE tramite il suo codice identificatico: \\u{codice_unicode} let str = \"\\u{1234}\" ; // \u1234 === 1234 codice unicode, 1 carattere console . log ( str ); console . log ( str , str . lenght ); //\u1234, 1 //Attenzione!! la codifica UTF-16 non raggiunge direttamnte il carattere stampato qui di seguito //Utilizza quindi 2 caratteri Javascript let str = \"\\u{1F600}\" ; // \ud83d\ude00 === 1F600 codice unicode, 2 caratteri console . log ( str , str . lenght ); //\ud83d\ude00, 2 Posso risalire al codice unicode tramite il metodo charCodeAt(index) che restituisce il codice unicode del carattere specificato da index . let str = \"\\u{1F600}\" ; // \ud83d\ude00 === 1F600 codice unicode 2 caratteri console . log ( str ); //\ud83d\ude00 console . log ( str . charCodeAt ( 0 ), strCharCodeAt ( 1 )); //55357 56832 C'\u00e8 anche il metodo che pi\u00f9 completo charCodePointAt(index) che restituisce il codice unicode che inizia da index . Questo \u00e8 necessario per quei caratteri che non possono essere rappresentati da UTF-16 e che quindi sono necessari \"due caratteri\" Javascript let str = \"\\u{1F600}\" ; // \ud83d\ude00 === 1F600 codice unicode 2 caratteri console . log ( str ); //\ud83d\ude00 console . log ( str . codePointAt ( 0 )); // 128512 === 1F600 Posso usare l'unicode anche per il nome di variabili! Da evitare. var \\ u { 1 f68 } = 2017 ; // \u1f68","title":"Caratteri di Escape"},{"location":"javascript/READMEV2/#lezione-11","text":"","title":"Lezione 11"},{"location":"javascript/READMEV2/#type-conversion","text":"JavaScript \u00e8 un linguaggio con tipi assegnati dinamicamente. Questo significa che non si va a specificare il tipo di dato che una variabile conterr\u00e0 quando viene dichiarata e anche che il tipo di un dato viene convertito automaticamente a seconda delle necessit\u00e0 durante l'esecuzione dello script. Nelle espressioni che coinvolgono valori numerici e stringhe con l'operatore + JavaScript converte i valori numerici in stringhe (conversione implicita). Vediamo come formalizzare questi concetti e distinguere tra conversioni esplicite e implicite.","title":"Type conversion"},{"location":"javascript/READMEV2/#conversione-esplicita","text":"E' una pratica di buona programmazione far riferimento a conversioni esplicite come trattamento di errori o ricezione dati dall'esterno anche quando \"sembra\" che non sia necessario. La conversione esplicita forza un tipo e previene in molti casi errori di mal interpretazione dei dati. Vediamo alcune soluzioni disponibili per la conversione esplicita tra tipi in Javascript. String(value) : converte value (qualsiasi tipo) in un tipo String value.toString() : metodo che converte value in una stringa (equivalente a String(value) ) Number(value) : converte value in un tipo Number parseInt(value) - converte value in un tipo Number e ritorna la parte intera parseInt(value) - converte value in un tipo Number e ritorna la parte frazionaria //Number to string - String(value) let value = 45 ; String ( value ); //ritorna la stringa '45' //Boolean to string - String(value) let value2 = false ; String ( value2 ); //ritorna la stringa 'false' //Metodo alternativo - toString(); let value3 = false ; ( value3 ). toString (); //ritorna la stringa 'false' //String to number - Number(string) let string = '45' ; Number ( string ); //ritorna il numero 45 //Boolean to number - Number(string) let myBool = true ; Number ( myBool ); //1ritorna il numero 1 parseInt ( '100.31' ); //100 parseFloat ( '100.31' ); //31","title":"Conversione esplicita"},{"location":"javascript/READMEV2/#conversione-implicita","text":"Anche se \u00e8 sconsigliato affidarsi alle conversioni implicite, cio\u00e8 quelle che Javascript effettua implicitamente incontrando in una espressione due o pi\u00f9 valori appartenenti a tipi diversi, \u00e8 bene conoscerle per difendersi e saperle trattare. In alcuni semplici casi non \u00e8 comunque sbagliato utilizzarle. Riporto un esempio qui sotto: // Type coercion const nome = 'marco' ; const cognome = 'rossi' ; const eta = 20 ; const sposato = false ; console . log ( nome + ' ' + cognome + ' ha ' + eta + ' anni. ' + '\u00e9 sposato? ' + sposato ); /* Console: --------------- marco rossi ha 20 anni. E' sposato? false */ Notiamo che la variabile eta \u00e8 stata convertita da tipo numero a tipo stringa e la variabile sposato \u00e8 stata convertita da boolean a stringa in modo implicito da javascript. Queste sono conversioni effettuate in modo automatico da javascript poich\u00e8 nella stessa espressione si trovano tipi diversi.","title":"Conversione implicita"},{"location":"javascript/READMEV2/#lezione-12","text":"","title":"Lezione 12"},{"location":"javascript/READMEV2/#operatori-matematici","text":"Vediamo alcuni operatori matematici direttamente con un esempio: /* operatori matematici */ const questAnno = 2020 ; const etaMarco = 25 ; const etaStefano = 22 ; const nascitaMarco = questAnno - etaMarco ; const nascitaStefano = questAnno - etaStefano ; console . log ( nascitaMarco ); //1995 console . log ( nascitaStefano ); //1998 console . log ( 5 * 2 ); //10 console . log ( 5 / 2 ); //2.5 // Modulo: resto della divisione intera console . log ( 7 % 4 ); //3","title":"Operatori matematici"},{"location":"javascript/READMEV2/#pre-e-post-incrementodecremento","text":"L'operatore di incremento incrementa (aggiunge uno a) il suo operando e restituisce un valore. ++x / --x : pre incremento/decremento restituisce il valore dopo l'incremento x++ / x-- : post incremento/decremento restituisce il valore prima di incrementare Pre e post incremento/decremento rilevano una differenza solo in caso di valutazione di un'espressione. Se troviamo Pre e post incremento/decremento isolati in un singolo statement (come spesso accade) risultano equivalenti. //Pre incremento x = 0 ; y = ++ x ; //y=1, x=1 //Post incremento x = 0 ; y = x ++ ; //y=0, x=1 x = 0 ; x ++ ; //x=1 // in questo caso \u00e8 equivalente a ++x x = 0 ; ++ x ; //x=1 // in questo caso \u00e8 equivalente a x++ La lista di tutti gli operatori aritmetici la troviamo alla pagina: MDN - Operatori Aritmetici","title":"Pre e post incremento/decremento"},{"location":"javascript/READMEV2/#oggetto-math","text":"In JS \u00e8 possibile utilizzare funzioni matematiche avanzate tramite l'oggetto Math . Vediamo alcune tra le pi\u00f9 comuni: Math.round(value) : Ritorna l'arrotondamento di value al numero pi\u00f9 vicino Math.ceil(value) : Ritorna l' arrotondamento di value per eccesso Math.floor(value) : Ritorna l' arrotondamento di value per difetto Math.trunc(value) : Ritorna il troncamento di value Math.sqrt(value) : Ritorna la radice quadrata di value Math.abs(value) : Ritorna il valore assoluto di value Math.pow(base, exp) : Ritorna l'esponenziale: base^exp Math.min(value1, value2, value3, ..) : Ritorna il minimo valore tra i parametri indicati tra gli argomenti Math.max(value1, value2, value3, ..) : Ritorna il massimo valore tra i parametri indicati tra gli argomenti Math.random() : Ritorna un numero random decimale nel range 0 - 1 Esempio: //Math.PI console . log ( Math . PI ); //stampa del numero pi greco: 3,14.. Math . round ( 42.1 ); //42 Math . round ( 42.5 ); //43 Math . round ( 42.7 ); //43 Math . ceil ( 42.1 ); //43 Math . ceil ( 42.5 ); //43 Math . ceil ( 42.7 ); //43 Math . floor ( 42.1 ); //42 Math . floor ( 42.5 ); //42 Math . floor ( 42.7 ); //42 Math . sqrt ( 25 ); //5 Math . sqrt ( 42.5 ); //6. Math . abs ( - 25 ); //25 Math . abs ( 42.5 ); //42.5 Math . pow ( 2 , 5 ); //32 ( 2 ** 5 ); //32 === 2^5 >> equivalente a Math.pow(2, 5); Math . pow ( 5 , 3 ); //125 Math . min ( 2 , 5 , - 2 , 6 ); //-2 Math . max ( 2 , 5 , - 2 , 6 ); //6 Math . random (); //0.234514378429 Math . trunc ( 12.78899 ); //12 La seguente riga di codice genera un numero casuale da 0 a 100. console . log ( Math . round (( Math . reandom () * 100 ))); //45","title":"Oggetto MATH"},{"location":"javascript/READMEV2/#lezione-13","text":"","title":"Lezione 13"},{"location":"javascript/READMEV2/#equazione-di-ii-grado","text":"Il seguente script calcola le soluzioni reali di un'equazione di secondo grado. Stampa \"Soluzioni immaginarie\" se le soluzioni non sono reali <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table { border : 2 px solid gray ; padding : 5 px ; border-radius : 10 px ; } body { font-size : 20 px ; } . cofficient { text-align : right ; } # resolve { height : 30 px ; } </ style > </ head > < body > < h1 > Equazione di II grado </ h1 > < table > < tr > < td > < input type = \"text\" placeholder = \"a\" class = \"cofficient\" id = \"a\" > x < sup > 2 </ sup > + < input type = \"text\" placeholder = \"b\" class = \"cofficient\" id = \"b\" > x + < input type = \"text\" placeholder = \"c\" class = \"cofficient\" id = \"c\" > = 0 </ td > </ tr > < tr > < td >< input type = \"button\" value = \"Risolvi\" id = \"resolve\" ></ td > </ tr > < tr > < td > < input type = \"text\" placeholder = \"---\" id = \"ris-1\" > x < sub > 1 </ sub > </ td > </ tr > < tr > < td > < input type = \"text\" placeholder = \"---\" id = \"ris-2\" > x < sub > 2 </ sub > </ td > </ tr > </ table > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > function ResolveEqIIgrado (){ //Prelievo il valore dell'elemento con id=\"myText\" lo converto a stringa e lo assegno alla variabile testoInserito let a = Number ( $ ( \"#a\" ). val ()); let b = Number ( $ ( \"#b\" ). val ()); let c = Number ( $ ( \"#c\" ). val ()); let delta = Math . sqrt ( b ** 2 - 4 * a * c ); if ( isNaN ( delta )) { $ ( \"#ris-1\" ). val ( \"Soluzioni immaginarie\" ); $ ( \"#ris-2\" ). val ( \"Soluzioni immaginarie\" ); } else { let ris1 = ( - b - delta ) / ( 2 * a ); let ris2 = ( - b + delta ) / ( 2 * a ); $ ( \"#ris-1\" ). val ( String ( ris1 )); $ ( \"#ris-2\" ). val ( String ( ris2 )); } } $ ( function (){ $ ( \"#resolve\" ). click ( ResolveEqIIgrado ) }); </ script > </ body > </ html >","title":"Equazione di II grado"},{"location":"javascript/READMEV2/#lezione-14","text":"","title":"Lezione 14"},{"location":"javascript/READMEV2/#operator-precedence","text":"La precedenza degli operatori determina la priorit\u00e0 in cui gli operatori vengono valutati. Gli operatori con precedenza pi\u00f9 alta sono valutati prima degli operatori con precedenza pi\u00f9 bassa. La lista completa di tutti gli operatori con le rispettive precedenze la troviamo qua: MDN - Operator Precedence Da notare che l'operatore ( ) ha la priorit\u00e0 pi\u00f9 alta e quindi la precedenza su tutti gli operatori. Questo significa che per forzare la precedenza, esattamente come per la matematica \u00e8 possibile sfruttare le parentesi ( ) . Regola di buona programmazione: Non \u00e8 mai una buona pratica di programmazione lasciare espressioni troppo complesse prive di parentesi anche se sono rispettate dal punto di vista semantico tutte le precedenze previste. Le parentesi, oltre a forzare la precedenza, offrono visivamente una chiarezza maggiore, evitando di commettere errori banali di svista. /* Operatore precedence */ /* Calcolo eta' media */ const questAnno = 2020 ; const maggiorenne = 18 ; const nascitaMarco = 1996 ; const nascitaLuca = 2006 ; /* l'operatore \"-\" ha precedenza sull'operatore \">\" quindi l'espressione \u00e8 svolta correttamente da sinistra verso destra La sottrazione verr\u00e0 quindi svolta prima dell'operatore \">\" */ let isMaggiorenne = questAnno - nascitaMarco > maggiorenne console . log ( isMaggiorenne ); //true let isMaggiorenne = questAnno - nascitaMarco > maggiorenne console . log ( isMaggiorenne ); //false //Grouping const etaMarco = questAnno - nascitaMarco ; //24 const etaLuca = questAnno - nascitaLuca ; //14 // In questo caso poich\u00e8 la divisione ha precedenza sulla somma \u00e8 necessario forzare la priorit\u00e0 inserendo le parentesi // Calcolo et\u00e0 media console . log ( ( etaMarco + nascitaLuca ) / 2 ); //19","title":"Operator Precedence"},{"location":"javascript/READMEV2/#associativita","text":"L'associativit\u00e0 specifica in che modo vengono eseguite le elaborazioni a parit\u00e0 di operatore. Mentre la precedenza valuta la priorit\u00e0, l'associativit\u00e0 valuta la modalit\u00e0 di esecuzione. Quasi tutti gli operatori hanno un'associativit\u00e0 left-to-right ovvero, l'elaborazione \u00e8 da sinistra verso destra esattamente come per la matematica. Alla pagina MDN - Operator Precedence si trova una tabella riassuntiva che mostra priorit\u00e0/associativit\u00e0 per ogni operatore. //Associativit\u00e0 del'operatore +. L'operatore + vale sia da somma che da concatenazione stringa for ( let i = 0 , j = 5 ; i <= j ; i ++ , j -- ){ document . writeln ( i + j + \" \" ); //5//5//5 } for ( let i = 0 , j = 5 ; i <= j ; i ++ , j -- ){ document . writeln ( i + ( j + \" \" ) ); //05//14//23 }","title":"Associativit\u00e0"},{"location":"javascript/READMEV2/#operatori-di-assegnamento","text":"L'operatore di assegnazione semplice = viene utilizzato per assegnare un valore a una variabile. L'operazione di assegnazione restituisce il valore assegnato. \u00c8 possibile concatenare l'operatore di assegnazione per assegnare un singolo valore a pi\u00f9 variabili (multiple assignment). //Multiple assignement // E' possibile dichiarare due variabili contemporaneamente let x , y ; /*Molto importante! L'operatore \"= \u00e8 un operatore da destra a sinistra */ x = y = ( 2 * 7 ) * 3 - 5 ; // 9 * 3 - 5 // 27 - 5 // 22 console . log ( x ); //22 console . log ( y ); //22 Molto utilizzati sono anche gli operatori di assegnamento composto come: +=, -=, *=, /= .. Hanno una sintassi molto chiara e compatta. Vengono utilizzati nei casi in cui \u00e8 necessario elaborare anche il valore della variabile a sinistra contrariamente all'operatore di assegnamento semplice = che ignora e distrugge il valore contenuto a sinistra. let x = 10 ; x *= 2 ; // x = x * 2 console . log ( x ); //20 x /= 2 ; // x = x / 2 console . log ( x ); //10","title":"Operatori di assegnamento"},{"location":"javascript/READMEV2/#lezione-15","text":"","title":"Lezione 15"},{"location":"javascript/READMEV2/#operatori-logici","text":"Gli operatori logici < , <= , == , > , >= , != .. trattano l'espressione come un espressione logica e ritornano un valore booleano. Sono spesso utilizzati nel controllo di condizioni in costruttti if o cicli while , for e tutti i costrutti condizionali e iterativi inerenti. console . log ( 1 >= 5 ); //false //Per le stringhe si segue un ordine lessicografico console . log ( \"ciao\" < \"pasta\" ); //true console . log ( 12 != 5 ); / / / true Nota - Operatore di uguaglianza: == Vs === Entrambi sono operatori logici di uguaglianza. === : Uguaglianza forte , valuta l'uguaglianza dell'espressione valutanto il tipo e il contenuto. == : Uguaglianza debole , valuta l'uguaglianza dell'espressione valutanto il contenuto effettuando prima una conversione di tipo. /* === */ console . log ( 5 === 5 ); //true console . log ( 15 === \"15\" ); //false -> sono tipi di dati diversi, il primo \u00e8 un numero, il secondo \u00e8 una stringa console . log ( null === undefined ); //false -> sono tipi di dati diversi. /* == */ console . log ( 5 == 5 ); //true console . log ( 15 == \"15\" ); //true!! -> sono tipi di dati diversi, il primo \u00e8 un numero, il secondo \u00e8 una stringa ma il contenuto \u00e8 lo stesso console . log ( false == 0 ); //true!! -> entrambi hanno un valore falsy anche se il tipo \u00e8 diverso console . log ( null == undefined ); //true!! -> entrambi hanno un valore falsy anche se il tipo \u00e8 diverso In generale l'uguaglianza forte \u00e8 da preferire per essere sicuri di effettuare quindi anche un controllo sul tipo e rendere pi\u00f9 semplice l'individuazione di errori run-time spesso causati da conversioni implicite di Javascript.","title":"Operatori Logici"},{"location":"javascript/READMEV2/#logica-booleana","text":"Trattano l'espressione come un'espressione logica e permettono la concatenazione di espressioni con pi\u00f9 operatori logici. Ritornano un valore booleano: TRUE , FALSE . Vediamo i principali: AND : condition1 && condition2 : Ritorna true se entrambe condition1 e condition2 risultano true . OR : condition1 || condition2 : Ritorna true se almeno una tra condition1 e condition2 risulta true . NOT : !condition1 : Inverte il risultato logico di condition1 . console . log ( ( 1 >= 5 ) || ( \"ciao\" < \"pasta\" ) ); //true console . log ( ( \"ciao\" < \"pasta\" ) && ( 12 == 5 ) ); //false","title":"Logica Booleana"},{"location":"javascript/READMEV2/#approfondimento-short-evalutation","text":"Se un' espressione logica risulta necessariamente true o false le elaborazioni concatenate non vengono elaborate. true || expr : expr non viene valutata false && expr : expr non viene valutata Esempio: console . log ( ( 1 < 2 ) || ( \"ciao\" < \"pasta\" ) ); //true, (\"ciao\" < \"pasta\") non viene valutata console . log ( ( 12 == 5 ) && ( \"c\" < \"p\" ) ); //false, (\"c\" < \"p\") non viene valutata","title":"Approfondimento - Short evalutation"},{"location":"javascript/READMEV2/#truthy-e-falsy","text":"I valori truthy e falsy sono quei valori considerati rispettivamente sempre veri o falsi o per meglio dire che ritornano sempre un boolean: true/false . Valori truthy: 1 , \"content\" .. Valori falsy: undefined , null , 0 , \"\" , NaN Vedremo adesso come mettere in pratica questi concetti attraverso l'uso di costrutti condizionali e iterativi.","title":"Truthy e falsy"},{"location":"javascript/READMEV2/#lezione-16","text":"","title":"Lezione 16"},{"location":"javascript/READMEV2/#control-structure-ifelse","text":"La struttura di controllo if/else esegue un'istruzione o un blocco di istruzioni se una condizione specificata come argomento di if risulta true . Se la condizione risulta false si eseguono le istruzioni del ramo else MDN - if...else if ( condition1 ) { //code } else if ( condition2 ) { //code } else { //code } La condizione espressa come argomento di if \u00e8 trattata come un'espressione logica e quindi ritorna un boolean: true/false . /*Utilizzo di operatori logici combinati al costrutto if/else*/ const maggioreEta = 18 ; const etaLuca = 10 ; if ( etaLuca > maggioreEta ) { console . log ( \"Luca \u00e8 maggiorenne\" ); } else { console . log ( \"Luca non \u00e8 maggiorenne\" ); } /* Luca non \u00e8 maggiorenne */ /* Boolean logic, trattano l'espressione come logica AND -> && : ritorna TRUE se tutte le condizioni sono VERE OR -> || : ritorna TRUE se una condizione \u00e8 VERE NOT -> ! : inverte il risultato dell'espressione logica */ const nome = \"Luca\" ; const eta = 15 ; if ( eta <= 13 ) { console . log ( nome + \" \u00e8 un bambino\" ); } else if ( eta > 13 && eta <= 20 ) { console . log ( nome + \" \u00e8 un ragazzo\" ); } else { console . log ( nome + \" \u00e8 un adulto\" ); } /* Luca \u00e8 un ragazzo */","title":"Control Structure if/else"},{"location":"javascript/READMEV2/#ternary-operator","text":"Il Ternary Operator \u00e8 un costrutto condizionale inline. L'operatore condizionale (ternary) \u00e8 l'unico operatore JavaScript che necessit\u00e0 di tre operandi. Questo operatore \u00e8 frequentemente usato al posto del comando if per la sua sintassi concisa e perch\u00e9 fornisce direttamente un espressione valutabile. MDN - Operatore condizionale (ternary) (condition) ? (steatement1) : (steatement2); : Se condition risulta true verr\u00e0 eseguito steatement1 altrimenti steatement2 . /* Ternary Operator */ var nome = \"Marco\" ; var eta = \"17\" ; eta >= 18 ? console . log ( nome + \" pu\u00f2 guidare\" ) : console . log ( nome + \" non pu\u00f2 guidare\" ); /* Marco non pu\u00f2 guidare */ E' da preferire il ternary operator nei casi in cui si hanno due semplici statemeant da eseguire condizionati da un'espressione altrettanto semplice. In questo caso risulta chiaro ed elegante.","title":"Ternary Operator"},{"location":"javascript/READMEV2/#switch-statemeant","text":"L'ultimo costrutto condizionale \u00e8 switch . Il comando switch valuta un espressione, confronta il valore dell'espressione con ciascuna delle clausole case ed esegue i comandi (statements) associati alla clausola (case) che verifica il confronto. MDN - switch switch ( key ) { case value1 : //code break ; case value2 : //code break ; default : //code break ; } Esempio: /* switch statemeant*/ const sport = \"calcio\" ; switch ( sport ) { case \"calcio\" : console . log ( \"Amo giocare a calcio\" ); break ; case \"tennis\" : console . log ( \"Amo giocare a tennis\" ); break ; default : console . log ( \"non amo nessuno sportf\" ); break ; } /* Console: --------------- Amo giocare a calcio */ In che occasioni si usa \u00e8 preferibile utilizzare il costrutto switch ? E' da preferire quando si hanno opzioni multiple di una un unico key (un tipo di dato qualsiasi) da valutare e tutte le opzioni sono omogenee. In questo caso risulta chiaro e leggibile. Nel prossimo esempio lo switch/case \u00e8 trasformato in un if/else . /* switch statemeant*/ const nome = \"Matteo\" ; const eta = 15 ; switch ( true ) { case ( eta <= 13 ) : console . log ( nome + \" \u00e8 un bambino\" ); break ; case ( eta > 13 && eta <= 20 ) : console . log ( nome + \" \u00e8 un ragazzo\" ); break ; default : console . log ( nome + \" \u00e8 un adulto\" ); break ; } /* Matteo \u00e8 un ragazzo */ In questo caso lo switch/case risulta meno chiaro di un if/else . E' importante fin da subito saper utilizzare i costrutti giusti per la situazione giusta.","title":"Switch statemeant"},{"location":"javascript/READMEV2/#lezione-17","text":"","title":"Lezione 17"},{"location":"javascript/READMEV2/#while-loop","text":"L'istruzione while crea un ciclo che esegue un'istruzione specificata fintanto che la condizione di test restituisce true . La condizione viene valutata prima di eseguire l'istruzione. MDN - while while ( condition ) { //code } Esempio: let contatore = 1 ; while ( contatore < 5 ) { console . log ( contatore ); contatore ++ ; } /* 1 2 3 4 */ In un qualsiasi costrutto iterativo \u00e8 sempre bene tenere in considerazione: - La condizione da verificare - l'evento che altera, ad ogni ciclo, la condizione da verificare. Il programmatore si deve assicurare che prima o poi la condizione diventi falsa altrimenti rischia di creare un loop infinito causando un crash del browser. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > LOOP INFINITO </ h1 > < script > /*Loop Infinito - DA EVITARE! */ var infinito = 0 ; while ( infinito < 10 ) { console . log ( infinito ); } </ script > </ body > </ html > Altro esempio di un ciclo iterativo applicato a una stringa con while : var parola = \"ciao\" ; var contatore = 0 ; while ( contatore < parola . length ) { // 0 < 4 // 1 < 4 // 2 < 4 // 3 < 4 console . log ( parola [ contatore ]); // c // i // a // o contatore ++ ; // 1 // 2 // 3 // 4 } /* parola.lenght -> restituisce il numero delle lettere che compongono la stringa parola parola[contatore] -> restituisce il contenuto relativo all'indice \"contaotore\" Output: c i a o */","title":"while loop"},{"location":"javascript/READMEV2/#do-while-loop","text":"L'istruzione do ... while crea un ciclo che esegue un'istruzione specificata finch\u00e9 la condizione di test non restituisce false. La condizione viene valutata dopo l'esecuzione dell'istruzione, determinando l'esecuzione dell'istruzione specificata almeno una volta. MDN - do...while do { //code } while ( condition ); let j = 0 ; do { j ++ ; console . log ( j ); } while ( j < 5 ); console . log ( j ); /* Console: --------------- 0 1 2 3 4 */ Il do-while loop \u00e8 molto simile al while loop ma differisce nel punto in cui valuta la condizione sotto test. Qui sotto riporto un esempio dello stesso loop realizzato prima con while e poi con do-while. //while let i = 5 ; //la condizione \u00e8 falsa, non eseguo il corpo del loop while ( i < 5 ){ i ++ ; console . log ( i ); } console . log ( i ); /* 5 */ //do-while let j = 5 ; do { j ++ ; console . log ( j ); } while ( j < 5 ); //la condizione \u00e8 falsa ma ho eseguito una volta il corpo del loop console . log ( j ); /* Console: --------------- 6 6 */ do...while esegue il ciclo almeno una volta mentre while pu\u00f2 anche non eseguire mai il corpo. do...while \u00e8 meno utilizzato rispetto while ma pu\u00f2 comunque essere utilizzato in strutture iterative sempre in esecuzione come quella di selezione di un men\u00f9 grafico a opzioni multiple.","title":"do-while loop"},{"location":"javascript/READMEV2/#lezione-18","text":"","title":"Lezione 18"},{"location":"javascript/READMEV2/#for-loop","text":"L'istruzione for crea un ciclo che consiste di tre espressioni opzionali, racchiuse tra parentesi tonde ( ) e separate da punto e virgola, seguite da un'istruzione (di solito un'istruzione di blocco) da eseguire nel ciclo. MDN - for for ( inizializzazione ; condizione ; incremento / decremento ){ //code } Esempio: for ( let contatore = 1 ; contatore < 5 ; contatore ++ ){ console . log ( contatore ); } /* 1 2 3 4 */ Nota : la variabile \"contatore\", poich\u00e8 \u00e8 creata all'interno del ciclo for vive all'interno del ciclo. Al di fuori del ciclo non \u00e8 conosciuta. Vediamo anche un altro esempio precedentemente svolto con while : /* For Loop */ const nome = \"Marco\" ; for ( let i = 0 ; i < nome . length ; i ++ ){ // 0 < 4 // 1 < 4 // 2 < 4 // 3 < 4 // 4 < 5 // console . log ( nome [ i ]); // M // a // r // c // o } /* M a r c o */ Approfondimento: I cicli in cui sono note a priori il numero di iterazioni sono sono detti \"enumerativi\". Per questi cicli la struttura pi\u00f9 adatta \u00e8 certamente il for . I cicli si dicono invece \"indefiniti\" quando a priori non \u00e8 noto il numero esatto di iterazioni. Per questi cicli la struttura pi\u00f9 adatta \u00e8 il while o il do-while . Gli esempi riportati fino ad ora sono tutti cicli enumerativi. Notiamo infatti che la struttura for risulta pi\u00f9 chiara e compatta ed \u00e8 quindi da preferire.","title":"for loop"},{"location":"javascript/READMEV2/#break-coninue","text":"All'interno del corpo di loop statemeant for / while / do... while \u00e8 possible invocare i comandi: continue , break . - continue : Salta all'iterazione successiva ignorando le istruzioni successive - break : Esce dal loop. Vediamo l'uso attraverso un esempio //NO continue NO break for ( let i = 0 ; i < 5 ; i ++ ){ if ( i === 2 ){ console . log ( 'QUESTO \u00c8 2' ); } console . log ( i ); } /* Console: --------------- 0 1 QUESTO \u00c8 2 2 3 4 */ //<conitnue> salta all'iterazione successiva for ( let i = 0 ; i < 5 ; i ++ ){ if ( i === 2 ){ console . log ( 'QUESTO \u00c8 2' ); continue } console . log ( i ); } /* 0 1 QUESTO \u00c8 2 3 4 */ //<break> esce dal ciclo for ( let i = 0 ; i < 5 ; i ++ ){ if ( i === 2 ){ console . log ( 'QUESTO \u00c8 2' ); break ; } console . log ( i ); } /* 0 1 QUESTO \u00c8 2 */ Approfondimento break: E' possibile uscire da loop innestati facendo uso di un'etichetta. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > table td { text-align : center ; border : 1 px dashed black ; padding : 10 px ; margin-bottom : 10 px ; } </ style > </ head > < body > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > document . write ( \"<table>\" ); myLoop : for ( let i = 1 ; i <= 10 ; i ++ ) { document . write ( \"<tr>\" ); for ( let j = 1 ; j <= 10 ; j ++ ) { document . write ( \"<td>\" + \"A\" + \"</td>\" ); if ( j * i == 20 ) break myLoop ; } document . write ( \"</tr>\" ); } document . write ( \"</table>\" ); </ script > </ body > </ html >","title":"break &amp; coninue"},{"location":"javascript/READMEV2/#lezione-19","text":"","title":"Lezione 19"},{"location":"javascript/READMEV2/#function","text":"Le funzioni sono tra i blocchi di programmazione fondamentali in JavaScript. Una funzione \u00e8 una procedura JavaScript \u2014 un gruppo di istruzioni ( statement ) che esegue un compito o calcola un valore. La definizione di funzione ( o dichiarazione di funzione, o istruzione di funzione ) consiste della parola chiave function , seguita da: il nome della funzione. una lista di argomenti per la funzione, chiusi tra due parentesi e separati da una virgola. le istruzioni JavaScript che definiscono la funzione, chiuse tra due parentesi graffe, { }. MDN - Funzioni //Dichiarazione o definizione di una funzione function name ( param1 , param2 , ? param3 ) { //code } //Chiamata name ( param1 , param2 ); Esempio: /* Function with arguments */ function salutoCompleanno ( nome , anni ){ console . log ( \"ciao \" + nome + \", auguri per i tuoi \" + anni + \" anni!\" ); } salutoCompleanno ( \"Francesco\" , 22 ); //ciao Francesco, auguri per i tuoi 22 anni! Nota: L'ordine dei parametri \u00e8 importante! Nota2: Il passaggio dei parametri \u00e8 sempre per valore intendendo che al momento della chiamata della funzione, si esegue una copia dei parametri. Non vengono quindi elaborati direttamente i valori passati a una funzione","title":"Function"},{"location":"javascript/READMEV2/#parametri-di-default","text":"Alcuni parametri possono essere opzionali. In fase di chiamata possono quindi essere passati dei valori a tali parametri opppure no. In caso non venga passato un valore a tali parametri assumeranno all'interno della funzione un cos\u00ecdetto valore di default . Per inserire un valore di default e quindi rendere il parametro opzionale basta assegnare ad esso un valore in fase di dichiarazione della funzione. Vediamo un esempio: function salutoCompleanno ( nome , anni = 0 ){ if ( anni === 0 ){ console . log ( \"ciao \" + nome + \", auguri per il tuo compleanno!\" ); } else { console . log ( \"ciao \" + nome + \", auguri per i tuoi \" + anni + \" anni!\" ); } } salutoCompleanno ( \"Francesco\" , 22 ); //ciao Francesco, auguri per i tuoi 22 anni! salutoCompleanno ( \"Mario\" ); //ciao Mario, auguri per il tuo compleanno! NOTA: E' buona norma passare parametri in modo che i primi siano obbligatori e gli altri opzionali anche se tutto \u00e8 consentito ma di fatto in fase di chiamata della funzione i parametri passati sono interpretati a partire dal primo. Ricorda che conta solo l'ordine dei parametri e non l'identificativo utilizzato","title":"Parametri di default"},{"location":"javascript/READMEV2/#ritorno-di-una-funzione","text":"Una funzione pu\u00f2 restituire un valore con il comando return /* Return Keword */ function quadrato ( numero ){ return ( numero * numero ); } console . log ( quadrato ( 5 ) ); //25 E' preferibile che una funzione esegua un'elaborazione interna e che ritorni un valore invece di salvare il risultato all'interno di variabili esterne globali. In questo modo \u00e8 possibile riutilizzare la funzione ovunque e non renderla dipendente dal codice. E' quindi indispensabile l'utilizzo del return Note Una funzione ammette un solo return che termina l'esecuzione della funzione. Eventuali linee di codice dopo il return verranno ignorate.","title":"Ritorno di una funzione"},{"location":"javascript/READMEV2/#lezione-20","text":"","title":"Lezione 20"},{"location":"javascript/READMEV2/#funzioni-passaggio-di-oggetti-e-array","text":"Il passaggio di oggetti e array come parametri ad una funzione avviene per riferimento . Dal momento che viene passato il nome dell'oggetto e dell'array che corrisponde all'indirizzo puntatore dei dati contenuti, viene effettuata la copia dell'indirizzo e non dell'intero oggetto/array contenente i dati interni. In sostanza \u00e8 possibile accedere e modificare i dati dell'array o oggetto passato!! //Metodo Object - Gli oggetti sono passati per riferimento const annoAttuale = 2020 ; const objPersona = { nome : \"simone\" , eta : 24 , titolo : \"laurea\" , annoNascita : 1994 } aggiornaEta ( objPersona , annoAttuale ); console . log ( objPersona . eta ); //26 function aggiornaEta ( obj , anno ){ obj . eta = anno - obj . annoNascita ; console . log () } //Metodo Array - Gli array sono passati per riferimento const arrayPersona = [ \"simone\" , //0 24 , //1 \"laurea\" , //2 1994 //3 ]; aggiornaEta2 ( arrayPersona , annoAttuale ); console . log ( arrayPersona [ 1 ]); //26 function aggiornaEta2 ( array , anno ){ array [ 1 ] = anno - array [ 3 ]; console . log ( array ); }","title":"Funzioni - Passaggio di oggetti e array"},{"location":"javascript/READMEV2/#funzioni-ritorno-di-un-oggetto-o-un-array","text":"Una funzione in Javascript pu\u00f2 avere come tipo di ritorno anche un oggetto o un array //Metodo Oggetto let objRisultatoEqIIgrado = objCalcolaRisultatoEqIIgrado ( 1 , 5 , - 1 ); console . log ( \"Risultato 1: \" + objRisultatoEqIIgrado . x1 ); console . log ( \"Risultato 2: \" + objRisultatoEqIIgrado . x2 ); function objCalcolaRisultatoEqIIgrado ( a , b , c ){ let delta = Math . sqrt ( b * b - 4 * a * c ); let ris1 = ( - b + delta ) / 2 ; let ris2 = ( - b - delta ) / 2 ; //Ritorno un oggetto return { x1 : ris1 , x2 : ris2 }; } //Metodo Array let arrayRisultatoEqIIgrado = arrayCalcolaRisultatoEqIIgrado ( 1 , 6 , - 1 ); console . log ( \"Risultato 1: \" + arrayRisultatoEqIIgrado [ 0 ]); console . log ( \"Risultato 2: \" + arrayRisultatoEqIIgrado [ 1 ]); function arrayCalcolaRisultatoEqIIgrado ( a , b , c ){ let delta = Math . sqrt ( b * b - 4 * a * c ); let ris1 = ( - b + delta ) / 2 ; let ris2 = ( - b - delta ) / 2 ; //Ritorno un oggetto return [ ris1 , ris2 ]; }","title":"Funzioni - Ritorno di un oggetto o un array"},{"location":"javascript/READMEV2/#approfondimento-funzioni-oggetto-arguments","text":"Facendo uso di arguments \u00e8 possibile passare un numero indefinito di parametri. arguments raggruppa gli argomenti in un oggetto collezione di elementi. L'oggetto arguments permette di utilizzare la propriet\u00e0 lenght , l'indicizzazione [ ] ma non \u00e8 un array e quindi non si possono applicare i metodi applicabili agli array. arguments non si specifica nella definizione di una funzione tra i parametri poich\u00e8 \u00e8 un oggetto riconosciuto nel contesto stesso della funzione //arguments \u00e8 un oggetto riconosciuto all'interno della definizione della funzione function somma (){ let ris = 0 ; for ( let index = 0 ; index < arguments . length ; index ++ ) { ris += arguments [ index ]; } console . log ( arguments ); return ris ; } console . log ( somma ( 1 , 4 )); //5 console . log ( somma ( 1 , 4 , 6 , 0 , 3 , 1 , 2 )); //17 console . log ( somma ()); //0","title":"Approfondimento funzioni - Oggetto Arguments"},{"location":"javascript/READMEV2/#approfondimento-funzioni-parametri-rest","text":"La sintassi dei rest parameter permette di rappresentare un indefinito numero di argomenti come un array. A differenza dell'oggetto arguments in questo caso gli argomenti \"restanti\" sono rappresentati e raggruppati in un array ed \u00e8 possibile quindi utilizzare ogni metodo applicabile agli arrays. Si specificano i rest parameter all'interno della definizione di una funzione come ultimo parametro attraverso l'operatore rest ... ... : Operatore rest MDN - Rest parameters function calcola ( a , b , ... altriParam ){ ris = a + b ; //Il forEach(param1, param2) ha due parametri. Il primo \u00e8 una funzione che a sua volta accetta i parametri //opzionali (valore, indice, array) in questo caso dell'array altriParam passato come argomento a calcola. //this in questo caso rappresenta il fatto che voglio ritornare il valore all'interno del contesto di ris altriParam . forEach ( controllaEsomma , this ); return ris ; } function controllaEsomma ( valore , indice , array ){ if ( valore < 100 ) { //this riesce a raggiungere il contesto di \"ris\" della funzione calcola this . ris += valore ; } } console . log ( calcola ( 1 , 4 )); //5 console . log ( calcola ( 1 , 4 , 6 , 100 , 3 , 1 , 2 )); //17 console . log ( calcola ( 1 , 2 )); //0","title":"Approfondimento funzioni - Parametri Rest"},{"location":"javascript/READMEV2/#approfondimento-introduzione-foreach-this","text":"forEach() \u00e8 un metodo applicabile agli array. E' una struttura iterativa cheesegue una funzione fornita una volta per ogni elemento dell'array a cui si applica il metodo. La funzione riceve dall'array tre parametri opzionali in ordine: value, index, array ovvero il valore dell'elemento dell'array a cui si applica il metodo, l'indice dell'elemento e l'array stesso. myArray . forEach ( myFunc ); function myFunc ( value , index , array ){ //code; } Nell'esempio di sopra: altriParam . forEach ( controllaEsomma , this ); Esegue la funzione controllaEsomma per ogni elemento dell'array. function controllaEsomma ( valore , indice , array ){ if ( valore < 100 ) { //this riesce a raggiungere il contesto di \"ris\" della funzione calcola this . ris += valore ; } } L'identificatore this , come il forEach stesso verranno approfonditi pi\u00f9 avanti. Per adesso ci basta sapere che this consente di raggiungere un oggetto utilizzato come callback (valore di ritorno). Osservazione: Se dichiariamo la variabile \"ris\" con let o var ritorna NaN . Approfondimento: MDN - var","title":"Approfondimento Introduzione forEach / this"},{"location":"javascript/READMEV2/#lezione-21","text":"","title":"Lezione 21"},{"location":"javascript/READMEV2/#approfondimento-funzioni-ricorsive","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. La funzioni ricorsive sono funzioni che richiamano se stesse all'interno del corpo. Questa tecnica fornisce un modo per scomporre problemi complicati in problemi semplici che sono pi\u00f9 facili da risolvere. Con le funzioni ricorsive si costruiscono algoritmi potenti. function x ( contatore ){ if ( contatore > 5 ){ return ; //Terminatore, } else { x ( ++ contatore ); //passo ricorsivo console . log ( contatore ); } } x ( 0 ); /* 6 5 4 3 2 1 */ Nell'esempio di sopra al primo passo ricorsivo x(++contatore) non eseguo console.log(contatore); che rimane pending nello stack. Cos\u00ec anche per gli altri passi successivi finch\u00e8 la condizione dell' if diventa true e l'ultima funzione ritorna. A questo punto lo statemeant console.log(contatore); rimasto pending viene eseguito e cos\u00ec via i precedenti. fino al ritorno dell'intera funzione Osservazioni: - Se nulla limita il meccanismo di chiamate a funzione con una serie di ritorni a cascata, lo stack si riempie e il browser va in crash con l'errore Maximum call stack size exceeded . - E' un meccanismo che rallenta parecchio l'applicazione quando il passo ricorsivo diverge.","title":"Approfondimento Funzioni ricorsive"},{"location":"javascript/READMEV2/#approfondimento-function-expression","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. La parola chiave function pu\u00f2 essere utilizzata per definire una funzione all'interno di un'espressione. var media = function ( a , b ){ //funzione anonima return ( a + b ) / 2 ; }; console . log ( media ( 4 , 9 )); var fattoriale = function fatt ( n ){ if ( n === 0 ){ return 1 ; } else { return n * ( fatt ( n - 1 )); } } console . log ( fattoriale ( 4 )); //24","title":"Approfondimento Function expression"},{"location":"javascript/READMEV2/#approfondimento-hoisting","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. Per comprendere l'hoisting \u00e8 necessario introdurre il meccanismo di parsing dell'interprete javascript. Prima di eseguire lo script, il parser dell'interprete Javascript scansiona tutto il codice per risolvere i valori da assegnare agli identificatori ed esegue molte altre operazioni function esterna () { function interna (){ return \"interna1\" ; } return interna (); function interna (){ return \"interna2\" ; } } console . log ( esterna () ); //interna2 Nell'esempio di sopra, poich\u00e8 la funzione interna() \u00e8 stata definita due volte, il parser sovraiscrive la prima definizione con la seconda! Tutto cambia se utilizzo le function expression function esterna () { var interna = function (){ return \"interna1\" ; } return interna (); var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //interna1 In questo caso poich\u00e8 non sono definizioni di funzione ma variabili la seconda variabile non viene valutata poich\u00e8 \u00e8 codice irraggiungibile. In questo caso si segue un andamento lineare del codice anche detto paradigma imperativo. Nel caso invece di chiamate a funzione il paradigma si dice funzionale. Altro controesempio: function esterna () { return interna (); var interna = function (){ return \"interna1\" ; } var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //ERROR. interna() non \u00e8 riconosciuto perch\u00e8 non \u00e8 stato dichiarato l'identificaore Con il paradigma funzionale invece non ci sono problemi: function esterna () { return interna (); function interna (){ return \"interna1\" ; } function interna (){ return \"interna2\" ; } } console . log ( esterna () ); //interna2","title":"Approfondimento Hoisting"},{"location":"javascript/READMEV2/#approfondimento-differenza-tra-undefined-e-not-defined","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. Anche se sembra un uso improprio del vocabolario, c'\u00e8 una differenza tra una variabile undefined e un errore dell'interprete dovuto a una variabile not defined . undefined : L'interprete trova la definizione della variabile ma non trova nessun valore associato a tale variabile. Non genera un errore not defined : l'interprete non trova da nessuna parte nel codice l'identificatore. Genera un errore function esterna () { return interna ; var interna = function (){ return \"interna1\" ; } var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //undefined, l'interprete sa cos'\u00e8 ma non \u00e8 stata definita a quel punto del codice function esterna () { return y ; var interna = function (){ return \"interna1\" ; } var interna = function { return \"interna2\" ; } } console . log ( esterna () ); //ERROR. y is not defined. L'interprete non sa cosa sia y, ben diverso","title":"Approfondimento Differenza tra undefined e not defined"},{"location":"javascript/READMEV2/#approfondimento-iifi-immediatly-invoked-function-expression","text":"Questa parte per adesso potrebbe essere troppo \"approfondita\", \u00e8 possibile saltarla senza pregiudicare il corso. Sebbene introdurre funzioni aiuti a scrivere moduli indipendenti si rischia di inondare il contesto globale di nomi di funzioni. Il pattern IIFE (Immediately Invoked Function Expression) aiuta in tal senso. Le IIFI functions sono funzioni che vengono eseguite al momento della definizione. Non necessitano quindi della chiamata. ( function name (){ //code })(); Esempio: //Questa \u00e8 una funzione standard, NON IIFI. Viene eseguita solo alla chiamata function stampaLogo (){ console . log ( 'myLogo' ); } stampaLogo (); //in questa linea eseguo la funzione /* */ //Questa \u00e8 una funzione IIFI. Viene eseguita al momento. //(function name(){})(); ( function stampaLogo (){ console . log ( 'myLogo' ); })(); //eseguo qui la funzione IIFI Esempio 2: ( //operatore di raggruppamento: cio' che e' all'interno e' una espressione function iife () { var a = 222 ; console . log ( \"parto da sola!! \" + a ); } ) //fine espressione (); //operatore di chiamata di funzione //forma alternativa ( function iife () { var a = 444 ; console . log ( \"parto da sola!! \" + a ); } () ); iife (); //errore! iife come identificatore non esiste nel contesto globale","title":"Approfondimento IIFI Immediatly invoked function expression"},{"location":"javascript/READMEV2/#paradigma-di-programmazione-javascript","text":"Javascript \u00e8 un linguaggio multiparadigma, consente quindi il paradigma imperativo, quello funzionale e il paradigma object oriented in un unico linguaggio. Non esiste il miglior paradigma in assoluto ma esista il paradigma migliore per la situazione migliore.","title":"Paradigma di programmazione Javascript"},{"location":"javascript/READMEV2/#lezione-22","text":"","title":"Lezione 22"},{"location":"javascript/READMEV2/#scope","text":"Lo scope \u00e8 l'attuale contesto di esecuzione. Il contesto in cui i valori e le espressioni sono \"visibili\" o possono essere referenziati. Se una variabile o un'altra espressione non \u00e8 \"nell'ambito corrente\", non \u00e8 disponibile per l'uso. Gli ambiti possono anche essere stratificati in una gerarchia, in modo che gli ambiti figlio abbiano accesso agli ambiti padre, ma non viceversa. Una funzione funge da chiusura, closure in JavaScript e quindi crea uno scope, in modo che (ad esempio) non sia possibile accedere a una variabile definita esclusivamente all'interno della funzione dall'esterno della funzione o da altre funzioni. MDN - Scope Esempio: /* Scope */ /* Gloabl variable -> Riconosciuta da tutto il programma */ let var1 = 1 ; function function1 (){ /* Local variable -> ricnosciuta solo nel blocco di codice tra le parentesi {} in cui \u00e8 stata dichiarata*/ let var2 = 10 ; //qui nasce var2 console . log ( var2 ); } //qui muore var2 function1 (); console . log ( var1 ); //var1 is defined, var1 is global console . log ( var2 ); //var2 is not defined /* Console: --------------- 10 1 Uncaught ReferenceError: var2 is not defined */ Vediamo un esempio molto pi\u00f9 complesso: /* Scope */ /* Gloabl variable -> Riconosciuta da tutto il programma */ let var1 = 1 ; function function1 (){ /* Local variable -> ricnosciuta solo nel blocco di codice tra le parentesi {} in cui \u00e8 stata dichiarata*/ let var2 = 10 ; //qui nasce var2 console . log ( \"var2 function1 : \" + var2 ); } //qui muore var2 function function2 (){ /* Local variable -> ricnosciuta solo nel blocco di codice tra le parentesi {} in cui \u00e8 stata dichiarata*/ let var2 = 20 ; //qui nasce var2 ma \u00e8 diversa rispetto a quella di prima, \u00e8 una nuova var2 console . log ( \"var2 function2 : \" + var2 ); console . log ( \"var1: \" + var1 ); //\u00e8 riconosciuta anche var1 perch\u00e8 \u00e8 stata dichiarata in un blocco pi\u00f9 esterno for ( let var3 = 0 ; var3 < 1 ; var3 ++ ) { console . log ( \"var3: \" + var3 ); console . log ( \"var2 function2: \" + var2 ); //\u00e8 riconosciuta anche var2 perch\u00e8 \u00e8 stata dichiarata in un blocco pi\u00f9 esterno console . log ( \"var1: \" + var1 ); //\u00e8 riconosciuta anche var1 perch\u00e8 \u00e8 stata dichiarata in un blocco pi\u00f9 esterno } //qui muore var3 } //qui muore var2 function1 (); function2 (); console . log ( \"var1: \" + var1 ); //OK console . log ( \"var3: \" + var3 ); //non riconosciuta console . log ( \"var2: \" + var2 ); //non riconosciuta /* Console: --------------- var2 function1 : 10 var2 function2 : 20 var1: 1 var3: 0 var2 function2: 20 var1: 1 var1: 1 Uncaught ReferenceError: var3 is not defined */","title":"Scope"},{"location":"javascript/READMEV2/#visibilita-di-variabili","text":"Lo 'scope' di una variabile (visibilita' di una variabile) e' la sezione di codice in cui essa e' visibile ed in Javascript e' regolato con l'uso delle funzioni. NB: non confondere lo scope con il context (contesto) che indica invece l'oggetto per il quale una funzione viene eseguita ( this ). Per una funzione visibile a livello globale cioe' non contenuta in alcun oggetto questo in realta' esiste e coincide con 'window'. La distinzione e' tra visibilita' globale, locale e di blocco.","title":"Visibilit\u00e0 di variabili"},{"location":"javascript/READMEV2/#visibilita-globale-global-scope","text":"E' quella che ha come riferimento l'intero codice. Sono le variabili/oggetti dichiarate all'esterno di qualunque funzione usate in una funzione senza var/let . In generale la visibilita' globale e' da evitare Esempio: var x = 100 ; function f_bad () { //modifica la variabile esterna potenzialmente all'insaputa di chi la chiama x = 2 ; } console . log ( \"Prima di invocare f_bad() \" + x ); //x = 100 f_bad (); //modifica x, da evitare console . log ( \"Dopo f_bad() \" + x ); //x = 2 L'obiettivo delle funzioni \u00e8 proprio racchiudere il codice in blocchi riutilizzabili. Se modificano/dipendono da variabili esterne/globali questo concetto viene a meno. Per risolvere questa cosa: x = 100 ; //versione corretta di f function f_good () { //dichiarazione di una variabile LOCALE (x) distinta da quella globale var x = 2 ; var y = 200 ; } console . log ( \"Prima di invocare f_good() \" + x ); // x = 100 f_good (); console . log ( \"Dopo f_good() \" + x ); // x = 100, Ok console . log ( y ); //errore: y not defined; visibile solo a f_good in esecuzione","title":"Visibilit\u00e0 Globale (global scope)"},{"location":"javascript/READMEV2/#scope-chaining","text":"Una varibaile \u00e8 visibile ai blocchi interni (figli) ma non ai contenitori (padre). I blocchi interni (figli) ereditano tutto dai loro contenitori (padri) ma i padri non conoscono i segreti dei figli ovvero non possono conoscere le variabili/oggetti dichiarati dei figli. var x = 2 ; //FUNZIONI ANNIDATE (nested) function esterna () { var x = 999 ; // dichiaro una nuova \"x\" diversa da quella globale interna (); //Accedo alla \"x\" esterna tramite il contest. <window> \u00e8 il contesto esterno, \u00e8 il contenitore di tutto window . x = 18 ; //interna accede anche allo scope di esterna ma non il viceversa function interna () { //code } }","title":"Scope Chaining"},{"location":"javascript/READMEV2/#visibilita-a-livello-di-blocco-block-scope","text":"La visibilit\u00e0 \u00e8 racchiusa da i delimitatori { } Per mantenere la visibilit\u00e0 a livello di blocco \u00e8 necesario usare let , var mantiene soltanto lo scope locale a livello di funzione ma non di blocco { } let : Mantiene lo scope delle variabili sia a livello locale (all'interno di una funzione) sia livello di blocco ovvero tra i delimitatori { } var : Mantiene lo scope delle variabili solo a livello locale (all'interno di una funzione) ma non a livello di blocco ovvero tra i delimitatori { } //\"var\" non mantiene la visibilit\u00e0 di blocco var x = 5 ; if ( Math . random () > 0.5 ) { var x = 100 ; } else { var x = 200 } console . log ( \"La x ora vale: \" + x ); //100 o 200!! ATTENZIONE, //\"let\" mantiene la visibilit\u00e0 di blocco x = 5 ; if ( Math . random () > 0.5 ) { let x = 100 ; } else { let x = 200 } console . log ( \"La x globale vale ancora: \" + x ); //5, ok","title":"Visibilit\u00e0 a livello di blocco (block scope)"},{"location":"javascript/READMEV2/#approfondimento-closure-di-una-funzione","text":"Si ricordi: Una funzione funge da chiusura, closure in JavaScript e quindi crea uno scope, in modo che (ad esempio) non sia possibile accedere a una variabile definita esclusivamente all'interno della funzione dall'esterno della funzione o da altre funzioni Applichiamo questo concetto ad un esempio pratico. La funzione: setInterval( param1, param2 ) : param1 \u00e8 una funzione, param2 rappresenta un intervallo di tempo espresso in ms . La funzione setInterval() chiama la funzione param1 ogni param2 ms . function chiamaMessaggio ( messaggio ){ setInterval ( function (){ writeln ( messaggio );}, 1000 ); //uso una funzione anonima } chiamaMessaggio ( \"il sistema \u00e8 in fase di spegnimento..\" ); Ho utilizzato il concetto di closure (e quindi dell'ereditariet\u00e0 delle variabili/oggetti padre->figlio) di una funzione per passare un parametro alla funzione (parametro) di setInterval() Esempio 2: function chiamaMessaggio2 ( ilMessaggio , volte ) { let timer = setInterval ( function () { writeln ( ilMessaggio + \" \" + volte + \" secondi...\" ); -- volte ; if ( volte < 1 ) { clearInterval ( timer ); writeln ( \"Boom!\" );} } , 1000 ) } chiamaMessaggio2 ( \"Sistem Shutdown in \" , 5 ); Approfondimento: Le funzioni che ricevono come parametri altre funzioni o ritornano altre funzioni prendono il nome di High orderd function","title":"Approfondimento - Closure di una funzione"},{"location":"javascript/READMEV2/#lezione-23","text":"","title":"Lezione 23"},{"location":"javascript/READMEV2/#array","text":"Gli array sono aggragatori di dati utilizzati per raggruppare elementi appartenenti alla stessa famiglia ed accedere ad uno di essi in lettura o scrittura in modo semplice. Ogni elemento dell'array \u00e8 raggiungibile tramite un numero detto indice . L'indice indica la posizione dell'elemento nell'array. La propriet\u00e0 lenght restituisce il numero degli elementi in un array // Dichiarazione e inizializzazione // 0 1 2 const elementi = [ \"elemento1\" , \"elemento2\" , \"element03\" ]; console . log ( elementi ); //(3) [\"elemento1\", \"elemento2\", \"element03\"] console . log ( elementi [ 1 ]); //elemento2 console . log ( elementi . lenght ); //3 elementi [ 2 ] = \"Silicio\" ; console . log ( elementi ); //(3) [\"elemento1\", \"elemento2\", \"Silicio\"] // Solo dichiarazione const mammiferi = []; Altre sintassi (meno utilizzate ma valide): //Array vuoto let vuoto1 = new Array (); let vuoto2 = Array (); let vuoto3 = []; //da preferire let v1 = Array ( 100 ); //100 elementi pre allocati let v2 = Array ( '100' ); //1 elemento stringa, crea confusione let v3 = new Array ( 31 , 8 , 2017 ); //meno consigliata let arr3 = [ 31 , 8 , 2017 ]; //sintassa pi\u00f9 chiara Alcuni esempi: const mammiferi = [ \"tigre\" , \"scoiattolo\" , \"orso\" ]; mammiferi [ mammiferi . length ] = \"volpe\" ; // === mammiferi[3] = \"volpe\", aggiunge in coda un elemento console . log ( mammiferi ); //(4) [\"tigre\", \"scoiattolo\", \"orso\", \"volpe\"] mammiferi [ 10 ] = \"cinghiale\" ; //aggiunge \"cinghiale\" al decimo elemento e riempie con elementi vuoti i restanti console . log ( mammiferi , mammiferi . lenght ); //(11) [\"tigre\", \"scoiattolo\", \"orso\", \"volpe\", empty \u00d7 6, \"cinghiale\"] 11 mammiferi . lenght = 20 ; console . log ( mammiferi , mammiferi . lenght ); //(11) [\"tigre\", \"scoiattolo\", \"orso\", \"volpe\", empty \u00d7 6, \"cinghiale\", lenght: 20] 20 //Iterazione sugli elementi dell'array for ( let i = 0 ; i < mammiferi . length ; i ++ ){ if ( mammiferi [ i ] != undefined ){ console . log ( i + \": \" + mammiferi [ i ]); } else { console . log ( i + \": \" + \"non \u00e8 un mammifero\" ); } } /* 0: tigre 1: scoiattolo 2: orso 3: volpe 4: non \u00e8 un mammifero 5: non \u00e8 un mammifero 6: non \u00e8 un mammifero 7: non \u00e8 un mammifero 8: non \u00e8 un mammifero 9: non \u00e8 un mammifero 10: cinghiale */","title":"Array"},{"location":"javascript/READMEV2/#matrix","text":"Della famiglia degli array ci sono anche le matrici che non sono altro che array di array. const social = [ [ \"facebook\" , \"instagram\" ], [ \"whatsapp\" , \"telegram\" ], [ \"tiktok\" , \"snapchat\" ], ]; console . log ( social ); console . log ( social [ 1 ][ 1 ]); console . log ( social [ 2 ][ 0 ]); /* Console: --------------- Esercizio 2 (3) [Array(2), Array(2), Array(2)] 0: (2) [\"facebook\", \"instagram\"] 1: (2) [\"whatsapp\", \"telegram\"] 2: (2) [\"tiktok\", \"snapchat\"] telegram tiktok */","title":"Matrix"},{"location":"javascript/READMEV2/#lezione-24","text":"","title":"Lezione 24"},{"location":"javascript/READMEV2/#array-metodi-base","text":"Qualche metodo base applicabile agli array in javascript: push(elem) : aggiunge l'elemento elem in coda all'array. Restituisce il numero di elementi dell'array. pop() : rimuove l'ultimo elemento dall'array. Restituisce l'elemento che ha tolto. array.unshift(elem) : aggiunge l'elemento elem in testa all'array. Restituisce il numero di elementi dell'array array.shift() : rimuove il primo elemento dall'array. Restituisce l'elemento che ha tolto indexOf(elem) : Restituisce l'indice dell' elemento elem nell'array. Se non lo trova restituisce -1 slice(startIndex, endIndex); : Restituisce un array derivato dall'array a cui si applica il metodo filtrando gli elementi nel range ( startIndex incluso, endIndex escluso). .concat(array2); : Restituisce un array che \u00e8 la concatenazione dell'array a cui si applica il metodo e array2 splice(startIndex, nToDelete, elem1, elem2, ...); : Restituisce un array derivato dall'array a cui si applica il metodo aggiungendo elem1 , elem2 , .. a partire da startIndex ed eliminando i primi nToDelete elementi a partire da startIndex . Se non specifico i parametri elem1 , elem2 , .. semplicemente elimina gli elementi nToDelete a partire da startIndex . fill(value, indexStart, indexEnd) : Inserisce value all'interno dell'array tra i parametri opzionali indexStart e indexEnd . Omettendo indexStart e indexEnd riempie tuttto l'array con value join() : Trasforma un array in stringa reverse() : Inverte l'ordine degli elementi sort() : Ordinamento lessicografico degli elementi. Ogni elemento viene quindi trattato come una stringa e poi ordinato secondo la precedenza definita dalla rappresentazione in UTF-8 (ASCII) //push const colori = [ \"rosso\" , \"verde\" , \"giallo\" ]; console . log ( colori ); //(3) [\"rosso\", \"verde\", \"giallo\"] let newArrayLenght = colori . push ( \"blu\" ); //push ritorna il numero degli elementi dell'array console . log ( colori , newArrayLenght ); //(4) [\"rosso\", \"verde\", \"giallo\", \"blu\"] 4 //pop console . log ( colori ); //(4) [\"rosso\", \"verde\", \"giallo\", \"blu\"] let lastElement = colori . pop (); //pop ritorna l'elemento che ha tolto console . log ( colori , lastElement ); //(3) [\"rosso\", \"verde\", \"giallo\"] \"blu\" //unshift console . log ( colori ); //[\"rosso\", \"verde\", \"giallo\"] newArrayLenght = colori . unshift ( \"gialletto\" ); //unshift ritorna il numero degli elementi dell'array console . log ( colori , newArrayLenght ); //(4) [\"gialletto\", \"rosso\", \"verde\", \"giallo\"] 4 //shift console . log ( colori ); //(4) [\"gialletto\", \"rosso\", \"verde\", \"giallo\"] let firstElement = colori . shift (); //shift ritorna l'elemento che ha tolto console . log ( colori , firstElement ); //(3) [\"rosso\", \"verde\", \"giallo\"] \"gialletto\" //indexOf console . log ( colori ); //(3) [\"rosso\", \"verde\", \"giallo\"] let indexElem = colori . indexOf ( \"verde\" ); console . log ( indexElem ); //1 //slice // 0 1 2 3 4 const social = [ \"facebook\" , \"instagram\" , \"whatsapp\" , \"telegram\" , \"snapchat\" ]; const messaggi = social . slice ( 2 , 4 ); console . log ( messaggi ); //(2) [\"whatsapp\", \"telegram\"] //concat const numeriBassi = [ 1 , 2 , 3 ]; const numeriAlti = [ 100 , 200 , 300 ]; const tuttiNumeri = numeriBassi . concat ( numeriAlti ); console . log ( tuttiNumeri ); //(6) [1, 2, 3, 100, 200, 300] //splice //poich\u00e8 il secondo parametro \u00e8 0, aggiunger\u00e0 a partire dall'indice 3 i parametri 50, 60, 70 tuttiNumeri . splice ( 3 , 0 , 50 , 60 , 70 ); //poich\u00e8 il secondo parametro \u00e8 0 console . log ( tuttiNumeri ); //(9) [1, 2, 3, 50, 60, 70, 100, 200, 300] //poich\u00e8 il secondo parametro \u00e8 3, sostituir\u00e0 50, 60, 70 con -50, -60, -70 tuttiNumeri . splice ( 3 , 3 , - 50 , - 60 , - 70 ); console . log ( tuttiNumeri ); //(9) [1, 2, 3, -50, -60, -70, 100, 200, 300] //fill() const myArr = [ 1 , 2 , 4 , 1 , 5 , 5 , 7 ]; myArr . fill ( 0 , 1 , 3 ); console . log ( myArr ); //(7) [1, 0, 0, 1, 5, 5, 7] //join() const paroleTesto = [ \"ciao\" , \" \" , \"a\" , \" \" , \"tutti\" ]; console . log ( paroleTesto ); //(5) [\"ciao\", \" \", \"a\", \" \", \"tutti\"] conole . log ( parole . Testo . join ()); // ciao, ,a, ,tutti //reverse() const numeriDispari = [ 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 ]; console . log ( numeriDispari ); //(10 [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] console . log ( numeriDispari . reverse ()); //(10) [19, 17, 15, 13, 11, 9, 7, 5, 3, 1] //sort() - ATTENZIONE console . log ( numeriDispari . sort ()); //(10) [1, 11, 13, 15, 17, 19, 3, 5, 7, 9]","title":"Array - Metodi base"},{"location":"javascript/READMEV2/#lezione-25","text":"","title":"Lezione 25"},{"location":"javascript/READMEV2/#arrays-foreach","text":"forEach() \u00e8 un metodo applicabile agli array utilizzato per l'iterazione. forEach ( function ( value , index , array ){ /*code*/ }); Riceve come parametro una funzione detta anonima poich\u00e8 non ha un nome. La funzione riceve tre parametri opzionali, in ordine value , index , array che, dell'array a cui \u00e8 applicato il metodo, rappresentano rispettivamente l'elemento, l'indice e l'array stesso. Viene invocata la funzione anonima per ogni elemento (forEach) presente nell'array. const frutta = [ \"mela\" , \"pera\" , \"banana\" ]; stampaArray ( frutta ); function stampaArray ( arr ) { //i parametri della funzione anonima del forEach sono opzionali e, essendo parametri posso //dare un nome simbolico qualsiasi arr . forEach ( function ( elemento , indice , a ) { console . log ( indice + \": \" + a [ indice ] ); } ); } /* 0: mela 1: pera 2: banana */","title":"Arrays - forEach()"},{"location":"javascript/READMEV2/#arrays-map","text":"map() \u00e8 un metodo applicabile agli array utilizzato per l'iterazione. map ( function ( value , index , array ){ /*code*/ }); Itera ogni elemento dell'array e ritorna un array. E' utile quindi all'elaborazione e costruzione di un nuovo array a partire da quello a cui si applica il metodo. Riceve come parametro una funzione detta anonima poich\u00e8 non ha un nome. La funzione riceve tre parametri opzionali, in ordine value , index , array che, dell'array a cui \u00e8 applicato il metodo, rappresentano rispettivamente l'elemento, l'indice e l'array stesso. Viene invocata la funzione anonima per ogni elemento (forEach) presente nell'array. const fruits = [ 'mela' , 'pera' , 'banana' ]; //In questo caso newFruits sar\u00e0 identico a fruits. Ho effettuato una copia const newFruits = fruits . map ( function ( value , index ){ return value ; }) console . log ( newFruits ); //(3) [\"mela\", \"pera\", \"banana\"] //In questo caso newFruits2 sar\u00e0 un array contenente 0, 1, 2 poich\u00e8 ritorna l'indice const newFruits2 = fruits . map ( function ( value , index ){ return index ; }) console . log ( newFruits2 ); //3) [0, 1, 2]","title":"Arrays - map()"},{"location":"javascript/READMEV2/#funzioni-freccia-lambda","text":"Oltre alla sintassi espressa tramite funzione anonima esiste anche una sintassi diversa espressa tramite l'operatore freccia => . Ogni funzione anonima pu\u00f2 essere espressa tramite l'operatore freccia, questo tipo di funzione prende il nome di funzione lambda . ( param1 , param2 , ..) => { /*code*/ }; //function(param1, param2, ..{/*code*/} //Esempi con forEach() e map() map ( ( value , index , array ) => { /*code*/ } ); forEach ( ( value , index , array ) => { /*code*/ }); Nota: - I parametri vanno sempre espressi tra parentesi. Se si ha necessit\u00e0 solo del primo parametro le parentesi possono essere omesse. - In generale il corpo della funzione lambda va tra le parentesi graffe { } . Se il corpo ha un'istruzione inline, le parentesi graffe possono essere omesse. Esempio interessante: //casuali \u00e8 un array di 30 numeri inter casuali const numeriCasuali = []; for ( let i = 0 ; i < 10 ; i ++ ) { numeriCasuali . push ( Math . floor ( Math . random () * 100 ) ) ;} console . log ( numeriCasuali ); //32, 54, 33, 91, 4, 25, 46, 37, 73, 2] //calcola il resto della divisione per 7 dei numeri casuali //e crea con questi un nuovo array const isPari = numeriCasuali . map ( ( elemento , indice , a ) => Boolean ( ! ( elemento % 2 )) ); console . log ( isPari ); //[true, true, false, false, true, false, true, false, false, true]","title":"Funzioni freccia (lambda)"},{"location":"javascript/READMEV2/#array-metodi-avanzati","text":"filter( (value,index,array) => {/*CONDITION*/} ); : Ritorna un array risultato del filtraggio gli elementi dell'array a cui si applica il metodo che restituiscono true nella CONDITION some ( (value,index,array) => {/*CONDITION*/} ); : Ritorna un booleano se c'\u00e8 almeno un elemento nell'array che restituisce true alla CONDITION every ( (value,index,array) => {/*CONDITION*/} ); Ritorna true (ritorna n boolean) se c'\u00e8 almeno un elemento nell'array che restituisce true alla CONDITION reduce ((accumulatore, value,index,array) => {/*CONDITION*/}, startValueAccumulatore); : Ritorna il numero di elementi che soddisfano la CONDITION . Ha due parametri: il primo \u00e8 una funzione freccia che riceve a sua volta 4 parametri in ordine: accumulatore , value , index , array , il secondo, startValueAccumulatore \u00e8 il valore di partenza dell'accumulatore, opzionale. Se non si specifica il valore di partenza dell'accumulatore startValueAccumulatore viene assegnato come valore il primo elemento. let casuali = []; for ( let i = 0 ; i < 20 ; i ++ ) { casuali . push ( Math . floor ( Math . random () * 100 ) ) ;} let diversiDaZero = casuali . filter ( elemento => elemento !== 0 ); console . log ( diversiDaZero ); if ( diversiDaZero . some ( elemento => elemento > 4 ) ) { console . log ( \"Trovato almento un resto maggiore di zero\" );} let quanti = diversiDaZero . reduce ( ( conta , elemento ) => elemento > 4 ? conta + 1 : conta , 0 ); console . log ( quanti ); //19 let totale = diversiDaZero . reduce ( ( somma , elemento ) => somma + elemento ); console . log ( totale ); //1057 /* [37, 67, 31, 88, 55, 45, 26, 21, 32, 2, 20, 62, 79, 48, 85, 53, 33, 97, 92, 84] Trovato almento un resto maggiore di zero 19 1057 */","title":"Array - Metodi avanzati"},{"location":"javascript/READMEV2/#lezione-26","text":"","title":"Lezione 26"},{"location":"javascript/READMEV2/#introduzione-agli-object","text":"JavaScript \u00e8 progettato su un semplice paradigma basato su oggetti. Un oggetto \u00e8 una raccolta di propriet\u00e0 e una propriet\u00e0 \u00e8 un'associazione tra un nome (o chiave) e un valore. Il valore di una propriet\u00e0 pu\u00f2 essere una funzione, nel qual caso la propriet\u00e0 \u00e8 nota come metodo. Oltre agli oggetti predefiniti nel browser, \u00e8 possibile definire i propri oggetti. Questo capitolo descrive come utilizzare oggetti, propriet\u00e0, funzioni e metodi e come creare i propri oggetti. Gli oggetti in JavaScript, proprio come in molti altri linguaggi di programmazione, possono essere paragonati agli oggetti nella vita reale. Il concetto di oggetti in JavaScript pu\u00f2 essere compreso con oggetti tangibili della vita reale. In JavaScript, un oggetto \u00e8 un'entit\u00e0 autonoma, con propriet\u00e0 e tipo. Confrontalo con una tazza, per esempio. Una tazza \u00e8 un oggetto, con propriet\u00e0. Una tazza ha un colore, un disegno, un peso, un materiale di cui \u00e8 composta, ecc. Allo stesso modo, gli oggetti JavaScript possono avere propriet\u00e0 che definiscono le loro caratteristiche. Fonte: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#:~:text=JavaScript%20is%20designed%20on%20a,is%20known%20as%20a%20method. Sono un tipo di data-structure che rappresenta elementi tramite una coppia chiave/valore . Si accede al valore tramite il nome dell'oggetto e la sua property cio\u00e8 l'identificativo della chiave. const object = { key1 : value1 , key2 : value2 , key3 : value3 } SI chiama modello per prototipazione. Cio\u00e8 un modello creato che andremo ad arricchire e modificare nel corso del codice dinamicamente. Un oggetto in js \u00e8 una collezione di coppe identificatore: valore Esempio // Dichiarazione di un oggetto, prototipo const persona = { nome : \"Simone\" , eta : 23 , citta : \"Lucca\" } //accesso ai dati //Modo 1 persona . nome ; //Simone, (=== persona[\"nome\"]) //Modo2 persona [ \"citta\" ]; //Lucca, (=== persona.citta) //modifica di un valore dell'oggetto persona . nome = \"Luigi\" ; //Eliminazione della property <citta> dall'oggetto delete persona . citta ; console . log ( persona ); /* persona = { nome: \"Luigi\", eta: 23 } */ La creazione/dichiarazione di un oggetto con propriet\u00e0 e metodi (vedremo pi\u00f9 avanti) viene anche detto prototipo. Il prototipo \u00e8 un modello base dell'oggetto che pu\u00f2 essere arricchito o modificato nel corso del programma dinamicamente Posso creare un oggetto inizialmente vuoto e aggiungere gli elementi successivamente //Dichiaro un oggetto vuoto, modo 1 - preferibile var persona = {}; //Dichiaro un oggetto vuoto, modo 2 var computer = new Object ; //Inserisco elementi in un oggetto inizialmente vuoto persona . nome = \"billy\" ; persona . hobby = \"scacchi\" ; computer . ram = \"4Gb\" ; computer . rom = \"1Tb\" ; Di seguito mostro un esempio di un oggetto pi\u00f9 complicato. In realt\u00e0 \u00e8 un array di oggetti var post = [ // index: 0 { username : \"Billy\" , like : 4 , commenti : [ \"figo!\" , \"ottimo\" , \"bleah\" ] }, // index: 1 { username : \"thebest95\" , like : 0 , commenti : [ \"fighissimo\" , \"buono\" , \"buonissimo\" ] } ] console . log ( post ); /* Console: --------------- (2) [{\u2026}, {\u2026}] 0: commenti: (3) [\"figo!\", \"ottimo\", \"bleah\"] like: 4 username: \"Billy\" __proto__: Object 1: commenti: (3) [\"fighissimo\", \"buono\", \"buonissimo\"] like: 0 username: \"thebest95\" __proto__: Object length: 2 __proto__: Array(0) */ //Aggiungo un commento al primo elemento, cio\u00e8 all'oggetto cui corrisponde username \"Billy\" post [ 0 ]. commenti . push ( \"Fantastico!\" ); console . log ( post ); /* Console: --------------- (2) [{\u2026}, {\u2026}] 0: commenti: (3) [\"figo!\", \"ottimo\", \"bleah\",\"Fantastico!\"] like: 4 username: \"Billy\" __proto__: Object 1: commenti: (3) [\"fighissimo\", \"buono\", \"buonissimo\"] like: 0 username: \"thebest95\" __proto__: Object length: 2 __proto__: Array(0) */","title":"Introduzione agli Object"},{"location":"javascript/READMEV2/#javascript-oop","text":"Javascript Lezione 01 Prerequisiti al corso Approccio al corso Strumenti Necessari Javascript, ECMA-Script? Lezione 02 Primo script all'interno del browser web Javascript all'interno del tag script Javascript all'interno di un file .js Primo script Javascript con node.js Console Alert & prompt Commenti Introduzione al DOM Introduzione alla libreria JQuery DOM ed Eventi Variabili Javascript Alcune regole per dichiarazione di variabili Tipi di dati in JS Tipi Primitivi Standard built-in Object Oggetti Fondamentali Approfondimento Null - undefined - NaN Stringhe Opearotri, Propriet\u00e0 e Metodi su stringhe Operatori Approfondimento Interpolazioni di stringhe Le stringhe sono immutabili Propriet\u00e0 Metodi Lezione 08 Conta parole Lezione 09 Approfondimento - Rappresentazione numerica in Javascript Numeri in Fixed Point Numeri in Floating Point Not A Number NaN Lezione 10 Approfondimento - Codifica caratteri Javascript ASCII Unicode Caratteri di Escape Lezione 11 Type conversion Conversione esplicita Conversione implicita Lezione 12 Operatori matematici Pre e post incremento/decremento Oggetto MATH Lezione 13 Equazione di II grado Lezione 14 Operator Precedence Associativit\u00e0 Operatori di assegnamento Lezione 15 Operatori Logici Logica Booleana Approfondimento - Short evalutation Truthy e falsy Lezione 16 Control Structure if/else Ternary Operator Switch statemeant Lezione 17 while loop do-while loop Lezione 18 for loop break & coninue Lezione 19 Function Parametri di default Ritorno di una funzione Lezione 20 Funzioni - Passaggio di oggetti e array Funzioni - Ritorno di un oggetto o un array Approfondimento funzioni - Oggetto Arguments Approfondimento funzioni - Parametri Rest Approfondimento Introduzione forEach / this Lezione 21 Approfondimento Funzioni ricorsive Approfondimento Function expression Approfondimento Hoisting Approfondimento Differenza tra undefined e not defined Approfondimento IIFI Immediatly invoked function expression Paradigma di programmazione Javascript Lezione 22 Scope Visibilit\u00e0 di variabili Visibilit\u00e0 Globale (global scope) Scope Chaining Visibilit\u00e0 a livello di blocco (block scope) Approfondimento - Closure di una funzione Lezione 23 Array Matrix Lezione 24 Array - Metodi base Lezione 25 Arrays - forEach() Arrays - map() Funzioni freccia (lambda) Array - Metodi avanzati Lezione 26 Introduzione agli Object Javascript OOP Lezione 01 OOP Object Oriented Programming Lezione 02 Introduzione ai Metodi Lezione 03 Costruttore Lezione 04 Ereditariet\u00e0 Lezione 05 Ereditariet\u00e0 - Shadowing Ereditariet\u00e0 classica Lezione 06 THIS Object - Variabili Statiche (condivise) Lezione 07 Introduzione For In Oggetto Date() Lezione 08 Classi Lezione 09 Classi assegnanili a variabili Get / Set try-catch Lezione 10 Derivazione di classi , ereditariet\u00e0 Lezione 11 Ereditariet\u00e0 classi Pt 2 Lezione 12 Approfondimento - Symbols Lezione 13 Approfondimento - Iterables/Iterator Costrutto for - of Lezione 14 Approfondimento - Funzioni Generatrici Lezione 15 Approfondimento - Esempio (For .. of) custom Lezione 16 Destructuring Lezione 17 Map Object Iterazione Map Object Lezione 18 Set Conversione di un Oggetto Map / Set in un Array Lezione 19 Dom Manipulation Lezione 20 DOM - Selettori Metodi di selezione di elementi html Lezione 21 Dom - Child e Parent DOM - Manipolazione dello stile degli elementi html Lezione 22 DOM - Manipolazione del testo degli elementi html DOM - Manipolazione degli attributi html Lezione 23 DOM - Creazione di Un elemento DOM - Rimpiazzo di un elemento DOM - ELiminazione di un elemento Lezione 24 DOM Events Metodo addEventListener Lezione 25 Prevent Default Che cos'\u00e8 esattamente l'oggetto ricevuto come unico parametro \"e\"? Lezione 26 Approfondimento type event Aprrofondimento eventi tastiera e input Lezione 27 Argomeni non trattati / da approfondire Fonti APPRONDIMENTI PT.1 Node.js Cos'\u00e8 node Install node Prima applicazione nodejs Non esiste l'oggetto window global objects Modules Creiamo un modulo Moduli built-in Modulo path Modulo OS Modulo File System Eventi Modulo HTTP Approfondimenti Passare dei parametri esterni My first IO sync My first IO async Filtered APPRONDIMENTI PT.2 Promise Un esempio semplice APPRONDIMENTI PT.3 Approfondimento Hoisting Approfondimento Oggetti Approfondimento Moduli Packages Approfondimento THIS Costruttori prefdefiniti javascript for .. of for .. in Memoization Come fare una copia profonda tra oggetti? propriet\u00e0 associate ai dati e proprier\u00e0 associate all'accesso get & set Arrow functions High Order Functions Array filter Array map Array reduce Gli array possiedono gi\u00e0 come metodi filer, map, reduce Qualche chicca sugli Array Arrray.of, Array.from concat, every, some find, filter, forEach, includes, indexOf push, pop, shift, unshift sort, splice, slice setTimeout(), setInterval() Eventi Asincroni Promise, resolve, reject, then Async, Await Promise.all() e Promise.race() Set e Map Map","title":"Javascript OOP"},{"location":"javascript/READMEV2/#lezione-01_1","text":"","title":"Lezione 01"},{"location":"javascript/READMEV2/#oop-object-oriented-programming","text":"Si ricordi la frase di apertura di questo corso: In informatica JavaScript \u00e8 un linguaggio di programmazione orientato agli oggetti e agli eventi... Ma che cos'\u00e8 un linguaggio di programmazione orientato agli oggetti? In informatica, la programmazione orientata agli oggetti (in inglese object-oriented programming, in acronimo OOP) \u00e8 un paradigma di programmazione che permette di definire oggetti software in grado di interagire gli uni con gli altri attraverso lo scambio di messaggi. Particolarmente adatta nei contesti in cui si possono definire delle relazioni di interdipendenza tra i concetti da modellare (contenimento, uso, specializzazione), un ambito che pi\u00f9 di altri riesce a sfruttare i vantaggi della programmazione ad oggetti \u00e8 quello delle interfacce grafiche. Tra gli altri vantaggi della programmazione orientata agli oggetti: essa fornisce un supporto naturale alla modellazione software degli oggetti del mondo reale o del modello astratto da riprodurre; permette una pi\u00f9 facile gestione e manutenzione di progetti di grandi dimensioni; l'organizzazione del codice sotto forma di classi favorisce la modularit\u00e0 e il riuso di codice. Fonte: https://it.wikipedia.org/wiki/Programmazione_orientata_agli_oggetti Ma non esiste solo il paradigma di programmazione orientato agli oggetti. Altri due paradigmi di programmazione sono il paradigma di programmazione procedurale e il paradigma di programmazione imperativa Programmazione Procedurale In informatica la programmazione procedurale \u00e8 un paradigma di programmazione che consiste nel creare dei blocchi di codice sorgente, identificati da un nome e racchiusi da dei delimitatori, che variano a seconda del linguaggio di programmazione; questi sono detti anche sottoprogrammi (in inglese subroutine), procedure o funzioni, a seconda del linguaggio e dei loro ruoli all'interno del linguaggio stesso. Il nome deriva dal linguaggio COBOL, che \u00e8 stato il primo ad utilizzare questo concetto. Questi blocchi possono essere dotati di parametri, cio\u00e8 variabili locali i cui valori vengono forniti o passati dall'esterno del blocco di codice ed eventualmente esportati; esistono due tipi di parametri: quelli di tipo valore e quelli di tipo variabile; nei primi viene passato un valore che, se modificato, non viene comunque salvato al termine del sottoprogramma; nel tipo variabile invece, viene comunicato l'indirizzo della cella di memoria (ad es.tramite un puntatore) al quale troviamo l'informazione, che pu\u00f2 quindi essere modificata effettivamente e permanentemente. All'interno di un sottoprogramma possono essere generalmente definite o dichiarate delle variabili locali, che vengono deallocate al termine del sottoprogramma stesso; il loro contenuto viene quindi perso se non salvato o trasmesso altrimenti. In Linguaggio C esiste solo la function, che pu\u00f2 o meno restituire valori; lo stesso dicasi per il Java ed il PHP; i blocchi sono racchiusi tra parentesi graffe. Questo tipo di paradigma \u00e8 tipico per la programmazione di sistemi embedded. Fonte: https://it.wikipedia.org/wiki/Programmazione_procedurale Programmazione imperativa In informatica, la programmazione imperativa \u00e8 un paradigma di programmazione secondo cui un programma viene inteso come un insieme di istruzioni (dette anche direttive o comandi), ciascuna delle quali pu\u00f2 essere pensata come un \"ordine\" che viene impartito alla macchina virtuale del linguaggio di programmazione utilizzato. Da un punto di vista sintattico, i costrutti di un linguaggio imperativo sono spesso identificati da verbi all'imperativo. L'approccio imperativo \u00e8 l'approccio dominante in programmazione. Nello studio dei linguaggi di programmazione, si definisce il concetto di paradigma di programmazione, ovvero un insieme di regole e strutture che definiscono un tipo di linguaggio basandosi esclusivamente sulle sue strutture, e quindi non sulle sue caratteristiche peculiari legate all'implementazione dello stesso (es. le parole chiave). Sono di tipo imperativo la grande maggioranza dei (sotto-)paradigmi di programmazione (per esempio la programmazione procedurale, la programmazione strutturata, la programmazione orientata agli oggetti e cos\u00ec via) e la grande maggioranza dei linguaggi (per esempio ALGOL, Ada, BASIC, Fortran, Pascal, PHP eccetera). Fonte: https://it.wikipedia.org/wiki/Programmazione_imperativa Javascript \u00e8 un linguaggio di programmazione che si presta molto bene a tutti e tre i paradigmi. Adesso approfondiremo il paradigma di programmazione orientato agli oggetti concludendo con la definizione di classe","title":"OOP Object Oriented Programming"},{"location":"javascript/READMEV2/#lezione-02_1","text":"","title":"Lezione 02"},{"location":"javascript/READMEV2/#introduzione-ai-metodi","text":"Si ricordi che con Javascript \u00e8 possibile definire delle funzioni assegnabili a variabili, \u00e8 quindi possibile definire delle funzioni assegnabili a una property. In questo caso si parla di metodi Metodo: Funzione applicabile a un oggetto. Non ha senso al di fuori del contesto dell'oggetto in cui \u00e8 stata definita var persona = { nome : \"Simone\" , dataDiNascita : 1995 , sesso : \"maschio\" , isMarried : false , famiglia : [ \"Anotinio\" , \"Giovanni\" , \"Alice\" ], calcolaEta : function (){ return 2020 - this . dataDiNascita ; } } console . log ( persona . calcolaEta ()); //25 Nella definizione di un metodo (una funzione all'interno di un oggetto), this rappresenta l'oggetto stesso. E' quindi necessario per poter prelevare ed elaborare le property interne dell'oggetto che ricordiamo sono accessibili solo attraverso il nome dell'oggetto. Nella definizione di un metodo non posso accedere direttamente alle property senza invocare this l'interprete solleverebbere un'eccezione poich\u00e8 non riconoscerebbe l'identificatore invocato. var persona = { nome : \"Simone\" , dataDiNascita : 1995 , sesso : \"maschio\" , isMarried : false , famiglia : [ \"Anotinio\" , \"Giovanni\" , \"Alice\" ], calcolaEta : function (){ return 2020 - dataDiNascita ; } } console . log ( persona . calcolaEta ()); //dataDiNascita is not defined Nota: la keyword this ha anche altri significati che dipendono dal contesto in cui \u00e8 chiamato. Posso invocare un metodo anche per definire una nuova propriet\u00e0 dell'oggetto: const persona = { nome : \"Simone\" , dataDiNascita : 1995 , sesso : \"maschio\" , isMarried : false , famiglia : [ \"Anotinio\" , \"Giovanni\" , \"Alice\" ], calcolaEta : function (){ return 2020 - this . dataDiNascita ; } } //Verr\u00e0 aggiunta la property \"eta\" all'oggetto persona . eta = persona . calcolaEta (); console . log ( persona ); /* Console: --------------- {nome: \"Simone\", dataDiNascita: 1995, sesso: \"maschio\", isMarried: false, famiglia: Array(3), \u2026} calcolaEta: \u0192 () dataDiNascita: 1995 eta: 25 famiglia: (3) [\"Anotinio\", \"Giovanni\", \"Alice\"] isMarried: false nome: \"Simone\" sesso: \"maschio\" __proto__: Object */ Vediamo un altro esempio: let libro = { titolo : \"Fondazione\" , pagine : 571 } let autorePreferito = { cognome : \"Asimov\" , nome : \"Isaac\" , // E' possibile definire una property tra gli apici doppi \"nameProperty\" //in modo da forzare a valutarla come identificatore. //Infatti in questo caso il nome libro-preferito non sarebbe accettata come sintassi a causa del \"-\" //E' comunque da EVITARE \"libro-preferito\" : { titolo : \"L`uomo del bicentenario\" , pagine : 288 }, //Riferimento all'oggetto \"libro\" esterno. Attenzione! //E' un riferimento non \u00e8 una copia. Se modifico questa property di questo oggetto (autorePreferito) //modifico anche l'oggetto libro e viceversa. bestSeller : libro , } //Per accedere alla propriet\u00e0 \"libro-preferito\" devo per necessariamente utilizzare la notazione con le []. La notazione ///con \".\" non pu\u00f2 andare bene. //Ecco perch\u00e8 \u00e8 necessario evitare questi nomi con caratteri non validi cosnole . log ( autorePreferito [ \"libro-preferito\" ]. pagine ); console . log ( autorePreferito . bestSeller . titolo ); autorePreferito . bestSeller . pagine = 1000 ; console . log ( libro . pagine ); //1000, ATTENZIONE Come abbiamo visto in questo esempio, specificando come property un altro oggetto, questo viene passato per riferimento e non viene fatta una copia. La libreria JQuery pu\u00f2 aiutarci in questo. let libro = { titolo : \"Fondazione\" , pagine : 571 } let autorePreferito = { cognome : \"Asimov\" , nome : \"Isaac\" , //in questo caso sono necessari i doppi apici (o singoli) perch\u00e8 scrivendo libro-preferito lo tratterebbe com espressione. E' comunque da EVITARE \"libro-preferito\" : { titolo : \"L`uomo del bicentenario\" , pagine : 288 }, //in questo caso \u00e8 JQuery che si occupa di restituire una copia dell'oggetto bestSeller : jQuery . extend ( true , {}, libro ) } console . log ( autorePreferito [ \"libro-preferito\" ]. pagine ); //288 console . log ( autorePreferito . bestSeller . titolo ); //Fondazione autorePreferito . bestSeller . pagine = 1000 ; console . log ( libro . pagine ); //571 La funzione jQuery.extend(true, {}, object) effettua la copia ricorsiva di tutti elementi dell'oggetto specificato come terzo parametro.","title":"Introduzione ai Metodi"},{"location":"javascript/READMEV2/#lezione-03","text":"","title":"Lezione 03"},{"location":"javascript/READMEV2/#costruttore","text":"Partendo dall'esempio della lezione precedente, riporto un esempio completo di come creare un nuovo oggetto partendo dal prototipo. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > let libro = { titolo : \"\" , pagine : 0 } let autorePreferito = { cognome : \"\" , nome : \"\" , libroPreferito : { titolo : \"\" , pagine : 0 }, //JQuery.extend() restituisce una copia dell'oggetto bestSeller : jQuery . extend ( true , {}, libro ) } console . log ( autorePreferito . cognome ); console . log ( autorePreferito . nome ); console . log ( autorePreferito . libroPreferito . titolo ); console . log ( autorePreferito . libroPreferito . pagine ); console . log ( autorePreferito . bestSeller . titolo ); console . log ( autorePreferito . bestSeller . pagine ); //Chiamata al costruttore libro = new LibroConstructor ( \"Il ritorno all'isola\" , 301 ); //Chiamata al costruttore autorePreferito = new Autore ( \"Isaac\" , \"Asimov\" , \"L`uomo del bicentenario\" , 288 , libro ); //Modo alternativo /* autorePreferito = new Autore( \"Isaac\", \"Asimov\", \"L`uomo del bicentenario\", 288, new LibroConstructor ( \"Il ritorno all'isola\", 301 ) ); */ //Funzione costruttore function Autore ( cognome , nome , titolo , pagine , bestSeller ) { //stato interno this . cognome = cognome ; this . nome = nome ; this . libroPreferito = { titolo , pagine }; //this.libroPreferito = {titolo: titolo,pagine: pagine}; this . bestSeller = jQuery . extend ( true , {}, bestSeller ); } function LibroConstructor ( titolo , pagine ){ this . titolo = titolo ; this . pagine = pagine ; } console . log ( autorePreferito . cognome ); console . log ( autorePreferito . nome ); console . log ( autorePreferito . libroPreferito . titolo ); console . log ( autorePreferito . libroPreferito . pagine ); console . log ( autorePreferito . bestSeller . titolo ); console . log ( autorePreferito . bestSeller . pagine ); /* \"\" \"\" \"\" 0 \"\" 0 Isaac Asimov L`uomo del bicentenario 288 Il ritorno all'isola 301 */ </ script > </ body > </ html > Il costruttore \u00e8 una funzione che riceve come parametri i valori delle property e costruisce (ritorna) un oggetto. Notare l'uso del new necessario per l'invocazione del costruttore e del this ripetuto per ogni property necessario per stabilire il contesto dell'oggetto che viene creato dal costruttore. Vediamo adesso l'aggiunta di metodi all'esempio di sopra: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > let libro = { titolo : \"\" , pagine : 0 } function LibroConstructor ( titolo , pagine ){ this . titolo = titolo ; this . pagine = pagine ; } let autorePreferito = { cognome : \"\" , nome : \"\" , libroPreferito : { titolo : \"\" , pagine : 0 }, bestSeller : jQuery . extend ( true , {}, libro ) } function Autore ( cognome , nome , titolo , pagine , bestSeller ) { //stato interno this . cognome = cognome ; this . nome = nome ; this . libroPreferito = { titolo , pagine }; //this.libroPreferito = {titolo: titolo,pagine: pagine}; this . bestSeller = jQuery . extend ( true , {}, bestSeller ); //metodi this . getSchedaBestSeller = function () { let stringa = this . bestSeller . titolo + \"\\n\" + this . bestSeller . pagine ; let stringaConCornicetta = \"*\" . repeat ( 10 ) + \"\\n\" + \"BestSeller\" + \"\\n\" + \"-\" . repeat ( 10 ) + \"\\n\" + stringa + \"\\n\" + \"*\" . repeat ( 10 ); return stringaConCornicetta ; } this . getSchedaAutore = function () { let stringa = this . cognome + \"\\n\" + this . nome + \"\\n\" + this . libroPreferito . titolo + \"\\n\" + this . libroPreferito . pagine ; let stringaConCornicetta = \"*\" . repeat ( 10 ) + \"\\n\" + \"Scheda\" + \"\\n\" + \"-\" . repeat ( 10 ) + \"\\n\" + stringa + \"\\n\" + \"*\" . repeat ( 10 ); return stringaConCornicetta ; } } //Creo una collezione di oggetti, cio\u00e8 un array di oggetti let schedario = [ new Autore ( \"Runny\" , \"Ted\" , \"Lo sguardo del principe\" , 212 , new LibroConstructor ( \"Il mio viaggio\" , 272 ) ), new Autore ( \"Buld\" , \"Frank\" , \"I segreti di tutti\" , 302 , new LibroConstructor ( \"Il mio segreto\" , 180 ) ) ]; //Aggiungo in coda un nuovo oggetto schedario . push ( new Autore ( \"Tuy\" , \"malek\" , \"La voglia di te\" , 167 , new LibroConstructor ( \"la voglia di niente\" , 134 ) ) ); //itero ogni elemento dell'array e chiamo i metodi for ( let autore of schedario ) { console . log ( autore . getSchedaAutore () ); console . log ( autore . getSchedaBestSeller () ); } /* ********** Scheda ---------- Runny Ted Lo sguardo del principe 212 ********** ********** BestSeller ---------- Il mio viaggio 272 ********** ********** Scheda ---------- Buld Frank I segreti di tutti 302 ********** ********** BestSeller ---------- Il mio segreto 180 ********** ********** Scheda ---------- Tuy malek La voglia di te 167 ********** ********** BestSeller ---------- la voglia di niente 134 ********** */ </ script > </ body > </ html >","title":"Costruttore"},{"location":"javascript/READMEV2/#lezione-04","text":"","title":"Lezione 04"},{"location":"javascript/READMEV2/#ereditarieta","text":"JavaScript confonde un po' gli sviluppatori che hanno esperienza di linguaggi basati sulle classi (come Java o C++), poich\u00e8 \u00e8 un linguaggio dinamico e non fornisce un'implementazione di class (la keyword class \u00e8 introdotto in ES2015, ma \u00e8 zucchero sintattico, Javascript rimarr\u00e0 basato sui prototipi). In termini di ereditariet\u00e0, Javascript ha solo un costrutto: gli oggetti. Ogni oggetto ha un link interno ad un altro oggetto chiamato prototype. Questo oggetto prototype ha a sua volta un suo prototype, e cos\u00ec via finch\u00e9 si raggiunge un oggetto con property null. null, per definizione, non ha un prototype, ed agisce come link finale nella catena di prototipi. Quasi tutti gli oggetti in Javascript sono istanze di Object, che risiede in cima alla catena dei prototipi. Nonostante questo sia considerato spesso come una debolezza di Javascript, il modello di ereditariet\u00e0 prototipale \u00e8 invece pi\u00f9 potente del modello classico. Per esempio, \u00e8 banale costruire un classico modello sul modello prototipale, mentre il contrario \u00e8 molto pi\u00f9 difficile. Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Inheritance_and_the_prototype_chain Supponiamo di aver creato un oggetto con certe propriet\u00e0 e metodi e di voler creare un altro oggetto con le stesse propiet\u00e0 e gli stessi metodi ed altre propriet\u00e0/metodi speifiche. Una soluzione, per quello che conosciamo adesso, si ha banalmente con un copia e incolla dell'oggetto modello (prototipo) aggiungendo poi le caratteristiche aggiuntive. Il concetto dell'ereditariet\u00e0 evita questa procedura di copia incolla non solo perch\u00e8 sarebbe una ripetizione ma anche, soprattutto, perch\u00e8 gli errori con i copia e incolla diventano intracciabili. Se \u00e8 stato individuato un errore nell'oggetto A, \u00e8 necessario riportare tutte le modifiche anche negli altri oggetti di cui si \u00e8 effettuata la copia manuale .. non \u00e8 il massimo. Per parlare di ereditariet\u00e0 dobbiamo parlare di gerarchia padre/figlio. Un figlio \u00e8 un oggetto che contiene tutte le caratteristiche del padre ovvero ne eredita le propriet\u00e0. Si parla anche di modello is-a Immaginiamo di avere questo modello piramidale: Animali Mammiferi Cane Gatto Volpe L'oggetto Volpe \u00e8 un (is-a) Mammifero , un Mammifero \u00e8 un (is-a) Animale . Secondo questo modello \u00e8 possibile costruire degli oggetti molto dettagliati semplicemente sfruttando le propriet\u00e0 ereditate Vediamo come si costruisce un oggetto con propriet\u00e0 ereditate //persona \u00e8 l'oggetto <padre> let persona = { nome : \"\" }; //Creo l'oggetto fantozzi. //fantozzi \u00e8 un oggetto che ha come prototipo l'oggetto persona. //fantozzi is-a persona let fantozzi = Object . create ( persona ); //persona e il prototipo di fantozzi sono la stesso oggetto console . log ( persona === Object . getPrototypeOf ( fantozzi )); => true //Per accedere in scrittura alle propriet\u00e0 ereditate si utilizza il metodo getPrototypeOf() //applicabile agli oggetti Object . getPrototypeOf ( fantozzi ). nome = \"Fantozzi\" ; //non avrei potuto scrivere direttamente \"fantozzi.nome\" perch\u00e8 avrebbe creato una propriet\u00e0 locale //poich\u00e8 <nome> non \u00e8 una propriet\u00e0 dell'oggetto \"fantozzi\" ma dell'oggetto \"persona\" //e quindi una propriet\u00e0 ereditata \u00e8 necessario il metodo getPrototypeOf() per distinguere in scrittura //le propriet\u00e0 locali da quelle ereditate. //In lettura, se non ci sono conflitti (vedremo pi\u00f9 avanti), //non importa specificare getPrototypeOf() perch\u00e8 il costrutto cerca prima tra le propriet\u00e0 locali //la propriet\u00e0 <nome>, se non \u00e8 presente la si cerca tra gli oggetti padre e quindi tra le property ereditate //In questo caso non la trover\u00e0 tra le propriet\u00e0 locali ma tra quelle ereditate console . log ( fantozzi . nome ); //Fantozzi //In questo caso aggiungo una propriet\u00e0 locale fantozzi . nome = \"il super sfigato\" ; //La proprit\u00e0 locale ha la precedenza. La propriet\u00e0 locale maschera quella ereditata //Shadowing console . log ( fantozzi . nome ); //il super sfigato //Per accedere in lettura alla propriet\u00e0 <nome> ereditata devo necessariamente utilizzare il //getPrototypeOf() console . log ( Object . getPrototypeOf ( fantozzi ). nome ); ATTENZIONE!! Il metodo create non crea una copia. let fantozzi = Object . create ( persona ); l'oggetto fantozzi non \u00e8 una copia dell'oggetto persona . Il figlio (fantozzi) condivide le stesse property del padre(persona). Se modifico le property del figlio (fantozzi) le trovo modificate anche nell'oggetto padre (persona) proprio perch\u00e8 condividono le stesse variabili, lo stesso spazio in memoria. Questo \u00e8 da tenere in considerazione!","title":"Ereditariet\u00e0"},{"location":"javascript/READMEV2/#lezione-05","text":"","title":"Lezione 05"},{"location":"javascript/READMEV2/#ereditarieta-shadowing","text":"Lo shadowing \u00e8 un meccanismo di mascheramento/oscuramento di property ereditate con la definizione di property locali Esempio let persona = { nome : \"\" , cognome : \"\" , Etichetta : function () //Stringhe template. Iniziano con $. Prima vengono valutate poi il valore viene sostituito e notare gli acccenti gravi { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } }; //L'oggetto persona diventa il prototipo dell'oggetto fantozzi let fantozzi = Object . create ( persona ); //Metodo hasOwnProperty(\"property\"): ritorna <true> se l'oggetto a cui si applica il metodo //ha come propriet\u00e0 diretta (non ereditata) \"property\", quella indicata come parametro. console . log ( fantozzi . hasOwnProperty ( \"nome\" )); //false //In questo caso constrollo se \"nome\" appartiene al padre console . log ( Object . getPrototypeOf ( fantozzi ). hasOwnProperty ( \"nome\" )); //true cosnole . log ( fantozzi . nome ); //non ancora inizializzata ma la variabile viene trovata come propriet\u00e0 ereditata //Accedo in scrittura alle propriet\u00e0 ereditate Object . getPrototypeOf ( fantozzi ). nome = \"Ugo\" ; Object . getPrototypeOf ( fantozzi ). cognome = \"Fantozzi\" ; //Creo una propriet\u00e0 locale fantozzi . nome = \"e io chi sono??\" ; //Accedo in lettura alla propriet\u00e0 locale console . log ( fantozzi . nome ); //e io chi sono?? //Accedo in lettura alla propriet\u00e0 ereditata console . log ( Object . getPrototypeOf ( fantozzi ). nome ); //Ugo //Posso eliminare una property tramite il comando <delete> ma solo tra quelle locali delete fantozzi . nome ; //A questo punto rimane solo la property <name> ereditata console . log ( fantozzi . nome ); //Ugo //Shadowing: Meccanismo di mascheramento/oscuramento di property ereditate con la definizione di //prperty locali //Chiamo il metodo Etichetta dell'oggetto fantozzi eredietato dall'oggetto persona console . log ( \"1: \" + fantozzi . Etichetta () ); //Oscuro il metodo <Etichetta> ereditato dal metodo <Etichetta> definito localmente -> shadowing fantozzi . Etichetta = function () { return \"il sottoposto per eccellenza\" ;} console . log ( \"2: \" + fantozzi . Etichetta ()); //Variante ... //Un po' complessa. //Definisco un metodo locale che utilizza il metodo ereditato. //il this fa riferimento all'oggetto in cui si definisce il metodo quindi \"fantozzi\" fantozzi . Etichetta = function () { return Object . getPrototypeOf ( this ). Etichetta () + \" detto il sottoposto\" ;} console . log ( \"3: \" + fantozzi . Etichetta ()); //le propriet\u00e0 del prototipo sono CONDIVISE. //Se modifico una propiet\u00e0 in un figlio ereditata da una propriet\u00e0 del padre, //la ritrovo modificata anche nel padre e negli altri figli del padre, cio\u00e8 nei \"fratelli\" //Questo non \u00e8 lo stesso meccanismo del C/C#/Java let filini = Object . create ( persona ); Object . getPrototypeOf ( filini ). cognome = \"Filini\" ; console . log (( \"4: \" + fantozzi . cognome ); //Filini, ATTTT!! Metodo hasOwnProperty() : ritorna se l'oggetto a cui si applica il metodo ha come propriet\u00e0 diretta (non ereditata) \"property\", quella indicata come parametro. Cosniderazione: Il padre di tutti gli oggetti \u00e8 proprio \"Object\" Ricorda: Con il metodo create() non creo una copia dell'oggetto, cio\u00e8 un'istanza del prototipo, ma instauro solo un rapporto di condivisione","title":"Ereditariet\u00e0 - Shadowing"},{"location":"javascript/READMEV2/#ereditarieta-classica","text":"Per ereditariet\u00e0 classica si intende il meccanismo con il quale Javascript permette la crazione di istanze di oggetti a partire da un prototipo. Nell'esempio vedremo come realizzare una copia dato un prototipo Vediamo finalmente il metodo per creare una fottuta copia //Prototipo function Persona ( nome , cognome ) { //stato interno //Ogni istanza avr\u00e0 la sua copia di cognome e nome this . cognome = cognome ; this . nome = nome ; //ogni istanza avr\u00e0 la sua copia di etichetta this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } //chiamata al costruttore let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ) //gli oggetti fantozzi e filini hanno le loro copie distinte //delle variabili dello stato interno console . log ( \"1: \" + fantozzi . etichetta ()); cosnole . log ( \"2: \" + filini . etichetta ()); cosnole . log `3: ${ fantozzi . etichetta === filini . etichetta } ` ); //false","title":"Ereditariet\u00e0 classica"},{"location":"javascript/READMEV2/#lezione-06","text":"","title":"Lezione 06"},{"location":"javascript/READMEV2/#this","text":"In questi esempi cercheremo di capire la funzione di this in Javascript a seconda dei contesti. function Persona ( nome , cognome ) { //stato interno this . cognome = cognome ; this . nome = nome ; console . log ( this === window ); //true this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } //Attenzione, qua non utilizzo il costruttore. //this punta all'oggetto <window> (cio\u00e8 il padre del DOM). //Il risultato \u00e8 che le property <nome>, <cognme> diventano a tutti gli effetti variabili globali //poich\u00e8 <window> \u00e8 un oggetto implicito Persona ( \"\" , \"zzzzzz\" ); //cognome \u00e8 una variabile globale, window.cognome === cognome console . log ( cognome ); //zzzzzz Se invece utilizzo il costruttore dell'oggetto.. function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; console . log ( this === window ); //false this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } //Utilizzo il costruttore per creare due istanze dell'oggetto \"Persona\", \"fantozzi\", \"filini\" let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); //Adesso le variabili (property) <nome>, <cognome> sono visibili solo nel contesto degli oggetti \"fantozzi\" e \"filini\" //e accessibili solo tramite l'opertore \".\" console . log ( cognome ); //cognome is not defined. console . log ( fantozzi . cognome ); //Fantozzi. console . log ( filini . cognome ); //Filini. Quando this \u00e8 all'interno della definizione di un metodo, fa riferimento all'oggetto per cui si definisce il metodo. Nota: Non posso definire una variabile locale \"local_var\" senza far uso di this . Non sar\u00e0 disponibile nelle istanze degli oggetti ma solo nel constesto della chiamata funzione e quindi non nel contesto della chiamata a costruttore. Vediamo un esempio function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; let local_var = 999 ; //ATTENZIONE!! Non ha senso nel contesto di chiamata a costruttore //ogni istanza avr\u00e0 la sua copia di etichetta this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); console . log ( fantozzi . local_var ); //undefined console . log ( fantozzi . cognome ); //Fantozzi. console . log ( filini . cognome ); //Filini.","title":"THIS"},{"location":"javascript/READMEV2/#object-variabili-statiche-condivise","text":"In generale, le variabili statiche sono variabili condivise. Nel contesto di un oggetto, per creare delle variabili statiche cio\u00e8 condivise tra tutte le istanze si ottiene attraverso il metodo prototype function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); //dichairo una variabile (property) \"s\", \"ETA_MIN\" statica cio\u00e8 condivisa tra tutte le istanze create attravero il modello //dell'oggetto \"Persona\" Persona . prototype . s = \"ciao\" ; Persona . prototype . ETA_MIN = { value : 18 } ; console . log ( fantozzi . s ); //ciao console . log ( filini . s ); //ciao console . log ( fantozzi . ETA_MIN ); //{value: 18} console . log ( filini . ETA_MIN ); //{value: 18} //Posso dichiarare anche un metodo condiviso Persona . prototype . etichettaCondivisa = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } console . log ( `3: ${ fantozzi . etichetta === filini . etichetta } ` ); //false console . log ( `4: ${ fantozzi . etichettaCondivisa === filini . etichettaCondivisa } ` ); //true Vediamo un ultimo esempio: function Persona ( nome , cognome ) { this . cognome = cognome ; this . nome = nome ; this . etichetta = function () { return `Egr. Sig. Lup. Mann. ${ this . nome } ${ this . cognome } ` } } let fantozzi = new Persona ( \"Ugo\" , \"Fantozzi\" ); let filini = new Persona ( \"Renzo Silvio\" , \"Filini\" ); Persona . prototype . s = \"ciao\" ; console . log ( fantozzi . s ); //ciao console . log ( filini . s ); //ciao //Se voglio accedere in scrittura ad una property condivisa tramite un figlio, dobbiamo al solito modo //utilizzare getPrototypeOf() Object . getPrototypeOf ( fantozzi ). s = \"amor\" ; console . log ( fantozzi . s ); //amor console . log ( filini . s ); //amor //Definisco una property locale a fantozzi fantozzi . s = \"mare\" ; console . log ( fantozzi . s ); //mare console . log ( filini . s ); //amor","title":"Object - Variabili Statiche (condivise)"},{"location":"javascript/READMEV2/#lezione-07","text":"","title":"Lezione 07"},{"location":"javascript/READMEV2/#introduzione-for-in","text":"for-in \u00e8 un metodo utilizzato per iterare sulle property degli oggetti tramite l'identificativo delle chiavi. Vedremo pi\u00f9 avanti cosa sta dietro a un costrutto cos\u00ec semplice e potente for ( const x in object ){ //code } const Persona = { name : 'Simone' , eta : 23 , hobby : 'Tennis' } for ( const x in Persona ) { console . log ( '+++++++++++++++' ); console . log ( x ); //Itero sulle chiavi console . log ( typeof x ); //x \u00e8 una stringa //non posso utilizzare Persona.x poich\u00e8 x \u00e8 una stringa. //Posso comunque utilizzare la notazione Persona[x] che in questo i torna comodo console . log ( Persona [ x ]); //Itero sui valori console . log ( Persona . x ); //Itero sui valori console . log ( '+++++++++++++++' ); } /* +++++++++++++++ name string Simone +++++++++++++++ +++++++++++++++ eta string 23 +++++++++++++++ +++++++++++++++ hobby string Tennis +++++++++++++++ */","title":"Introduzione For In"},{"location":"javascript/READMEV2/#oggetto-date","text":"Un oggetto interessante \u00e8 l'oggetto Date() . Javascript permette di gestire in modo semplice il tempo, la data, l'ora acquisendo dati dalla rete. //Chiamata al costruttore Date() con parametri di default let oggi = new Date (); console . log ( oggi ); /* Console: --------------- Wed Nov 11 2020 17:13:04 GMT+0100 (Ora standard dell\u2019Europa centrale) */ //Passaggio di parametri al costruttore Date() let compleannoMio = new Date ( '07-22-1991-09:30:12' ); //Modi alternativi let compleannoMario = new Date ( '07/22/1991' ); let compleannoGiovanni = new Date ( 'July 22 1991' ); console . log ( 'compleannoMio: ' + compleannoMio ); console . log ( 'compleannoMario: ' + compleannoMario ); console . log ( 'compleannoGiovanni: ' + compleannoGiovanni ); /* Console: --------------- compleannoMio: Mon Jul 22 1991 09:30:12 GMT+0200 (Ora legale dell\u2019Europa centrale) compleannoMario: Mon Jul 22 1991 00:00:00 GMT+0200 (Ora legale dell\u2019Europa centrale) compleannoGiovanni: Mon Jul 22 1991 00:00:00 GMT+0200 (Ora legale dell\u2019Europa centrale) */ Essendo Date() un oggetto ci sono diversi metodi get associati a questo oggetto come: getFullYear() : Ritorna l'anno getMonth() : Ritorna il mese a partire da 0, 0 = GEN, 1 = FEB getDate() : Ritorna il giorno del mese corrente, range [1 - 31] getDay() : Ritorna il giorno della settimana a partire da 0, 0 = DOM, 1 = LUN getHours() : Ritornano le ore getMinutes() : Ritornano i minuti getSeconds() : Ritornano i secondi getMilliseconds() : Ritornano i millisecondi getTime() : he getTime() method returns the number of milliseconds between midnight of January 1, 1970 and the specified date ... Ma anche metodi analoghi di set come: - setFullYear(year) - setMonth(month) - setHours(h, m, s) - .. //Metodi get let myData = new Date (); console . log ( 'getFullYear: ' + myData . getFullYear ()); console . log ( 'getMonth: ' + myData . getMonth ()); console . log ( 'getDate: ' + myData . getDate ()); console . log ( 'getDay: ' + myData . getDay ()); console . log ( 'getHours: ' + myData . getHours ()); console . log ( 'getMinutes: ' + myData . getMinutes ()); console . log ( 'getSeconds: ' + myData . getSeconds ()); console . log ( 'getMilliseconds: ' + myData . getMilliseconds ()); console . log ( 'getTime: ' + myData . getTime ()); /* Console: --------------- getFullYear: 2020 getMonth: 10 getDate: 12 getDay: 4 getHours: 10 getMinutes: 27 getSeconds: 50 getMilliseconds: 336 getTime: 1605173270336 */ //Metodi set let compleannoMario = new Date ( 'April 02 2002' ); console . log ( 'compleannoMario: ' + compleannoMario ); /* Console: --------------- compleannoMario: Tue Apr 02 2002 00:00:00 GMT+0200 (Ora legale dell\u2019Europa centrale) */ compleannoMario . setFullYear ( '1991' ); compleannoMario . setMonth ( 9 ); compleannoMario . setHours ( 12 , 45 , 09 ); console . log ( 'compleannoMario: ' + compleannoMario ); /* Console: --------------- compleannoMario: Wed Oct 02 1991 12:45:09 GMT+0100 (Ora standard dell\u2019Europa centrale) */ Nota: Se creto un'istanza dell'oggetto Date() senza parametri, verr\u00e0 invocato il costruttore con parametri di default. Di default Date() restituisce l'ora e la data locale fornita dalla rete. Quindi l'oggetto appena creato far\u00e0 riferimento all'ora corrente, un dato dinamico.","title":"Oggetto Date()"},{"location":"javascript/READMEV2/#lezione-08_1","text":"","title":"Lezione 08"},{"location":"javascript/READMEV2/#classi","text":"Le classi JavaScript, introdotte in ECMAScript 2015, sono principalmente zucchero sintattico sull'esistente ereditariet\u00e0 prototipale di JavaScript. La sintassi non introduce un nuovo modello di eredit\u00e0 orientata agli oggetti in JavaScript. Le classi sono di fatto delle \"funzioni speciali\", e cos\u00ec come puoi definire function expressions e function declarations, la sintassi per la classe ha due componenti: class expressions e class declarations. Non \u00e8 lo stesso concetto di classe definita come ad esempio per il linguaggio C++. class Persona { } let Fantozzi = new Persona (); cosnole . log ( typeof ( Fantozzi )); //Object //Dietro il meccanismo di classe c'\u00e8 di fatto il concetto di prototipo/funzione cosnole . log ( typeof ( Persona )); //function Vediamo un esempio pi\u00f9 completo class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } } //non passo nessun parametro quindi utilizzer\u00e0 i valori di default let Fantozzi = new Persona (); cosnole . log ( Fantozzi . nome ); //sconosciuto Note: - Con questa definizione di classe non esiste tuttavia un meccanismo che possa rendere privati i dati come nel concetto di classe che si avrebbe nel c++. - Non \u00e8 possibile un meccanismo di overload dei costruttori , non possono quindi coesistere pi\u00f9 costruttori. E' ammesso un solo costruttore per classe. Tuttavia ogni istanza creata avr\u00e0 i dati separati class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } } //non passo nessun parametro quindi utilizzer\u00e0 i valori di default let Fantozzi = new Persona (); console . log ( Fantozzi . nome ); //sconosciuto let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); console . log ( Fantozzi . nome ); //Ugo let Filini = new Persona ( \"Filini\" , \"Silvio\" ); console . log ( Filini . nome ); //Silvio console . log ( Fantozzi . nome ); //Ugo Ampliamo la classe con l'aggiunta di metodi: class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } } let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); let Filini = new Persona ( \"Filini\" , \"Silvio\" ); cosnole . log ( Fantozzi . etichetta ); cosnole . log ( Filini . Etichetta ); cosnole . log ( Fantozzi . etichetta === Filini . Etichetta ); //false Aggiunta di metodi condivisi class Persona { //utilizzo parametri di default constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; } //metodo condiviso tra tutte le istanze static etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } //metodo separato per ogni istanza etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } } let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); let Filini = new Persona ( \"Filini\" , \"Silvio\" ); //Assegno dei \"value\" alle property della classe Persona . cognome = \"Liberti\" ; Persona . nome = \"Franco\" ; //il metodo Filini.etichetta \u00e8 il metodo locale alla classe Filini. //Prende il nome di \"Metodo di istanza\" console . log ( \"Metodo di istanza: \" + Filini . etichetta () ); //Metodo di istanza: Egr. Sig. Silvio Filini //il metodo Persona.etichetta \u00e8 il metodo condiviso tra tutte le istanze della classe Persona. //Prende il nome di \"Metodo di classe\" console . log ( \"Metodo di classe: \" + Persona . etichetta () ); //Metodo di classe: Egr. Sig. Franco Liberti Vediamo un esempio in cui posso sfruttare le variabili statiche. In questo esempio, ogni volta che creo un'istanza della classe Persona, incremento una variabile statica che indicher\u00e0 alla fine quante istanze ho creato class Persona { constructor ( cognome = \"sconosciuto\" , nome = \"sconosciuto\" ) { this . cognome = cognome ; this . nome = nome ; //ogni volta che creo un'istanza della classe Persoan, si icrementa la variabile \"conta\" //Nota <conta> \u00e8 stata aggiunta dopo la creazione della classe Persona Persona . conta ++ ; } static personeCreate () { return Persona . conta ;} etichetta () { return `Egr. Sig. ${ this . nome } ${ this . cognome } ` ; } } //Resetto il conteggio Persona . conta = 0 ; let Fantozzi = new Persona ( \"Fantozzi\" , \"Ugo\" ); let Filini = new Persona ( \"Filini\" , \"Silvio\" ); console . log ( Persona . conta ); //2 console . log ( Persona . personeCreate () ); //2","title":"Classi"},{"location":"javascript/READMEV2/#lezione-09_1","text":"","title":"Lezione 09"},{"location":"javascript/READMEV2/#classi-assegnanili-a-variabili","text":"Posso assegnare una classe ad una variabile esattamente come per gli oggetti, le funzioni.. //questa \u00e8 una classe anonima let Punto = class { constructor ( x , y ) { this . x = x ; this . y = y ;} } let p = new Punto ( 10 , - 30 ); console . log ( p . y ); //-30 p . x = \"paperino\" ; //non viene fatto nessun controllo semantico console . log ( p . x ); //paperino","title":"Classi assegnanili a variabili"},{"location":"javascript/READMEV2/#get-set","text":"Non c'\u00e8 un modo di definire x e y private con un meccanismo simile alle property private per le classi definite dal linguaggio C++ tuttavia esiste un sistema che ci aiuta a nascondere le variabili interne, get/set . //PuntoIQ \u00e8 una classe che assegna punti solo nel primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } } try { //poich\u00e8 questo punto non appartiene al primo quadrante si verifica l'eccezione e salta al catch let p = new PuntoIQ ( 10 , - 30 ); } catch ( eccezione ) { console . log ( eccezione ); }","title":"Get / Set"},{"location":"javascript/READMEV2/#try-catch","text":"Nota il sistema try-catch . Con tale sistema \u00e8 possibile tentare l'esecuzione del codice presente nel corpo di try . Se va a buon fine si prosegue altrimenti si esegue il corpo del catch . Per stabilire se il codice presente nel try va o meno a buon fine si utilizza la keyword throw . Nella classe PuntoIQ infatti se i dati passati al costruttore sono minori di zero si passa un'eccezione attravero throw , l'eccezione in questo caso \u00e8 semplicemente la stringa \"Non nel primo quadrante\" che viene passata al catch try { //prova ad eseguire il codice. Se il codice presenta un'eccezione salta al catch } catch ( eccezione ){ //esegui eccezione } Riprendiamo con il concetto di get/set //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } //Per accedere a questa propriet\u00e0 devo usare \"_x\", //\u00e8 di fatto un sistema di costrizione dell'utilizzatore della classe a NON usare questa property this . _x = x ; //Per accedere a questa propriet\u00e0 devo usare \"_y\", //\u00e8 di fatto un sistema di costrizione dell'utilizzatore della classe a NON usare questa property this . _y = y ; } //Le keyword \"get\" definisce di fatto un metodo che pu\u00f2 essere richiamato con la nomenclatura //utilizzata per le propriet\u00e0. Posso quindi richiamare il metodo x tramite <punto.x> //get definisce un metodo di lettura quindi posso leggere la property \"x\" //nascondendo la \"vera\" property definita sopra tramite \"_x\" get x () { return this . _x ; } //Le keyword \"set\" definisce come \"get un metodo che pu\u00f2 essere richiamato con la nomenclatura //utilizzata per le propriet\u00e0. Posso quindi richiamare il metodo x tramite <punto.x> //get definisce un metodo di scrittura quidni posso scrivere la property \"x\" //nascondendo la \"vera\" property definita sopra \"_x\" set x ( valore ) { this . _x = valore ; } } try { var p = new PuntoIQ ( 10 , 30 ); //Ok } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 10, _y: 30} try { p . x = 56 ; // === p._x = 56 } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 56, _y: 30} try { p . _x = 12 ; // L'utilizzatore della classe sta bypassando il metodo \"ufficiale\" tramite get/set } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 12, _y: 30} Passare attravero get/set \u00e8 utile per poter eseguire controlli avanzati e restituire un errore in caso di fallimento. Vediamo di estendere la classe di sopra aggiungendo un controllo in fase di set //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore ) ){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } } try { var p = new PuntoIQ ( 10 , 30 ); //Ok } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //PuntoIQ {_x: 10, _y: 30} try { p . x = \"dodici\" ; // === p._x = 56 } catch ( eccezione ) { console . log ( eccezione ); } console . log ( p ); //Non \u00e8 un numero","title":"try-catch"},{"location":"javascript/READMEV2/#lezione-10_1","text":"","title":"Lezione 10"},{"location":"javascript/READMEV2/#derivazione-di-classi-ereditarieta","text":"Il meccanismo di derivazione delle classi ovvero la costruzione di una classe figlia a partire da una classe padre aggiungendo una specializzazione \u00e8 noto anche come meccanismo di ereditariet\u00e0 e si ottiene semplicemente la keyword extends . Abbiamo gi\u00e0 visto come \u00e8 implementato questo concetto negli oggetti in Javascript. Per quanto riguarda le classi si ricordi che \u00e8 solo \"zucchero sintattico\" quindi il meccanismo sotto sar\u00e0 il medesimo. //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore ) ){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } } class PuntoIQColorato extends PuntoIQ { } La lasse \"PuntoIQColorato\" \u00e8 derivata dalla classe madre PuntoIQ ma accede a a tutte le strutture interne della classe madre. Vediamo di estendere la classe definita sopra con altri metodi: //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore )){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } //\"distanza(altro)\", applicato a un oggetto A <PuntoIQ> calcola la distanza tra //l'oggetto a cui si applica il metodo (oggetto A) e un altro oggetto ricevuto come argomento //<altro> che dovr\u00e0 essere un oggetto della classe <PuntoIQ> distanza ( altro ){ //\"A instanceof B\" ritorna true se A \u00e8 un'istanza di B //Viene quindi fatto un controllo per essere sicuri di aver ricevuto un oggetto compatibile if ( altro instanceof PuntoIQ ){ //formula distanza tra due punti return ( Math . sqrt ( Math . pow ( this . x - altro . x , 2 ) + Math . pow ( this . y - altro . y , 2 ) ) ); } else { throw \"Il parametro attuale `altro` non \u00e8 un punto\" ; } } } class PuntoIQColorato extends PuntoIQ { } let p1 = new PuntoIQ ( 5 , 5 ); let p2 = new PuntoIQ ( 10 , 10 ); cosnole . log ( p1 . distanza ( p2 ) ); //7.07... //un oggetto della classe <PuntoIQColorato> \u00e8 identico a un oggetto della classe <PuntoIQ> let pc = new PuntoIQColorato ( 100 , 100 ); console . log ( \"Punto Colorato: \" + pc . x ); //La classe figlia PuntoIQColorato passa il controllo if (altro instanceof PuntoIQ) Poich\u00e8 \u00e8 figlia //di PuntoIQ cosnole . log ( pc . distanza ( p2 ) ); Nella prossima lezione aggiungeremo elementi specifici della classe PuntoIQColorato","title":"Derivazione di classi , ereditariet\u00e0"},{"location":"javascript/READMEV2/#lezione-11_1","text":"","title":"Lezione 11"},{"location":"javascript/READMEV2/#ereditarieta-classi-pt-2","text":"In questo esempio vedremo aggiungeremo elementi specifici della classe PuntoIQColorato . Utilizzeremo anche il comando super . Un comando usato nella classe figlia per richiamare il costruttore della classe madre //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore )){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } //\"distanza(altro)\", applicato a un oggetto A <PuntoIQ> calcola la distanza tra //l'oggetto a cui si applica il metodo (oggetto A) e un altro oggetto ricevuto come argomento //<altro> che dovr\u00e0 essere un oggetto della classe <PuntoIQ> distanza ( altro ){ //\"A instanceof B\" ritorna true se A \u00e8 un'istanza di B //Viene quindi fatto un controllo per essere sicuri di aver ricevuto un oggetto compatibile if ( altro instanceof PuntoIQ ){ //formula distanza tra due punti return ( Math . sqrt ( Math . pow ( this . x - altro . x , 2 ) + Math . pow ( this . y - altro . y , 2 ) ) ); } else { throw \"Il parametro attuale `altro` non \u00e8 un punto\" ; } } } class PuntoIQColorato extends PuntoIQ { constructor ( x , y , colore ){ //super richiama il costruttore della classe madre //super deve essere sempre il primo statemeant super ( x , y ); this . _colore = colore ; //Potrei accedere ai dati interni della classe madre PuntoIQ tramite ad esempio //this._x = 999; //E' ASSOLUTAMENTE DA EVITARE PERCHE' BYPASSO TUTTI I CONTROLLI SU \"x\" } get colore (){ return this . _colore ; } //Shadowing. //Il metodo \"distanza\" definito qua \u00e8 locale alla classe <PuntoIQColorato> e oscura il metodo ereditato //dalla classe <PuntoIQ> distanza ( altro ){ return 1000 ; } } let p1 = new PuntoIQ ( 5 , 5 ); let p2 = new PuntoIQ ( 10 , 10 ); console . log ( p1 . distanza ( p2 ) ); //7.0... let pc = new PuntoIQColorato ( 100 , 100 , \"blue\" ); console . log ( \"Punto Colorato: \" + pc . x , pc . y , pc . colore ); //Punto Colorato: 100 100 blue //Poich\u00e8 il metodo \"distanza\" \u00e8 applicato a <pc> che \u00e8 un <PuntoIQColorato> verr\u00e0 applicato il metodo locale console . log ( pc . distanza ( p2 ) ); //1000 Attenzione: E' buona norma mettere il comando super come primo comando nel costruttore della classe figlia per poter permettere al costrutto di creare le caratteristiche ereditate correttamente Metodi locali ed ereditati possono coesistere e collaborare. Con super posso richiamare il metodo della classe madre all'interno della classe figlia //punto appartenente al primo quadrante class PuntoIQ { constructor ( x , y ) { if ( x < 0 || y < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = x ; this . _y = y ; } get x () { return this . _x ; } set x ( valore ) { if ( typeof ( valore ) === \"boolean\" || isNaN ( valore )){ throw \"Non \u00e8 un numero\" ; } if ( valore < 0 ){ throw \"Non nel primo quadrante\" ; } this . _x = valore ; } get y () { return this . _y ; } //\"distanza(altro)\", applicato a un oggetto A <PuntoIQ> calcola la distanza tra //l'oggetto a cui si applica il metodo (oggetto A) e un altro oggetto ricevuto come argomento //<altro> che dovr\u00e0 essere un oggetto della classe <PuntoIQ> distanza ( altro ){ //\"A instanceof B\" ritorna true se A \u00e8 un'istanza di B //Viene quindi fatto un controllo per essere sicuri di aver ricevuto un oggetto compatibile if ( altro instanceof PuntoIQ ){ //formula distanza tra due punti return ( Math . sqrt ( Math . pow ( this . x - altro . x , 2 ) + Math . pow ( this . y - altro . y , 2 ) ) ); } else { throw \"Il parametro attuale `altro` non \u00e8 un punto\" ; } } } class PuntoIQColorato extends PuntoIQ { constructor ( x , y , colore ){ //super deve essere sempre il primo statemeant super ( x , y ); this . _colore = colore ; } get colore (){ return this . _colore ; } //Shadowing. distanza ( altro ){ //richiamo il metodo \"distanza\" della classe madre return super . distanza ( altro ) + 1000 ; } } let p1 = new PuntoIQ ( 5 , 5 ); let p2 = new PuntoIQ ( 10 , 10 ); console . log ( p1 . distanza ( p2 ) ); //7.0... let pc = new PuntoIQColorato ( 100 , 100 , \"blue\" ); console . log ( \"Punto Colorato: \" + pc . x , pc . y , pc . colore ); //Punto Colorato: 100 100 blue console . log ( pc . distanza ( p2 ) ); //1127.2792206135787","title":"Ereditariet\u00e0 classi Pt 2"},{"location":"javascript/READMEV2/#lezione-12_1","text":"","title":"Lezione 12"},{"location":"javascript/READMEV2/#approfondimento-symbols","text":"Ogni valore symbol restituito da Symbol() \u00e8 unico. Un valore symbol pu\u00f2 essere utilizzato come identificatore per propriet\u00e0 di un oggetto; questo \u00e8 lo scopo di tale tipo di dati. Il tipo di dati symbol \u00e8 un primitive data type. Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/Symbol //Il simbolo \u00e8 un nuovo tipo che permette di creare valori univoci //Nell'esempio creo due variabili di tipo Symbol(). //I loro valori (che non possiamo stampare) saranno sicuramente diversi let un_simbolo = Symbol (); let un_altro_simbolo = Symbol (); //Posso agire per confronti ma non stampare direttamente i simboli console . log ( un_simbolo === un_altro_simbolo ); //false, sempre console . log ( un_simbolo ); //ERROR GUID: Il GUID (Globally Unique Identifier, identificatore unico globale) \u00e8 un numero pseudo-casuale usato nella programmazione software, per poter distinguere vari oggetti. Il tipo pi\u00f9 noto di GUID \u00e8 l'utilizzo di Microsoft dell'UUID, ideato dalla Open Software Foundation, ma vi sono anche altri usi, come quello all'interno di XML. Fonte: https://it.wikipedia.org/wiki/GUID Vediamo l'utilizzo di un Symbol come identificatore di una propriet\u00e0 di un oggetto let oggetto = { colore : \"giallo\" , peso : 21 , } //creo un nuovo simbolo let check = Symbol (); //aggiungo la property \"check\" \u00e8 un valore \"OK\" oggetto [ check ] = \"OK\" ; console . log ( oggetto [ check ]); //OK La property aggiunta con Symbol \u00e8 nascosta.. let oggetto = { colore : \"giallo\" , peso : 21 , scheda : function () { let s = \"\" ; //Si traduce in: per ogni property presente in questo oggetto.. //Itera sulle property tranne su \"scheda\" //E le concatena in una stringa s = \"colore peso\" for ( x in this ){ if ( x !== \"scheda\" ){ s += x + \" \" ; } } return s ; } } //Posso assegnare un'etichetta al Symbol let check = Symbol ( \"il check\" ); oggetto [ check ] = \"OK\" ; console . log ( oggetto [ check ]); //Una property aggiunta con Symbol \u00e8 nascosta. //Utilizzo il metodo \"scheda\" per stampare tutte le property. //Vedremo che la property \"check\" non apparir\u00e0 console . log ( oggetto . scheda () ); //colore peso //Notare la differenza con la seguente propery aggiunta localmente //check2 \u00e8 una propriet\u00e0 locale e visibile oggetto . check2 = \"YES\" ; console . log ( oggetto . scheda () ); //colore peso check2 Posso generare un metodo attraverso Symbol let report = Symbol (); let oggetto2 = { prodotto : \"xyz\" , //genero il metodo con il simbolo [ report ]() { return this . prodotto ;} } console . log ( oggetto2 [ report ]()); //xyz Posso aggiungere il metodo a posteriori let report = Symbol (); let oggetto2 = { prodotto : \"xyz\" , [ report ]() { return this . prodotto ;} } //Assegno al metodo un nuovo valore oggetto2 [ report ] = function () { return \"Controllo effettuato!\" ;} console . log ( oggetto2 [ report ]()); //Controllo effettuato!","title":"Approfondimento - Symbols"},{"location":"javascript/READMEV2/#lezione-13_1","text":"","title":"Lezione 13"},{"location":"javascript/READMEV2/#approfondimento-iterablesiterator","text":"Un oggetto \u00e8 un iterator quando sa come accedere agli elementi di una collezione uno per volta, conservando l'informazione sulla sua posizione corrente nella sequenza. In Javascript un iterator \u00e8 un oggetto che implementa il metodo next() , il quale ritorna l'elemento successivo della sequenza. Questo metodo ritorna un oggetto con due propriet\u00e0: done e value . Una volta che \u00e8 stato creato, un iterator pu\u00f2 essere utlizzato esplicitamente chiamando pi\u00f9 volte il metodo next() . Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Guida/Iteratori_e_generatori","title":"Approfondimento - Iterables/Iterator"},{"location":"javascript/READMEV2/#costrutto-for-of","text":"Il costrutto for...of crea un ciclo con gli oggetti iterabili (inclusi Array, Map, Set, String, TypedArray, argomenti di oggetti e cos\u00ec via), iterando le istruzioni per ogni valore di ogni propriet\u00e0. for ( elem of collection ) { /*CODE*/ }; Vediamo un esempio: let s = \"ciao\" ; //ciclo tradizionale //for (let i=0; i<s.length; i++) console.log(s[i]); //ciclo che sfrutta un iteratore e il for ... of for ( carattere of s ) console . log ( carattere ); Dietro il meccanismo di un costrutto cos\u00ec potente c'\u00e8 il concetto di Iterables/Iterator e Symbol . Se un oggetto \u00e8 iterabile avr\u00e0 un iteratore. A tale iteratore \u00e8 applicabile il metodo next() che restituisce l'elemento successivo della lista degli elementi. Tale elemento \u00e8 un oggetto con due property: done e value . La property done \u00e8 un boolean che indica se siamo arrivati in fondo alla lista degli elementi iterabili mentre la property value restituisce il valore dell'elemento let s = \"ciao\" ; for ( carattere of s ) console . log ( carattere ); let iteratore = s [ Symbol . iterator ](); cosnole . log ( typeof ( s [ Symbol . iterator ]) ); //function cosnole . log ( typeof ( iteratore ) ); //Object. Questo \u00e8 l'oggetto iteratore //l'iteratore \u00e8 un oggetto formato da due sotto elementi //done -> restituisce true se \u00e8 l'ultimo elemento della lista //value -> rappresenta il valore dell'elemento estratto let elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //c, la prima lettera di \"ciao\" //Se continuiamo con next(), passo all'elemento successivo.. elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //i elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //a elemento = iteratore . next (); console . log ( elemento . done ); //false console . log ( elemento . value ); //o elemento = iteratore . next (); console . log ( elemento . done ); //true console . log ( elemento . value ); //undefined","title":"Costrutto for - of"},{"location":"javascript/READMEV2/#lezione-14_1","text":"","title":"Lezione 14"},{"location":"javascript/READMEV2/#approfondimento-funzioni-generatrici","text":"I generatori sono funzioni dalle quali \u00e8 possibile uscire e poi rientrarvi in un secondo momento. Il loro contesto (binding delle variabili) verr\u00e0 salvato all'uscita per quando vi entrer\u00e0 successivamente. La chiamata ad un generatore non viene eseguita immediatamente; la funzione ritorner\u00e0 invece un oggetto iterator . Quando il metodo next() dell'iteratore viene chiamato, il corpo del generatore viene eseguito fino alla prima espressione yield , la quale specifica quale espressione ritornare dall'iteratore oppure, con l'espressione yield , delegare questo valore ad un'altra funzione generatrice. Il metodo next() restituisce un oggetto con propriet\u00e0 value contenente il valore da restituito all'iteratore ed una propriet\u00e0 done che contiene un valore di tipo boolean per indicare se il generatore ha restituito l'ultimo valore. Chiamando il metodo next() con un argomento far\u00e0 riprendere l'esecuzione della funzione generatrice, sostituendo l'istruzione yield in cui l'esecuzione era stata fermata con l'argomento della funzione next() . Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Statements/function function * generatrice () { //la prima volta \u00e8 in attesa ... //che venga chiamato il metodo next() sull'oggetto restituito let n = 10 ; console . log ( n ); yield ; //genera n += 1 ; console . log ( n ); } let obj = generatrice (); //non succede niente. Siamo in attesa di invocare next() obj . next (); //10, si ferma a yield e ritorna ma lo stato dei dati \u00e8 memorizzato obj . next (); //11 obj . next (); // Vediamo un esempio pi\u00f9 interessante: function * generatrice () { let n = 0 ; while ( true ){ n ++ ; console . log ( n ); yield ; } } let obj = generatrice (); obj . next (); //1 obj . next (); //2 obj . next (); //3 yield \u00e8 il \"ritorno\" della funzione generatrice e restituisce un oggetto iterator , un oggetto formato quindi da due property value e done function * generatrice () { let n = 0 ; while ( true ){ n ++ ; yield n ; } } let obj = generatrice (); console . log ( obj . next (). value ); //1 console . log ( obj . next (). value ); //2 console . log ( obj . next (). value ); //3","title":"Approfondimento - Funzioni Generatrici"},{"location":"javascript/READMEV2/#lezione-15_1","text":"","title":"Lezione 15"},{"location":"javascript/READMEV2/#approfondimento-esempio-for-of-custom","text":"Dopo l'introduzione di Iterator/Iterables e di funzioni generatrici \u00e8 possibile costruire per una classe personale un metodo (for..of) personalizzabile class miaCollezione { //la classe contiene un array constructor () { this . items = []; } //posso aggiungere valori tramite il metodo \"add\" add ( value ) { this . items . push ( value ) } //questo definisce un metodo per il for - of * [ Symbol . iterator ] () { for ( let key in this . items ) { //Se la lunghezza dell'array \u00e8 maggiore di 4, restituisce l'array if ( this . items [ key ]. length > 4 ) yield this . items [ key ]; } } } let o = new miaCollezione (); o . add ( \"rossi\" ); o . add ( \"Bob\" ); o . add ( \"Gialli\" ); //L'elemento Bob non verr\u00e0 stampato perch\u00e8 ha 3 elementi for ( x of o ) { console . log ( x ); } /* rossi Gialli */ Posso aggiungere anche aggiungere una funzione generatrice come metodo per iterare sugli elementi sfruttando il costrutto while e come terminatore del ciclo la property done class miaCollezione { //la classe contiene in realt\u00e0 un array constructor () { this . items = []; } //posso aggiungere valori tramite il metodo \"add\" add ( value ){ this . items . push ( value ) } //questo definisce un metodo per il for - of * [ Symbol . iterator ] (){ for ( let key in this . items ){ //Se la lunghezza dell'array \u00e8 maggiore di 4, restituisce l'array if ( this . items [ key ]. length > 4 ) yield this . items [ key ]; } } * generatrice (){ for ( let key in this . items ){ yield this . items [ key ]; } } } let o = new miaCollezione (); o . add ( \"rossi\" ); o . add ( \"Bobyna\" ); o . add ( \"Gialli\" ); let iterator = o . generatrice (); //itero \"a mano\" tramite la funzione mia generatrice. //E' esattamente il (for.. of ) //Nota < (elemento=iterator.next()).done > equivale a: //elemento = iterator.next() //elemento.done while ( ! ( elemento = iterator . next ()). done ) cosnole . log ( elemento . value );","title":"Approfondimento - Esempio (For .. of) custom"},{"location":"javascript/READMEV2/#lezione-16_1","text":"","title":"Lezione 16"},{"location":"javascript/READMEV2/#destructuring","text":"La sintassi di assegnamento di destrutturazione \u00e8 un'espressione JavaScript che rende possibile estrarre informazioni da array o oggetti in variabili distinte. Le espressioni letterali degli oggetti e degli array forniscono un modo facile per creare ad hoc pacchetti di data. Fonte: https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment let prodotto = { codice : \"BPX001\" , categoria : \"alimentari\" , prezzo : 1.25 }; //FORMA ABBREVIATA //i valori delle property \"codice\" e \"prezzo\" sono memorizzate in due variabili di nome \"codice\", \"prezzo\" //il nome delle variabili deve coincidere con il nome della property let { codice , prezzo } = prodotto ; /* Equivale a: let codice = prodotto.codice; let prezzo = prodotto.prezzo; */ console . log ( ` ${ codice } - ${ prezzo } ` ); // BPX001 - 1.25 //FORMA ESTESA //E' possibile assegnare un nome alle variabili con l'associazione di un'etichetta let { codice : il_codice , prezzo : il_prezzo } = prodotto ; console . log ( ` ${ il_codice } - ${ il_prezzo } ` ); // BPX001 - 1.25 Il Destructuring funziona con qualsiasi collezione iterabile //il destructuring funziona con gli array let temperature = [ 1 , 3 , 6 , 9 , 8 , 5 , 4 , - 1 ] let [ h00 , h3 , h6 , h9 , h12 , h15 , h18 , h21 ] = temperature ; console . log ( `Temp. alle h06:00 ${ h6 } \u2103; alle h18:00 ${ h18 } \u2103` ); // Temp. alle h06:00 6\u2103; alle h18:00 $4\u2103 Posso utilizzare il destructuring per il ritorno di variabili multiple in una funzione function min_max ( vettore ) { let pos_min = 0 ; let pos_max = 0 ; //immaginiamo qui l`algoritmo che determina le //posizioni dell`elemento minimo e massimo pos_min = 3 ; pos_max = 7 ; return [ pos_min , pos_max ]; } let temperature = [ 1 , 3 , 6 , 9 , 8 , 5 , 4 , - 1 ] let [ h00 , h3 , h6 , h9 , h12 , h15 , h18 , h21 ] = temperature ; console . log ( `Temp. alle h06:00 ${ h6 } \u2103; alle h18:00 ${ h18 } \u2103` ); //Temp. alle h06:00 6\u2103; alle h18:00 4\u2103 //------------------------------------------------------------------------- let [ pos_temp_min , pos_temp_max ] = min_max ( temperature ); console . log ( `Temperatura minima alle ${ 3 * pos_temp_min } ` ); //Temperatura minima alle 9 console . log ( `Temperatura massima alle ${ 3 * pos_temp_max } ` ); //Temperatura massima alle 21 Si pu\u00f2 scavare anche dentro oggetti senza esagerare troppo let libro = { autore : { cognome : \"Alessandro\" , nome : \"Manzoni\" }, titolo : \"I promessi sposi\" , nato_a : { nome : \"Milano\" , nazione : \"Italia\" } }; let { autore : { cognome , nome }, titolo } = libro ; console . log ( cognome ); //Alessandro console . log ( nome ); //Manzoni console . log ( titolo ); //I promessi sposi let { titolo : t2 } = libro ; console . log ( t2 ); ////I promessi sposi let s = \"\" ; //questa sintassi \u00e8 per l'assegnamento ({ titolo : s } = libro ); Con gli array questo metodo dell'assegnamento \u00e8 pi\u00f9 semplice let temperature = [ 1 , 3 , 6 , 9 , 8 , 5 , 4 , - 1 ] let [ h00 , h3 , h6 , h9 , h12 , h15 , h18 , h21 ] = temperature ; console . log ( `Temp. alle h06:00 ${ h6 } \u2103; alle h18:00 ${ h18 } \u2103` ); //------------------------------------------------------------------------- let t = 0 ; [ t ] = temperature ; console . log ( t ); //1, ottengo la temperatura alla prima posizione //Estraggo il 4 elemento [,,, t ] = temperature ; //temperature[3] console . log ( t ); //9 let v = [ 1 , 2 ]; let [,, z = 0 ] = v ; console . log ( z ); //0 // in questo caso con l'operatore \"...\" (rest) creo un sottoarray con le sole temperature dalle 9 in poi let [,,,... dalle_9_in_poi ] = temperature for ( temp of dalle_9_in_poi ) console . log ( temp ); //9 8 5 4 -1","title":"Destructuring"},{"location":"javascript/READMEV2/#lezione-17_1","text":"","title":"Lezione 17"},{"location":"javascript/READMEV2/#map-object","text":"L'oggetto Map \u00e8 una collezione di elementi chiave / valore . Qualsiasi valore (sia oggetti che valori primitivi) pu\u00f2 essere utilizzato come chiave o come valore. Qualche metodo applicabile all'oggetto Map : set(key, value) : Aggiunge un elemento all'oggetto Map specificando la chiave di accesso e il valore has(key) : Ritorna un boolean true/false in base al risultato della ricerca di un elemento con una particolare key . get(key) : Ritorna il valore corrispondente alla chiave key delete(key) : Elimina l'elemento con la chiave key clear() : Elimina tutto il contenuto dalla mappa Propriet\u00e0 dell'oggetto Map : size : Ritorna il numero di elementi in una mappa //Creo un nuovo oggeto Map vuoto let capitali = new Map (); //Il metodo set(key, value) aggiunge elementi indicando una coppia chiave valore capitali . set ( \"Italia\" , \"Roma\" ); capitali . set ( \"Francia\" , \"Parigi\" ); console . log ( capitali ); //Map(2) {\"Italia\" => \"Roma\", \"Francia\" => \"Parigi\"} console . log ( capitali . size ); //2 //Il punto di forza di Map \u00e8 che posso ricercare certi valori attraverso la Key nazione_richiesta = prompt ( \"Quale nazione?\" ); //Francia if ( capitali . has ( nazione_richiesta ) ){ console . log ( `La capitale \u00e8 ${ capitali . get ( nazione_richiesta ) } ` ); } //La capitale \u00e8 Parigi else { console . log ( \"Nazione non trovata\" ); } capitali . clear (); console . log ( capitali ); //Map(0) {} Posso aggiungere diversi elementi con la notazione ad array, anzi direi a Matrice visto che ogni elemento \u00e8 formato da una coppia chiave/valore //Fornisco al costruttore di Map() come parametro un oggetto iterabile let capitali = new Map ([ [ \"Italia\" , \"Roma\" ], [ \"Francia\" , \"Parigi\" ], [ \"Inghilterra\" , \"Londra\" ] ]); nazione_richiesta = prompt ( \"Quale nazione vuoi eliminare?\" ); //Se nazione_richiesta \u00e8 tra quelle specificate nell'oggetto <capitali> la eliminer\u00e0 if ( capitali . has ( nazione_richiesta ) ){ capitali . delete ( nazione_richiesta ); console . log ( ` ${ nazione_richiesta } eliminata ...` ); } else { console . log ( \"Nazione non trovata\" ); } Posso inserire qualsiasi tipo di elemento in un oggetto di tipo Map. //Creo un oggetto di tipo Map e identificativo \"listino\" vuoto let listino = new Map (); //Creo un oggetto che utilizzer\u00f2 come chiave dell'oggetto listino let prodotto = { codice : 100 , descrizione : { breve : \"bla bla\" , lunga : \"bla bla bla bla\" } } //Creo un oggetto che utilizzer\u00e0\u00ec\u00f2 come valore dell'oggetto listino let prezzo = { costo_base : 145 , sconto : 5 , metodi_pagamento : { cash : true , carta : true , paypal : false } } //Aggiungo un elemento all'oggetto listino. //Prodotto e prezzo sono due oggetti diversi listino . set ( prodotto , prezzo ); if ( listino . has ( prodotto ) ) { valore = listino . get ( prodotto ); console . log ( valore . costo_base ); //145 if ( valore . metodi_pagamento . carta ){ console . log ( \"Pagabile con carta di credito\" ); //Pagabile con carta di credito } }","title":"Map Object"},{"location":"javascript/READMEV2/#iterazione-map-object","text":"Il metodo key() restituisce un iteratore sulle chiavi let capitali = new Map ([ [ \"Italia\" , \"Roma\" ], [ \"Francia\" , \"Parigi\" ], [ \"Inghilterra\" , \"Londra\" ] ]); //iterare sugli elementi for ( let elemento of capitali ) { console . log ( elemento ); } //elemento[0]=nazione, [1]=capitale /* [\"Italia\", \"Roma\"] [\"Francia\", \"Parigi\"] [\"Inghilterra\", \"Londra\"] */ //iterare sulle chiavi //key() restituisce un iteratore sulle chiavi for ( let chiave of capitali . keys ()) { console . log ( chiave ); } /* Italia Francia Inghilterra */ Esempio di iterazione applicando il destructuring: let listino = new Map (); //Chiave let prodotto = { codice : 100 , descrizione : { breve : \"bla bla\" , lunga : \"bla bla bla bla\" } } //Valore let prezzo = { costo_base : 145 , sconto : 5 , metodi_pagamento : { cash : true , carta : true , paypal : false } } listino . set ( prodotto , prezzo ); //iterare sugli elementi, applico il destructuring for ( let [ chiave , valore ] of listino ) //listino.entries()) { console . log ( chiave ); } //Restituisce prodotto /* {codice: 100, descrizione: {\u2026}} codice: 100 descrizione: {breve: \"bla bla\", lunga: \"bla bla bla bla\"} */","title":"Iterazione Map Object"},{"location":"javascript/READMEV2/#lezione-18_1","text":"","title":"Lezione 18"},{"location":"javascript/READMEV2/#set","text":"L'oggetto Set permette di memorizzare valori unici di qualunque tipo, che siano valori primitivi o riferimenti ad oggetti. Gli oggetti Set sono collezioni di valori, quindi \u00e8 possibile iterare i valori nel loro ordine di inserimento. Un valore in un Set pu\u00f2 occorrere solo una volta; \u00e8 quindi unico nella collezione. A differenza di un semplice array presenta le seguenti differenze: Un oggetto Set rifiuta elementi duplicati. E' utile quindi per raggruppare elementi in una lista univoca Non consente un accesso indicizzato cio\u00e8 per posizione come negli array Non si applicano i metodi applicabili agli array ma metodi simili all'oggetto Map Vale la property size e i metodi has() e clear() , add() simili per l'oggetto Map let nazioni = new Set ([ \"Italia\" , \"Francia\" , \"Inghilterra\" ]); nazioni . add ( \"Ungheria\" ); //Metodo per aggiungere un elemento //La lista degli elementi rimane inalterata poich\u00e8 l'elemento <Francia> \u00e8 gi\u00e0 presente nazioni . add ( \"Francia\" ); for ( let nazione of nazioni ) { console . log ( nazione );} /* Italia Francia Inghilterra Ungheria */","title":"Set"},{"location":"javascript/READMEV2/#conversione-di-un-oggetto-map-set-in-un-array","text":"Per la conversione di un Oggetto Map / Set in un array \u00e8 possibile sfruttare l'operatore \"...\" (rest). Questo operatore in generale si applica ad ogni elemento iterabile e restituisce un array di elementi derivati dall'iterazione sull'iteratore selezionato let nazioni = new Set ([ \"Italia\" , \"Francia\" , \"Inghilterra\" ]); nazioni . add ( \"Ungheria\" ); //Metodo per aggiungere un elemento //l'operatore \"...\" \u00e8 anche detto spread operator //In questo caso andr\u00e0 ad iterare ogni elemento di <nazioni> aggiungendolo all'array <vNazioni> let arrayNazioni = [... nazioni ]; //arrayNazioni adesso \u00e8 un array ottenuto da un oggetto Set console . log ( arrayNazioni [ 2 ]);","title":"Conversione di un Oggetto Map / Set in un Array"},{"location":"javascript/READMEV2/#lezione-19_1","text":"","title":"Lezione 19"},{"location":"javascript/READMEV2/#dom-manipulation","text":"Quando programmi pagine web e app, una delle cose pi\u00f9 comuni che vorrai fare \u00e8 manipolare in qualche modo la struttura del documento. Questo di solito viene fatto utilizzando il Document Object Model (DOM), un insieme di API per il controllo dell'HTML e delle informazioni di stile che fa un uso intenso dell'oggetto Document. In questo articolo vedremo come utilizzare il DOM in dettaglio, insieme ad altre API interessanti che possono alterare il tuo ambiente in modi interessanti. I browser web sono software molto complicati con molte parti mobili, molte delle quali non possono essere controllate o manipolate da uno sviluppatore web che utilizza JavaScript. Potresti pensare che tali limitazioni siano una brutta cosa, ma i browser sono bloccati per buone ragioni, principalmente incentrate sulla sicurezza. Immagina se un sito Web potesse accedere alle tue password memorizzate o ad altre informazioni sensibili e accedere ai siti Web come se fossi tu.. Nonostante i limiti, le API Web ci danno ancora accesso a molte funzionalit\u00e0 che ci consentono di fare molte cose con le pagine web. Window \u00e8 la scheda del browser in cui viene caricata una pagina web; questo \u00e8 rappresentato in JavaScript dall'oggetto Window . Usando i metodi disponibili su questo oggetto puoi fare cose come restituire le dimensioni della finestra (vedi Window.innerWidth e Window.innerHeight ), manipolare il documento caricato in quella finestra, memorizzare i dati specifici di quel documento sul lato client (ad esempio usando un database locale o un altro meccanismo di archiviazione), collegare un gestore di eventi alla finestra corrente e altro ancora. Il navigatore rappresenta lo stato e l'identit\u00e0 del browser (ovvero lo user-agent) cos\u00ec come esiste sul web. In JavaScript, questo \u00e8 rappresentato dall'oggetto Navigator . Puoi utilizzare questo oggetto per recuperare elementi come la lingua preferita dell'utente, un flusso multimediale dalla webcam dell'utente, ecc. Il documento (rappresentato dal DOM nei browser) \u00e8 la pagina effettiva caricata nella finestra ed \u00e8 rappresentato in JavaScript dall'oggetto Document . \u00c8 possibile utilizzare questo oggetto per restituire e manipolare le informazioni sull'HTML e il CSS che compongono il documento, ad esempio ottenere un riferimento a un elemento nel DOM , modificarne il contenuto del testo, applicarvi nuovi stili, creare nuovi elementi e aggiungerli a l'elemento corrente come figli, o addirittura eliminarlo del tutto. In questo articolo ci concentreremo principalmente sulla manipolazione del DOM. DOM - Document Object Model Il documento attualmente caricato in ciascuna delle schede del browser \u00e8 rappresentato da un modello di oggetti (document object model). E' rappresentato tramita una \"struttura ad albero\" creata dal browser che consente di accedere facilmente alla struttura HTML dai linguaggi di programmazione. Fonte: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents Per la manipolazione del DOM ci torna utile il paradigma di programmazione orientato agli oggetti di Javascript. Infatti il DOM non \u00e8 altro che un enorme oggetto con diverse property e metodi console . log ( document . all ); //stampa tutti i nodi all'interno della pagina htmlconsole.log(document.body); console . log ( document . head ); //Stampa l'oggetto <head> console . log ( document . body ); //Stampa l'oggetto <body>","title":"Dom Manipulation"},{"location":"javascript/READMEV2/#lezione-20_1","text":"","title":"Lezione 20"},{"location":"javascript/READMEV2/#dom-selettori","text":"Per manipolare un elemento all'interno del DOM, \u00e8 necessario prima selezionarlo e memorizzare un riferimento ad esso all'interno di una variabile. In questo esempio selezioneremo l'elemento h1 e successivamente applicheremo dello style all'elemento, colorandolo di rosso <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > DOM: Document Object Model </ h1 > < script type = \"text/javascript\" src = \"jquery-3.5.1.min.js\" ></ script > < script > let h1 = document . querySelector ( \"h1\" ); h1 . style . color = 'red' ; </ script > </ body > </ html >","title":"DOM - Selettori"},{"location":"javascript/READMEV2/#metodi-di-selezione-di-elementi-html","text":"Vediamo i metodi per selezionare gli elementi in JS. - document.getElementById(myID) : Selziona tutti gli elementi con un particolare id = \"myID\" - document.getElementsByClassName(myClassName) : Selziona tutti gli elementi che appartengono a una particolare classe, class = \"myClassName\" - document.getElementsByTagName(\"tag\") : Selziona tutti gli elementi che hanno particolare \"tag\" HTML - document.querySelector(any) : Selziona la prima occorrenza dell' elemento spcecificato attraverso la classe , l' id oppure il tag . - Selezione attraverso la classe: Si usa il simbolo \".\" seguito dal nome della classe, esempio: \".myClassName\" - Selezione attraverso l'id: Si usa il simbolo \"#\" seguito dal nome della classe, esempio: \"#myID\" - Selezione attraverso il tag HTML: \"h1\" - document.querySelectorAll : Selziona tutti gli elementi spcecificati attraverso la classe , l' id oppure il tag . Valgono le stesse regole di selezione viste per il querySelector <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < h1 > La manipolazione </ h1 > < ul > < li id = \"FRIST-ELEM\" > elemento UNO </ li > < li class = \"myClass\" > elemento DUE </ li > < li class = \"myClass\" > elemento TRE </ li > </ ul > < script > document . getElementById ( \"FRIST-ELEM\" ); //Selezione di \"elemento UNO\" document . getElementsByClassName ( \"myClass\" ); //Selezione di \"elemento DUE\", \"elemento TRE\" document . getElementsByClassName ( \"myClass\" )[ 0 ]; //Selezione di \"elemento DUE\" document . getElementsByTagName ( \"h1\" ); //Selezione di \"DOM: Document Object Manipulation\", \"La manipolazione\" // document.querySelector document . querySelector ( \".myClass\" ); //Selezione di \"elemento DUE\" document . querySelector ( \"#FRIST-ELEM\" ); //Selezione di \"elemento UNO\" document . querySelector ( \"h1\" ); //Selezione di \"DOM: Document Object Manipulation\" // document.querySelectorAll document . querySelectorAll ( \".myClass\" ); //Selezione di \"elemento DUE\", \"elemento TRE\" document . querySelectorAll ( \"#FRIST-ELEM\" ); //Selezione di \"elemento UNO\" document . querySelectorAll ( \"h1\" ); ////Selezione di \"DOM: Document Object Manipulation\", \"La manipolazione\" //last-child & nth-child(i) document . querySelector ( 'li:last-child' ); //li:last-child seleziona l'ultimo elemento <li> document . querySelector ( 'li:nth-child(2)' ). style . color = 'brown' ; //li:nth-child(i) seleziona l'i-esimo elemento <li> </ script > </ body > </ html > E' possibile utilizzare l'operatore [index] per indicizzare la collezione di elementi HTML selezionati. Nell'esempio di sopra infatti ho selezionato soltanto \"elemento DUE\" utilizzando document.getElementsByClassName(\"myClass\")[0] . Quando ci sono pi\u00f9 elementi selezionati vengono create delle collezioni di oggetti. Nel caso si utilizzi querySelectorAll verr\u00e0 restituita una collezione NodeList che dal punto di vista di Javascript \u00e8 un array. Se tuttavia utilizzassi come selettore ad esempio getElementsByTagName verrebbe restituito un HTML Collection che non \u00e8 un array e se volessi usarlo come tale sarebbe necessaria una conversione let myLI = document . querySelectorAll ( \"li\" )[ 0 ]; /* myLI <li id=\u200b\"FRIST-ELEM\">\u200b\u2026\u200b</li>\u200b */ console . log ( typeof myLI ); //object //NODE LIST let myLIAll = document . querySelectorAll ( \"li\" ); console . log ( myLIAll ); //\u00e8 una collezione \"NodeList\", un array /* NodeList(3) [li#FRIST-ELEM, li.myClass, li.myClass] 0: li#FRIST-ELEM 1: li.myClass 2: li.myClass length: 3 __proto__: NodeList */ //Essendo un array posso applicare tutti i metodi applicabili agli array myLIAll . forEach (( elem , index ) => { //il metodo \"textContent\" assegna un valore testuale all'elemento, cambia il testo elem . textContent = 'nuovo testo in li' ; }); //HTML COLLECTION let MyH1All = document . getElementsByTagName ( \"h1\" ); console . log ( MyH1All ); //HTMLCollection(2) [h1, h1] -> NON E' UN ARRAY, Attenzione!! //Posso convertirlo in array utilizzando \"Array.from\" const listaArray = Array . from ( MyH1All ); console . log ( listaArray ); /* (2) [h1, h1] 0: h1 1: h1 length: 2 */ //A questo punto posso utilizzare tutte le propriet\u00e0 degli array listaArray . forEach (( elem , index ) => { elem . style . color = 'red' ; }); //Posso usare anche un ciclo iterativo standard for ( let i = 0 ; i < listaArray . length ; i += 2 ) { //Cambia il colore del background dell'elemento <h1> in giallo listaArray [ i ]. style . background = 'yellow' ; }","title":"Metodi di selezione di elementi html"},{"location":"javascript/READMEV2/#lezione-21_1","text":"","title":"Lezione 21"},{"location":"javascript/READMEV2/#dom-child-e-parent","text":"Data la struttura ad albero del DOM \u00e8 semplificato l'accesso ad elementi figli o padri di un dato elemento children : Accede agli elementi figli parentElement : Accede all'elemento padre <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < h1 > La manipolazione </ h1 > < ul > < li id = \"FRIST-ELEM\" > elemento UNO </ li > < li class = \"myClass\" > elemento DUE </ li > < li class = \"myClass\" > elemento TRE </ li > </ ul > < script > const ul = document . querySelector ( 'ul' ); //rappresenta tutti gli <li> contenuti come HTML collection console . log ( ul . children ); //HTMLCollection(3) [li#FRIST-ELEM, li.myClass, li.myClass, FRIST-ELEM: li#FRIST-ELEM] console . log ( ul . parentElement ); //Seleziona l'elemento parente quindi il <body> console . log ( ul . parentElement . parentElement ); //Seleziona l'elemento <html> cio\u00e8 il \"nonno\" //Rappresenta i figli in una NodeList (ottimo) ma considera come elementi anche eventuali elementi di formatazione //Poich\u00e8 gli <li> sono rappresentati a capo, uno sotto l'altro ci sono altri 4 elementi che rappresentano l'elemento \"a capo\" console . log ( ul . childNodes ); //NodeList(7) [text, li#FRIST-ELEM, text, li.myClass, text, li.myClass, text] </ script > </ body > </ html >","title":"Dom - Child e Parent"},{"location":"javascript/READMEV2/#dom-manipolazione-dello-stile-degli-elementi-html","text":"La manipolazione statica dello stile degli elementi HTML non ha molto senso. Infatti \u00e8 possibile assegnare uno stile gi\u00e0 con CSS. Ha invece senso una manipolazione dinamica ovvero al verificarsi di un particolare evento classList permette di applicare dinamicamente una classe gi\u00e0 definita in formato CSS ma ancora non applicata a nessun elemento. Javascript funziona da ponte tra un elemento HTML e uno style CSS. E' infatti possibile aggiungere e rimuovere dinamicamente una classe da un elemento per aggiungere o rimuovere dello stile da quel dato elemento. classList.add(\"myClassName\") : Aggiunge la classe myClassName all'elemento selezionato classList.remove(\"myClassName\") : Rimuove la classe myClassName all'elemento selezionato classList.toggle(\"myClassName\") : Esegue il toggle della classe myClassName all'elemento selezionato, aggiungendola se non \u00e8 attiva e rimuovendola se \u00e8 attiva. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeFirstLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < h1 > La manipolazione </ h1 > < ul > < li id = \"FRIST-ELEM\" > elemento UNO </ li > < li class = \"myClass\" > elemento DUE </ li > < li class = \"myClass\" > elemento TRE </ li > </ ul > < script > var tag = document . getElementById ( \"FRIST-ELEM\" ); //Aggiungo la classe <classeFirstLi> all'elemento html associato a <tag>. //Aggiungo quindi anche tutte le proprit\u00e0 annesse alla classe <classeFirstLi>. tag . classList . add ( \"classeFirstLi\" ); //Applico lo stile all'elemento \"elemento UNO\" //Rimuovo la classe <classeFirstLi> tag . classList . remove ( \"classeFirstLi\" ); //Rimuovo lo stile all'elemento \"elemento UNO\" //Toggle della classe <classeFirstLi>. // Rimuovo la classe <classeFirstLi> se \u00e8 attiva, la aggiungo se non \u00e8 attiva tag . classList . toggle ( \"classeFirstLi\" ); //Applico lo stile all'elemento \"elemento UNO\" tag . classList . toggle ( \"classeFirstLi\" ); //Rimuovo lo stile all'elemento \"elemento UNO\" tag . classList . toggle ( \"classeFirstLi\" ); //Applico lo stile all'elemento \"elemento UNO\" </ script > </ body > </ html >","title":"DOM - Manipolazione dello stile degli elementi html"},{"location":"javascript/READMEV2/#lezione-22_1","text":"","title":"Lezione 22"},{"location":"javascript/READMEV2/#dom-manipolazione-del-testo-degli-elementi-html","text":"textContent La propriet\u00e0 textContent dell'interfaccia Node rappresenta il contenuto del testo di un nodo e dei suoi discendenti innerText La propriet\u00e0 innerText dell'interfaccia HTMLElement rappresenta il contenuto di testo \"renderizzato\" di un nodo e dei suoi discendenti. Come getter, approssima il testo che l'utente otterrebbe se evidenziasse il contenuto dell'elemento con il cursore e poi lo copiasse negli appunti. Nota: innerText \u00e8 facilmente confuso con Node.textContent , ma ci sono differenze importanti tra i due. Fondamentalmente, innerText \u00e8 a conoscenza dell'aspetto renderizzato del testo, mentre textContent non lo \u00e8. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeFirstLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < p > Lorem ipsum, dolor sit amet consectetur adipisicing elit. < strong > Doloremque, modi? </ strong ></ p > < script > var p = document . querySelector ( \"p\" ); //<textContent> //<textContent> restituisce una stringa del testo contenuto dell'elemento // convertendo anche il contenuto di eventuali elementi figli in puro testo console . log ( p . textContent ); //\"Lorem ipsum, dolor sit amet consectetur adipisicing elit. Doloremque, modi?\" //E' possibile cambiare la stringa del tag selezionato semplicemente con l'assegnazione p . textContent = \"lorem ps htigh manulip ase travit\" ; console . log ( p . textContent ); //\"lorem ps htigh manulip ase travit\" //<innerHTML> //<innerHTML> restituisce l'elemento HTML mantenendo la formattazione HTML console . log ( p . innerHTML ); //\"Lorem ipsum, dolor sit amet consectetur adipisicing elit. <strong>Doloremque, modi?</strong>\" //Con <innerHTML> \u00e8 possibile inserire tag HTML p . innerHTML = \"<strong>ciao</strong>\" ; console . log ( p . innerHTML ); //<strong>ciao</strong>\" </ script > </ body > </ html >","title":"DOM - Manipolazione del testo degli elementi html"},{"location":"javascript/READMEV2/#dom-manipolazione-degli-attributi-html","text":"getAttribute e setAttribute sono metodi di lettura e scrittura di attributi di elementi html. getAttribute ( \"attribute\" ); //ritorna il valore dell'attributo \"attribute\" setAttribute ( \"attribute\" , \"value\" ); //Assegna il valore \"value\" all'attributo \"attribute\" Nell'esempio seguente cambier\u00f2 l'immagine di un elemento <img> e il link di un elemento <a> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeFirstLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < div > < img src = \"https://www.corriere.it/methode_image/2020/04/09/Spettacoli/Foto%20Spettacoli%20-%20Trattate/MILANO_20100328_CORSERA_43_0_0-k9PF-U3180411917161aAH-656x492@Corriere-Web-Sezioni.jpg\" > </ div > < div > < a href = \"https://www.google.com/maps\" > link </ a > </ div > < script > //Modifico l'immagine modificandone l'attributo <src> //Seleziono l'elemento \"img\" var img = document . querySelector ( \"img\" ); //<getAttribute(\"attribute\")> restituisce il valore dell'attributo passato come argomento. img . getAttribute ( \"src\" ); // \"https://www.corriere.it/methode_image/2020/04/09/Spettacoli/Foto%20Spettacoli%20-%20Trattate/MILANO_20100328_CORSERA_43_0_0-k9PF-U3180411917161aAH-656x492@Corriere-Web-Sezioni.jpg\" //<setAttribute(\"attribute\", \"value\")> consente di cambiare il valore di un attributo img . setAttribute ( \"src\" , \"https://www.pensalibero.it/wp-content/uploads/2010/02/chopin1.jpg\" ); //ho cambiato l'immagine img . getAttribute ( \"src\" ); //https://www.pensalibero.it/wp-content/uploads/2010/02/chopin1.jpg //Modifico il link, modificandone l'attributo <href> //Seleziono l'elemento \"a\" var a = document . querySelector ( \"a\" ); //<getAttribute(\"attribute\")> restituisce il valore dell'attributo passato come argomento. a . getAttribute ( \"href\" ); //\"https://www.google.com/maps\" //<setAttribute(\"attribute\", \"value\")> consente di cambiare il valore di un attributo a . setAttribute ( \"href\" , \"https://mail.google.com\" ); //Ho cambiato il link a . getAttribute ( \"href\" ); //\"https://mail.google.com\" </ script > </ body > </ html >","title":"DOM - Manipolazione degli attributi html"},{"location":"javascript/READMEV2/#lezione-23_1","text":"","title":"Lezione 23"},{"location":"javascript/READMEV2/#dom-creazione-di-un-elemento","text":"In un documento HTML, il metodo document.createElement() crea l'elemento HTML specificato da tagName o un HTMLUnknownElement se tagName non viene riconosciuto. Nell'esempio successivo creeremo un elemento <li> e lo piazzeremo in coda ad una <ul> gi\u00e0 esistente. Faremo uso anche del metodo appendChild() e del metodo createTextNode() Il metodo Node.appendChild() aggiunge un nodo alla fine dell'elenco di figli di un nodo genitore specificato. Se il figlio dato \u00e8 un riferimento a un nodo esistente nel documento, appendChild() lo sposta dalla sua posizione corrente alla nuova posizione (non \u00e8 necessario rimuovere il nodo dal suo nodo padre prima di aggiungerlo ad un altro nodo). A questo link c'\u00e8 un'importante discussione tra l'uso di createTextNode() e textContent : https://stackoverflow.com/questions/31643204/textnode-or-textcontent <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < script > //creo un elemento <li> vuoto const myLi = document . createElement ( 'li' ); console . log ( myLi ); //<li></li> //Inserisco del testo nell'elemento <li> myLi . textContent = 'Elemento QUATTRO' ; console . log ( myLi ); //<li><Elemento QUATTRO/li> //Aggiungo in coda l'elemento <li> a <ul> document . querySelector ( 'ul' ). appendChild ( myLi ); //Aggiungo una classe.. e lo stile annesso myLi . className = \"classeLastLi\" ; </ script > </ body > </ html >","title":"DOM - Creazione di Un elemento"},{"location":"javascript/READMEV2/#dom-rimpiazzo-di-un-elemento","text":"Il metodo Node.replaceChild () sostituisce un nodo figlio all'interno del nodo (genitore) specificato. Notare l'ordine degli argomenti idiosincratico (nuovo prima del vecchio). ChildNode.replaceWith () potrebbe essere pi\u00f9 facile da leggere e utilizzare. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < script > //Creo un nuovo <li> const nuovoLi = document . createElement ( 'li' ); //Aggiungo del testo dentro <li> nuovoLi . appendChild ( document . createTextNode ( 'nuovo li' )); // equivale a \"nuovoLi.textContent = 'nuovo li';\" //Seleziono l'elemento che voglio rimpiazzare const vecchioLi = document . getElementsByTagName ( 'li' )[ 1 ]; //Selziono l'elemento padre dell'elemento che voglio rimpiazzare */ const ul = document . querySelector ( 'ul' ); //replaceChild(new,old) permette di rimpiazzare un elemento figlio //specificando come parametri il nuovo elemento e il vecchio elemento (quello da rimpiazzare) ul . replaceChild ( nuovoLi , vecchioLi ); </ script > </ body > </ html >","title":"DOM - Rimpiazzo di un elemento"},{"location":"javascript/READMEV2/#dom-eliminazione-di-un-elemento","text":"Il metodo Node.removeChild () rimuove un nodo figlio dal DOM e restituisce il nodo rimosso. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { border : 3 px solid red ; color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < script > /** Si possono cancellare i figli attraverso il padre */ /** Seleziono il padre */ const ulParent = document . querySelector ( 'ul' ); /** Seleziono tutti gli <li> e li metto in un contenitore che sar\u00e0 un array di <li> */ const listitem = document . querySelectorAll ( 'li' ); console . log ( listitem ); ulParent . removeChild ( listitem [ 2 ]); //rimuovo \"Elemento TRE\" //Rimuove tutti gli elementi <child> //La property <firstChild> restituisce il primo elemento \"child\" e \"null\" se non ci sono elementi child while ( ulParent . firstElementChild ){ ulParent . removeChild ( ulParent . firstElementChild ); } </ script > </ body > </ html > Property firstChild : La propriet\u00e0 di sola lettura Node.firstChild restituisce il primo figlio del nodo nell'albero o null se il nodo non ha figli. Se il nodo \u00e8 un documento, restituisce il primo nodo nell'elenco dei suoi figli diretti.","title":"DOM - ELiminazione di un elemento"},{"location":"javascript/READMEV2/#lezione-24_1","text":"","title":"Lezione 24"},{"location":"javascript/READMEV2/#dom-events","text":"Vengono trasmessi eventi per notificare al codice eventi accaduti. Ogni evento \u00e8 rappresentato da un oggetto basato su un 'interfaccia Event e pu\u00f2 avere campi e / o funzioni personalizzati aggiuntivi utilizzati per ottenere ulteriori informazioni su quanto accaduto. Gli eventi possono rappresentare qualsiasi cosa, dalle interazioni utente di base alle notifiche automatiche di eventi che accadono nel modello di rendering. Alla pagina: https://developer.mozilla.org/en-US/docs/Web/Events E' possibile consultare i cos\u00ecdetti Standard Events , eventi comuni ad ogni tipo di browser definiti dalla specifica standard Web.","title":"DOM Events"},{"location":"javascript/READMEV2/#metodo-addeventlistener","text":"Il metodo EventTarget addEventListener() imposta una funzione che verr\u00e0 chiamata ogni volta che l'evento specificato viene consegnato all'elemento di destinazione. I target comuni sono Element, Document, e Window, ma la destinazione pu\u00f2 essere qualsiasi oggetto che supporti eventi (come XMLHttpRequest). addEventListener() funziona aggiungendo una funzione o un oggetto che implementa EventListener all'elenco di listener di eventi per il tipo di evento specificato sul EventTarget sul quale \u00e8 chiamato. target . addEventListener ( type , listener [, options ]); Parametri: - type : Una stringa sensibile al maiuscolo/minuscolo che rappresenta il tipo di evento da assegnare. Alcuni tipi di eventi, click , dblclick , cut , scroll , compositionstart , blur .. - listener : L'oggetto che riceve una notifica (un oggetto che implementa l'interfaccia Event) quando si verifica un evento del tipo specificato. Questo deve essere un oggetto che implementa l'interfaccia EventListener, o una funzione. Vedi Il callback del listener di eventi per i dettagli sul callback stesso. Fonte: https://developer.mozilla.org/it/docs/Web/API/Element/addEventListener#Il_callback_del_listener_di_eventi Vedremo qualche evento attraverso gli esempi: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input id = \"changeColor\" type = \"button\" value = \"OK\" > < script > var input = document . querySelector ( \"#changeColor\" ); //Seleziono il primo <li> var ulChild = document . querySelector ( \"ul\" ). firstElementChild ; //addEventListener(\"eventType\", function) //aggiunge un evento all'elemento <input>. //Al click del mouse sull'elemento <input> viene eseguita la funzione anonima //che in questo caso esegue il toggle della classe \"classeLi\" sul primo elemento <li> input . addEventListener ( \"click\" , function (){ ulChild . classList . toggle ( \"classeLi\" ); }) </ script > </ body > </ html > Vediamo un esempio pi\u00f9 interessante. In questo esempio assegneremo lo stile agli elementi <li> ogni volta che schiacceremo il tasto OK a partire dal primo elemento. Una volta che lo stile \u00e8 applicato a tutti gli elementi, schiacciando nuovamente il tasto andremo a togliere lo stile a tutti gli elementi partendo dal primo. Per applicare e togliere stile utilizzeremo classList.toggle(\"myClassName) gi\u00e0 visto qualche lezione fa. Utilizzeremo anche firstElementChild gi\u00e0 visto e nextElementSibling che restituisce l'elemento successivo a quello attualmente puntato dal figlio. nextElementSibling La propriet\u00e0 di sola lettura NonDocumentTypeChildNode.nextElementSibling restituisce l'elemento immediatamente successivo a quello specificato nell'elenco dei figli del suo genitore o null se l'elemento specificato \u00e8 l'ultimo nell'elenco. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input id = \"changeColor\" type = \"button\" value = \"OK\" > < script > var input = document . querySelector ( \"#changeColor\" ); var ulChild = document . querySelector ( \"ul\" ). firstElementChild ; input . addEventListener ( \"click\" , function (){ if ( ulChild !== null ){ ulChild . classList . toggle ( \"classeLastLi\" ); ulChild = ulChild . nextElementSibling ; } else { ulChild = document . querySelector ( \"ul\" ). firstElementChild ; ulChild . classList . toggle ( \"classeLastLi\" ); ulChild = ulChild . nextElementSibling ; } }) </ script > </ body > </ html > Non \u00e8 necessario schiacciare elementi <input type=\"button\"> . Possono essere utilizzati tutti gli elementi html. In questo esempio associeremo un evento ad ogni elemento <li> <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input id = \"changeColor\" type = \"button\" value = \"OK\" > < script > //Seleziono tutti i <li> var listaLi = document . querySelectorAll ( \"li\" ); console . log ( listaLi ); //creo un array di <li> //Itero su ogni <li> for ( var i = 0 ; i < listaLi . length ; i ++ ){ //aggiungo un evento ad ogni li. Premendo sull'elemento <li> si applicher\u00e0/toglier\u00e0 lo style definito da \"classeLastLi\" listaLi [ i ]. addEventListener ( \"click\" , function (){ this . classList . toggle ( \"classeLastLi\" ); }) } </ script > </ body > </ html > this: this in questo caso rappresenta l'elemento i-esimo a cui \u00e8 posizionato il listener cio\u00e8 listaLi[i] . Oltre alla funzione anonima, posso definire anche una funzione esterna al verificarsi di un certo evento. In questo esempio cambieremo il testo al Titolo con un testo inserito dall'utente in una casella testuale <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input type = \"text\" id = \"newTitle\" > < input id = \"changeTitle\" type = \"button\" value = \"Cambia Titolo\" > < script > var input = document . querySelector ( \"#changeTitle\" ); var h1 = document . querySelector ( \"h1\" ); function changeTitle () { testo = document . querySelector ( \"#newTitle\" ); h1 . textContent = testo . value ; } input . addEventListener ( \"click\" , changeTitle ); </ script > </ body > </ html > Nel prossimo esempio avremo una casella di testo in cui sar\u00e0 possibile inserire del testo. Facendo doppio click su un elemento qualsiasi della pagina html andr\u00e0 a cambiare il testo dell'elemento cliccato <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . classeLastLi { color : blue ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > Elemento UNO </ li > < li > Elemento DUE </ li > < li > Elemento TRE </ li > </ ul > < input type = \"text\" id = \"newTitle\" > < script > var listaLI = document . querySelectorAll ( \"li\" ); //crea un array di <li> var h1 = document . querySelector ( \"h1\" ); //seleziono <h1> function changeText () { testo = document . querySelector ( \"#newTitle\" ); this . textContent = testo . value ; this . cla } for ( let i = 0 ; i < listaLI . length ; i ++ ){ listaLI [ i ]. addEventListener ( \"dblclick\" , changeText ); } h1 . addEventListener ( \"dblclick\" , changeText ); </ script > </ body > </ html >","title":"Metodo addEventListener"},{"location":"javascript/READMEV2/#lezione-25_1","text":"","title":"Lezione 25"},{"location":"javascript/READMEV2/#prevent-default","text":"Il metodo preventDefault () dell'interfaccia Event dice al programma utente che se l'evento non viene gestito esplicitamente, la sua azione predefinita non dovrebbe essere eseguita come sarebbe normalmente. L'evento continua a propagarsi come al solito, a meno che uno dei suoi listener di eventi non chiami stopPropagation () o stopImmediatePropagation () , entrambi i quali terminano immediatamente la propagazione. Fonte: https://developer.mozilla.org/it/docs/Web/API/Event/preventDefault Consideriamo il seguente esempio. Al click di ogni link vorrei che venisse stampato per esteso il link nella casella testuale. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > li { margin : 2 px ; } input { margin : 2 px ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > < a href = \"https://www.youtube.com/\" > youtube </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://developer.mozilla.org/en-US/\" > MDN </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://www.google.com/maps\" > maps </ a >< br > < input type = \"text\" > </ li > </ ul > < script > var linkList = document . querySelectorAll ( \"a\" ); for ( let i = 0 ; i < linkList . length ; i ++ ) { linkList [ i ]. addEventListener ( \"click\" , function (){ //this rappresenta l'elemento <a> i-esimo //this.parentElement === <li> //this.parentElement.lastElementChild === <input> input = this . parentElement . lastElementChild ; input . value = this . href ; }); } </ script > </ body > </ html > Se avete provato ad eseguire il codice noterete che al click sull'elemento <a> , la pagina verr\u00e0 rendirizzata sul link corrispondente, in poche parole non funziona. Questo accade perch\u00e8 il comportamento di default di <a> tag \u00e8 quello di saltare alla pagina specificata dall'attributo href . Per inibire il comportamento di default di qualsiasi elemento si utilizza il metodo prevenDefault() applicato all'oggetto ricevuto come parametro (opzionale) dal listener. Normalmente questo oggetto viene indicato con e . Qui sotto riporto l'esempio funzionante. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > li { margin : 2 px ; } input { margin : 2 px ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < ul > < li > < a href = \"https://www.youtube.com/\" > youtube </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://developer.mozilla.org/en-US/\" > MDN </ a >< br > < input type = \"text\" > </ li > < li > < a href = \"https://www.google.com/maps\" > maps </ a >< br > < input type = \"text\" > </ li > </ ul > < script > var linkList = document . querySelectorAll ( \"a\" ); for ( let i = 0 ; i < linkList . length ; i ++ ) { linkList [ i ]. addEventListener ( \"click\" , function ( e ){ //this rappresenta l'elemento <a> i-esimo //this.parentElement === <li> //this.parentElement.lastElementChild === <input> input = this . parentElement . lastElementChild ; input . value = this . href ; e . preventDefault (); }); } </ script > </ body > </ html >","title":"Prevent Default"},{"location":"javascript/READMEV2/#che-cose-esattamente-loggetto-ricevuto-come-unico-parametro-e","text":"L'interfaccia Event (oggetto \"e\") I gestori degli eventi possono essere assegnati a vari elementi DOM. Quando un dato evento si verifica, un oggetto evento viene creato dinamicamente e passato agli event listener che permettono di gestirlo. L'interfaccia Event del DOM \u00e8 quindi accessibile dalla funzione che gestisce l'evento, alla quale viene passato un oggetto evento come primo e unico argomento ( e ). Fonte: https://developer.mozilla.org/en-US/docs/Web/API/Event //.. console . log ( e ); /** MouseEvent {isTrusted: true, screenX: 196, screenY: 208, clientX: 196, clientY: 105, \u2026} altKey: falsebubbles: truebutton: 0buttons: 0cancelBubble: falsecancelable: trueclientX: 196clientY: 105composed: truectrlKey: falsecurrentTarget: nulldefaultPrevented: falsedetail: 1eventPhase: 0fromElement: nullisTrusted: truelayerX: 196layerY: 105metaKey: falsemovementX: 0movementY: 0offsetX: 149offsetY: 12pageX: 196pageY: 105path: (8) [a, li#ciao.myClass, ul, div, body, html, document, Window]relatedTarget: nullreturnValue: truescreenX: 196screenY: 208shiftKey: falsesourceCapabilities: InputDeviceCapabilities {firesTouchEvents: false}srcElement: atarget: atimeStamp: 125025.42499999981toElement: atype: \"click\"view: Window {window: Window, self: Window, document: document, name: \"\", location: Location, \u2026}which: 1x: 196y: 105__proto__: MouseEvent */ L'oggetto \"Event\" fornisce un sacco di informazioni sulla natura dell'evento scatenato. Al sito: https://developer.mozilla.org/it/docs/Web/API/Event \u00e8 possibile visionare ogni propriet\u00e0 e ogni metodo dell'oggetto Event (e)","title":"Che cos'\u00e8 esattamente l'oggetto ricevuto come unico parametro \"e\"?"},{"location":"javascript/READMEV2/#lezione-26_1","text":"","title":"Lezione 26"},{"location":"javascript/READMEV2/#approfondimento-type-event","text":"Vediamo adesso un'insieme di eventi typeEvent mouse/tastiera tra i pi\u00f9 usati. Ricordo che typeEvent \u00e8 il primo parametro del metodo addEventListener() La lista completa la troviamo al link: https://developer.mozilla.org/it/docs/Web/API/Element HTMLelement . addEventListener ( 'typeEvent' , function (){ //code }); Eventi mouse mousedown : Scatta l'evento al click del mouse sull'elemento mouseup : Scatta l'evento al rilascio del click del mouse sull'elemento mouseover : Scatta l'evento passando sopra l'elemento con il mouse mouseout : Scatta l'evento non appena esco dal campo dall'elemento con il mouse mousemove : Scatta l'evento ogni volta che mi muovo all'interno dell'elemento con il mouse Nell'esempio successivo, utilizzer\u00f2 gli eventi mousemove , mouseout e le propriet\u00e0 offsetX , offsetY dell'oggetto Event passato come argomento al listener utilizzate per restituire la posizione X/Y dell'evento scatenato. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . colorRed { color : red ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < div > < textarea id = \"textAreaEvent\" cols = \"60\" rows = \"30\" > Muovi il mouse all'interno di quest'area </ textarea > < div > < table > < tr > < td > Pos-x: </ td > < td >< input id = \"pos-X\" type = \"text\" ></ td > </ tr > < tr > < td > Pos-y: </ td > < td >< input id = \"pos-Y\" type = \"text\" ></ td > </ tr > </ table > </ div > </ div > < script > var textAreaEvent = document . querySelector ( \"#textAreaEvent\" ); var posX = document . querySelector ( \"#pos-X\" ); var posY = document . querySelector ( \"#pos-Y\" ); textAreaEvent . addEventListener ( \"mousemove\" , function ( e ){ posX . value = e . offsetX ; posY . value = e . offsetY ; posX . classList . remove ( \"colorRed\" ) posY . classList . remove ( \"colorRed\" ) }) textAreaEvent . addEventListener ( \"mouseout\" , function () { posX . classList . add ( \"colorRed\" ) posY . classList . add ( \"colorRed\" ) }) </ script > </ body > </ html > Finch\u00e8 il mouse si muove all'interno della textarea scatter\u00e0 l'evento mousemove che restituir\u00e0 posizione X/Y del mouse. Non appena si esce da textarea scatter\u00e0 l'evento mouseout colorando di rosso il valore della posizione X/Y.","title":"Approfondimento type event"},{"location":"javascript/READMEV2/#aprrofondimento-eventi-tastiera-e-input","text":"File html < body > < h3 > evento JS </ h3 > < div > < p > Lorem ipsum, dolor sit amet consectetur adipisicing elit. < strong > Doloremque, modi? </ strong ></ p > < ul > <!-- #region Importante mettere '#' come valore di href perch\u00e8 evita il comportamento di default del link che come ricordiamo tenderebbe a raggiungere il link specificato da href ma nel caso di un bottone premuto voglio stabilirlo io cosa deve accadere--> < li id = \"ciao\" class = \"myClass\" > elemento UNO < a href = \"#\" > click me </ a ></ li > < li class = \"classe\" > elemento DUE </ li > < li class = \"classe\" > elemento TRE </ li > </ ul > < form id = 'form' action = \"\" > < input id = 'input' type = \"text\" > </ form > </ div > < script src = \"08_mainDOM.js\" ></ script > </ body > </ html > Eventi Tastiera 'keydown': genera un evento alla pressione di ogni tasto digitato 'keyup': genera un evento al rilascio di ogni tasto digitato 'keypress': genera un evento alla pressione di ogni tasto digitato (alcuni tasti speciali non sono considerati) 'focus': genera un evento quando aziono il focus sull'elemento (spesso equivale al click) 'blur': genera un evento quando esco dalla zona di focus dell'elemento 'copy': genera un evento al comando \"ctrl + c\", copia 'paste': genera un evento al comando \"ctrl + v\", incolla L'esempio seguente permette di contare il numero di tasti premuti di due caselle di input \"Nome\" e \"Cognome\" visualizzando il conteggio in una casella testuale \"Tasti Premuti\". Il conteggio si azzera con il focus sulla casella testuale \"Tasti Premuti\". Appare un alert con la scritta \"Non \u00e8 possibile usare la funzione copia!\" quando si tenta di eseguire il comando Ctrl + c (copia) all'interno della casella \"Nome\" o \"Cognome\". Inoltre, abbandonando il focus sulle caselle di input \"Nome\" o \"Cognome\" il testo digitato si colorer\u00e0 di rosso ma non appena torneremo alla digitazione il testo torner\u00e0 di colore nero. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Document </ title > < style > . colorRed { color : red ; } </ style > </ head > < body > < h1 > DOM: Document Object Manipulation </ h1 > < table > < tr > < td > Tasti Premuti: </ td > < td >< input type = \"text\" id = \"pressed-key\" ></ td > </ tr > < tr > < td > Nome: </ td > < td >< input type = \"text\" id = \"name\" ></ td > </ tr > < tr > < td > Cognome: </ td > < td >< input type = \"text\" id = \"cognome\" ></ td > </ tr > </ table > < script > var form = [ document . querySelector ( \"#name\" ), document . querySelector ( \"#cognome\" )] var textPressedKey = document . querySelector ( \"#pressed-key\" ); Tasti Premuti var charInserted = 0 ; //alla pressione di un tasto nei campi \"Nome\" e \"Cognome\" verr\u00e0 aggiornato il conteggio dei caratteri //totali inseriti e tolto lo stile all' elemento che ha scatenato l'evento rimuovendo la classe \"colorRed\" function pressedKey (){ textPressedKey . value = String ( ++ charInserted ); this . classList . remove ( \"colorRed\" ); } //quando viene lasciato il focus dall'elemento viene aggiunto lo stile tramite la classe \"colorRed\" function changeColor (){ this . classList . add ( \"colorRed\" ); } //quando si tenta di lanciare il comando \"copia\" dai campi \"Nome\" e \"Cognome\" si genera un alert di errore function printErrorCopyMessage () { alert ( \"Non \u00e8 possibile usare la funzione copia!\" ); } //quando sposto il focus sull'elemento \"Tasti Premuti\" azzero il conteggio textPressedKey . addEventListener ( \"focus\" , function () { charInserted = 0 ; textPressedKey . value = String ( charInserted ); }) //Aggiungo eventi ai campi \"Nome\" e \"Cognome\" for ( elem of form ){ elem . addEventListener ( \"keydown\" , pressedKey ); elem . addEventListener ( \"blur\" , changeColor ); elem . addEventListener ( \"copy\" , printErrorCopyMessage ); } </ script > </ body > </ html >","title":"Aprrofondimento eventi tastiera e input"},{"location":"javascript/READMEV2/#lezione-27","text":"","title":"Lezione 27"},{"location":"javascript/READMEV2/#argomeni-non-trattati-da-approfondire","text":"Typed Array : Gli array tipizzati JavaScript sono oggetti simili a array che forniscono un meccanismo per leggere e scrivere dati binari grezzi nei buffer di memoria. Come forse gi\u00e0 saprai, gli oggetti Array crescono e si riducono dinamicamente e possono avere qualsiasi valore JavaScript. I motori JavaScript eseguono ottimizzazioni in modo che questi array siano veloci. Utile per curare aspetti delicati come l'Endianess. Fonte: MDN - Typed Array Endianess. In informatica, endianness \u00e8 l'ordine o la sequenza di byte di una parola di dati digitali nella memoria del computer. L'Endianness \u00e8 principalmente espresso come big-endian (BE) o little-endian (LE) . Un sistema big-endian memorizza il byte pi\u00f9 significativo di una parola all'indirizzo di memoria pi\u00f9 piccolo e il byte meno significativo al pi\u00f9 grande. Un sistema little-endian, al contrario, memorizza il byte meno significativo all'indirizzo pi\u00f9 piccolo.L'Endianness pu\u00f2 anche essere usato per descrivere l'ordine in cui i bit vengono trasmessi su un canale di comunicazione, ad esempio, il big-endian in un canale di comunicazione trasmette prima i bit pi\u00f9 significativi. Il bit-endianness \u00e8 usato raramente in altri contesti. I protocolli Internet come TCP e IPV4 utilizzano lo schema little endian mentre i processori Intel utilizzano spesso la notazione big endian . Questo \u00e8 un problema reale da conoscere saper gestire Fonte: Wikipedia - Endianess Regular Expression Le espressioni regolari sono schemi usati per confrontare combinazioni di caratteri nelle stringhe. In JavaScript, le espressioni regolari sono anche oggetti. Questi pattern sono usati con i metodi exec() e test() della classe RegExp , e con i metodi match() , matchAll() , replace() , search() , e split() della classe String . Fonte: MDN - Espressioni_Regolari Moduli Fonte: MDN - JavaScript modules Eventi/Manipolazione DOM (programmazione asincrona, promis) Dom Manipulation Quando scrivi pagine web e app, una delle cose pi\u00f9 comuni che vorrai fare \u00e8 manipolare in qualche modo la struttura del documento. Questo di solito viene fatto utilizzando il Document Object Model (DOM), un insieme di API per il controllo dell'HTML e delle informazioni di stile che fa un uso intenso dell'oggetto Document. In questo articolo vedremo come utilizzare il DOM in dettaglio, insieme ad alcune altre API interessanti che possono alterare il tuo ambiente in modi interessanti. Fonte: MDN - Manipulating documents Javascript async function Una funzione asincrona \u00e8 una funzione dichiarata con la parola chiave asincrona. Le funzioni asincrone sono istanze del costruttore AsyncFunction e al loro interno \u00e8 consentita la parola chiave await. Le parole chiave async e await consentono di scrivere un comportamento asincrono basato sulla promessa in uno stile pi\u00f9 pulito, evitando la necessit\u00e0 di configurare esplicitamente catene di promesse. Fonte: MDN - async function Libreria JQuery jQuery \u00e8 una libreria JavaScript per applicazioni web, distribuita come software libero, distribuito sotto i termini della Licenza MIT. Nasce con l'obiettivo di semplificare la selezione, la manipolazione, la gestione degli eventi e l'animazione di elementi DOM in pagine HTML, nonch\u00e9 semplificare l'uso di funzionalit\u00e0 AJAX, la gestione degli eventi e la manipolazione dei CSS. Le sue caratteristiche permettono agli sviluppatori JavaScript di astrarre le interazioni a basso livello con i contenuti delle pagine HTML. L'approccio di tipo modulare di jQuery consente la creazione semplificata di applicazioni web e contenuti dinamici versatili. Nel 2020, jQuery risulta la libreria JavaScript pi\u00f9 utilizzata in Internet, ovvero \u00e8 presente nel 74,4% dei primi 10 milioni di siti Internet pi\u00f9 popolari secondo W3Techs. Fonte: Wikipedia - JQuery","title":"Argomeni non trattati / da approfondire"},{"location":"javascript/READMEV2/#fonti","text":"Risorse gratuite - Exploring JS: JavaScript books for programmers - MDN Video-Corsi gratuiti: - fcamuso - Corso Javascript (ES6) ITA - Andrea Tommasello - corso Javascript - 2019 italiano","title":"Fonti"},{"location":"javascript/READMEV2/#-","text":"","title":"--------------------------------------------------------------------------"},{"location":"javascript/READMEV2/#approndimenti-pt1","text":"","title":"APPRONDIMENTI PT.1"},{"location":"javascript/READMEV2/#-_1","text":"","title":"--------------------------------------------------------------------------"},{"location":"javascript/READMEV2/#nodejs","text":"Node.js Cos'\u00e8 node Install node Prima applicazione nodejs Non esiste l'oggetto window global objects Modules Creiamo un modulo Moduli built-in Modulo path Modulo OS Modulo File System Eventi Modulo HTTP Approfondimenti Passare dei parametri esterni My first IO sync My first IO async Filtered","title":"Node.js"},{"location":"javascript/READMEV2/#cose-node","text":"Node \u00e8 un programma c++ che include l'engine javascript V8 di Chrome javascript che ti permette di programmare il server con Javascript","title":"Cos'\u00e8 node"},{"location":"javascript/READMEV2/#install-node","text":"Verifica se hai gi\u00e0 installato node node --version Se il comando node non \u00e8 riconosciuto significa che lo hai installato, quindi installalo da qui Lancia nuovamente: node --version A questo punto dovrebbe rispondere con la versione appena installata: v14.15.4","title":"Install node"},{"location":"javascript/READMEV2/#prima-applicazione-nodejs","text":"Crea un file .js ad esempio app.js e scrivi codice javascript function sayHello ( name ){ console . log ( name ); } sayHello ( 'simone' ); Adesso, digitando da terminale: node app.js Vedrai: simone node eseguir\u00e0 direttamente il codice sul terminale. Il programma di node trasferir\u00e0 il codice all'engine V8 il quale poi verr\u00e0 tradotto in c++ per essere letto dalla macchina (?almeno credo?)","title":"Prima applicazione nodejs"},{"location":"javascript/READMEV2/#non-esiste-loggetto-window","text":"non esiste l'oggetto globale window poich\u00e8 fa parte del runtime environment che si ha nei browser console . log ( window ); ReferenceError: window is not defined In nodejs l'oggetto globale si chiama global ed \u00e8 condiviso e accessibile ovunque","title":"Non esiste l'oggetto window"},{"location":"javascript/READMEV2/#global-objects","text":"Hai accesso a tutte le funzionalit\u00e0 definite da javascript grazie all'oggetto global global . console . log (); global . setTimeout (); global . clearTimeout (); global . setInterval (); global . clearInterval (); L'oggetto global \u00e8 implicito quindi puoi sempre ometterlo console . log (); setTimeout (); clearTimeout (); setInterval (); clearInterval (); Locale o globale? //Javascript nel tuo browser //Globale var message = '' ; In Javascript \u00e8 una variabile globale , poich\u00e8 viene aggiunta all'oggetto window . In node questa assume uno scope locale al file. In altre parole non viene aggiunta all'oggetto global //nodejs //Locale var message = '' ; console . log ( global . message ); //undefined Attenzione che, dichiarando una variabile, assume uno scope locale al file contrariamente a quanto accadeva con Javascript. Infatti con Javascript una variabile","title":"global objects"},{"location":"javascript/READMEV2/#modules","text":"Il concetto di modulo serve proprio a incapsulare la definizione di variabili, classi e quantaltro evitando quindi eventuali problemi di conflitto tra calssi o variabili che verrebbero brutalmente sovraiscritti. nel concetto di nodejs, ogni file \u00e8 considerato un modulo Se si parla di OOP, si potrebbe dire che all'interno di ogni file tutti gli oggetti sono privati al container che \u00e8 il file. Se vuoi utilizzare ed esportare dei dati esternamente devi renderli pubblici esplicitamente Ogni applicazione nodejs ha un modulo main Per adesso non abbiamo ancora definito un modulo node ma a breve lo faremo. module \u00e8 un oggetto richiamabile esattamente come global o window nel caso di javascript all'interno di un browser console . log ( module ); /** * Module { id: '.', path: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app', exports: {}, parent: null, filename: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\app.js', loaded: false, children: [], paths: [ 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\node_modules', 'C:\\\\Users\\\\node_modules', 'C:\\\\node_modules' ] } */","title":"Modules"},{"location":"javascript/READMEV2/#creiamo-un-modulo","text":"In questo esempio creeremo un modulo, quindi un file js chiamato logger.js . In questo file definiremo una funzione e una variabile ed esporteremo la funzione esternamente. In realt\u00e0 dovremmo parlare di metodo poich\u00e8 di fatto \u00e8 appartenente al modulo logger.js che \u00e8 racchiuso in un oggetto var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports . log = log ; //module.exports.url = url; Nel file app.js andremo a richiamare l'oggetto restituito //require ritorna l'oggetto esportato dal modulo var logger = require ( './logger' ); console . log ( logger ); /** * { log: [Function: log] } */ la variabile logger ritorna ci\u00f2 che esporta il modulo logger.js infatti stampando module da logger.js avremo: var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports . log = log ; console . log ( module ); //module.exports.url = url; /* Module { id: '.', path: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app', exports: { log: [Function: log] }, parent: null, filename: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\logger.js', loaded: false, children: [], paths: [ 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\node_modules', 'C:\\\\Users\\\\node_modules', 'C:\\\\node_modules' ] } */ la property exports \u00e8 l'oggetto esportato esternamente. Ad ogni modo, adesso posso usare il metodo log del modulo logger . /*logger.js*/ var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports . log = log ; /*app.js*/ //require ritorna l'oggetto esportato dal modulo var logger = require ( './logger' ); logger . log ( 'ciao' ); >node .\\app.js ciao E' buona norma utilizzare il qualificatore const per i moduli importati questo perch\u00e8 non vogliamo in nessun modo che vengano sovraiscritti erroneamente. Se accidentalmente si prova a cambiare il valore di una costante, viene sollevato un errore a runtime /*app.js*/ //require ritorna l'oggetto esportato dal modulo const logger = require ( './logger' ); logger . log ( 'ciao' ); di sotto vedrai come esportare la funzione log in quanto funzione e non come metodo di un oggetto /*logger.js*/ var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports = log ; /*app.js*/ //require ritorna l'oggetto esportato dal modulo var log = require ( './logger' ); log ( 'ciao' ); >node .\\app.js ciao Stampiamo in questo caso cosa esporta il modulo logger /*logger.js*/ var url = 'http://mylogger.io/log' ; function log ( message ) { //send an HTTP request console . log ( message ); } //esporto esternamente il metodo log (appartenente a questo modulo \"logger.js\") module . exports = log ; console . log ( module ); /* Module { id: '.', exports: [Function: log], parent: null, filename: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\logger.js', loaded: false, children: [], paths: [ 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\node_modules', 'C:\\\\Users\\\\Di Ricco\\\\node_modules', 'C:\\\\Users\\\\node_modules', 'C:\\\\node_modules' ] } */","title":"Creiamo un modulo"},{"location":"javascript/READMEV2/#moduli-built-in","text":"Sulla pagina ufficiale di node.js puoi trovare la sezione relativa alla documentazione .","title":"Moduli built-in"},{"location":"javascript/READMEV2/#modulo-path","text":"Nel prossimo esempio useremo il modulo path che fornisce delle utility per lavorare con file e directory. Utilizzeremo in particolare il metodo parse() Il metodo parse() restituisce un oggetto le cui propriet\u00e0 rappresentano elementi significativi del percorso. L'oggetto ritorna le seguenti propriet\u00e0: dir <string> root <string> base <string> name <string> ext <string> Vediamo un esempio: const path = require ( 'path' ); const pathObj = path . parse ( './app.js' ); console . log ( pathObj ); /** * { root: '', dir: '.', base: 'app.js', ext: '.js', name: 'app' } */","title":"Modulo path"},{"location":"javascript/READMEV2/#modulo-os","text":"La documentazione del modulo os la trovi qui In questo esempio vedremo come usare il modulo os e in particolare i metodi totalmem() e freemem() che restituiscono informazioni rispettivamente sulla memoria totale di sistema e la memoria libera const os = require ( 'os' ); const totalMemory = os . totalmem (); const freeMemory = os . freemem (); console . log ( 'Total Memory ' + totalMemory ); console . log ( `Free Memory: ${ freeMemory } ` ); /** * Total Memory 8502140928 * Free Memory: 4154499072 */","title":"Modulo OS"},{"location":"javascript/READMEV2/#modulo-file-system","text":"Puoi trovare l'intera documentazione qui . In particolare vedremo il metodo fs.readdirSync(path[, options]) e il metodo fs.readdir(path[, options], callback) Metodo sincrono readdirSync() . Ritorna un array di elementi contenuti al path passato come parametro. E' un metodo sincrono! I metodi sincroni sono anche detti bloccanti in quanto impegnano la CPU per tutto il tempo necessario al completamento dell'attivit\u00e0 impedendo al codice di proseguire e servire le altre attivit\u00e0. Questo \u00e8 il funzionamento tipico della programmazione procedurale sincrona const fs = require ( 'fs' ); //Metodo sincrono const files = fs . readdirSync ( './' ); console . log ( files ); Metodo asincrono readdir() . Ritorna (attraverso la callback) un array di elementi contenuti al path passato come primo parametro. Esegue la callback passata come secondo parametro. I metodi asincroni sono anche detti non-bloccanti in quanto impegnano la CPU solo al momento di partenza dell'attivit\u00e0. In questo caso il codice pu\u00f2 proseguire con le altre attivit\u00e0. Una volta che il metodo avr\u00e0 concluso l'attivit\u00e0, verr\u00e0 eseguita una cos\u00ecdetta \"callback\" una funzione in grado di comunicare se il risultato \u00e8 andato a buon fine oppure no. In una funzione \"callback\", il primo parametro rappresenta l'errore (eventuale), il secondo parametro rappresenta il valore di ritorno del metodo. Nel caso della readdir() rappresenta l'array di file contenuti al path specificato come primo parametro della readdir() const fs = require ( 'fs' ); //Metodo asincrono fs . readdir ( './' , function ( err , files ){ if ( err ) console . log ( 'Error' , err ); else console . log ( 'Result' , files ); }); /* Result [ 'app.js', 'logger.js' ] */ Simuliamo un errore: const fs = require ( 'fs' ); //Metodo asincrono fs . readdir ( 'aaaaa' , function ( err , files ){ if ( err ) console . log ( 'Error' , err ); else console . log ( 'Result' , files ); }); /* Error [Error: ENOENT: no such file or directory, scandir 'C:\\Users\\Di Ricco\\Google Drive\\Intecs\\Saleri\\Appunti-nodejs\\first-app\\aaaaa'] { errno: -4058, code: 'ENOENT', syscall: 'scandir', path: 'C:\\\\Users\\\\Di Ricco\\\\Google Drive\\\\Intecs\\\\Saleri\\\\Appunti-nodejs\\\\first-app\\\\aaaaa' } */","title":"Modulo File System"},{"location":"javascript/READMEV2/#eventi","text":"La documentazione sugli eventi, in particolare la classe EventEmitter la puoi trovare qui Per poter far scattare un evento hai bisgono di: - emitter.on() : Il metodo on() si mette in ascolto dell'evento passato come primo parametro. Questa pratica in inglese si chiama \"to register a listener\". Inolte in questa fase stabilisci cosa fare quando l'evento scatta tramite una callback. - emitter.emit() : Il metodo emit() fa scattare un evento. Quando scatta torna al listener come callback. //events ritorna una classe, la classe degli eventi const EventEmitter = require ( 'events' ); //in questo modo ho istanziato un oggetto della classe EventEmitter, chiamando il suo costruttore senza nessun parametro const emitter = new EventEmitter (); //Register a listener. //devi registrare un listener prima che l'evento scatti. //E' un po' come abilitare l'interrupt per un particolare evento nei sistemi embedded e implementare l'ISR emitter . on ( 'messageLogged' , function (){ console . log ( 'listener called' ) }) //Raise an event //L'evento pu\u00f2 scattare solo dopo che \u00e8 stato registrato il listener. emitter . emit ( 'messageLogged' ); E' possibile ritornare un parametro al listener. Normalmente questo parametro viene passato come oggetto per maggiore chiarezza. La funzione di callback si aspetta un parametro. Vediamo un esempio: const EventEmitter = require ( 'events' ); const emitter = new EventEmitter (); //Register a listener. emitter . on ( 'messageLogged' , function ( eventArg ){ console . log ( 'listener called' , eventArg ) }) //Raise an event emitter . emit ( 'messageLogged' , { id : 1 , url : 'https://' }); /* listener called { id: 1, url: 'https://' } */ Puoi usare anche la sintassi \"arrow function\" const EventEmitter = require ( 'events' ); const emitter = new EventEmitter (); //Register a listener. emitter . on ( 'messageLogged' , ( eventArg ) => { console . log ( 'listener called' , eventArg ) }) //Raise an event emitter . emit ( 'messageLogged' , { id : 1 , url : 'https://' }); Normalmente gli eventi possono scattare da ogni modulo ma vorresti averne il controllo sul tuo main module. Vedremo adesso come mettersi in ascolto da eventi che possono scattare da altri moduli facendo uso delle classi /*logger.js*/ const EventEmitter = require ( 'events' ); var url = 'http://mylogger.io/log' ; //\"Logger\" contiene tutti i metodi e le propriet\u00e0 di \"EventEmitter\" class Logger extends EventEmitter { log ( message ) { //send an HTTP request console . log ( message ); //Raise an event this . emit ( 'messageLogged' , { id : 1 , url : 'https://' }); } } module . exports = Logger ; /*app.js*/ const Logger = require ( './logger' ); const logger = new Logger (); //Register a listener. logger . on ( 'messageLogged' , ( eventArg ) => { console . log ( 'listener called' , eventArg ) }) logger . log ( 'message' ); /* message listener called { id: 1, url: 'https://' } */","title":"Eventi"},{"location":"javascript/READMEV2/#modulo-http","text":"Se lanci questa applicazione con node.js const http = require ( 'http' ); const server = http . createServer (); server . on ( 'connection' , ( socket ) => { console . log ( 'New connection' ); }) server . listen ( 3000 ); console . log ( 'Listening on port 3000..' ); e poi dal tuo browser digiti localhost:3000 vedrai stampato New connection const http = require ( 'http' ); const server = http . createServer (( req , res ) => { if ( req . url === '/' ){ res . write ( 'hello world' ); res . end (); } if ( req . url === '/api/courses' ){ res . write ( JSON . stringify ([ 1 , 2 , 3 ])); res . end (); } }); server . listen ( 3000 ); console . log ( 'Listening on port 3000..' );","title":"Modulo HTTP"},{"location":"javascript/READMEV2/#approfondimenti","text":"Alcuni riferimenti utili: puoi imparare node su nodeschoold . Cliccando su learnyounode Ti suggerir\u00e0 di scaricare tramite npm un simpatico software per l'apprendimento di node. puoi imparare le nuoe features di es6 su es6 features","title":"Approfondimenti"},{"location":"javascript/READMEV2/#passare-dei-parametri-esterni","text":"Eseguiremo l'esercizio baby-steps suggerito da learnyounode /*baby-steps.js*/ const argArray = process . argv ; let sum = 0 ; argArray . forEach ( ( element , index ) => { if ( index >= 2 ) sum += Number ( element ); }); console . log ( sum ); Esegui ad esempio: node .\\baby-steps.js 1 2 3 Vedrai: 6","title":"Passare dei parametri esterni"},{"location":"javascript/READMEV2/#my-first-io-sync","text":"Nel prossimo esempio leggeremo un file di testo e stamperemo il numero di caratteri a capo . Faremo uso del modulo fs e del metodo readFileSync() per la lettura dei file in modo sincrono const fs = require ( 'fs' ); const buf = fs . readFileSync ( './myFile.txt' ); const str = buf . toString (); const strArr = str . split ( '\\n' ); console . log ( buf ); console . log ( str ); console . log ( strArr ); console . log ( strArr . length - 1 ); /* <Buffer 63 69 61 6f 20 0a 61 20 0a 74 75 74 74 69 0a 71 75 61 6e 74 69> ciao a tutti quanti [ 'ciao ', 'a ', 'tutti', 'quanti' ] 3 */ Di default readFileSync() resistutisce un oggetto della classe Buffer che puoi approfondire direttamente sulla documentazione di nodejs. In pratica comunque resitituisce i caratteri decodificandoli in binario attraverso utf8 che \u00e8 equivalente al codice ASCII. Se vuoi verificare, basta tu prenda una tabella ASCII e tu legga il valore esadecimale per ogni lettera. Questo sistema potrebbe essere molto interessante per la comunicazione con un microcontrollore. Se vuoi tuttavia convertire direttamente in stringa puoi specificare il tipo di codifica utf8 come secondo parametro. Il codice si semplifica e diventa const fs = require ( 'fs' ); const str = fs . readFileSync ( './myFile.txt' , 'utf8' ); const strArr = str . split ( '\\n' ); console . log ( str ); console . log ( strArr ); console . log ( strArr . length ); /* ciao a tutti quanti [ 'ciao ', 'a ', 'tutti', 'quanti' ] 3 */","title":"My first IO sync"},{"location":"javascript/READMEV2/#my-first-io-async","text":"In questo esempio vedremo invece lo stesso esempio ma utilizzando la programmazione asincrona e quindi tramite il metodo readFile() . Questo metodo non ritorna niente, il suo output \u00e8 in realt\u00e0 la funzione di callback passata come secondo parametro che viene chiamata solo quando si \u00e8 raggiunto un risultato const fs = require ( 'fs' ); console . log ( 'before' ); fs . readFile ( './myFile.txt' , 'utf8' , ( err , data ) => { //fs.readFile('./myFile.txt', 'utf8', function(err, data){ console . log ( data ); console . log ( data . split ( '\\n' ). length - 1 ); }) console . log ( 'after' ); /* before after ciao a tutti quanti 3 */ Attenzione Quello che devi notare \u00e8 che con questo sistema, al contrario del sistema sincrono, l'evoluzione del programma continua una volta chiamato il metodo readFile() . Per questo ho inserito console.log('before'); e console.log('after'); , per dimostrare in output che il risultato non \u00e8 quello atteso In genere conviene sempre fare il check di eventuali errori. Poich\u00e8 la callback come primo parametro riceve anche un errore segnalandoci se qualcosa \u00e8 andato storto, \u00e8 buona norma utilizzarlo per sollevare un'eccezione attraverso throw oppure qualsiasi altra operazione desiderata const fs = require ( 'fs' ); console . log ( 'before' ); fs . readFile ( './myFile.txt' , 'utf8' , ( err , data ) => { if ( err ) throw err console . log ( data ); console . log ( data . split ( '\\n' ). length - 1 ); }) console . log ( 'after' ); /* before after ciao a tutti quanti 3 */","title":"My first IO async"},{"location":"javascript/READMEV2/#filtered","text":"In questo esempio vedrai come stampare il contenuto dei file all'interno di una directory con una particolare estensione. Il path e l'estensione vengono passati come parametri esterni allo script /*05-filtered-ls.js*/ const fs = require ( 'fs' ); const path = require ( 'path' ); const dir = process . argv [ 2 ]; const ext = process . argv [ 3 ]; fs . readdir ( dir , ( err , files ) => { files . forEach (( elem )=>{ if ( path . extname ( elem ) == ext ) console . log ( elem ) }) }) Otterrai: >node 05-filtered-ls.js ./ .js 01-hello-node.js 02-baby-steps.js 03-my-first-io-async.js 04-my-first-io.js 05-filtered-ls.js Puoi renderlo migliore.. In questo esempio utilizzero il metodo filter e passer\u00f2 l'estensione del file senza dover specificare il . const fs = require ( 'fs' ); const path = require ( 'path' ); const dir = process . argv [ 2 ]; const ext = `. ${ process . argv [ 3 ] } ` ; fs . readdir ( dir , ( err , files ) => { if ( err ) throw err ; const filesFiltered = files . filter (( file ) => path . extname ( file ) === ext ); filesFiltered . forEach (( file ) => console . log ( file )); });","title":"Filtered"},{"location":"javascript/READMEV2/#-_2","text":"","title":"--------------------------------------------------------------------------"},{"location":"javascript/READMEV2/#approndimenti-pt2","text":"","title":"APPRONDIMENTI PT.2"},{"location":"javascript/READMEV2/#-_3","text":"","title":"--------------------------------------------------------------------------"},{"location":"javascript/READMEV2/#promise","text":"Puoi trovare degli approfondimenti utili sull'argomento qua: MDN Gli oggetti Promise sono usati per computazioni in differita e asincrone. Una Promise rappresenta un'operazione che non \u00e8 ancora completata, ma lo sar\u00e0 in futuro. new Promise ( function ( resolve , reject ) { ... }); Una promise accetta come argomento una funzione che ha due parametri: resolve e reject . Tale funzione viene chiamata immediatamente dall'implementazione della Promise, passando i due argomenti resolve e reject , che sono due funzioni. Le due funzioni resolve e reject , quando chiamate, risolvono o rigettano la promise. L'esecutore inizia del lavoro (solitamente asincrono), e, una volta completato, chiama resolve per risolvere la promise, o reject se c'\u00e8 stato qualche errore. Se un errore viene sollevato nella funzione di esecuzione (executor) la promise viene rigettata. Una Promise consente di associare degli handlers con il successo o il fallimento di un'azione asincrona. Questo in pratica consente di utilizzare dei metodi asincroni di fatto come se fossero sincroni. Una Promise pu\u00f2 presentarsi in uno dei seguenti stati: pending (attesa): stato iniziale, n\u00e9 soddisfatto n\u00e9 respinto. fulfilled (soddisfatto): significa che l'operazione si \u00e8 conclusa con sucesso. rejected (respinto): significa che l'operazione \u00e0 fallita. Una promise in pending pu\u00f2 evolvere sia in fulfilled , sia in rejected con la possibilit\u00e0 in entrambi i casi di passare valori. Quando accade una di queste situazioni, vengono chiamati gli handler associati che sono stati accodati dal metodo then della promise. Poich\u00e8 i metodi .then e .catch restituiscono delle promise , \u00e8 possibile concatenarli tramite l'operazione di composition .","title":"Promise"},{"location":"javascript/READMEV2/#un-esempio-semplice","text":"In questo esempio creo una promise in cui chiamer\u00f2 la funzione setTimeout() . Una volta che setTimeout() sar\u00e0 completata la promise entrer\u00e0 nello stato fulfilled ritornando un messaggio di successo rappresentato dal parametro della funzione resolve() . Poich\u00e8 mi aspetto che non ci siano errori in questa situazione, ho aggiunto una variabile esterna in modo da simulare una qualsiasi condizione di errore. Con la variabile booleana ForceRejected forzo la promise ad entrare nello stato di rejected , ritornando il valore identificato dal parametro della funzione reject() . Una volta che la Promise ha terminato ed \u00e8 passata da pending a fulfilled \u00e8 possibile restituire il risultato tramite il metodo .then della Promise . Tale metodo accetta come parametro una callbackc che come parametro ha il valore passato da resolve() . Allo stesso modo, quando la Promise ha terminato ed \u00e8 passata da pending a rejected viene restituito il valore passato a reject() alla callback del metodo catch() const ForceRejected = false ; console . log ( \"Inizio\" ); let myFirstPromise = new Promise (( resolve , reject ) => { if ( ForceRejected ) { reject ( \"Error\" ); } else { setTimeout ( function (){ resolve ( \"Success!\" ); }, 1000 ); } }); myFirstPromise . then (( successMessage ) => { console . log ( \"Yee! \" + successMessage ); }). catch (( errorMessage ) => { console . log ( \"...! \" + errorMessage ); }) console . log ( \"Fine\" ); Il risultato sar\u00e0: Inizio Fine Yee! Success! Se esegui il codice con const ForceRejected = true; avrai come risultato: Inizio Fine ...! Error Nota che ho inserito anche due extra-stampe Inizio , Fine per evidenziare che il processo \u00e8 asincrono e quindi continua la sua esecuzione nel mentre che la Promise cerca di evolvere da pending a fulfilled o rejected","title":"Un esempio semplice"},{"location":"javascript/READMEV2/#-_4","text":"","title":"--------------------------------------------------------------------------"},{"location":"javascript/READMEV2/#approndimenti-pt3","text":"","title":"APPRONDIMENTI PT.3"},{"location":"javascript/READMEV2/#-_5","text":"","title":"--------------------------------------------------------------------------"},{"location":"javascript/READMEV2/#approfondimento-hoisting_1","text":"Differenza tra var , let , const , blocchi di codici, funzioni etc.. Puoi trovare un approfondimento qui","title":"Approfondimento Hoisting"},{"location":"javascript/READMEV2/#approfondimento-oggetti","text":"Modo alternativo per inizializzare un oggetto let fsName = 'simone' ; let lsName = 'diricco' ; let user = { fsName , lsName }; console . log ( user ); //{ fsName: 'simone', lsName: 'diricco' } In questo caso l'oggeto prende come key il nome della variabile let fsName = 'simone' ; let lsName = 'diricco' ; let user = { fsName , lsName }; console . log ( user ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user [ 'lsName' ]); //diricco console . log ( user . fsName ); //simone let user2 = { [ 'fs' + 'Name' ] : fsName , lsName }; console . log ( user ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user2 [ 'fsName' ]); //simone console . log ( user2 . lsName ); //diricco Con la notazione ['nomeKey] ho il vantaggio di poter valutare delle espressioni stringhe Per verificare se esiste unar propriet\u00e0 all'interno di un oggetto: let fsName = 'simone' ; let lsName = 'diricco' ; let user = { fsName , lsName }; console . log ( 'fsName' in user ); //true","title":"Approfondimento Oggetti"},{"location":"javascript/READMEV2/#approfondimento-moduli","text":"CommonJS require / exports Con require posso importare tutto ci\u00f2 che desidero appartenente a moduli esterni //main.js let a = require ( './module1' ); console . log ( a ) Con module.exports posso esportare cio\u00e8 che desidero di un modulo //module1.js let a = 10 ; module . exports = a ; Mandando in esecuzione main.js otterremo la stampa di a , il cui valore \u00e8 prelevato dal modulo module1.js . E' lo stesso identico concetto di include in c++ solo che in questo caso l'esportazione e l'importazione non \u00e8 a livello di file ma a livello proprio di funzionalit\u00e0, oggetti, classi etc.. Vediamo un esempio pi\u00f9 completo //main.js let math = require ( './math' ); console . log ( math . sum ( 20 , 30 )); console . log ( math . sub ( 20 , 30 )); console . log ( math . mul ( 20 , 30 )); console . log ( math . div ( 20 , 30 )); //math.js let sum = function ( x , y ){ return x + y ; } let div = function ( x , y ){ return x / y ; } let mul = function ( x , y ){ return x * y ; } let sub = function ( x , y ){ return x - y ; } module . exports = { sum , div , mul , sub }","title":"Approfondimento Moduli"},{"location":"javascript/READMEV2/#packages","text":"NPM Installiamo ad esempio il pacchetto prompt-sync tramite npm install prompt-sync . Verr\u00e0 scaricato una cartella node_modules Questo pacchetto serve per l'acquisizione di dati da tastiera. Vediamo un esempio: let prompt = require ( 'prompt-sync' )(); let number = prompt ( 'Insert a number: ' ); console . log ( number );","title":"Packages"},{"location":"javascript/READMEV2/#approfondimento-this","text":"this si riferisce sempre all'oggetto referenziato al quale il metodo fa riferimento let printName = function (){ return this . fsName + ' ' + this . lsName ; } let user1 = { fsName : 'mario' , lsName : 'rossi' , printName } let user2 = { fsName : 'matteo' , lsName : 'bianchi' , printName } console . log ( user1 . printName ()); //mario rossi console . log ( user2 . printName ()); //matteo bianchi Vediamo un alrto esercizio let listProducts = { \"0001\" : { name : 'PC' , price : 12.45 }, \"0002\" : { name : 'smth' , price : 13.45 }, \"0002\" : { name : 'tast' , price : 2.45 }, \"0003\" : { name : 'Monit' , price : 12.35 }, \"0004\" : { name : 'mous' , price : 124.45 } } let store = { listProducts , print : function (){ for ( let item in this . listProducts ){ console . log ( this . listProducts [ item ]. name ); console . log ( this . listProducts [ item ]. price ); console . log ( '------------------------' ); } } } store . print (); /* PC 12.45 ------------------------ tast 2.45 ------------------------ Monit 12.35 ------------------------ mous 124.45 ------------------------ */ Un altro esempio che usa il costruttore in modo da poter utilizzare un oggetto come modello e poter istanziare delle copie del modello dell'oggetto function User ( fsName , lsName , email ){ this . fsName = fsName , this . lsName = lsName , this . email = email this . name = function (){ return this . fsName + ' ' + this . lsName ; } } let user1 = new User ( 'sim' , 'dir' , 'em@em.it' ); console . log ( user1 ); console . log ( user1 . name ()); /* User { fsName: 'sim', lsName: 'dir', email: 'em@em.it', name: [Function (anonymous)] } sim dir */ Reference data type Al contrario delle strutture dati primitive, con le strutture dati referenziate come array o oggetti, l'assegnamento tra strutture dati referenziate effettua una copia solo dell'indirizzo a cui \u00e8 allocato il nome della struttura referenziata il che \u00e8 diverso dall'eseguire una copia del valore come accade con le strutture dati primitive. Questo significa che in fase di assegnamento tra due oggetti o array poich\u00e8 copio l'indirizzo dell'oggetto o array, di fatto ho ottenuto due oggetti che puntano alla stessa struttura dati. Se modifico uno, modifico anche l'altro.. Vediamo un esempio.. let user1 = { fsname : 'mario' , lsname : 'rossi' } let user2 = user1 ; console . log ( user1 ); //{ fsname: 'mario', lsname: 'rossi' } console . log ( user2 ); //{ fsname: 'mario', lsname: 'rossi' } user2 . fsname = 'Luigi' ; console . log ( user1 ); //{ fsname: 'Luigi', lsname: 'rossi' } console . log ( user2 ); //{ fsname: 'Luigi', lsname: 'rossi' } user1 . email = 'em@em.it' ; console . log ( user1 ); //{ fsname: 'Luigi', lsname: 'rossi', email: 'em@em.it' } console . log ( user2 ); //{ fsname: 'Luigi', lsname: 'rossi', email: 'em@em.it' }","title":"Approfondimento THIS"},{"location":"javascript/READMEV2/#costruttori-prefdefiniti-javascript","text":"Object, String, Boolean, Number, Array RegExp, Function, Error, Symbol, Date let user = new Object (); Questo significa che anche i dati primitivi sono implementati in javascript come oggetti e quindi avranno propriet\u00e0 e metodi! ecco perch\u00e8 puoi fare str.lenght oppure str.toUpperCase() oppure nmb.toFixed() Non \u00e8 possibile modificare tuttavia metodi e propriet\u00e0 di un dato primitivo! Attenzione! Anche gli Array sono particolari oggetti estesi","title":"Costruttori prefdefiniti javascript"},{"location":"javascript/READMEV2/#for-of","text":"","title":"for .. of"},{"location":"javascript/READMEV2/#for-in","text":"","title":"for .. in"},{"location":"javascript/READMEV2/#memoization","text":"","title":"Memoization"},{"location":"javascript/READMEV2/#come-fare-una-copia-profonda-tra-oggetti","text":"Sappiamo che l'assegnamento standard effetua solo una copia dei riferimenti e questo equivale a creare un oggetto che punta alla stessa struttura dati. il metodo Object.assig() invece effettua una copia profonda dell'oggetto passato come parametro restituendo di fatto un oggetto copia let user1 = { fsName : 'simone' , lsName : 'diricco' }; let user2 = Object . assign ({}, user1 ); //deep copy console . log ( user1 ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user2 ); //{ fsName: 'simone', lsName: 'diricco' } user2 . lsName = 'rossi' ; console . log ( user1 ); //{ fsName: 'simone', lsName: 'diricco' } console . log ( user2 ); //{ fsName: 'simone', lsName: 'rossi' }","title":"Come fare una copia profonda tra oggetti?"},{"location":"javascript/READMEV2/#proprieta-associate-ai-dati-e-propriera-associate-allaccesso","text":"","title":"propriet\u00e0 associate ai dati e proprier\u00e0 associate all'accesso"},{"location":"javascript/READMEV2/#get-set_1","text":"let square = { x : 10 , //propriet\u00e0 di accesso get area (){ return this . x * this . x ; } }; console . log ( square . x ); //10 console . log ( square . area ); //100 square . x = 20 ; console . log ( square . x ); //20 console . log ( square . area ); //400 square . area = 23 ; console . log ( square . x ); //20 //La propriet\u00e0 area non viene modificata console . log ( square . area ); //400 let square = { x : 10 , //propriet\u00e0 di accesso get area (){ return this . x * this . x ; }, set area ( val ){ this . x = Math . sqrt ( val ); } }; console . log ( square . x ); //10 console . log ( square . area ); //100 square . area = 25 ; console . log ( square . x ); //5 //La propriet\u00e0 area non viene modificata console . log ( square . area ); //25","title":"get &amp; set"},{"location":"javascript/READMEV2/#arrow-functions","text":"Sintassi funzioni function sum ( x , y ){ return x + y ; } //anonymous fucntions let sum2 = function ( x , y ){ return x + y ; } //Arrow functions let sum3 = ( x , y ) => { return x + y ; } //arrow functions with 1 argument let square = x => { return x * x ; } //arrow functions with 1 argument //compact let square2 = x => x * x ;","title":"Arrow functions"},{"location":"javascript/READMEV2/#high-order-functions","text":"//funzione identit\u00e0 let id = x => x ; let sum = ( x , y ) => x + y ; //Funzione di ordine superiore //poich\u00e8 accetta come argomento una funzione e ritorna una funzione id ( sum )( 4 , 5 );","title":"High Order Functions"},{"location":"javascript/READMEV2/#array-filter","text":"let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //test \u00e8 una funzione che decido in fase di invocazione let filter = ( array , test ) => { let result = []; for ( let item of array ) if ( test ( item )){ result . push ( item ) } return result ; } //ritorno un array con l'elemento 'simone' se \u00e8 presente console . log ( filter ( array , x => x == 'simone' )); //ritorno un array con gli elementi che contengono una 'a' console . log ( filter ( array , x => x . search ( \"a\" ) >= 0 ));","title":"Array filter"},{"location":"javascript/READMEV2/#array-map","text":"let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //test \u00e8 una funzione che decido in fase di invocazione let filter = ( array , test ) => { let result = []; for ( let item of array ) if ( test ( item )){ result . push ( item ) } return result ; } let map = ( array , trans ) => { let result = []; for ( let item of array ){ result . push ( trans ( item )); } return result ; } console . log ( map ( array , x => x . toUpperCase ())); //[ 'SIMONE', 'CIAO', 'MATTEO', 'ALESSANDRO' ]","title":"Array map"},{"location":"javascript/READMEV2/#array-reduce","text":"let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //test \u00e8 una funzione che decido in fase di invocazione let filter = ( array , test ) => { let result = []; for ( let item of array ) if ( test ( item )){ result . push ( item ) } return result ; } let map = ( array , trans ) => { let result = []; for ( let item of array ){ result . push ( trans ( item )); } return result ; } let reduce = ( array , combine , start ) => { let current = start ; for ( let item of array ){ current = combine ( current , item ) } return current ; } let count = map ( array , x => x . length ); let totCount = reduce ( count , ( a , b ) => a + b , 0 ); console . log ( count ); //[ 6, 4, 6, 10 ] console . log ( totCount ); //26","title":"Array reduce"},{"location":"javascript/READMEV2/#gli-array-possiedono-gia-come-metodi-filer-map-reduce","text":"Gli array possiedono gi\u00e0 come metodi filer, map, reduce array . map (); array . filter (); array . reduce (); E funzionano allo stesso modo di come li abbiamo implementati noi. Vediamo adesso come combinare queste funzioni let array = [ 'simone' , 'ciao' , 'matteo' , 'alessandro' ]; //conta le lettere totali degli elementi che contengono una 'a' console . log ( //['ciao', 'matteo', 'alessandro']; array . filter ( item => { return item . search ( 'a' ) >= 0 ; }) //[ 4, 6, 10 ] . map ( item => { return item . length ; }) //20 . reduce (( a , b ) => { return a + b ; }) ); //20","title":"Gli array possiedono gi\u00e0 come metodi filer, map, reduce"},{"location":"javascript/READMEV2/#qualche-chicca-sugli-array","text":"","title":"Qualche chicca sugli Array"},{"location":"javascript/READMEV2/#arrrayof-arrayfrom","text":"let numbers = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 ]; console . log ( numbers . length ); //10 let numbers1 = Array . of ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 ); console . log ( numbers1 ); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 0] let numberString = \"1234567890\" ; let numbers2 = Array . from ( numberString ); console . log ( numbers2 ); //['1', '2', '3', '4','5', '6', '7', '8','9', '0'] let numbers3 = Array . from ( numberString , value => parseInt ( value )); console . log ( numbers3 ); //[1, 2, 3, 4, 5,6, 7, 8, 9, 0] let numbers4 = Array . from ( numbers3 , value => value + 1 ); console . log ( numbers4 ); //[2, 3, 4, 5, 6,7, 8, 9, 10, 1]","title":"Arrray.of, Array.from"},{"location":"javascript/READMEV2/#concat-every-some","text":"let array1 = [ 1 , 2 , 3 , 4 , 5 ]; let array2 = [ 6 , 7 , 8 , 9 , 0 ]; console . log ( array1 . concat ( array2 )); //[1, 2, 3, 4, 5,6, 7, 8, 9, 0] //ogni elemento deve soddisfare la condizione console . log ( array1 . every ( value => typeof value === \"number\" )); //true //almeno un elemento deve soddisfare la condizione console . log ( array1 . some ( value => typeof value === \"number\" )); //true","title":"concat, every, some"},{"location":"javascript/READMEV2/#find-filter-foreach-includes-indexof","text":"let users = [ \"Cosimo\" , \"Simone\" , \"mario\" , \"maria\" , \"giuseppe\" , \"asinello\" ]; //find console . log ( users . find ( value => value == \"mario\" )); //mario //find //ritorna un elemento dell'array console . log ( users . find ( value => value . search ( \"g\" ) == 0 )); //giuseppe //filter //ritorna un array console . log ( users . filter ( value => value . search ( \"a\" ) == 0 )); //[ 'asinello' ] /* COSIMO SIMONE MARIO MARIA GIUSEPPE ASINELLO */ //forEach users . forEach ( value => { console . log ( value . toLocaleUpperCase ()); }) //includes console . log ( users . includes ( \"pippo\" )); //false console . log ( users . includes ( \"Simone\" )); //true //indexOf console . log ( users . indexOf ( \"Simone\" )); //1 console . log ( users . indexOf ( \"maria\" )); //3","title":"find, filter, forEach, includes, indexOf"},{"location":"javascript/READMEV2/#push-pop-shift-unshift","text":"let numbers = [ 1 , 2 , 3 , 4 ]; //push //ritorna la lunghezza dell'array console . log ( numbers . push ( 17 )); //5 console . log ( numbers ); //[ 1, 2, 3, 4, 17 ] //pop //ritorna l'elemento rimosso console . log ( numbers . pop ( 4 )); //17 console . log ( numbers ); //[ 1, 2, 3, 4 ] //shift //ritorna l'elemento rimosso console . log ( numbers . shift ()); //1 console . log ( numbers ); //[ 2, 3, 4 ] //unshift //ritorna la lunghezza dell'array console . log ( numbers . unshift ( 23 )); //4 console . log ( numbers ); //[ 23, 2, 3, 4 ]","title":"push, pop, shift, unshift"},{"location":"javascript/READMEV2/#sort-splice-slice","text":"let users = [ \"Cosimo\" , \"Luigi\" , \"Mario\" , \"Alessio\" , \"Matteo\" ]; console . log ( users ); //[ 'Cosimo', 'Luigi', 'Mario', 'Alessio', 'Matteo' ] //sort //Consente l'ordinamento degli elementi dell'array //L'argomento specifica la condizione di ordinamento //modifica l'array console . log ( users . sort ( compare )); //[ 'Alessio', 'Cosimo', 'Luigi', 'Mario', 'Matteo' ] function compare ( a , b ) { if ( a < b ) { return - 1 ; } else if ( a > b ) { return 1 ; } else { return 0 ; } } users = [ \"Cosimo\" , \"Luigi\" , \"Mario\" , \"Alessio\" , \"Matteo\" ]; //splice(x, y) //elimina y elementi a partire da una posizione x //modifica l'array users . splice ( 2 , 1 ); console . log ( users ); //[ 'Cosimo', 'Luigi', 'Alessio', 'Matteo' ] //splice //puoi anche aggiungere elementi //modifica l'array users . splice ( 2 , 0 , \"giuseppia\" , \"antonio\" ); console . log ( users ); //[ 'Cosimo', 'Luigi', 'giuseppia', 'antonio', 'Alessio', 'Matteo' ] users = [ \"Cosimo\" , \"Luigi\" , \"Mario\" , \"Alessio\" , \"Matteo\" ]; //slice //ritorna un sub-array let subArray = users . slice ( 0 , 2 ); console . log ( subArray ); //[ 'Cosimo', 'Luigi' ]","title":"sort, splice, slice"},{"location":"javascript/READMEV2/#settimeout-setinterval","text":"la setTimeout() chiama la funzione passata come argomento dopo un certo valore di tempo specificato come argomento. La setInterval() invece chiama la funzione passata come argomento periodicamente con il periodo specificato come argomento //setTimeout() setTimeout (() => { console . log ( 'start' ); }, 1000 ); let i = 0 ; //setTimeout() setInterval (() => { console . log ( i ++ ); }, 1000 ); /* start 0 1 2 3 4 5 */","title":"setTimeout(), setInterval()"},{"location":"javascript/READMEV2/#eventi-asincroni","text":"// ----------------------------------> t // x x const fs = require ( 'fs' ); //chiamata asincrona.. //viene passato un path e una callback, una funzione //la callback viene chiamata una volta che la lettura \u00e8 completata //readFile restituisce un buffer fs . readFile ( './data.txt' , function ( err , data ){ console . log ( data . toString ()); }); console . log ( 'end!!' ); /* end!! hello! */","title":"Eventi Asincroni"},{"location":"javascript/READMEV2/#promise-resolve-reject-then","text":"const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise ( function ( resolve , reject ){ fs . readFile ( fileName , function ( err , data ){ if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let file = readFile ( './data.txt' ); console . log ( file ); //Promise { <pending> } //metodo .then della Promise //Come primo parametro accetta una funzione che viene invocata se la Promise evolve in resolve //Come secondo parametro accetta una funzione che viene invocata se la Promise evolve in reject file . then ( function ( data ){ console . log ( data . toString ()); //hello! }, function ( err ){ console . log ( err ) }) Vediamo lo stesso esempio ma con qualche console.log() const fs = require ( 'fs' ); console . log ( 'start' ); //1 //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ console . log ( 'readFIle() inizio esecuzione' ); //3 return new Promise ( function ( resolve , reject ){ console . log ( \"promise(), prima dell'invocazione del metodo async readFile\" ); //4 fs . readFile ( fileName , function ( err , data ){ console . log ( \"promise(), esecuzione callback del metodo async readFile\" ); //8 if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } console . log ( \"Prima dell'invocazione di readFile()\" ); //2 let file = readFile ( './data.txt' ); console . log ( file ); //Promise { <pending> } //5 console . log ( \"Dopo l'invocazione di readFile()\" ); //6 //metodo .then della Promise //Come primo parametro accetta una funzione che viene invocata se la Promise evolve in resolve //Come secondo parametro accetta una funzione che viene invocata se la Promise evolve in reject console . log ( \".then(), invocazione del metodo della Promise\" ); //7 file . then ( function ( data ){ console . log ( \".then(), esecuzione del metodo della Promise\" ); //9 console . log ( data . toString ()); //hello! //10 }, function ( err ){ console . log ( err ) }) /* start Prima dell'invocazione di readFile() readFIle() inizio esecuzione promise(), prima dell'invocazione del metodo async readFile Promise { <pending> } Dopo l'invocazione di readFile() .then(), invocazione del metodo della Promise promise(), esecuzione callback del metodo async readFile .then(), esecuzione del metodo della Promise hello! */","title":"Promise, resolve, reject, then"},{"location":"javascript/READMEV2/#async-await","text":"Vediamo lo stesso esempio di prima inserendo la chiamata a readFile in un contesto di chiamata asincrona const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let main = async function (){ console . log ( 'start' ); readFile ( './data.txt' ). then ( data => { console . log ( data . toString ()); }); console . log ( 'end' ); } main (); /* start end hello! */ Se per\u00f2 sfruttiamo anche la parola chiave await const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let main = async function (){ console . log ( 'start' ); await readFile ( './data.txt' ). then ( data => { console . log ( data . toString ()); }) console . log ( 'end' ); } main (); Oppure, visto che ritorna una Promise , posso anche fare cos\u00ec: const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } let main = async function (){ console . log ( 'start' ); let data = await readFile ( './data.txt' ); console . log ( data . toString ()); console . log ( 'end' ); } main (); In questo modo ottengo un comportamento sequenziale del codice Vediamo un esempio pi\u00f9 completo const fs = require ( 'fs' ); //Promise //costrutto che permette di trattare le chiamate asicnrone come se fossero sincrone //non perdendo quindi il concetto di sequenzialit\u00e0 di un programma function readFile ( fileName ){ return new Promise (( resolve , reject ) => { fs . readFile ( fileName , ( err , data ) => { if ( err ){ reject ( err ); return ; } resolve ( data ); }) }); } function wait ( time ){ return new Promise (( resolve , reject ) => { setTimeout (() => { resolve () }, time ); }) } let main = async function (){ console . log ( 'start' ); console . log ( 'attendi 5 sec..' ); await wait ( 5000 ); console . log ( 'sono passati 5 sec' ); let data = await readFile ( './data.txt' ); console . log ( 'attendi 5 sec..' ); await wait ( 5000 ); console . log ( 'sono passati 5 sec' ); console . log ( data . toString ()); console . log ( 'end' ); } main (); /* start attendi 5 sec.. sono passati 5 sec attendi 5 sec.. sono passati 5 sec hello! end */","title":"Async, Await"},{"location":"javascript/READMEV2/#promiseall-e-promiserace","text":"Le Promise.all() accettano come parametro un array di Promise function wait ( time , string ){ return new Promise (( resolve , reject ) => { setTimeout (() => { resolve ( string ) }, time ); }) } //Pormise.all() //Cercano come argomento un array di Promise Promise . all ([ wait ( 1000 , 1 ), wait ( 2000 , 2 ), wait ( 3000 , 3 )]). then ( value => { console . log ( value ); }) /* [ 1, 2, 3 ] */ Dopo 3 secondi stampa a video [ 1, 2, 3 ] cio\u00e8 il valore delle Promise dopo che tutte sono state risolte. La Promise.race() invece ritorna il valore della Promise che viene risolta per prima function wait ( time , string ){ return new Promise (( resolve , reject ) => { setTimeout (() => { resolve ( string ) }, time ); }) } //Pormise.all() //Cercano come argomento un array di Promise Promise . race ([ wait ( 1000 , 1 ), wait ( 2000 , 2 ), wait ( 3000 , 3 )]). then ( value => { console . log ( value ); })","title":"Promise.all() e Promise.race()"},{"location":"javascript/READMEV2/#set-e-map","text":"let set = new Set (); set . add ( 56 ); set . add ( 'test' ); set . add ( '34' ); //con i set \u00e8 possibile aggiungere univocamente un valore //questo significa che aggiungendo pi\u00f9 volte lo stesso valore non avr\u00e0 effetto set . add ( 34 ); set . add ( 34 ); set . add ( 34 ); console . log ( set . size ); //4 let set = new Set ([ 32 , '45' , 5 , 6 , 7 , 8 , 8 , 8 ]); console . log ( set . size ); //6 set . delete ( 32 ); console . log ( set . size ); //5 console . log ( set . has ( 6 )); //true console . log ( '-----' ); set . forEach (( value , key , set ) => { console . log ( value ); console . log ( key ); console . log ( set . size ); console . log ( '-----' ); }) /** ----- 45 45 5 ----- 5 5 5 ----- 6 6 5 ----- 7 7 5 ----- 8 8 5 ----- */ E' possibile convertire un set in un array con lo spread operator. let set = new Set ([ 32 , '45' , 5 , 6 , 7 , 8 , 8 , 8 ]); let array = [... set ]; console . log ( array ); //[ 32, '45', 5, 6, 7, 8 ] In questo caso l'array non conterr\u00e0 elementi duplicati. E' quindi possibile usare il set per rimuovere i duplicati all'interno di un array function deleteDuplicates ( items ){ return [... new Set ( items )]; } console . log ( deleteDuplicates ([ 0 , 1 , 2 , 3 , 3 , 3 , 3 , 4 , 5 , 6 , 7 , 7 , 7 , 7 ])); //[0, 1, 2, 3, 4, 5, 6, 7]","title":"Set e Map"},{"location":"javascript/READMEV2/#map","text":"let map = new Map () map . set ( 'user1' , 'Cosimo' ); map . set ( 'user2' , 'Simone' ); console . log ( map ); //Map(2) { 'user1' => 'Cosimo', 'user2' => 'Simone' } console . log ( map . get ( 'user1' )); //Cosimo console . log ( map . has ( 'user1' )); //true map . delete ( 'user2' ); console . log ( map . has ( 'user2' )); //false map . clear (); //svuota la mappa console . log ( map . size ); //0 let map = new Map ([[ 'key1' , 1 ], [ 'key2' , 2 ]]); console . log ( map . get ( 'key1' )); //1 map . forEach (( value , key ) => { console . log ( key , value ); }) /* key1 1 key2 2 */","title":"Map"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/","text":"Libreria node.js SerialPort Libreria node.js SerialPort Link utili Primo script Leggere dati dalla seriale con SerialPort Script lato nodejs Costruttore SerialPort() parametro path parametro [, openOptions] parametro [, openCallback] Eventi SerialPort Evento open Evento data Sketch lato Arduino SerialPort parser parseInt applicato al Buffer SerialPort Lato Arduino Lato node.js Endianess? Trasmettere dati dalla seriale con SerialPort SerialPort.write() Esempio semplice di trasmissione dati con SerialPort Esempio avanzato di trasmissione dati con SerialPort Link utili Documentazione ufficiale Stream Interface Arduino & nodejs Primo script Il seguente script stamper\u00e0 una lista delle porte disponibili const SerialPort = require ( 'serialport' ) //Il metodo SerialPort.list() ritorna una promise che restituisce un array di PortInfo //SerialPort.list(): Promise<PortInfo[]> const USBarray = SerialPort . list (); USBarray . then (( res ) => { console . log ( res ); }). catch (( err ) => { console . log ( err ); }); [ { path: 'COM3' , manufacturer: 'Arduino LLC (www.arduino.cc)' , serialNumber: 'A413937353035101F0E0' , pnpId: 'USB\\\\VID_2341&PID_0042\\\\A413937353035101F0E0' , locationId: 'Port_#0001.Hub_#0002' , vendorId: '2341' , productId: '0042' } ] Potrebbe essere utilizzato per verificare che sia collegato arduino alla porta USB Leggere dati dalla seriale con SerialPort Uno script semplice per leggere dati dalla seriale \u00e8 il seguente: var SerialPort = require ( 'serialport' ); var port = new SerialPort ( 'COM3' , { baudRate : 115200 }); port . on ( 'data' , function ( data ) { console . log ( 'Data:' , data ); }); Come trasmettitore uso Arduino con il seguente sketch: uint8_t number_8 [ 2 ]; uint16_t number_16 = 0xA031 ; void setup (){ Serial . begin ( 115200 ); } void loop (){ number_8 [ 0 ] = number_16 & 0xFF ; number_8 [ 1 ] = ( number_16 >> 8 ); Serial . write ( number_8 , 2 ); delay ( 1000 ); } Il risultato che vedrai sar\u00e0: Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> .. Anche se a volte potrai vedere una cosa del tipo: Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 > Data: <Buffer a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Spieghier\u00f2 tutto in dettaglio qui sotto Script lato nodejs Riprendiamo lo script var SerialPort = require ( 'serialport' ); var port = new SerialPort ( 'COM3' , { baudRate : 115200 }); port . on ( 'data' , function ( data ) { console . log ( 'Data:' , data ); }); Costruttore SerialPort() In questo script chiamo il costruttore SerialPort() che ha una sintassi del tipo: new SerialPort ( path [, openOptions ] [, openCallback ]) parametro path E' una string che rappresenta la porta che vuoi aprire. Nei sistemi Linux o Mac sar\u00e0 qualcosa del tipo /dev/tty.XXX mentre nei sistemi Windows sar\u00e0 qualcosa del tipo COM1 . Nel nostro caso, la porta \u00e8 COM3 . Per verificare quale sia la porta puoi usare SerialPort.list() e trovi uno script funzionante qui oppure puoi verificarla all'interno dell'IDE arduino in Strumenti/porta oppure ancora dallo strumento Gestione dispositivi di windows parametro [, openOptions] E' un oggetto con le seguenti propriet\u00e0: /** * @typedef {Object} openOptions * @property {boolean} [autoOpen=true] Automatically opens the port on `nextTick`. * @property {number=} [baudRate=9600] The baud rate of the port to be opened. This should match one of the commonly available baud rates, such as 110, 300, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200. Custom rates are supported best effort per platform. The device connected to the serial port is not guaranteed to support the requested baud rate, even if the port itself supports that baud rate. * @property {number} [dataBits=8] Must be one of these: 8, 7, 6, or 5. * @property {number} [highWaterMark=65536] The size of the read and write buffers defaults to 64k. * @property {boolean} [lock=true] Prevent other processes from opening the port. Windows does not currently support `false`. * @property {number} [stopBits=1] Must be one of these: 1 or 2. * @property {string} [parity=none] Must be one of these: 'none', 'even', 'mark', 'odd', 'space'. * @property {boolean} [rtscts=false] flow control setting * @property {boolean} [xon=false] flow control setting * @property {boolean} [xoff=false] flow control setting * @property {boolean} [xany=false] flow control setting * @property {object=} bindingOptions sets binding-specific options * @property {Binding=} Binding The hardware access binding. `Bindings` are how Node-Serialport talks to the underlying system. Will default to the static property `Serialport.Binding`. * @property {number} [bindingOptions.vmin=1] see [`man termios`](http://linux.die.net/man/3/termios) LinuxBinding and DarwinBinding * @property {number} [bindingOptions.vtime=0] see [`man termios`](http://linux.die.net/man/3/termios) LinuxBinding and DarwinBinding */ A noi interessa in questa fase solo la propiet\u00e0: baudRate , quindi dovr\u00f2 passare un oggetto che sar\u00e0 fatto in questo modo: { baudRate : 115200 } Naturalmente il baud rate dovr\u00e0 essere sincronizzato con quello impostato lato trasmettitore che in questo caso \u00e8 Arduino. parametro [, openCallback] E' una callback che \u00e8 chiamata quando \u00e8 stabilit\u00e0 la conessione. Noi non utilizziamo in questo momento la callback ma pi\u00f9 avanti prevedo di utilizzarla per segnalare che la connessione \u00e8 stabilita type openCallback = ( Error | null ) = {} Eventi SerialPort La libreria SerialPort espone gli eventi open , error , close , data , drain . In node.js per mettersi in ascolto di un evento si utilizza il metodo .on() applicato alla classe EventEmitter . Nell'esempio, che riporto qui sotto mi metto in ascolto dell'evento data che restituisce come parametro della callback un Buffer che \u00e8 un array di dati. port . on ( 'data' , function ( data ) { console . log ( 'Data:' , data ); }); Vediamo adesso in dettaglio gli eventi utili come open e data Evento open L'evento open si verifica quando la porta \u00e8 aperta e quest si pu\u00f2 verificare subito dopo l'invocazione del costruttore SerialPort() attraverso l'opzione autoOpen che di default \u00e8 impostata a true oppure dopo il metodo manuale open() in caso autoOpen sia false Evento data Scatta questo evento quando vengono ricevuti dei dati. I dati sono un oggetto Buffer Sketch lato Arduino Riporto lo sketch uint8_t number_8 [ 2 ]; uint16_t number_16 = 0xA031 ; void setup (){ Serial . begin ( 115200 ); } void loop (){ number_8 [ 0 ] = number_16 & 0xFF ; number_8 [ 1 ] = ( number_16 >> 8 ); Serial . write ( number_8 , 2 ); delay ( 1000 ); } Lato Arduino viene inizializzata la porta seriale con un baud rate di 115200 e vengono trasmessi una coppia di byte attraverso Serial.write() . Avrei potuto inviare una stringa tramite Serial.print() ma per questa applicazione ho la necessit\u00e0 di trattare i dati di basso livello. Inoltre ho simulato una situazione in cui devo poter inviare dati numerici con una rappresentazione maggiore di 8 bit. In questo caso ho inviato un dato a 16 bit come un array di due byte SerialPort parser Riporto lo script lato node.js var SerialPort = require ( 'serialport' ); var port = new SerialPort ( 'COM3' , { baudRate : 115200 }); port . on ( 'data' , function ( data ) { console . log ( 'Data:' , data ); }); A volte pu\u00f2 capitare di vedere una cosa del tipo: Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 > Data: <Buffer a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Questo accade perch\u00e8 lato ricezione non si conosce quanto \u00e8 lungo il frame. Il seguente script, fa uso di un parser che raggruppa i byte con una lunghezza stabilita attraverso ByteLenght const SerialPort = require ( 'serialport' ) const ByteLength = require ( '@serialport/parser-byte-length' ) var port = new SerialPort ( 'COM3' , { baudRate : 115200 }); const parser = port . pipe ( new ByteLength ({ length : 2 })) parser . on ( 'data' , function ( data ) { console . log ( 'Data:' , data ); }); In questo modo si \u00e8 sicuri si quanti byte si attendono e il risultato all'interno del Buffer sar\u00e0 quello atteso: Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Se provi a cambiare la propriet\u00e0 lenght e metti ad esempio 8 vedrai: Data: <Buffer 31 a0 31 a0 31 a0 31 a0> Data: <Buffer 31 a0 31 a0 31 a0 31 a0> Data: <Buffer 31 a0 31 a0 31 a0 31 a0> Attenzione per\u00f2 che riceverai i dati ogni 4 secondi dal momento che Arduino invia due byte ogni secondo parseInt applicato al Buffer SerialPort Abbiamo visto come inviare e ricevere dei byte Arduino/node.js. Adesso voglio inviare da Arduino un numero intero a 16bit 50321 e voglio interpretarlo come intero lato nodejs, in pratica voglio inviare e ricevere un intero a 16 bit. Lato Arduino Lato Arduino non cambia quasi niente. - Ho sostituito number_16 con un numero rappresentato in decimale anzich\u00e8 in esadecimle. - Ho invertito la codifica della parte alta e della parte bassa, questo per motivi di endianess che spiegher\u00f2 pi\u00f9 avanti uint8_t number_8 [ 2 ]; uint16_t number_16 = 50321 ; void setup (){ Serial . begin ( 115200 ); } void loop (){ //number_8[0] = number_16 & 0xFF; //number_8[1] = (number_16 >> 8); number_8 [ 0 ] = ( number_16 >> 8 ); number_8 [ 1 ] = number_16 & 0xFF ; Serial . write ( number_8 , 2 ); delay ( 1000 ); } Lato node.js Lato node.js ho applicato il metodo parseInt al buffer. const SerialPort = require ( 'serialport' ) const ByteLength = require ( '@serialport/parser-byte-length' ) var port = new SerialPort ( 'COM3' , { baudRate : 115200 }); const parser = port . pipe ( new ByteLength ({ length : 2 })) parser . on ( 'data' , function ( data ) { console . log ( 'Data:' , parseInt ( data . toString ( 'hex' ), 16 )); }); Adesso vedrai stampato: Data: 50321 Data: 50321 Data: 50321 Data: 50321 Data: 50321 Data: 50321 Data: 50321 Data: 50321 Data: 50321 Data: 50321 Ovvero il valore trasmesso da Arduino. Endianess? Quando trasmetti e ricevi dei byte su un canale di trasmissione devi sempre assicurarti di fare le cose in maniera corretta. Mi riferisco all'ordine dei byte in trasmissione e di conseguenza di ricezione. E' naturale pensare che l'ordine debba essere coerente altrimenti in ricezione non \u00e8 possibile ricostruire i dati. Per questo mi sono reso conto, sbagliando (per fortuna!) che l'endianess era sbagliato solo inviando un intero e reinterpretandolo. Ho dovuto invertire quindi (lato Arduino) la parte bassa con la parte alta Trasmettere dati dalla seriale con SerialPort Per la trasmissione dati, si usa il metodo .write() . .write() scrive i dati sulla porta seriale specificata. Memorizza i dati scritti se la porta non \u00e8 aperta e li scrive dopo l'apertura della porta. L'operazione di scrittura non \u00e8 bloccante. Quando ritorna, i dati potrebbero non essere ancora stati scritti sulla porta seriale. Nota 1 - Apertura di una connessione e Arduino Molti dispositivi come Arduino si ripristinano quando apri una connessione ad essi. In questi casi, la scrittura immediata sul dispositivo causer\u00e0 la perdita dei dati trasmessi poich\u00e9 i dispositivi non saranno pronti a ricevere i dati. Questo viene spesso aggirato facendo in modo che Arduino invii un byte \"pronto\" che il programma Node attende prima di scrivere. Spesso puoi anche farla franca aspettando un importo prestabilito, circa 400 ms. Vedere ReadyParser per una soluzione a questo problema. Nota 2 - Gestione degli errori Se una porta viene disconnessa durante una scrittura, la scrittura produrr\u00e0 un errore oltre all'evento close Nota 3 - Gestione degli errori Se si verifica un errore, il callback pu\u00f2 o meno essere chiamato con l'errore come primo argomento. Per rilevare in modo affidabile gli errori di scrittura, aggiungi un listener per l'evento \"errore\". SerialPort.write() Prototipo del metodo .write() : serialport . write ( data : string | Buffer | Array < number > , encoding ?: string , callback ?: error => {}) : boolean Parametri: data : Pu\u00f2 essere una string , un Buffer o Array di number . encoding : E' un parametro opzionale di tipo string e rappresenta la codifica che pu\u00f2 essere utf8 , ascii , base64 , binary , hex callback : E' un parametro opzionale che rappresenta la callback chiamata al termine dell'operazione di scrittura. I dati potrebbero non essere ancora drenati nella porta sottostante. Tipo di ritorno Restituisce false se lo stream desidera che il codice chiamante attenda l'emissione dell'evento drain prima di continuare a scrivere dati aggiuntivi; altrimenti vero . Esempio semplice di trasmissione dati con SerialPort Vediamo un esempio semplice di trasmissione dati con SerialPort. - Creo un Buffer che contiene un solo byte del valore di 65 . - Per aggirare il problema del reset di Arduino all'apertura della connessione , vedi anche qui , mi metto in ascolto di un qualsiasi dato da Arduino aspettando l'evento data che poi stampo a video. - Solo in questo momento posso considerare stabilita la connessione quindi scrivo un dato, o meglio un byte dell'oggetto Buffer Naturalmente non \u00e8 una gestione ottimale ma volevo mantenere uno script semplice lato node.js var serialport = require ( \"serialport\" ); const buf = Buffer . from ([ 65 ]); var sp = new serialport ( 'COM3' , { baudRate : 115200 , }); sp . on ( 'data' , data => { console . log ( 'connection estabilished' ); console . log ( parseInt ( data . toString ( 'hex' ), 16 )); sp . write ( buf ); }); Lato Arduino invece trasmetto il dato 233 finch\u00e8 non verr\u00e0 letto da node.js che rappresenta lo stato READY di Arduino. Quando node.js legge il dato mandato da Arduino e invia il byte 65 . Arduino riceve il dato, smette di trasmettere il dato 233 e valuta il dato ricevuto da node.js. Se \u00e8 65 accende il LED, se non \u00e8 65 spegna il LED byte incomingByte [ 1 ]; // for incoming serial data bool isReadyTransimetted = false ; void setup () { Serial . begin ( 115200 ); // opens serial port, sets data rate to 9600 bps pinMode ( 13 , OUTPUT ); } void loop () { // send data only when you receive data: if ( Serial . available () > 0 ) { isReadyTransimetted = true ; // read the incoming byte: Serial . readBytes ( incomingByte , 1 ); if ( incomingByte [ 0 ] == 65 ){ digitalWrite ( 13 , HIGH ); } else { digitalWrite ( 13 , LOW ); } } else { if ( ! isReadyTransimetted ){ Serial . write ( 233 ); delay ( 1000 ); } } } Esempio avanzato di trasmissione dati con SerialPort Questo esempio sar\u00e0 un po' pi\u00f9 interessante rispetto all'esempio precedente. Con node.js far\u00f2 blinkare il LED di Arduino. Lato node.js ho creato due funzioni... var serialport = require ( \"serialport\" ); var byteFromArduino = '' ; let connectionEstabilished = false ; let varToggle = false ; const buf = Buffer . from ([ 65 ]); const buf2 = Buffer . from ([ 66 ]); var sp = new serialport ( 'COM3' , { baudRate : 115200 , }); function write () //for writing { if ( connectionEstabilished ){ if ( varToggle ){ console . log ( 'LED ON, pin 13' ); sp . write ( buf ); varToggle = ! varToggle ; } else { console . log ( 'LED OFF, pin 13' ); sp . write ( buf2 ); varToggle = ! varToggle ; } } } function waitForConnection (){ sp . on ( 'data' , function ( data ) { byteFromArduino = parseInt ( data . toString ( 'hex' ), 16 ); console . log ( byteFromArduino ); if ( byteFromArduino === 233 ){ console . log ( 'connection estabilished' ); connectionEstabilished = true ; } else { console . log ( 'connection not estabilished' ); connectionEstabilished = false ; } }); } sp . on ( 'open' , function () { // execute your functions waitForConnection (); setInterval ( write , 1000 ); });","title":"Libreria node.js SerialPort"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#libreria-nodejs-serialport","text":"Libreria node.js SerialPort Link utili Primo script Leggere dati dalla seriale con SerialPort Script lato nodejs Costruttore SerialPort() parametro path parametro [, openOptions] parametro [, openCallback] Eventi SerialPort Evento open Evento data Sketch lato Arduino SerialPort parser parseInt applicato al Buffer SerialPort Lato Arduino Lato node.js Endianess? Trasmettere dati dalla seriale con SerialPort SerialPort.write() Esempio semplice di trasmissione dati con SerialPort Esempio avanzato di trasmissione dati con SerialPort","title":"Libreria node.js SerialPort"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#link-utili","text":"Documentazione ufficiale Stream Interface Arduino & nodejs","title":"Link utili"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#primo-script","text":"Il seguente script stamper\u00e0 una lista delle porte disponibili const SerialPort = require ( 'serialport' ) //Il metodo SerialPort.list() ritorna una promise che restituisce un array di PortInfo //SerialPort.list(): Promise<PortInfo[]> const USBarray = SerialPort . list (); USBarray . then (( res ) => { console . log ( res ); }). catch (( err ) => { console . log ( err ); }); [ { path: 'COM3' , manufacturer: 'Arduino LLC (www.arduino.cc)' , serialNumber: 'A413937353035101F0E0' , pnpId: 'USB\\\\VID_2341&PID_0042\\\\A413937353035101F0E0' , locationId: 'Port_#0001.Hub_#0002' , vendorId: '2341' , productId: '0042' } ] Potrebbe essere utilizzato per verificare che sia collegato arduino alla porta USB","title":"Primo script"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#leggere-dati-dalla-seriale-con-serialport","text":"Uno script semplice per leggere dati dalla seriale \u00e8 il seguente: var SerialPort = require ( 'serialport' ); var port = new SerialPort ( 'COM3' , { baudRate : 115200 }); port . on ( 'data' , function ( data ) { console . log ( 'Data:' , data ); }); Come trasmettitore uso Arduino con il seguente sketch: uint8_t number_8 [ 2 ]; uint16_t number_16 = 0xA031 ; void setup (){ Serial . begin ( 115200 ); } void loop (){ number_8 [ 0 ] = number_16 & 0xFF ; number_8 [ 1 ] = ( number_16 >> 8 ); Serial . write ( number_8 , 2 ); delay ( 1000 ); } Il risultato che vedrai sar\u00e0: Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> .. Anche se a volte potrai vedere una cosa del tipo: Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 > Data: <Buffer a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Spieghier\u00f2 tutto in dettaglio qui sotto","title":"Leggere dati dalla seriale con SerialPort"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#script-lato-nodejs","text":"Riprendiamo lo script var SerialPort = require ( 'serialport' ); var port = new SerialPort ( 'COM3' , { baudRate : 115200 }); port . on ( 'data' , function ( data ) { console . log ( 'Data:' , data ); });","title":"Script lato nodejs"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#costruttore-serialport","text":"In questo script chiamo il costruttore SerialPort() che ha una sintassi del tipo: new SerialPort ( path [, openOptions ] [, openCallback ])","title":"Costruttore SerialPort()"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#parametro-path","text":"E' una string che rappresenta la porta che vuoi aprire. Nei sistemi Linux o Mac sar\u00e0 qualcosa del tipo /dev/tty.XXX mentre nei sistemi Windows sar\u00e0 qualcosa del tipo COM1 . Nel nostro caso, la porta \u00e8 COM3 . Per verificare quale sia la porta puoi usare SerialPort.list() e trovi uno script funzionante qui oppure puoi verificarla all'interno dell'IDE arduino in Strumenti/porta oppure ancora dallo strumento Gestione dispositivi di windows","title":"parametro path"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#parametro-openoptions","text":"E' un oggetto con le seguenti propriet\u00e0: /** * @typedef {Object} openOptions * @property {boolean} [autoOpen=true] Automatically opens the port on `nextTick`. * @property {number=} [baudRate=9600] The baud rate of the port to be opened. This should match one of the commonly available baud rates, such as 110, 300, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200. Custom rates are supported best effort per platform. The device connected to the serial port is not guaranteed to support the requested baud rate, even if the port itself supports that baud rate. * @property {number} [dataBits=8] Must be one of these: 8, 7, 6, or 5. * @property {number} [highWaterMark=65536] The size of the read and write buffers defaults to 64k. * @property {boolean} [lock=true] Prevent other processes from opening the port. Windows does not currently support `false`. * @property {number} [stopBits=1] Must be one of these: 1 or 2. * @property {string} [parity=none] Must be one of these: 'none', 'even', 'mark', 'odd', 'space'. * @property {boolean} [rtscts=false] flow control setting * @property {boolean} [xon=false] flow control setting * @property {boolean} [xoff=false] flow control setting * @property {boolean} [xany=false] flow control setting * @property {object=} bindingOptions sets binding-specific options * @property {Binding=} Binding The hardware access binding. `Bindings` are how Node-Serialport talks to the underlying system. Will default to the static property `Serialport.Binding`. * @property {number} [bindingOptions.vmin=1] see [`man termios`](http://linux.die.net/man/3/termios) LinuxBinding and DarwinBinding * @property {number} [bindingOptions.vtime=0] see [`man termios`](http://linux.die.net/man/3/termios) LinuxBinding and DarwinBinding */ A noi interessa in questa fase solo la propiet\u00e0: baudRate , quindi dovr\u00f2 passare un oggetto che sar\u00e0 fatto in questo modo: { baudRate : 115200 } Naturalmente il baud rate dovr\u00e0 essere sincronizzato con quello impostato lato trasmettitore che in questo caso \u00e8 Arduino.","title":"parametro [, openOptions]"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#parametro-opencallback","text":"E' una callback che \u00e8 chiamata quando \u00e8 stabilit\u00e0 la conessione. Noi non utilizziamo in questo momento la callback ma pi\u00f9 avanti prevedo di utilizzarla per segnalare che la connessione \u00e8 stabilita type openCallback = ( Error | null ) = {}","title":"parametro [, openCallback]"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#eventi-serialport","text":"La libreria SerialPort espone gli eventi open , error , close , data , drain . In node.js per mettersi in ascolto di un evento si utilizza il metodo .on() applicato alla classe EventEmitter . Nell'esempio, che riporto qui sotto mi metto in ascolto dell'evento data che restituisce come parametro della callback un Buffer che \u00e8 un array di dati. port . on ( 'data' , function ( data ) { console . log ( 'Data:' , data ); }); Vediamo adesso in dettaglio gli eventi utili come open e data","title":"Eventi SerialPort"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#evento-open","text":"L'evento open si verifica quando la porta \u00e8 aperta e quest si pu\u00f2 verificare subito dopo l'invocazione del costruttore SerialPort() attraverso l'opzione autoOpen che di default \u00e8 impostata a true oppure dopo il metodo manuale open() in caso autoOpen sia false","title":"Evento open"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#evento-data","text":"Scatta questo evento quando vengono ricevuti dei dati. I dati sono un oggetto Buffer","title":"Evento data"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#sketch-lato-arduino","text":"Riporto lo sketch uint8_t number_8 [ 2 ]; uint16_t number_16 = 0xA031 ; void setup (){ Serial . begin ( 115200 ); } void loop (){ number_8 [ 0 ] = number_16 & 0xFF ; number_8 [ 1 ] = ( number_16 >> 8 ); Serial . write ( number_8 , 2 ); delay ( 1000 ); } Lato Arduino viene inizializzata la porta seriale con un baud rate di 115200 e vengono trasmessi una coppia di byte attraverso Serial.write() . Avrei potuto inviare una stringa tramite Serial.print() ma per questa applicazione ho la necessit\u00e0 di trattare i dati di basso livello. Inoltre ho simulato una situazione in cui devo poter inviare dati numerici con una rappresentazione maggiore di 8 bit. In questo caso ho inviato un dato a 16 bit come un array di due byte","title":"Sketch lato Arduino"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#serialport-parser","text":"Riporto lo script lato node.js var SerialPort = require ( 'serialport' ); var port = new SerialPort ( 'COM3' , { baudRate : 115200 }); port . on ( 'data' , function ( data ) { console . log ( 'Data:' , data ); }); A volte pu\u00f2 capitare di vedere una cosa del tipo: Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 > Data: <Buffer a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Questo accade perch\u00e8 lato ricezione non si conosce quanto \u00e8 lungo il frame. Il seguente script, fa uso di un parser che raggruppa i byte con una lunghezza stabilita attraverso ByteLenght const SerialPort = require ( 'serialport' ) const ByteLength = require ( '@serialport/parser-byte-length' ) var port = new SerialPort ( 'COM3' , { baudRate : 115200 }); const parser = port . pipe ( new ByteLength ({ length : 2 })) parser . on ( 'data' , function ( data ) { console . log ( 'Data:' , data ); }); In questo modo si \u00e8 sicuri si quanti byte si attendono e il risultato all'interno del Buffer sar\u00e0 quello atteso: Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Data: <Buffer 31 a0> Se provi a cambiare la propriet\u00e0 lenght e metti ad esempio 8 vedrai: Data: <Buffer 31 a0 31 a0 31 a0 31 a0> Data: <Buffer 31 a0 31 a0 31 a0 31 a0> Data: <Buffer 31 a0 31 a0 31 a0 31 a0> Attenzione per\u00f2 che riceverai i dati ogni 4 secondi dal momento che Arduino invia due byte ogni secondo","title":"SerialPort parser"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#parseint-applicato-al-buffer-serialport","text":"Abbiamo visto come inviare e ricevere dei byte Arduino/node.js. Adesso voglio inviare da Arduino un numero intero a 16bit 50321 e voglio interpretarlo come intero lato nodejs, in pratica voglio inviare e ricevere un intero a 16 bit.","title":"parseInt applicato al Buffer SerialPort"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#lato-arduino","text":"Lato Arduino non cambia quasi niente. - Ho sostituito number_16 con un numero rappresentato in decimale anzich\u00e8 in esadecimle. - Ho invertito la codifica della parte alta e della parte bassa, questo per motivi di endianess che spiegher\u00f2 pi\u00f9 avanti uint8_t number_8 [ 2 ]; uint16_t number_16 = 50321 ; void setup (){ Serial . begin ( 115200 ); } void loop (){ //number_8[0] = number_16 & 0xFF; //number_8[1] = (number_16 >> 8); number_8 [ 0 ] = ( number_16 >> 8 ); number_8 [ 1 ] = number_16 & 0xFF ; Serial . write ( number_8 , 2 ); delay ( 1000 ); }","title":"Lato Arduino"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#lato-nodejs","text":"Lato node.js ho applicato il metodo parseInt al buffer. const SerialPort = require ( 'serialport' ) const ByteLength = require ( '@serialport/parser-byte-length' ) var port = new SerialPort ( 'COM3' , { baudRate : 115200 }); const parser = port . pipe ( new ByteLength ({ length : 2 })) parser . on ( 'data' , function ( data ) { console . log ( 'Data:' , parseInt ( data . toString ( 'hex' ), 16 )); }); Adesso vedrai stampato: Data: 50321 Data: 50321 Data: 50321 Data: 50321 Data: 50321 Data: 50321 Data: 50321 Data: 50321 Data: 50321 Data: 50321 Ovvero il valore trasmesso da Arduino.","title":"Lato node.js"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#endianess","text":"Quando trasmetti e ricevi dei byte su un canale di trasmissione devi sempre assicurarti di fare le cose in maniera corretta. Mi riferisco all'ordine dei byte in trasmissione e di conseguenza di ricezione. E' naturale pensare che l'ordine debba essere coerente altrimenti in ricezione non \u00e8 possibile ricostruire i dati. Per questo mi sono reso conto, sbagliando (per fortuna!) che l'endianess era sbagliato solo inviando un intero e reinterpretandolo. Ho dovuto invertire quindi (lato Arduino) la parte bassa con la parte alta","title":"Endianess?"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#trasmettere-dati-dalla-seriale-con-serialport","text":"Per la trasmissione dati, si usa il metodo .write() . .write() scrive i dati sulla porta seriale specificata. Memorizza i dati scritti se la porta non \u00e8 aperta e li scrive dopo l'apertura della porta. L'operazione di scrittura non \u00e8 bloccante. Quando ritorna, i dati potrebbero non essere ancora stati scritti sulla porta seriale. Nota 1 - Apertura di una connessione e Arduino Molti dispositivi come Arduino si ripristinano quando apri una connessione ad essi. In questi casi, la scrittura immediata sul dispositivo causer\u00e0 la perdita dei dati trasmessi poich\u00e9 i dispositivi non saranno pronti a ricevere i dati. Questo viene spesso aggirato facendo in modo che Arduino invii un byte \"pronto\" che il programma Node attende prima di scrivere. Spesso puoi anche farla franca aspettando un importo prestabilito, circa 400 ms. Vedere ReadyParser per una soluzione a questo problema. Nota 2 - Gestione degli errori Se una porta viene disconnessa durante una scrittura, la scrittura produrr\u00e0 un errore oltre all'evento close Nota 3 - Gestione degli errori Se si verifica un errore, il callback pu\u00f2 o meno essere chiamato con l'errore come primo argomento. Per rilevare in modo affidabile gli errori di scrittura, aggiungi un listener per l'evento \"errore\".","title":"Trasmettere dati dalla seriale con SerialPort"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#serialportwrite","text":"Prototipo del metodo .write() : serialport . write ( data : string | Buffer | Array < number > , encoding ?: string , callback ?: error => {}) : boolean Parametri: data : Pu\u00f2 essere una string , un Buffer o Array di number . encoding : E' un parametro opzionale di tipo string e rappresenta la codifica che pu\u00f2 essere utf8 , ascii , base64 , binary , hex callback : E' un parametro opzionale che rappresenta la callback chiamata al termine dell'operazione di scrittura. I dati potrebbero non essere ancora drenati nella porta sottostante. Tipo di ritorno Restituisce false se lo stream desidera che il codice chiamante attenda l'emissione dell'evento drain prima di continuare a scrivere dati aggiuntivi; altrimenti vero .","title":"SerialPort.write()"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#esempio-semplice-di-trasmissione-dati-con-serialport","text":"Vediamo un esempio semplice di trasmissione dati con SerialPort. - Creo un Buffer che contiene un solo byte del valore di 65 . - Per aggirare il problema del reset di Arduino all'apertura della connessione , vedi anche qui , mi metto in ascolto di un qualsiasi dato da Arduino aspettando l'evento data che poi stampo a video. - Solo in questo momento posso considerare stabilita la connessione quindi scrivo un dato, o meglio un byte dell'oggetto Buffer Naturalmente non \u00e8 una gestione ottimale ma volevo mantenere uno script semplice lato node.js var serialport = require ( \"serialport\" ); const buf = Buffer . from ([ 65 ]); var sp = new serialport ( 'COM3' , { baudRate : 115200 , }); sp . on ( 'data' , data => { console . log ( 'connection estabilished' ); console . log ( parseInt ( data . toString ( 'hex' ), 16 )); sp . write ( buf ); }); Lato Arduino invece trasmetto il dato 233 finch\u00e8 non verr\u00e0 letto da node.js che rappresenta lo stato READY di Arduino. Quando node.js legge il dato mandato da Arduino e invia il byte 65 . Arduino riceve il dato, smette di trasmettere il dato 233 e valuta il dato ricevuto da node.js. Se \u00e8 65 accende il LED, se non \u00e8 65 spegna il LED byte incomingByte [ 1 ]; // for incoming serial data bool isReadyTransimetted = false ; void setup () { Serial . begin ( 115200 ); // opens serial port, sets data rate to 9600 bps pinMode ( 13 , OUTPUT ); } void loop () { // send data only when you receive data: if ( Serial . available () > 0 ) { isReadyTransimetted = true ; // read the incoming byte: Serial . readBytes ( incomingByte , 1 ); if ( incomingByte [ 0 ] == 65 ){ digitalWrite ( 13 , HIGH ); } else { digitalWrite ( 13 , LOW ); } } else { if ( ! isReadyTransimetted ){ Serial . write ( 233 ); delay ( 1000 ); } } }","title":"Esempio semplice di trasmissione dati con SerialPort"},{"location":"javascript/examples-and-projects/Projects/nodejs-arduino/documents/serialport/#esempio-avanzato-di-trasmissione-dati-con-serialport","text":"Questo esempio sar\u00e0 un po' pi\u00f9 interessante rispetto all'esempio precedente. Con node.js far\u00f2 blinkare il LED di Arduino. Lato node.js ho creato due funzioni... var serialport = require ( \"serialport\" ); var byteFromArduino = '' ; let connectionEstabilished = false ; let varToggle = false ; const buf = Buffer . from ([ 65 ]); const buf2 = Buffer . from ([ 66 ]); var sp = new serialport ( 'COM3' , { baudRate : 115200 , }); function write () //for writing { if ( connectionEstabilished ){ if ( varToggle ){ console . log ( 'LED ON, pin 13' ); sp . write ( buf ); varToggle = ! varToggle ; } else { console . log ( 'LED OFF, pin 13' ); sp . write ( buf2 ); varToggle = ! varToggle ; } } } function waitForConnection (){ sp . on ( 'data' , function ( data ) { byteFromArduino = parseInt ( data . toString ( 'hex' ), 16 ); console . log ( byteFromArduino ); if ( byteFromArduino === 233 ){ console . log ( 'connection estabilished' ); connectionEstabilished = true ; } else { console . log ( 'connection not estabilished' ); connectionEstabilished = false ; } }); } sp . on ( 'open' , function () { // execute your functions waitForConnection (); setInterval ( write , 1000 ); });","title":"Esempio avanzato di trasmissione dati con SerialPort"},{"location":"nas/readme/","text":"Nas e TrueNAS (FreeNAS) Un Network Attached Storage (NAS) \u00e8 un dispositivo collegato alla rete la cui funzione \u00e8 quella di consentire agli utenti di accedere e condividere una memoria di massa, in pratica costituita da uno o pi\u00f9 dischi rigidi, all'interno della propria rete o dall'esterno. In questa guida vedremo come riutilizzare un vecchio PC con hardware ormai obsoleto per realizzare un NAS utilizzando TrueNAS (freenas) . TrueNAS (FreeNas) TrueNAS \u00e8 un sistema operativo open source che ti permette di realizzare un NAS utilizzando un PC. Installazione di TrueNAS Scarica l'immagine del sistema operativo TrueNAS da qui , il solito file con estensione .iso Scrivi l'immagine su una chiavetta usb da almeno 8GB. Puoi usare uno dei tanti tool come Rufus o balenaEtcher Riavvia il PC che vuoi utilizzare come NAS ed entra nel BIOS. Da qua dovrai inserire l'opzione di boot attraverso chiavette USB assicurandoti che non ci siano opzioni di sicurezza attive che impediscano il boot. Collega il PC tramite cavo Ethernet alla presa LAN della tua adsl e gli hard disk che vuoi utilizzare come memoria di archiviazione. Avvia il PC. Se la configurazione del bios \u00e8 corretta, dovrebbe partire la procedura di installazione di TrueNAS. La procedura di installazione \u00e8 molto semplice, c'\u00e8 solo un passaggio a cui prestare attenzione: la scelta del disco di installazione di TrueNAS. Infatti, il disco che utilizziamo per ospitare il sistema operativo non pu\u00f2 essere utilizzato per la condivisione ma sar\u00e0 riservato al sistema operativo. Inoltre, a un certo punto dell'installazione, vi chieder\u00e0 di scegliere una password per accedere come amministratore al NAS. Queste credenziali vi serviranno una volta che l'installazione sar\u00e0 completata per accedere alla web user interface e configurare il NAS. Qui sotto riporto alcune immagini della procedura di installazione Una volta terminata l'installazione, riavvia il PC assicurandoti di aver tolto la chiavetta USB con l'immagine di TrueNAS. In questo modo partir\u00e0 il sistema operativo dal disco su cui hai scelto di installare il sistema operativo. Dopo il boot, se tutto \u00e8 andato a buon fine, dovrebbe comparire l'indirizzo IP a cui sar\u00e0 accessibile la web user interface di TrueNAS. Digitando l'indirizzo IP su un motore di ricerca, comparir\u00e0 la pagina di accesso alla web user interface. L'username \u00e8 root mentre la password \u00e8 quella che hai impostato in fase di installazione. Configurazione Una volta che hai installato TrueNAS, hai l'indirizzo IP e sei entrato nella pagina principale della web user interface direi che \u00e8 il momento di configurare un disco per la condivisione. Si tratta di: creare un nuovo pool dal menu Storage/Pools creare un account che possa accedere alla memoria di condivisione, dal men\u00f9 Accounts/Users aggiungere il path di condivisione (ovvero la porzione del disco che si desidera condividere) dal men\u00f9 Sharing/Windows Shares(SBM) (se si desidera averne accesso da un account windows). Accesso","title":"Nas e TrueNAS (FreeNAS)"},{"location":"nas/readme/#nas-e-truenas-freenas","text":"Un Network Attached Storage (NAS) \u00e8 un dispositivo collegato alla rete la cui funzione \u00e8 quella di consentire agli utenti di accedere e condividere una memoria di massa, in pratica costituita da uno o pi\u00f9 dischi rigidi, all'interno della propria rete o dall'esterno. In questa guida vedremo come riutilizzare un vecchio PC con hardware ormai obsoleto per realizzare un NAS utilizzando TrueNAS (freenas) .","title":"Nas e TrueNAS (FreeNAS)"},{"location":"nas/readme/#truenas-freenas","text":"TrueNAS \u00e8 un sistema operativo open source che ti permette di realizzare un NAS utilizzando un PC.","title":"TrueNAS (FreeNas)"},{"location":"nas/readme/#installazione-di-truenas","text":"Scarica l'immagine del sistema operativo TrueNAS da qui , il solito file con estensione .iso Scrivi l'immagine su una chiavetta usb da almeno 8GB. Puoi usare uno dei tanti tool come Rufus o balenaEtcher Riavvia il PC che vuoi utilizzare come NAS ed entra nel BIOS. Da qua dovrai inserire l'opzione di boot attraverso chiavette USB assicurandoti che non ci siano opzioni di sicurezza attive che impediscano il boot. Collega il PC tramite cavo Ethernet alla presa LAN della tua adsl e gli hard disk che vuoi utilizzare come memoria di archiviazione. Avvia il PC. Se la configurazione del bios \u00e8 corretta, dovrebbe partire la procedura di installazione di TrueNAS. La procedura di installazione \u00e8 molto semplice, c'\u00e8 solo un passaggio a cui prestare attenzione: la scelta del disco di installazione di TrueNAS. Infatti, il disco che utilizziamo per ospitare il sistema operativo non pu\u00f2 essere utilizzato per la condivisione ma sar\u00e0 riservato al sistema operativo. Inoltre, a un certo punto dell'installazione, vi chieder\u00e0 di scegliere una password per accedere come amministratore al NAS. Queste credenziali vi serviranno una volta che l'installazione sar\u00e0 completata per accedere alla web user interface e configurare il NAS. Qui sotto riporto alcune immagini della procedura di installazione Una volta terminata l'installazione, riavvia il PC assicurandoti di aver tolto la chiavetta USB con l'immagine di TrueNAS. In questo modo partir\u00e0 il sistema operativo dal disco su cui hai scelto di installare il sistema operativo. Dopo il boot, se tutto \u00e8 andato a buon fine, dovrebbe comparire l'indirizzo IP a cui sar\u00e0 accessibile la web user interface di TrueNAS. Digitando l'indirizzo IP su un motore di ricerca, comparir\u00e0 la pagina di accesso alla web user interface. L'username \u00e8 root mentre la password \u00e8 quella che hai impostato in fase di installazione.","title":"Installazione di TrueNAS"},{"location":"nas/readme/#configurazione","text":"Una volta che hai installato TrueNAS, hai l'indirizzo IP e sei entrato nella pagina principale della web user interface direi che \u00e8 il momento di configurare un disco per la condivisione. Si tratta di: creare un nuovo pool dal menu Storage/Pools creare un account che possa accedere alla memoria di condivisione, dal men\u00f9 Accounts/Users aggiungere il path di condivisione (ovvero la porzione del disco che si desidera condividere) dal men\u00f9 Sharing/Windows Shares(SBM) (se si desidera averne accesso da un account windows).","title":"Configurazione"},{"location":"nas/readme/#accesso","text":"","title":"Accesso"},{"location":"python/","text":"Python Lezione 01 Prerequisiti Conoscenza di un linguaggio qualsiasi OOP come C++ o Javascript Corso Python Python \u00e8 un linguaggio di programmazione di pi\u00f9 \"alto livello\" rispetto alla maggior parte degli altri linguaggi, orientato a oggetti, adatto, tra gli altri usi, a sviluppare applicazioni distribuite, scripting, computazione numerica e system testing. Ideato da Guido van Rossum all'inizio degli anni novanta, il nome fu scelto per la passione dello stesso inventore verso i Monty Python e per la loro serie televisiva Monty Python's Flying Circus ed \u00e8 spesso paragonato a Ruby, Tcl, Perl, JavaScript, Visual Basic o Scheme Wikipedia - Python Installazione e setup Collegati alla pagina ufficiale di Python e installa la versione per il tuo sistema operativo. Installazione e setup - Linux Per i sistemi su base linux \u00e8 sufficiente digitare i seguenti comandi: sudo apt-get install python3 sudo apt-get install python3-pip Nota: Il modulo pip di Python permette la gestione e l'installazione di moduli esterni Per verificare la corretta installazione dell'interprete python digitare da terminale python3 . In questo modo apriremo inoltre la shell interattiva di python in cui sar\u00e0 possibile inserire direttamente del codice ed avere una risposta simultanea Configurazione di un IDE Un ottimo ambiente di sviluppo per Python \u00e8 Pycharm . Per questo corso ho preferito non utilizzare un IDE specifico come Pycharm ma uno con un target pi\u00f9 ad uso generale come Visual Studio Code con l'ausilio di un'estensione che possa supportare gli emmet (abbreviazioni intelligenti) per il linguaggio python e opzioni per il debug del codice. L'estension che ho installato si chiama Python ed \u00e8 quella che riporto nell'immagine animata qua sotto. Lezione 02 Primo script Ogni file python ha un'estensione .py . Per l'esecuzione di uno script python \u00e8 possibile lanciare il file creato con l'estensione .py (esempio test.py ) direttamente dal terminale digitando il comando per l'invocazione dell'interprete python python3 ad esempio python3 test.py all'interno della cartella contenente il file test.py oppure attraverso l'estensione appena installata per VS code Run/Start Debugging Ecco l'esecuzione del primo script python print ( 'ciao mondo' ) Aggiunta di moduli Per l'aggiunta di un modulo che rientra nella libreria standard python basta semplicemente digitare: import < nomeModulo > A volte tuttavia potremmo aver bisogno di un modulo non standard disponibile sul web. Per installarlo possiamo far ricorso al pacchetto pip che permette la gestione e l'installazione dei moduli aggiuntivi python. Supponiamo di voler scaricare il modulo PyPDF2 per la gestione dei PDF. Digitare da terminale pip install PyPDF2 Qualora si avessero dubbi sul nome del modulo o sul comando esatto, niente paura, il browser ci \u00e8 di supporto \u00f9 Lezione 03 Introduzione a webbrowser Il seguente script aprir\u00e0 una localit\u00e0 su google.maps digitata come input dall'utente. Utilizzeremo il comando input() che permette l'acquisizione dati da tastiera e la funzione open del modulo python webbrowser . La funzione open permette di aprire un certo url specificato come parametro tra gli apici. Il parametro \u00e8 quindi passato come una stringa e come tale valgono tutte le operazioni e i metodi applicabili su stringa tra cui l'operatore + utilizzato per concatenare due o pi\u00f9 stringhe . input() : consente l'acquisizione dati da tastiera dell'utente. webbrowser.open(myUrl) : Apre l'indirizzo web specificato dal parametro myUrl . Il parametro specificato viene passato come stringa + : Operatore di concatenazione stringhe Ecco lo script completo: import webbrowser destinazione = input () webbrowser . open ( 'https://www.google.com/maps' + '/place/' + destinazione ) E' possibile ridurre ancora il codice import webbrowser webbrowser . open ( 'https://www.google.com/maps' + '/place/' + input ()) Come rendo eseguibile un file python? Linux Aggiungere la seguente linea di codice in testa allo script: #!/usr/bin/env python3 Ad esempio: #!/usr/bin/env python3 import webbrowser webbrowser . open ( 'https://www.google.com/maps' + '/place/' + input ()) E' sufficiente rendere il file eseguibile (all'interno delle propriet\u00e0 del file sezione \"permessi\") e lanciarlo da terminale. Commenti # questo \u00e8 un commento e verr\u00e0 ignorato dall'interprete print ( 'ciao' ) Lezione 04 Introduzione al modulo PyPDF2 Il seguente script tratter\u00e0 l'elaborazione di file pdf. Saremo in grado quindi di generare un file pdf con nome predefinito \"Output.pdf\" che \u00e8 la copia della prima pagina di un pdf con nome \"input.pdf\" ricevuto in input Faremo uso del modulo aggiuntivo PyPDF2 da installare da terminale tramite il comando pip install PyPDF2 Utilizzeremo le funzioni standard Python di apertuta e chiusura file: - open(myFile, mode) : apre un file e lo restituisce come oggetto. - myfile indica il nome comprensivo del path del file da aprire - mode indica la modalit\u00e0 di apertura del file - mode = \"r\" modalit\u00e0 lettura - mode = \"rb\" modalit\u00e0 lettura binaria - mode = \"w\" modalit\u00e0 scrittura - mode = \"wb\" modalit\u00e0 scrittura binaria - close() : chiude un file aperto. \u00c8 necessario chiudere sempre i file aperti poich\u00e8 in alcuni casi, a causa del buffering, le modifiche apportate a un file potrebbero non essere visualizzate finch\u00e9 non si chiude il file. w3schools - Python open() Function w3schools - Python close() Function Del modulo aggiuntivo PyPDF2 utilizzeremo le classi: - PdfFileReader(myPdf) : Chiama il costruttore della classe PdfFileReader che inzializza in lettura il file oggetto pdf myPdf ricevuto come parametro e restituisce un'istanza della classe PdfFileReader The PdfFileReader Class Metodi - getPage(pageNumber) : restituisce una pagina in base al numero pageNumber passato come parametro PdfFileWriter() : Chiama il costruttore della classe PdfFileWriter() che inizializza in scrittura un file oggetto pdf e restituisce un'istanza della classe PdfFileWriter() The PdfFileWriter Class Metodi addPage(page) : Aggiunge una pagina PDF, all'istanza della classe PdfFileWriter a cui si applica il metodo. La pagina viene solitamente acquisita da un'istanza di PdfFileReader . write(myPdf) : Scrive (su disco, da ram a rom) la raccolta di pagine aggiunte a questo oggetto come file PDF, riceve come parametro l'oggetto pdf da scrivere, myPdf . Nota: Le \"funzioni/classi\" di un modulo devono essere invocate sempre specificando il nome del modulo. Esempio: import PyPDF2 pdfInput = open ( \"pdf/input.pdf\" , \"rb\" ) #PyPDF2 \u00e8 il nome del modulo, PdfFileReader \u00e8 il nome della classe del modulo PyPDF2 reader1 = PyPDF2 . PdfFileReader ( pdfInput ) Script completo import PyPDF2 #Apro il file <input.pdf> all'interno della cartella <pdf> in modalit\u00e0 lettura binaria #Restituisco un oggetto all'interno della variabile <pdfInput> pdfInput = open ( \"pdf/input.pdf\" , \"rb\" ) #Restituisco un'istanza della classe <PdfFileReader> all'interno della variabile <reader1> reader1 = PyPDF2 . PdfFileReader ( pdfInput ) #apro un file <Output.pdf> all'interno della cartella <pdf> in modalit\u00e0 scrittura binaria #Restituisco un oggetto all'interno della variabile <pdfOutput> pdfOutput = open ( \"pdf/Output.pdf\" , \"wb\" ) #Restituisco un'istanza della classe <PyPDF2.PdfFileWriter> all'interno della variabile <writer1> writer1 = PyPDF2 . PdfFileWriter () #Prelevo la pagina numero <0> e ritorno un oggetto pdf di una pagina all'interno della variabile <pag0> pag0 = reader1 . getPage ( 0 ) #Aggiungo in coda pag0 all'istanza <writer1> (della classe PdfFileWriter) #Ripeto l'operazione per tre volte writer1 . addPage ( pag0 ) writer1 . addPage ( pag0 ) writer1 . addPage ( pag0 ) #Scrittura su disco dell'istanza della classe <writer1> su <pdfOutput> l'oggetto in scrittura corrispondente a \"Output.pdf\" writer1 . write ( pdfOutput ) #aChiudo i File pdfInput . close () pdfOutput . close () Lezione 05 Costrutto condizionale if...else Le istruzioni condizionali vengono utilizzate per eseguire un blocco di codice solo nel caso in cui una condizione risulti true o false Sintassi costrutto if esteso: if condition1 : #code 01 #.. elif condition2 : #code 02 #.. else : #code 03 #.. Esempio: print ( \"Inserisci due numeri..) primoValore = input () secondoValore = input () if a > b : print ( \"Il primo valore inserito, \" + primoValore + \" \u00e8 maggiore del secondo valore inserito, \" + secondoValore ) elif b > a : print ( \"Il secondo valore inserito, \" + secondoValore + \" \u00e8 maggiore del primo valore inserito, \" + primoValore ) else : print ( \"i due valori inseriti sono uguali\" ) Notare che per il costrutto if in python, la condition \u00e8 priva di parentesi tonde ( ) comuni invece a molti altri linguaggi di programmazione; l'operatore : \u00e8 usato come terminatore della condition e l'indentazione \u00e8 necessaria per racchiudere la porzione di codice condizionato da if . Lezione 06 Costrutto iterativo for Un ciclo for viene utilizzato per iterare su una sequenza (che pu\u00f2 essere una lista, una tupla, un dizionario, un insieme o una stringa). \u00c8 meno simile alla keyword for in altri linguaggi di programmazione e funziona pi\u00f9 come un metodo iteratore che si trova in altri linguaggi di programmazione orientati agli oggetti. w3schools - Python For Loops Sintassi: #Sintassi 1: for target_list in expression_list : #code Esempio: for numero in [ 1 , 2 , 3 , 4 , 5 ]: print ( numero * numero ) # 1 # 4 # 9 # 16 # 25 for frutto in [ \"banana\" , \"mela\" , \"pera\" ]: print ( frutto ) # banana # mela # pera Indentazione Python Il linguaggio python, a differenza di altri linguaggi come C/C++, Javascript .. Non utilizza delimitatori di blocco codice come { } ma si affida alla semplice indentazione . Rende quindi indispensabile l'uso di un buon editor di testo per evitare problemi di sintassi o semantica (in alcuni casi nemmeno troppo rari). Non utilizza neanche un terminatore di statement come il classico ; ma si affida al carattere a capo . L'interprete python comunque \u00e8 in grado di rilevare errori sintattici di indentazione e segnalarlo. range() Function Per iterare un insieme di codice un numero di volte specificato, possiamo usare la funzione range () . La funzione range (number) restituisce una sequenza di numeri, a partire da 0 per impostazione predefinita, incrementa di 1 (per impostazione predefinita) e termina con un numero specificato tramite il parametro number . In realt\u00e0 termina con il numero number - 1 . La funzione range () pu\u00f2 accettare 1, 2 o 3 parametri: range(number) : un parametro , genera una lista numerica incrementale nel range 0 - number-1 range(numberStart, numberEnd) : due parametri , genera una lista numerica incrementale nel range numberStart - numberEnd-1 range(numberStart, numberEnd, step) : tre parametri , genera una lista numerica con incremento pari a step nel range massimo numberStart - numberEnd-1 w3schools - The range() Function range ( 5 ) #[0, 1, 2, 3, 4] range ( 1 , 5 ) #[1, 2, 3, 4] range ( 1 , 5 , 2 ) #[1, 3] for target_list in range ( number ): #code # range(number) costruisce una lista da 0 a number-1 for numero in range ( 5 ): print ( numero * numero ) # 0 # 1 # 4 # 9 # 16 for numero in range ( 1 , 5 , 2 ): print ( numero ) # 1 # 3 Nel seguente esempio specifico alla funzione print() di non utilizzare il terminatore di default a capo rendendo nullo l'attributo end print ( end = \"\" ) Esempio: for numero in range ( 5 ): print ( str ( numero ) + \":\" , end = \"\" ) print ( numero * numero ) # 0:0 # 1:1 # 2:4 # 3:9 # 4:16 Lezione 07 PyPDF2 - Copia PDF Il seguente script prende in input un pdf \"input.pdf\" e ne produce una copia sul file \"Output.pdf\" Faremo uso della propriet\u00e0 della classe PdfFileReader : - numPages : Restituisce il numero delle pagine del file pdf dell'istanza (della classe PdfFileReader ) si cui si legge la propriet\u00e0 import PyPDF2 pdfInput = open ( \"pdf/input.pdf\" , \"rb\" ) reader1 = PyPDF2 . PdfFileReader ( pdfInput ) pdfOutput = open ( \"pdf/Output.pdf\" , \"wb\" ) writer1 = PyPDF2 . PdfFileWriter () #Copia delle pagine dell'oggetto (classe) pdf <reader1> nell'oggetto (classe) pdf <writer1> for numeroPagina in range ( reader1 . numPages ): page = reader1 . getPage ( numeroPagina ) writer1 . addPage ( page ) writer1 . write ( pdfOutput ) #aChiudo i File pdfInput . close () pdfOutput . close () PyPDF2 - Merge All pdf Il seguente script unisce tutti i file pdf presenti nella root directory salvandoli con un nome stabilito dall'utente. Faremo uso di: - Modulo os \u00e8 un modulo che contiene funzioni per interagire con il sistema operativo per la manipolazione di file e processi, os \u2014 Miscellaneous operating system interfaces . Nota: Per questo esercizio importeremo solo il metodo listdir() del modulo os: from os import listdir listdir(path) : Metodo del modulo os . Elenca file e cartelle specificate nella path-directory come parametro. Se non viene specificato nessun parametro restituisce i file della root-directory. Viene restituita una lista Python3 os.listdir () method Metodi su stringa endswith(myString) : Restituisce true se la stringa a cui applichiamo il metodo termina con la stringa indicata come parametro, myString Altre funzionalit\u00e0 del modulo PyPDF2 . - classe PdfFileMerger : Inizializza un oggetto PdfFileMerger . PdfFileMerger unisce pi\u00f9 PDF in un unico PDF. Restituisce un'istanza della classe PdfFileMerger , PyPDF2 - The PdfFileMerger Class . - metodo append(myPDF) della classe PdfFileMerger : Concatena tutte le pagine di un oggetto PDF passato come parametro, myPDF , alla fine del file PDF a cui si applica il metodo Riporto lo script completo: #Merge all pdf files from os import listdir import PyPDF2 print ( \"**********************************************\" ) print ( \"Unisco i file pdf presenti in questa directory\" ) print ( \"**********************************************\" ) #Non devo specificare <os.listdir> poich\u00e8 ho spcificato l'importazione <from os import listdir> #Se avessi usato <import os> avrei dovuto scrivere <os.listdir> #listdir restituisce file e cartelle in formato <lista> listaFiles = listdir () for nomeFile in listaFiles : if nomeFile . endswith ( '.pdf' ): print ( nomeFile ) print ( ' \\n ' ) #chiedo all'utente come vuole chiamare il file di output print ( \"Salvo il risultato con il nome:\" ) nomeFileDestinazione = input () #Apro il file in scrittura binaria PDF_Destinazione = open ( nomeFileDestinazione , \"wb\" ) print ( ' \\n ' ) merger = PyPDF2 . PdfFileMerger () print ( \"Elaborazione di..\" ) for nomeFile in listaFiles : #Elaboro solo i file con estensione \".pdf\" if nomeFile . endswith ( '.pdf' ): #stampo il nome del file print ( nomeFile ) #lo apro in lettura binaria pdfFileInput = open ( nomeFile , \"rb\" ) #creo un'istanza della classe <PdfFileReader> sul file appena aperto PDF_Reader = PyPDF2 . PdfFileReader ( pdfFileInput ) #Appendo il file PDF in coda all'oggetto merger merger . append ( PDF_Reader ) #chiudo il file aperto pdfFileInput . close () print ( ' \\n ' ) #Operazione di scrittura print ( \"Scrittura su: \" + nomeFileDestinazione ) merger . write ( PDF_Destinazione ) PDF_Destinazione . close () print ( \"Finito..\" ) Lezione 08 Liste Abbiamo gi\u00e0 visto implicitamente un'introduzione al tipo lista e in particolare come creare e iterare sugli elementi di una lista attraverso il ciclo for e la funzione range() . Il tipo dato lista \u00e8 molto importante nel linguaggio python. Le liste sono un tipo di dato utilizzato per memorizzare diversi elementi in una singola variabile. Le liste sono uno dei 4 tipi di dati incorporati in Python utilizzati per memorizzare raccolte di dati, gli altri 3 sono Tuple, Set e Dictionary, tutti con qualit\u00e0 e utilizzo diversi. Vediamo le caratteristiche principali delle liste: Le liste possono contenere qualsiasi tipo di dato Gli elementi della lista sono indicizzati, il primo elemento ha indice [0], il secondo elemento ha indice [1] .. A differenza della maggior parte dei linguaggi si possono usare anche indici negativi, [-1] si riferisce all'ultimo elemento, [-2] si riferisce al penultimo elemento ecc. Gli elementi in una lista sono ordinati e l'ordine \u00e8 stabilito dall'indice. Dopo la creazione, \u00e8 possibile aggiungere elementi, cambiare il valore degli elementi gi\u00e0 esistenti o rimuoverli Dal momento che le liste sono indicizzate \u00e8 possibile avere elementi duplicati La funzione len() ritorna il numero degli elementi presenti in una lista L'operatore [::] permette lo slicing di liste ovvero la creazione di porzioni di liste a partire dalla lista a cui si applica l'operatore [::] w3schools - Python Lists Accesso agli elementi di una lista L'accesso agli elementi di una lista si effettua tramite l'operatore [] #indici 0 1 2 3 4 #indici -5 -4 -3 -2 -1 myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] print ( myList [ 2 ]) #mela print ( myList [ - 1 ]) #cachi print ( len ( myList )) #5 Modifica del valore degli elementi in una lista. Per cambiare il valore degli elementi in una lista si utilizza l'operatore [] #indici 0 1 2 3 4 #indici -5 -4 -3 -2 -1 myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList [ - 1 ] = \"arancia\" myList [ 2 ] = \"pera\" print ( myList ) myList [ 1 : 3 ] = [ \"mandorla\" , \"nocciola\" ] print ( myList ) Aggiunta di elementi in una lista Sono disponibili i metodi: append(elem) : Appende elem in coda alla lista insert(index, elem) : Inserisce (senza nessun replace) elem alla posizione index facendo scalare di una posizione gli elementi dalla posizione index extend(otherList) : Appende in coda gli elementi della lista passata come parametro, otherList myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList2 = [ \"mandorla\" , \"nocciola\" , \"noce\" ] myList . append ( \"anguria\" ) print ( myList ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi', 'anguria'] myList . insert ( 2 , \"melone\" ) print ( myList ) #['banana', 'kiwi', 'melone', 'mela', 'mandarino', 'cachi', 'anguria'] myList . extend ( myList2 ) print ( myList ) #['banana', 'kiwi', 'melone', 'mela', 'mandarino', 'cachi', 'anguria', 'mandorla', 'nocciola', 'noce'] Rimozione di elementi in una lista Sono disponibili i metodi: remove(elem) : Toglie elem dalla lista pop(?index) : Toglie l'elemento corrispondente all'indice index passato come parametro opzionale. Se non viene passato nessun parametro toglie l'ultimo elemento. E' possibile ottenere questo risultato anche con il comando del , specificando l'elemento, del myList[index] clear() : Svuota la lista. La lista esiste ma \u00e8 vuota. E' possibile ottenere questo risultato anche con il comando del specificando il nome della lista del myList ma in questo caso elimina anche l'identificatore myList = [ 'banana' , 'kiwi' , 'melone' , 'mela' , 'mandarino' , 'cachi' , 'anguria' , 'mandorla' , 'nocciola' , 'noce' ] myList . remove ( \"mandarino\" ) print ( myList ) #['banana', 'kiwi', 'melone', 'mela', 'cachi', 'anguria', 'mandorla', 'nocciola', 'noce'] myList . pop ( 2 ) print ( myList ) #['banana', 'kiwi', 'mela', 'cachi', 'anguria', 'mandorla', 'nocciola', 'noce'] myList . pop () print ( myList ) #['banana', 'kiwi', 'mela', 'cachi', 'anguria', 'mandorla', 'nocciola'] del myList [ 0 ] print ( myList ) #['kiwi', 'mela', 'cachi', 'anguria', 'mandorla', 'nocciola'] myList . clear () print ( myList ) #[] myList = [ 'banana' , 'kiwi' , 'melone' , 'mela' , 'mandarino' , 'cachi' , 'anguria' , 'mandorla' , 'nocciola' , 'noce' ] del myList print ( myList ) #NameError: name 'myList' is not defined Creazione di sotto liste, slicing Sintassi: mySubList = myList[?startIndex: ?endIndex: ?Step] : Ritorna una sotto lista a partire dalla lista a cui si applica lo slicing ( myList ). L'operatore [] pu\u00f2 ricevere tre parametri opzionali separati da : . Il primo rappresenta l'indice di partenza (incluso), il secondo l'indice di fine (non incluso) e il terzo il passo. Se il primo parametro non \u00e8 specificato si assume 0 come valore di partenza. Se il secondo parametro non \u00e8 specificato si assume len(myList) - 1 come valore di fine cio\u00e8 l'ultimo elemento della lista. Se il terzo parametro non \u00e8 specificato si assume un incremento positivo unitario #indici 0 1 2 3 4 #indici -5 -4 -3 -2 -1 myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] mySubList = myList [ 1 :] print ( mySubList ) #['kiwi', 'mela', 'mandarino', 'cachi'] mySubList = myList [ - 2 :] print ( mySubList ) #['mandarino', 'cachi'] mySubList = myList [ 2 : 4 ] print ( mySubList ) #['mela', 'mandarino'] mySubList = myList [:: 2 ] print ( mySubList ) #['banana', 'mela', 'cachi'] #Restituisce una copia <non profonda> di una lista #Non valido per liste annidate mySubList = myList [:] print ( mySubList ) #[\"banana\", \"kiwi\", \"mela\", \"mandarino\", \"cachi\"] #Ordinamento inverso mySubList = myList [:: - 1 ] print ( mySubList ) #['cachi', 'mandarino', 'mela', 'kiwi', 'banana'] Lezione 09 Copia di Liste Abbiamo visto nel paragrafo precedente che per la copia di liste \u00e8 sufficiente utilizzare l'operatore [:] ma che non vale per liste annidate. In questa lezione approfondiremo l'operazione di copia di elementi. Copia semplice, valida per liste non annidate: myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList2 = myList [:] print ( myList ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi'] print ( myList2 ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi'] Cosa succede se eseguo la copia tramite il semplice assegnamento? myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList2 = myList print ( myList ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi'] print ( myList2 ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi'] Sfruttando quindi l'operatore di assegnamento = non ottengo una copia dei valori ma una copia dei riferimenti. In pratica in questo modo myList e myList2 condividono gli stessi dati. Se modifico uno modifico anche l'altro myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList2 = myList #Togliendo l'elemento da \"myList\" lo tolgo anche da \"myList2\" perch\u00e8 condividono gli stessi elementi myList . remove ( \"banana\" ) print ( myList ) #['kiwi', 'mela', 'mandarino', 'cachi'] # !!! print ( myList2 ) #['kiwi', 'mela', 'mandarino', 'cachi'] Ci\u00f2 non accade con la copia poich\u00e8 diventano due liste indipendenti: myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList2 = myList [:] myList . remove ( \"banana\" ) print ( myList ) #['kiwi', 'mela', 'mandarino', 'cachi'] print ( myList2 ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi'] Attenzione! Per liste pi\u00f9 complicate come liste annidate l'operatore [:] non pu\u00f2 essere utilizzato per la copia perch\u00e8 effettuerebbe una copia per riferimento degli elementi annidati. In generale per effettuare una copia ricorsiva e profonda \u00e8 necessario utilizzare la funzione deepcopy() del modulo copy . Per liste annidate l'operatore [:] fallisce: myList = [ \"banana\" , \"kiwi\" , \"mela\" , [ 1 , 2 ], \"cachi\" ] myList2 = myList [:] myList . remove ( \"banana\" ) myList2 [ 3 ][ 0 ] = 12 # !!! la scrittura su myList2 ha scritto anche myList perch\u00e8 la lista annidata \u00e8 stata copiata per riferimento print ( myList ) #['kiwi', 'mela', [12, 2], 'cachi'] print ( myList2 ) #'banana', 'kiwi', 'mela', [12, 2], 'cachi'] deepcopy() Per la copia di liste e qualsiasi altro oggetto \u00e8 possibile ed \u00e8 consigliabile utilizzare una funzione deepcopy() del modulo copy che esegue una copia profonda quindi considera anche oggetti e liste annidate import copy myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList2 = copy . deepcopy ( myList ) myList . remove ( \"banana\" ) print ( myList ) #['kiwi', 'mela', 'mandarino', 'cachi'] print ( myList2 ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi'] La funzione deepcopy() \u00e8 l'unica che eseegue in modo affidabile la copia di elementi considerando eventuali elementi annidati. import copy myList = [ \"banana\" , \"kiwi\" , \"mela\" , [ 1 , 2 ], \"cachi\" ] myList2 = copy . deepcopy ( myList ) myList . remove ( \"banana\" ) myList2 [ 3 ][ 0 ] = 12 print ( myList ) #['kiwi', 'mela', [1, 2], 'cachi'] print ( myList2 ) #['banana', 'kiwi', 'mela', [12, 2], 'cachi'] Lezione 10 Le stringe Le stringhe sono un tipo di dato immutabile in python Questo significa che la copia di stringhe pu\u00f2 essere fatta attraverso l'assegnamento tra i nomi (contrariamente a quanto accade per altri linguaggi come C++) poich\u00e8 quando viene creata una copia tramite l'assegnamento non viene copiato il riferimento della stringa ma l'intero oggetto stringa. s1 = \"ciao\" s2 = s1 s2 = \"ciaociao\" print ( s2 ) #ciaociao print ( s1 ) #ciao Ecco una dimostrazione approfondita andando ad scavare tra gli indirizzi in memoria con la funzione id s1 = \"ciao\" print ( id ( s1 )) #140440511029104 s2 = s1 print ( id ( s2 )) #140440511029104 s2 = \"ciaociao\" print ( id ( s2 )) #140440511029168 print ( s2 ) #ciaociao print ( s1 ) #ciao Attenzione Eseguendo la copia s2 = s1 ancora non si assegna ad s2 un nuovo indirizzo in memoria per motivi di efficienza. Lo si assegna quando ad s2 si assegna un nuovo valore Interpolazione di stringhe - Metodo format() Il metodo format() applicabile alle stringhe consente di inserire espressioni valutabili all'interno di stringhe w3schools - Python String format() Method . Il metodo format() formatta i valori specificati e li inserisce all'interno del segnaposto della stringa. Il segnaposto viene definito utilizzando le parentesi graffe: {}. Esempio: #sintassi 1 txt = \"1Kg di sale da cucina a solo {price} euro!\" print ( txt . format ( price = 2 )) #1Kg di sale da cucina a solo 2 euro! #sintassi 2 txt = \"1Kg di sale da cucina a solo {0} euro! Rimasti {1} pezzi\" print ( txt . format ( 2 , 500 )) #1Kg di sale da cucina a solo 2 euro! Rimasti 500 pezzi Esiste anche una sintassi leggermente diversa: myList = [ \"dentista\" , \"17:00\" ] print ( f \"Evento: { myList [ 0 ] } - Ora: { myList [ 1 ] } \" ) #Evento: dentista - Ora: 17:00 Lezione 11 PyPDF2 - Merge All pdf v2 Questa \u00e8 una versione migliorata dello script Merge All pdf . Aggiunge dei controlli sull'estensione del file e sulla natura del file. Controlla infatti se un file termina con formati \"strani\" come \".pdF\", \"PDf\" considerandoli comunque validi e controlla eventuali falsi file trappola come cartella che termina con estensione \".pdf\". Faremo uso di: os.path.isfile(path+file) : Ritorna true se il file specificato come parametro (eventualmente con un path relativo o assoluto) \u00e8 realmente un file. Metodo su stringhe .upper() : Ritorna una copia della stringa a cui si applica il metodo in caratteri maiscoli chaining condition and : Permette la concatenazione di condizioni logiche. Ritorna true se tutte le condizioni concatenate sono true Script completo e migliorato import PyPDF2 import os print ( \"**********************************************\" ) print ( \"Unisco i file pdf presenti in questa directory\" ) print ( \"**********************************************\" ) listaFiles = os . listdir () for nomeFile in listaFiles : if nomeFile . endswith ( '.pdf' ): print ( nomeFile ) print ( ' \\n ' ) #chiedo all'utente come vuole chiamare il file di output print ( \"Salvo il risultato con il nome:\" ) nomeFileDestinazione = input () #Apro il file in scrittura binaria PDF_Destinazione = open ( nomeFileDestinazione , \"wb\" ) print ( ' \\n ' ) merger = PyPDF2 . PdfFileMerger () print ( \"Elaborazione di..\" ) for nomeFile in listaFiles : #Elaboro solo i file con estensione \".pdf\" o \"PDF\" o \"PdF\" .. if os . path . isfile ( nomeFile ) and nomeFile . upper () . endswith ( '.PDF' ): #stampo il nome del file print ( nomeFile ) #lo apro in lettura binaria pdfFileInput = open ( nomeFile , \"rb\" ) #creo un'istanza della classe <PdfFileReader> sul file appena aperto PDF_Reader = PyPDF2 . PdfFileReader ( pdfFileInput ) #Appendo il file PDF in coda all'oggetto merger merger . append ( PDF_Reader ) #chiudo il file aperto pdfFileInput . close () print ( ' \\n ' ) #Operazione di scrittura print ( \"Scrittura su: \" + nomeFileDestinazione ) merger . write ( PDF_Destinazione ) PDF_Destinazione . close () print ( \"Finito..\" ) Lezione 12 Introduzione alla manipolazione dei docx Con il seguente script inizieremo a manipolare i docx Da terminale puoi installare il modulo per la manipolazione dei docx con il comando: pip install python-docx Importa il modulo \"python-docx\" all'interno del tuo script con: import docx La documentazione ufficiale del modulo \"python-docx\" la puoi trovare su docx - documentazione . Del modulo \"python-docx\" utilizzeremo: docx.Document(docxFile) : Chiama il costruttore della classe Document passando come parametro di inizializzazione il file \"docx\" che intendiamo elaborare. Ritorna un'istanza della classe Document Metodo sections della classe Document : applicato a un'istanza della classe Document restituisce le sezioni del documento \"docx\"- Metodo paragraphs della classe Document : applicato a un'istanza della classe Document restituisce una lista dell'oggetto Paragraph Metodo text della classe Paragraph : applicato a un'istanza della classe Paragraph restituisce il testo di un paragrafo Utilizzeremo anche l'operatore * su stringa che permette di generare una ripetizione della stringa a cui si applica l'operatore. print ( \"ciao \" * 2 + \"!\" ) #ciao ciao ! Script completo: #Manipolazione docx import docx divina = docx . Document ( \"divina1.docx\" ) sezioni = divina . sections print ( \"il documento contine:\" ) #Utile quando ci sono diversi valori da valutare print ( \"- {0} sezioni\" . format ( len ( sezioni ))) #altrenativa >>> print(str( len(sezioni) ) + \" sezioni\" ) paragrafi = divina . paragraphs print ( \"- {0} paragrafi\" . format ( len ( paragrafi ))) #4 sezioni print ( \" \\n Stampo i paragrafi..\" ) print ( \"-\" * 50 ) #Per ogni elemento p estratto dalla lista paragrafi.. for p in paragrafi : #p.text restituisce il testo di un paragrafo print ( p . text ) #questo metodo su stringa genera una ripetizione print ( \"-\" * 50 ) Lezione 13 Python while() Con il ciclo while possiamo eseguire un insieme di istruzioni fintanto che una condizione \u00e8 vera. w3schools - Python While Loops Sintassi: while condition : #code Esempio: i = 1 while i < 6 : #1 < 6, true #2 < 6, true #3 < 6, true #4 < 6, true #5 < 6, true #6 < 6, false -> exit print ( i ) #1 #2 #3 #4 #5 i = i + 1 #i = 2 #i = 3 #i = 4 #i = 5 #i = 6 # 1 # 2 # 3 # 4 # 5 Comando break Con l'istruzione break possiamo interrompere il ciclo anche se la condizione while \u00e8 vera: Sintassi: while condition : #code #code #.. break #esce Esempio: i = 1 while i < 6 : #1 < 6, true #2 < 6, true print ( i ) #1 #2 i = i + 1 #i = 2 #i = 3 if i == 3 : #i = 2, false #i = 3, true -> exit break # 1 # 2 Con i cicli c'\u00e8 sempre da tenere in considerazione quando viene effettuato il controllo delle condizioni di uscita ed entrata del ciclo e la sequenza con cui vengono eseguite le istruzioni all'interno del ciclo. Leggendo l'esempio di sopra non \u00e8 chiaro se il programmatore con la condizione i == 3 vuole che venga stampato il numero 3 oppure no. Un'ottima strategia \u00e8 quella di inserire tutte le condizioni di uscita del ciclo all'inizio ed eventuali istruzioni di controllo ciclo alla fine. Al centro del ciclo andranno tutte le istruzioni che verranno eseguite nel caso standard i = 1 while i < 6 : #1 < 6, true #2 < 6, true #3 < 6 #Condizione di uscita ciclo if i == 3 : #i = 1, false #i = 2, false #i = 3, true -> exit break print ( i ) #1 #2 #Condizione di controllo ciclo i = i + 1 #i = 2 #i = 3 # 1 # 2 Comando continue Con l'istruzione continue possiamo interrompere l'iterazione corrente e continuare con la successiva Sintassi: while condition : #code #code #.. continue #esce Esempio i = 1 while i < 6 : #1 < 6, true #2 < 6, true #3 < 6, true #4 < 6, true #5 < 6, true #6 < 6, false -> exit if i == 3 : #i = 1, false #i = 2, false #i = 3, true #i = 4, false #i = 5, false print ( \"Numero \" + i ) #Numero 3 i = i + 1 #i = 4 continue #execute print ( i ) #1 #2 #4 #5 i = i + 1 #i = 2 #i = 3 #i = 4 #i = 5 #i = 6 # 1 # 2 # Numero 3 # 4 # 5 Alcune considerazioni finali Python ha due comandi di loop primitivi: while loop for loop E' normale chiedersi quando usare uno e quando usare l'altro.. Riporto quindi una serie di caratteristiche dei due cicli iterativi in Python for loop \u00e8 un ciclo enumerativo. Andrebbe utilizzato quando \u00e8 noto a priori il numero di iterazioni totali while loop \u00e8 un ciclo indefinito. Andrebbe utilizzato quando non \u00e8 noto a priori il numero di iterazioni totali I comandi break e continue possono essere utilizzati indistintamente sia sul ciclo for che sul ciclo while Lezione 14 Esercizio Asta online v1 Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: - L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo. E' consentita un'unica offerta per utente! In questa prima parte ci occuperemo dell'acquisizione dati da tastiera e della generazione di una struttura dati adeguata. offerte = [] #dato booleano di controllo ciclo altre_offerte = True while altre_offerte : #offerta contiene l'offerte in bitcoin offerta = input ( \"Inserisci l`offerta pervenuta (0 per terminare): \" ) #Converto il dato ricevuto da tastiera in intero offerta = int ( offerta ) #Il valore \"0\" \u00e8 il terminatore if offerta == 0 : altre_offerte = False continue if offerta < 0 : print ( \"Non possono essere fatte offerte negative!\" ) continue #Se l'offerta supera i controlli chiedo l'email email = input ( \"Inserire l`email dell`offerente: \" ) #Inserisco la coppia email-offerta nella lista delle offerte offerte . append ([ email , offerta ]) print ( \"Le offerte valide sono:\" ) print ( offerte ) Che cosa succede se l'utente inserisce dei valori di input non atesi? Ad esempio, invece che inserire un numero inserisce una stringa o qualche carattere non previsto? Vedremo nel capito successivo come trattare questi errori tramite il costrutto try Except Lezione 15 Costrutto try Except Quando si verifica un errore (o un'eccezione), Python normalmente si ferma e genera un messaggio di errore. w3schools - Python Try Except Nell'esempio chiedo all'utente l'inserimento di un numero intero.. Fintanto che l'utente inserisce numeri interi tutto funziona correttamente ma quando per sbaglio l'utente inserisce un carattere non valido, un numero decimale o altro, che succede? while 1 : print ( \"inserisci un numero intero..\" ) x = int ( input ()) if x == 0 break print ( x ) #input() = 1 #1 #input() = 2 #2 #input() = dd # #Traceback (most recent call last): # File \"test.py\", line 3, in <module> # x = int(input()) #ValueError: invalid literal for int() with base 10: 'dd' Inserendo la stringa \"dd\" la conversione esplicita int() fallisce e restituisce un errore: #Traceback (most recent call last): # File \"test.py\", line 3, in <module> # x = int(input()) #ValueError: invalid literal for int() with base 10: 'dd' L'errore \u00e8 di tipo ValueError e la descrizione \u00e8: invalid literal for int() with base 10: 'dd' che significa che la costante letterale dd inserita non \u00e8 un tipo di dato valido per la conversione in base 10, cio\u00e8 in un numero decimale. Come gestisco queste situazioni di errore? Il costrutto try Except permette la gestione di queste situazioni. Sintassi: try : #code1 except #typeError: #code2 Significa: prova (try) ad eseguire code1 , se rilevi un'eccezione di tipo typeError esegui code2 ed \"ignora\" code1 ovvero fai finta che code1 non sia mai stato eseguito. Se non rilevi nessun errore nella fase di try allora esegui code1 Esempio: while 1 : print ( \"Inserisci un numero intero..\" ) try : x = int ( input ()) except ValueError : print ( \" \\n Non \u00e8 un numero intero, riprova..\" ) continue if x == 0 : break print ( \" \\n Il numero inserito \u00e8: \" + str ( x ) + \" \\n \" ) Lezione 16 Introduzione alle espressioni regolari con Python Una RegEx, o espressione regolare, \u00e8 una sequenza di caratteri che forma un modello di ricerca. Le RegEx possono essere utilizzate per verificare se una stringa contiene il modello di ricerca specificato. Python ha un modulo integrato chiamato re , che pu\u00f2 essere utilizzato per lavorare con le espressioni regolari. w3schools - Python RegEx Lezione 17 Esercizio Asta online v2 Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: - L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo. E' consentita un'unica offerta per utente! In questa seconda parte ci occuperemo di inserire dei controlli aggiuntivi dei dati acquisiti. Aggiungeremo la possibilit\u00e0 di inserire numeri decimali \"floating point\". Per far ci\u00f2 utilizzeremo la funzione di conversione esplicita da stringa (l'input da tastiera) a numero decimale, float() Rileveremo tutti gli errori legati ad un'inserimento di un dato float non valido come una stringa o qualche altro carattere (come ad esempio Invio ) non interpretabile come numero decimale. Alla rivelazione dell'errore stamperemo il messaggio d'errore \"Formato non valido, riprova ..\" . Utilizzeremo il costrutto try-except Aggiungeremo un'espressione regolare abbastanza semplice per il controllo del formato dell'email. Per far ci\u00f2 utilizzeremo la funzione re.match(regExp, myVar) del modulo re . L'espressione regolare controlla se la stringa (nel nostro caso l'email) inizia ^ con la sequenza di caratteri minuscoli \"a-z\" , maiuscoli \"A-Z\" o numerici \"0-9\" ripetuti. E' seguita dal carattere @ , continua con la sequenza di caratteri minuscoli, maiuscoli o numerici, prosegue con il carattere . ed p seguita dal dominio che per noi sar\u00e0 nuovamente una sequenza di caratteri minuscoli, maiuscoli o numerici. import re offerte = [] altre_offerte = True while altre_offerte : offerta = input ( \"Inserisci l`offerta pervenuta (0 per terminare): \" ) try : offerta = float ( offerta ) except ValueError : print ( \"Formato non valido, riprova ...\" ) continue if offerta == 0 : altre_offerte = False continue if offerta < 0 : print ( \"Non possono essere fatte offerte negative!\" ) continue email = input ( \"Inserire l`email dell`offerente: \" ) if not re . match ( \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\" , email ): print ( \"Email non valida, riprova ...\" ) continue nuova_offerta = [ offerta , email ] print ( offerte ) Lezione 18 Costrutto if ... in Analogamente al costrutto for ... in il costrutto if ... in si applica a collezioni di elementi in cui si richiede la ricerca di un particolare elemento in una lista if item in list : #code else : #code Esempio: myFruitsList = [ \"banana\" , \"mela\" , \"kiwi\" , \"mandarino\" , \"mela\" ] print ( \"Inserisci il nome di un frutto\" ) itemToSearch = input () if itemToSearch in myFruitsList : print ( \"C'\u00e8 almeno un/una: \" + itemToSearch + \" nella lista\" ) else : print ( \"Non \u00e8 presente nessuno/a \" + itemToSearch + \" nella lista\" ) Lezione 19 Esercizio Asta online v3 Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: - L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo. E' consentita un'unica offerta per utente! In questa terza parte contrellero che la coppia utente/offerta sia unica utilizzando il costrutto if ... in import re offerte = [] altre_offerte = True while altre_offerte : offerta = input ( \"Inserisci l`offerta pervenuta (0 per terminare): \" ) try : offerta = float ( offerta ) except ValueError : print ( \"Formato non valido, riprova ...\" ) continue if offerta == 0 : altre_offerte = False continue if offerta < 0 : print ( \"Non possono essere fatte offerte negative!\" ) continue email = input ( \"Inserire l`email dell`offerente: \" ) if not re . match ( \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\" , email ): print ( \"Email non valida, riprova ...\" ) continue nuova_offerta = [ email , offerta ] # controllo valido solo se viene fatta la stessa offerta con la stessa mail ... limitato! if nuova_offerta in offerte : print ( \"Questo utente ha gi\u00e0 fatto la sua unica offerta ... respinto!\" ) continue else : offerte . append ( nuova_offerta ) print ( \"Le offerte valide sono:\" ) print ( offerte ) Come si vede una coppia identica utente/bit coin viene catturata e rifiutata ma \u00e8 ancora permesso che un utente possa fare pi\u00f9 offerte Lezione 20 Introduzione alle Funzioni Le funzioni vanno definite prima di utilizzarle Una funzione \u00e8 un blocco di codice che viene eseguito solo quando viene chiamata. \u00c8 possibile passare dei valori, chiamati parametri , in una funzione. Una funzione pu\u00f2 restituire dei valori come risultato. In Python una funzione viene definita utilizzando la parola chiave def . w3schools - Python Functions #definizione di una funzione def myFunc ( param ) #code #chiamata di una funzione myFunc ( value1 ) Esempio: def saluta ( nome ): print ( \"ciao: \" + nome + \"!\" ) saluta ( \"Emil\" ) saluta ( \"Tobias\" ) saluta ( \"Linus\" ) # ciao: Emil! # ciao: Tobias! # ciao: Linus! Lezione 21 Esercizio Asta online v4 Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: - L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo. In questa quarte parte introdurremo la funzione stampa_lista(lista_offerte) che riceve in ingresso la lista delle offerte e stampa il risultato secondo un formato specifico e la funzione inserisci_offerte() che rappresenta l'acquisizione dati da tastiera da parte dell'utente e il controllo sull'integrit\u00e0 dei dati ricevuti. Di fatto la complessit\u00e0 dello script si riduce alla chiamta di due funzioni: inserisci_offerte() e stampa_lista import re def stampa_lista ( lista_offerte ): for offerta in lista_offerte : print ( f \"Email Offerente: { offerta [ 0 ] } - Offerta: { offerta [ 1 ] } \" ) def inserisci_offerte (): lista = [] altre_offerte = True while altre_offerte : offerta = input ( \"Inserisci l`offerta pervenuta (0 per terminare): \" ) try : offerta = float ( offerta ) except ValueError : print ( \"Formato non valido, riprova ...\" ) continue if offerta == 0 : altre_offerte = False # USCITA DAL CICLO continue if offerta < 0 : print ( \"Non possono essere fatte offerte negative!\" ) continue email = input ( \"Inserire l`email dell`offerente: \" ) if not re . match ( \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\" , email ): print ( \"Email non valida, riprova ...\" ) continue nuova_offerta = [ email , offerta ] # controllo valido solo se viene fatta la stessa offerta con la stessa mail ... limitato! if nuova_offerta in lista : print ( \"Questo utente ha gi\u00e0 fatto la sua unica offerta ... respinto!\" ) continue else : lista . append ( nuova_offerta ) return lista # grazie all`uso di funzioni la complessit\u00e0 del programma principale # \u00e8 drasticamente ridotta offerte = inserisci_offerte () stampa_lista ( offerte ) Lezione 22 Esercizio Asta online v5 Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: - L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo. In questa quinta parte introdurremo le funzioni: trova_email(email, lista_offerte) : Riceve come parametro una stringa digitata in input dall'utente che rappresenta l'identificativo utente, email e la lista di tutte le offerte, lista_offerte . Ritorna un boolean True se trova l'identificativo email ricevuto come parametro come identificativo nella lista_offerte . Questa funzione controlla quindi se un utente ha gi\u00e0 fatto un'offerta. media_offerte(lista_offerte) : Riceve come parametro la lista di tutte le offert lista_offerte , calcola la media dei valori delle offerte che rappresentano i bit coin e ne ritorna il valore. Ritorna quindi un valore float minimo(lista_offerte) : Riceve come parametro la lista di tutte le offert lista_offerte , calcola il minimo dei valori delle offerte che rappresentano i bit coin e ne ritorna il valore. Ritorna quindi un valore float massimo(lista_offerte) : Riceve come parametro la lista di tutte le offert lista_offerte , calcola il massimo dei valori delle offerte che rappresentano i bit coin e ne ritorna il valore. Ritorna quindi un valore float import re def trova_email ( email , lista_offerte ): trovato = False for offerta in lista_offerte : if offerta [ 0 ] == email : trovato = True break return trovato def media_offerte ( lista_offerte ): somma = 0.0 for offerta in lista_offerte : somma += offerta [ 1 ] return somma / len ( lista_offerte ) # si assume che la lista non sia vuota def minimo ( lista_offerte ): #non si parte mai da un valore assoluto #prelevo solo il valore numerico dell'offerta #min \u00e8 un numero float min = lista_offerte [ 0 ][ 1 ] #lista_offerte[1:] ritorna una lista dal primo elemento fino all'ultimo #Itero ogni elemento della lista lista_offerte a partire dal primo for offerta in lista_offerte [ 1 :]: #se trovo un elemento pi\u00f9 piccolo dell'attuale <min>, aggiorno min if offerta [ 1 ] < min : min = offerta [ 1 ] return min # si assume che la lista non sia vuota def massimo ( lista_offerte ): max = lista_offerte [ 0 ][ 1 ] for offerta in lista_offerte [ 1 :]: if offerta [ 1 ] > max : max = offerta [ 1 ] return max def stampa_lista ( lista_offerte ): for offerta in lista_offerte : print ( f \"Email Offerente: { offerta [ 0 ] } - Offerta: { offerta [ 1 ] } \" ) def inserisci_offerte (): lista = [] altre_offerte = True while altre_offerte : offerta = input ( \"Inserisci l`offerta pervenuta (0 per terminare): \" ) try : offerta = float ( offerta ) except ValueError : print ( \"Formato non valido, riprova ...\" ) continue if offerta == 0 : altre_offerte = False # USCITA DAL CICLO continue if offerta < 0 : print ( \"Non possono essere fatte offerte negative!\" ) continue email = input ( \"Inserire l`email dell`offerente: \" ) if not re . match ( \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\" , email ): print ( \"Email non valida, riprova ...\" ) continue nuova_offerta = [ email , offerta ] # controllo valido solo se viene fatta la stessa offerta con la stessa mail ... limitato! # if nuova_offerta in offerte: # print(\"Questo utente ha gi\u00e0 fatto la sua unica offerta ... respinto!\") # continue # else: # offerte.append(nuova_offerta) if trova_email ( email , lista ): print ( \"Questo utente ha gi\u00e0 fatto la sua unica offerta ... respinto!\" ) continue else : lista . append ( nuova_offerta ) return lista # grazie all`uso di funzioni la complessit\u00e0 del programma principale # \u00e8 drasticamente ridotta offerte = inserisci_offerte () stampa_lista ( offerte ) print ( f \"Offerta Media: { media_offerte ( offerte ) } \" ) print ( f \"Offerta minima: { minimo ( offerte ) } \" ) Lezione 23 Python - List Comprehension List Comprehension offre una sintassi pi\u00f9 breve quando si desidera creare un nuovo elenco basato sui valori di un elenco esistente. w3schools - Python - List Comprehension E' una sorta di RegEx utilizzata per il tipo List . Sintassi. newlist = [ expression for item in iterable if condition == True ] Nell'esempio che segue costruisco una lista non utilizzando List Comprehension : fruits = [ \"apple\" , \"banana\" , \"cherry\" , \"kiwi\" , \"mango\" ] newlist = [] #La nuova lista conterr\u00e0 soltanto elementi che contengono il carattere \"a\" for x in fruits : if \"a\" in x : newlist . append ( x ) print ( newlist ) #[\"apple\", \"banana\", \"mango\"] Il solito esempio utilizzando List Comprehension : fruits = [ \"apple\" , \"banana\" , \"cherry\" , \"kiwi\" , \"mango\" ] #List Comprehension newlist = [ x for x in fruits if \"a\" in x ] print ( newlist ) E' una sintassi molto vicina alla sintassi del linguaggio matematico.. Pu\u00f2 essere infatti tradotto nel seguente modo: << Cerca le \"x\" all'interno della lista \"fruits\" tali che il carattere \"a\" \u00e8 contenuto in \"x\">> Nel seguente esempio elenco i numeri dispari da 0 a 100 con una sola espressione List Comprehension : #Cerca le x da 0 a 100 tali che il risultato della divisione intera tra x e 2 moltiplicato successivamente per 2 sia diverso da x #es: 3/2 = 1 >> 1*2 = 2 >> 3!=2 >> print #es: 4/2 = 2 >> 2*2 = 4 >> 4=4 print ([ x for x in range ( 0 , 100 ) if x // 2 * 2 != x ]) Lezione 24 Esercizio Asta online v6 Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: - L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo. In questa sesta e ultima parte introdurremo le funzioni: offerta_minima(lista_offerte) : riceve la lista_offerte come parametro e ne identifica la lista con l'offerta minima. E' simile alla funzione minimo(lista_offerte) solo che invece di ritornare il valore decimale dell'offerta minima ritorna una lista comprendente la coppia email/offerta con offerta minima. offerta_massima(lista_offerte) : riceve la lista_offerte come parametro e ne identifica la lista con l'offerta massima. E' simile alla funzione massimo(lista_offerte) solo che invece di ritornare il valore decimale dell'offerta massima ritorna una lista comprendente la coppia email/offerta con offerta massima. Lo script filtrer\u00e0 inoltre le offerte che hanno una tolleranza del 10% calcolata sul valore medio. Infine, \u00e8 stata definita una funzione SIMULA_inserisci_offerte() per evitare di inserire i dati da tastiera e testare lo script import re def SIMULA_inserisci_offerte (): return [ [ 'a@a.com' , 1 ], [ 'b@b.com' , 3.3 ], [ 'c@c.com' , 4.1 ], [ 'd@d.com' , 3.8 ], [ 'e@e.com' , 12 ] ] def trova_email ( email , lista_offerte ): trovato = False for offerta in lista_offerte : if offerta [ 0 ] == email : trovato = True break return trovato def media_offerte ( lista_offerte ): somma = 0.0 for offerta in lista_offerte : somma += offerta [ 1 ] return somma / len ( lista_offerte ) # si assume che la lista non sia vuota def minimo ( lista_offerte ): min = lista_offerte [ 0 ][ 1 ] for offerta in lista_offerte [ 1 :]: if offerta [ 1 ] < min : min = offerta [ 1 ] return min # invece del solo valore minimo restituisce # l`intera offerta [email, valore_offerta] def offerta_minima ( lista_offerte ): min = lista_offerte [ 0 ] for offerta in lista_offerte [ 1 :]: if offerta [ 1 ] < min [ 1 ]: min = offerta #ritorna la coppia <email, valore_offerta> corrispondente al minimo di \"valore_offerta\" return min # si assume che la lista non sia vuota def massimo ( lista_offerte ): max = lista_offerte [ 0 ][ 1 ] for offerta in lista_offerte [ 1 :]: if offerta [ 1 ] > max : max = offerta [ 1 ] return max # invece del solo valore massimo restituisce # l`intera offerta [email, valore_offerta] def offerta_massima ( lista_offerte ): max = lista_offerte [ 0 ] for offerta in lista_offerte [ 1 :]: if offerta [ 1 ] > max [ 1 ]: max = offerta return max def stampa_lista ( lista_offerte ): for offerta in lista_offerte : print ( f \"Email Offerente: { offerta [ 0 ] } - Offerta: { offerta [ 1 ] } \" ) def inserisci_offerte (): lista = [] altre_offerte = True while altre_offerte : offerta = input ( \"Inserisci l`offerta pervenuta (0 per terminare): \" ) try : offerta = float ( offerta ) except ValueError : print ( \"Formato non valido, riprova ...\" ) continue if offerta == 0 : altre_offerte = False # USCITA DAL CICLO continue if offerta < 0 : print ( \"Non possono essere fatte offerte negative!\" ) continue email = input ( \"Inserire l`email dell`offerente: \" ) if not re . match ( \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\" , email ): print ( \"Email non valida, riprova ...\" ) continue nuova_offerta = [ email , offerta ] if trova_email ( email , lista ): print ( \"Questo utente ha gi\u00e0 fatto la sua unica offerta ... respinto!\" ) continue else : lista . append ( nuova_offerta ) return lista print ( \"\"\" Il seguente script vuole simulare l \\' andamento di un \\' asta online con la seguente regola: << L \\' asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri.>> L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo\"\"\" ) print ( \"-\" * 40 ) # grazie all`uso di funzioni la complessit\u00e0 del programma principale # \u00e8 drasticamente ridotta print ( \" \\n Stampo una lista di offerte predefinite, evito l'input da tastiera\" ) offerte = SIMULA_inserisci_offerte () stampa_lista ( offerte ) print ( \"-\" * 40 ) # eliminiamo l`offerta minima e massima print ( \" \\n Elimino l'offerta pi\u00f9 alta e l'offerta pi\u00f9 bassa\" ) offerte . remove ( offerta_minima ( offerte )) offerte . remove ( offerta_massima ( offerte )) stampa_lista ( offerte ) print ( \"-\" * 40 ) # costruiamo una nuova lista con gli elementi rimasti # che non si discostano pi\u00f9 del 10% dalla media dei rimasti offerta_media = media_offerte ( offerte ) print ( f \"Media: { offerta_media } \" ) tolleranza = offerta_media / 100 * 10 print ( f \"Tolleranza 10%: { tolleranza } \" ) print ( \"-\" * 40 ) offerte_filtrate = [ x for x in offerte if abs ( x [ 1 ] - offerta_media ) < tolleranza ] print ( \" \\n Offerte filtrate in base alla tolleranza..\" ) stampa_lista ( offerte_filtrate ) #Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: #<< L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri.>> #L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo #---------------------------------------- # #Stampo una lista di offerte predefinite, evito l'input da tastiera #Email Offerente: a@a.com - Offerta: 1 #Email Offerente: b@b.com - Offerta: 3.3 #Email Offerente: c@c.com - Offerta: 4.1 #Email Offerente: d@d.com - Offerta: 3.8 #Email Offerente: e@e.com - Offerta: 12 #---------------------------------------- # #Elimino l'offerta pi\u00f9 alta e l'offerta pi\u00f9 bassa #Email Offerente: b@b.com - Offerta: 3.3 #Email Offerente: c@c.com - Offerta: 4.1 #Email Offerente: d@d.com - Offerta: 3.8 #---------------------------------------- #Media: 3.733333333333333 #Tolleranza 10%: 0.3733333333333333 #---------------------------------------- # #Offerte filtrate in base alla tolleranza.. #Email Offerente: c@c.com - Offerta: 4.1 #Email Offerente: d@d.com - Offerta: 3.8","title":"Python"},{"location":"python/#python","text":"","title":"Python"},{"location":"python/#lezione-01","text":"","title":"Lezione 01"},{"location":"python/#prerequisiti","text":"Conoscenza di un linguaggio qualsiasi OOP come C++ o Javascript","title":"Prerequisiti"},{"location":"python/#corso-python","text":"Python \u00e8 un linguaggio di programmazione di pi\u00f9 \"alto livello\" rispetto alla maggior parte degli altri linguaggi, orientato a oggetti, adatto, tra gli altri usi, a sviluppare applicazioni distribuite, scripting, computazione numerica e system testing. Ideato da Guido van Rossum all'inizio degli anni novanta, il nome fu scelto per la passione dello stesso inventore verso i Monty Python e per la loro serie televisiva Monty Python's Flying Circus ed \u00e8 spesso paragonato a Ruby, Tcl, Perl, JavaScript, Visual Basic o Scheme Wikipedia - Python","title":"Corso Python"},{"location":"python/#installazione-e-setup","text":"Collegati alla pagina ufficiale di Python e installa la versione per il tuo sistema operativo.","title":"Installazione e setup"},{"location":"python/#installazione-e-setup-linux","text":"Per i sistemi su base linux \u00e8 sufficiente digitare i seguenti comandi: sudo apt-get install python3 sudo apt-get install python3-pip Nota: Il modulo pip di Python permette la gestione e l'installazione di moduli esterni Per verificare la corretta installazione dell'interprete python digitare da terminale python3 . In questo modo apriremo inoltre la shell interattiva di python in cui sar\u00e0 possibile inserire direttamente del codice ed avere una risposta simultanea","title":"Installazione e setup - Linux"},{"location":"python/#configurazione-di-un-ide","text":"Un ottimo ambiente di sviluppo per Python \u00e8 Pycharm . Per questo corso ho preferito non utilizzare un IDE specifico come Pycharm ma uno con un target pi\u00f9 ad uso generale come Visual Studio Code con l'ausilio di un'estensione che possa supportare gli emmet (abbreviazioni intelligenti) per il linguaggio python e opzioni per il debug del codice. L'estension che ho installato si chiama Python ed \u00e8 quella che riporto nell'immagine animata qua sotto.","title":"Configurazione di un IDE"},{"location":"python/#lezione-02","text":"","title":"Lezione 02"},{"location":"python/#primo-script","text":"Ogni file python ha un'estensione .py . Per l'esecuzione di uno script python \u00e8 possibile lanciare il file creato con l'estensione .py (esempio test.py ) direttamente dal terminale digitando il comando per l'invocazione dell'interprete python python3 ad esempio python3 test.py all'interno della cartella contenente il file test.py oppure attraverso l'estensione appena installata per VS code Run/Start Debugging Ecco l'esecuzione del primo script python print ( 'ciao mondo' )","title":"Primo script"},{"location":"python/#aggiunta-di-moduli","text":"Per l'aggiunta di un modulo che rientra nella libreria standard python basta semplicemente digitare: import < nomeModulo > A volte tuttavia potremmo aver bisogno di un modulo non standard disponibile sul web. Per installarlo possiamo far ricorso al pacchetto pip che permette la gestione e l'installazione dei moduli aggiuntivi python. Supponiamo di voler scaricare il modulo PyPDF2 per la gestione dei PDF. Digitare da terminale pip install PyPDF2 Qualora si avessero dubbi sul nome del modulo o sul comando esatto, niente paura, il browser ci \u00e8 di supporto \u00f9","title":"Aggiunta di moduli"},{"location":"python/#lezione-03","text":"","title":"Lezione 03"},{"location":"python/#introduzione-a-webbrowser","text":"Il seguente script aprir\u00e0 una localit\u00e0 su google.maps digitata come input dall'utente. Utilizzeremo il comando input() che permette l'acquisizione dati da tastiera e la funzione open del modulo python webbrowser . La funzione open permette di aprire un certo url specificato come parametro tra gli apici. Il parametro \u00e8 quindi passato come una stringa e come tale valgono tutte le operazioni e i metodi applicabili su stringa tra cui l'operatore + utilizzato per concatenare due o pi\u00f9 stringhe . input() : consente l'acquisizione dati da tastiera dell'utente. webbrowser.open(myUrl) : Apre l'indirizzo web specificato dal parametro myUrl . Il parametro specificato viene passato come stringa + : Operatore di concatenazione stringhe Ecco lo script completo: import webbrowser destinazione = input () webbrowser . open ( 'https://www.google.com/maps' + '/place/' + destinazione ) E' possibile ridurre ancora il codice import webbrowser webbrowser . open ( 'https://www.google.com/maps' + '/place/' + input ())","title":"Introduzione a webbrowser"},{"location":"python/#come-rendo-eseguibile-un-file-python","text":"","title":"Come rendo eseguibile un file python?"},{"location":"python/#linux","text":"Aggiungere la seguente linea di codice in testa allo script: #!/usr/bin/env python3 Ad esempio: #!/usr/bin/env python3 import webbrowser webbrowser . open ( 'https://www.google.com/maps' + '/place/' + input ()) E' sufficiente rendere il file eseguibile (all'interno delle propriet\u00e0 del file sezione \"permessi\") e lanciarlo da terminale.","title":"Linux"},{"location":"python/#commenti","text":"# questo \u00e8 un commento e verr\u00e0 ignorato dall'interprete print ( 'ciao' )","title":"Commenti"},{"location":"python/#lezione-04","text":"","title":"Lezione 04"},{"location":"python/#introduzione-al-modulo-pypdf2","text":"Il seguente script tratter\u00e0 l'elaborazione di file pdf. Saremo in grado quindi di generare un file pdf con nome predefinito \"Output.pdf\" che \u00e8 la copia della prima pagina di un pdf con nome \"input.pdf\" ricevuto in input Faremo uso del modulo aggiuntivo PyPDF2 da installare da terminale tramite il comando pip install PyPDF2 Utilizzeremo le funzioni standard Python di apertuta e chiusura file: - open(myFile, mode) : apre un file e lo restituisce come oggetto. - myfile indica il nome comprensivo del path del file da aprire - mode indica la modalit\u00e0 di apertura del file - mode = \"r\" modalit\u00e0 lettura - mode = \"rb\" modalit\u00e0 lettura binaria - mode = \"w\" modalit\u00e0 scrittura - mode = \"wb\" modalit\u00e0 scrittura binaria - close() : chiude un file aperto. \u00c8 necessario chiudere sempre i file aperti poich\u00e8 in alcuni casi, a causa del buffering, le modifiche apportate a un file potrebbero non essere visualizzate finch\u00e9 non si chiude il file. w3schools - Python open() Function w3schools - Python close() Function Del modulo aggiuntivo PyPDF2 utilizzeremo le classi: - PdfFileReader(myPdf) : Chiama il costruttore della classe PdfFileReader che inzializza in lettura il file oggetto pdf myPdf ricevuto come parametro e restituisce un'istanza della classe PdfFileReader The PdfFileReader Class Metodi - getPage(pageNumber) : restituisce una pagina in base al numero pageNumber passato come parametro PdfFileWriter() : Chiama il costruttore della classe PdfFileWriter() che inizializza in scrittura un file oggetto pdf e restituisce un'istanza della classe PdfFileWriter() The PdfFileWriter Class Metodi addPage(page) : Aggiunge una pagina PDF, all'istanza della classe PdfFileWriter a cui si applica il metodo. La pagina viene solitamente acquisita da un'istanza di PdfFileReader . write(myPdf) : Scrive (su disco, da ram a rom) la raccolta di pagine aggiunte a questo oggetto come file PDF, riceve come parametro l'oggetto pdf da scrivere, myPdf . Nota: Le \"funzioni/classi\" di un modulo devono essere invocate sempre specificando il nome del modulo. Esempio: import PyPDF2 pdfInput = open ( \"pdf/input.pdf\" , \"rb\" ) #PyPDF2 \u00e8 il nome del modulo, PdfFileReader \u00e8 il nome della classe del modulo PyPDF2 reader1 = PyPDF2 . PdfFileReader ( pdfInput ) Script completo import PyPDF2 #Apro il file <input.pdf> all'interno della cartella <pdf> in modalit\u00e0 lettura binaria #Restituisco un oggetto all'interno della variabile <pdfInput> pdfInput = open ( \"pdf/input.pdf\" , \"rb\" ) #Restituisco un'istanza della classe <PdfFileReader> all'interno della variabile <reader1> reader1 = PyPDF2 . PdfFileReader ( pdfInput ) #apro un file <Output.pdf> all'interno della cartella <pdf> in modalit\u00e0 scrittura binaria #Restituisco un oggetto all'interno della variabile <pdfOutput> pdfOutput = open ( \"pdf/Output.pdf\" , \"wb\" ) #Restituisco un'istanza della classe <PyPDF2.PdfFileWriter> all'interno della variabile <writer1> writer1 = PyPDF2 . PdfFileWriter () #Prelevo la pagina numero <0> e ritorno un oggetto pdf di una pagina all'interno della variabile <pag0> pag0 = reader1 . getPage ( 0 ) #Aggiungo in coda pag0 all'istanza <writer1> (della classe PdfFileWriter) #Ripeto l'operazione per tre volte writer1 . addPage ( pag0 ) writer1 . addPage ( pag0 ) writer1 . addPage ( pag0 ) #Scrittura su disco dell'istanza della classe <writer1> su <pdfOutput> l'oggetto in scrittura corrispondente a \"Output.pdf\" writer1 . write ( pdfOutput ) #aChiudo i File pdfInput . close () pdfOutput . close ()","title":"Introduzione al modulo PyPDF2"},{"location":"python/#lezione-05","text":"","title":"Lezione 05"},{"location":"python/#costrutto-condizionale-ifelse","text":"Le istruzioni condizionali vengono utilizzate per eseguire un blocco di codice solo nel caso in cui una condizione risulti true o false Sintassi costrutto if esteso: if condition1 : #code 01 #.. elif condition2 : #code 02 #.. else : #code 03 #.. Esempio: print ( \"Inserisci due numeri..) primoValore = input () secondoValore = input () if a > b : print ( \"Il primo valore inserito, \" + primoValore + \" \u00e8 maggiore del secondo valore inserito, \" + secondoValore ) elif b > a : print ( \"Il secondo valore inserito, \" + secondoValore + \" \u00e8 maggiore del primo valore inserito, \" + primoValore ) else : print ( \"i due valori inseriti sono uguali\" ) Notare che per il costrutto if in python, la condition \u00e8 priva di parentesi tonde ( ) comuni invece a molti altri linguaggi di programmazione; l'operatore : \u00e8 usato come terminatore della condition e l'indentazione \u00e8 necessaria per racchiudere la porzione di codice condizionato da if .","title":"Costrutto condizionale if...else"},{"location":"python/#lezione-06","text":"","title":"Lezione 06"},{"location":"python/#costrutto-iterativo-for","text":"Un ciclo for viene utilizzato per iterare su una sequenza (che pu\u00f2 essere una lista, una tupla, un dizionario, un insieme o una stringa). \u00c8 meno simile alla keyword for in altri linguaggi di programmazione e funziona pi\u00f9 come un metodo iteratore che si trova in altri linguaggi di programmazione orientati agli oggetti. w3schools - Python For Loops Sintassi: #Sintassi 1: for target_list in expression_list : #code Esempio: for numero in [ 1 , 2 , 3 , 4 , 5 ]: print ( numero * numero ) # 1 # 4 # 9 # 16 # 25 for frutto in [ \"banana\" , \"mela\" , \"pera\" ]: print ( frutto ) # banana # mela # pera","title":"Costrutto iterativo for"},{"location":"python/#indentazione-python","text":"Il linguaggio python, a differenza di altri linguaggi come C/C++, Javascript .. Non utilizza delimitatori di blocco codice come { } ma si affida alla semplice indentazione . Rende quindi indispensabile l'uso di un buon editor di testo per evitare problemi di sintassi o semantica (in alcuni casi nemmeno troppo rari). Non utilizza neanche un terminatore di statement come il classico ; ma si affida al carattere a capo . L'interprete python comunque \u00e8 in grado di rilevare errori sintattici di indentazione e segnalarlo.","title":"Indentazione Python"},{"location":"python/#range-function","text":"Per iterare un insieme di codice un numero di volte specificato, possiamo usare la funzione range () . La funzione range (number) restituisce una sequenza di numeri, a partire da 0 per impostazione predefinita, incrementa di 1 (per impostazione predefinita) e termina con un numero specificato tramite il parametro number . In realt\u00e0 termina con il numero number - 1 . La funzione range () pu\u00f2 accettare 1, 2 o 3 parametri: range(number) : un parametro , genera una lista numerica incrementale nel range 0 - number-1 range(numberStart, numberEnd) : due parametri , genera una lista numerica incrementale nel range numberStart - numberEnd-1 range(numberStart, numberEnd, step) : tre parametri , genera una lista numerica con incremento pari a step nel range massimo numberStart - numberEnd-1 w3schools - The range() Function range ( 5 ) #[0, 1, 2, 3, 4] range ( 1 , 5 ) #[1, 2, 3, 4] range ( 1 , 5 , 2 ) #[1, 3] for target_list in range ( number ): #code # range(number) costruisce una lista da 0 a number-1 for numero in range ( 5 ): print ( numero * numero ) # 0 # 1 # 4 # 9 # 16 for numero in range ( 1 , 5 , 2 ): print ( numero ) # 1 # 3 Nel seguente esempio specifico alla funzione print() di non utilizzare il terminatore di default a capo rendendo nullo l'attributo end print ( end = \"\" ) Esempio: for numero in range ( 5 ): print ( str ( numero ) + \":\" , end = \"\" ) print ( numero * numero ) # 0:0 # 1:1 # 2:4 # 3:9 # 4:16","title":"range() Function"},{"location":"python/#lezione-07","text":"","title":"Lezione 07"},{"location":"python/#pypdf2-copia-pdf","text":"Il seguente script prende in input un pdf \"input.pdf\" e ne produce una copia sul file \"Output.pdf\" Faremo uso della propriet\u00e0 della classe PdfFileReader : - numPages : Restituisce il numero delle pagine del file pdf dell'istanza (della classe PdfFileReader ) si cui si legge la propriet\u00e0 import PyPDF2 pdfInput = open ( \"pdf/input.pdf\" , \"rb\" ) reader1 = PyPDF2 . PdfFileReader ( pdfInput ) pdfOutput = open ( \"pdf/Output.pdf\" , \"wb\" ) writer1 = PyPDF2 . PdfFileWriter () #Copia delle pagine dell'oggetto (classe) pdf <reader1> nell'oggetto (classe) pdf <writer1> for numeroPagina in range ( reader1 . numPages ): page = reader1 . getPage ( numeroPagina ) writer1 . addPage ( page ) writer1 . write ( pdfOutput ) #aChiudo i File pdfInput . close () pdfOutput . close ()","title":"PyPDF2 - Copia PDF"},{"location":"python/#pypdf2-merge-all-pdf","text":"Il seguente script unisce tutti i file pdf presenti nella root directory salvandoli con un nome stabilito dall'utente. Faremo uso di: - Modulo os \u00e8 un modulo che contiene funzioni per interagire con il sistema operativo per la manipolazione di file e processi, os \u2014 Miscellaneous operating system interfaces . Nota: Per questo esercizio importeremo solo il metodo listdir() del modulo os: from os import listdir listdir(path) : Metodo del modulo os . Elenca file e cartelle specificate nella path-directory come parametro. Se non viene specificato nessun parametro restituisce i file della root-directory. Viene restituita una lista Python3 os.listdir () method Metodi su stringa endswith(myString) : Restituisce true se la stringa a cui applichiamo il metodo termina con la stringa indicata come parametro, myString Altre funzionalit\u00e0 del modulo PyPDF2 . - classe PdfFileMerger : Inizializza un oggetto PdfFileMerger . PdfFileMerger unisce pi\u00f9 PDF in un unico PDF. Restituisce un'istanza della classe PdfFileMerger , PyPDF2 - The PdfFileMerger Class . - metodo append(myPDF) della classe PdfFileMerger : Concatena tutte le pagine di un oggetto PDF passato come parametro, myPDF , alla fine del file PDF a cui si applica il metodo Riporto lo script completo: #Merge all pdf files from os import listdir import PyPDF2 print ( \"**********************************************\" ) print ( \"Unisco i file pdf presenti in questa directory\" ) print ( \"**********************************************\" ) #Non devo specificare <os.listdir> poich\u00e8 ho spcificato l'importazione <from os import listdir> #Se avessi usato <import os> avrei dovuto scrivere <os.listdir> #listdir restituisce file e cartelle in formato <lista> listaFiles = listdir () for nomeFile in listaFiles : if nomeFile . endswith ( '.pdf' ): print ( nomeFile ) print ( ' \\n ' ) #chiedo all'utente come vuole chiamare il file di output print ( \"Salvo il risultato con il nome:\" ) nomeFileDestinazione = input () #Apro il file in scrittura binaria PDF_Destinazione = open ( nomeFileDestinazione , \"wb\" ) print ( ' \\n ' ) merger = PyPDF2 . PdfFileMerger () print ( \"Elaborazione di..\" ) for nomeFile in listaFiles : #Elaboro solo i file con estensione \".pdf\" if nomeFile . endswith ( '.pdf' ): #stampo il nome del file print ( nomeFile ) #lo apro in lettura binaria pdfFileInput = open ( nomeFile , \"rb\" ) #creo un'istanza della classe <PdfFileReader> sul file appena aperto PDF_Reader = PyPDF2 . PdfFileReader ( pdfFileInput ) #Appendo il file PDF in coda all'oggetto merger merger . append ( PDF_Reader ) #chiudo il file aperto pdfFileInput . close () print ( ' \\n ' ) #Operazione di scrittura print ( \"Scrittura su: \" + nomeFileDestinazione ) merger . write ( PDF_Destinazione ) PDF_Destinazione . close () print ( \"Finito..\" )","title":"PyPDF2 - Merge All pdf"},{"location":"python/#lezione-08","text":"","title":"Lezione 08"},{"location":"python/#liste","text":"Abbiamo gi\u00e0 visto implicitamente un'introduzione al tipo lista e in particolare come creare e iterare sugli elementi di una lista attraverso il ciclo for e la funzione range() . Il tipo dato lista \u00e8 molto importante nel linguaggio python. Le liste sono un tipo di dato utilizzato per memorizzare diversi elementi in una singola variabile. Le liste sono uno dei 4 tipi di dati incorporati in Python utilizzati per memorizzare raccolte di dati, gli altri 3 sono Tuple, Set e Dictionary, tutti con qualit\u00e0 e utilizzo diversi. Vediamo le caratteristiche principali delle liste: Le liste possono contenere qualsiasi tipo di dato Gli elementi della lista sono indicizzati, il primo elemento ha indice [0], il secondo elemento ha indice [1] .. A differenza della maggior parte dei linguaggi si possono usare anche indici negativi, [-1] si riferisce all'ultimo elemento, [-2] si riferisce al penultimo elemento ecc. Gli elementi in una lista sono ordinati e l'ordine \u00e8 stabilito dall'indice. Dopo la creazione, \u00e8 possibile aggiungere elementi, cambiare il valore degli elementi gi\u00e0 esistenti o rimuoverli Dal momento che le liste sono indicizzate \u00e8 possibile avere elementi duplicati La funzione len() ritorna il numero degli elementi presenti in una lista L'operatore [::] permette lo slicing di liste ovvero la creazione di porzioni di liste a partire dalla lista a cui si applica l'operatore [::] w3schools - Python Lists","title":"Liste"},{"location":"python/#accesso-agli-elementi-di-una-lista","text":"L'accesso agli elementi di una lista si effettua tramite l'operatore [] #indici 0 1 2 3 4 #indici -5 -4 -3 -2 -1 myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] print ( myList [ 2 ]) #mela print ( myList [ - 1 ]) #cachi print ( len ( myList )) #5","title":"Accesso agli elementi di una lista"},{"location":"python/#modifica-del-valore-degli-elementi-in-una-lista","text":"Per cambiare il valore degli elementi in una lista si utilizza l'operatore [] #indici 0 1 2 3 4 #indici -5 -4 -3 -2 -1 myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList [ - 1 ] = \"arancia\" myList [ 2 ] = \"pera\" print ( myList ) myList [ 1 : 3 ] = [ \"mandorla\" , \"nocciola\" ] print ( myList )","title":"Modifica del valore degli elementi in una lista."},{"location":"python/#aggiunta-di-elementi-in-una-lista","text":"Sono disponibili i metodi: append(elem) : Appende elem in coda alla lista insert(index, elem) : Inserisce (senza nessun replace) elem alla posizione index facendo scalare di una posizione gli elementi dalla posizione index extend(otherList) : Appende in coda gli elementi della lista passata come parametro, otherList myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList2 = [ \"mandorla\" , \"nocciola\" , \"noce\" ] myList . append ( \"anguria\" ) print ( myList ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi', 'anguria'] myList . insert ( 2 , \"melone\" ) print ( myList ) #['banana', 'kiwi', 'melone', 'mela', 'mandarino', 'cachi', 'anguria'] myList . extend ( myList2 ) print ( myList ) #['banana', 'kiwi', 'melone', 'mela', 'mandarino', 'cachi', 'anguria', 'mandorla', 'nocciola', 'noce']","title":"Aggiunta di elementi in una lista"},{"location":"python/#rimozione-di-elementi-in-una-lista","text":"Sono disponibili i metodi: remove(elem) : Toglie elem dalla lista pop(?index) : Toglie l'elemento corrispondente all'indice index passato come parametro opzionale. Se non viene passato nessun parametro toglie l'ultimo elemento. E' possibile ottenere questo risultato anche con il comando del , specificando l'elemento, del myList[index] clear() : Svuota la lista. La lista esiste ma \u00e8 vuota. E' possibile ottenere questo risultato anche con il comando del specificando il nome della lista del myList ma in questo caso elimina anche l'identificatore myList = [ 'banana' , 'kiwi' , 'melone' , 'mela' , 'mandarino' , 'cachi' , 'anguria' , 'mandorla' , 'nocciola' , 'noce' ] myList . remove ( \"mandarino\" ) print ( myList ) #['banana', 'kiwi', 'melone', 'mela', 'cachi', 'anguria', 'mandorla', 'nocciola', 'noce'] myList . pop ( 2 ) print ( myList ) #['banana', 'kiwi', 'mela', 'cachi', 'anguria', 'mandorla', 'nocciola', 'noce'] myList . pop () print ( myList ) #['banana', 'kiwi', 'mela', 'cachi', 'anguria', 'mandorla', 'nocciola'] del myList [ 0 ] print ( myList ) #['kiwi', 'mela', 'cachi', 'anguria', 'mandorla', 'nocciola'] myList . clear () print ( myList ) #[] myList = [ 'banana' , 'kiwi' , 'melone' , 'mela' , 'mandarino' , 'cachi' , 'anguria' , 'mandorla' , 'nocciola' , 'noce' ] del myList print ( myList ) #NameError: name 'myList' is not defined","title":"Rimozione di elementi in una lista"},{"location":"python/#creazione-di-sotto-liste-slicing","text":"Sintassi: mySubList = myList[?startIndex: ?endIndex: ?Step] : Ritorna una sotto lista a partire dalla lista a cui si applica lo slicing ( myList ). L'operatore [] pu\u00f2 ricevere tre parametri opzionali separati da : . Il primo rappresenta l'indice di partenza (incluso), il secondo l'indice di fine (non incluso) e il terzo il passo. Se il primo parametro non \u00e8 specificato si assume 0 come valore di partenza. Se il secondo parametro non \u00e8 specificato si assume len(myList) - 1 come valore di fine cio\u00e8 l'ultimo elemento della lista. Se il terzo parametro non \u00e8 specificato si assume un incremento positivo unitario #indici 0 1 2 3 4 #indici -5 -4 -3 -2 -1 myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] mySubList = myList [ 1 :] print ( mySubList ) #['kiwi', 'mela', 'mandarino', 'cachi'] mySubList = myList [ - 2 :] print ( mySubList ) #['mandarino', 'cachi'] mySubList = myList [ 2 : 4 ] print ( mySubList ) #['mela', 'mandarino'] mySubList = myList [:: 2 ] print ( mySubList ) #['banana', 'mela', 'cachi'] #Restituisce una copia <non profonda> di una lista #Non valido per liste annidate mySubList = myList [:] print ( mySubList ) #[\"banana\", \"kiwi\", \"mela\", \"mandarino\", \"cachi\"] #Ordinamento inverso mySubList = myList [:: - 1 ] print ( mySubList ) #['cachi', 'mandarino', 'mela', 'kiwi', 'banana']","title":"Creazione di sotto liste, slicing "},{"location":"python/#lezione-09","text":"","title":"Lezione 09"},{"location":"python/#copia-di-liste","text":"Abbiamo visto nel paragrafo precedente che per la copia di liste \u00e8 sufficiente utilizzare l'operatore [:] ma che non vale per liste annidate. In questa lezione approfondiremo l'operazione di copia di elementi. Copia semplice, valida per liste non annidate: myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList2 = myList [:] print ( myList ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi'] print ( myList2 ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi'] Cosa succede se eseguo la copia tramite il semplice assegnamento? myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList2 = myList print ( myList ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi'] print ( myList2 ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi'] Sfruttando quindi l'operatore di assegnamento = non ottengo una copia dei valori ma una copia dei riferimenti. In pratica in questo modo myList e myList2 condividono gli stessi dati. Se modifico uno modifico anche l'altro myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList2 = myList #Togliendo l'elemento da \"myList\" lo tolgo anche da \"myList2\" perch\u00e8 condividono gli stessi elementi myList . remove ( \"banana\" ) print ( myList ) #['kiwi', 'mela', 'mandarino', 'cachi'] # !!! print ( myList2 ) #['kiwi', 'mela', 'mandarino', 'cachi'] Ci\u00f2 non accade con la copia poich\u00e8 diventano due liste indipendenti: myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList2 = myList [:] myList . remove ( \"banana\" ) print ( myList ) #['kiwi', 'mela', 'mandarino', 'cachi'] print ( myList2 ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi'] Attenzione! Per liste pi\u00f9 complicate come liste annidate l'operatore [:] non pu\u00f2 essere utilizzato per la copia perch\u00e8 effettuerebbe una copia per riferimento degli elementi annidati. In generale per effettuare una copia ricorsiva e profonda \u00e8 necessario utilizzare la funzione deepcopy() del modulo copy . Per liste annidate l'operatore [:] fallisce: myList = [ \"banana\" , \"kiwi\" , \"mela\" , [ 1 , 2 ], \"cachi\" ] myList2 = myList [:] myList . remove ( \"banana\" ) myList2 [ 3 ][ 0 ] = 12 # !!! la scrittura su myList2 ha scritto anche myList perch\u00e8 la lista annidata \u00e8 stata copiata per riferimento print ( myList ) #['kiwi', 'mela', [12, 2], 'cachi'] print ( myList2 ) #'banana', 'kiwi', 'mela', [12, 2], 'cachi']","title":"Copia di Liste"},{"location":"python/#deepcopy","text":"Per la copia di liste e qualsiasi altro oggetto \u00e8 possibile ed \u00e8 consigliabile utilizzare una funzione deepcopy() del modulo copy che esegue una copia profonda quindi considera anche oggetti e liste annidate import copy myList = [ \"banana\" , \"kiwi\" , \"mela\" , \"mandarino\" , \"cachi\" ] myList2 = copy . deepcopy ( myList ) myList . remove ( \"banana\" ) print ( myList ) #['kiwi', 'mela', 'mandarino', 'cachi'] print ( myList2 ) #['banana', 'kiwi', 'mela', 'mandarino', 'cachi'] La funzione deepcopy() \u00e8 l'unica che eseegue in modo affidabile la copia di elementi considerando eventuali elementi annidati. import copy myList = [ \"banana\" , \"kiwi\" , \"mela\" , [ 1 , 2 ], \"cachi\" ] myList2 = copy . deepcopy ( myList ) myList . remove ( \"banana\" ) myList2 [ 3 ][ 0 ] = 12 print ( myList ) #['kiwi', 'mela', [1, 2], 'cachi'] print ( myList2 ) #['banana', 'kiwi', 'mela', [12, 2], 'cachi']","title":"deepcopy()"},{"location":"python/#lezione-10","text":"","title":"Lezione 10"},{"location":"python/#le-stringe","text":"Le stringhe sono un tipo di dato immutabile in python Questo significa che la copia di stringhe pu\u00f2 essere fatta attraverso l'assegnamento tra i nomi (contrariamente a quanto accade per altri linguaggi come C++) poich\u00e8 quando viene creata una copia tramite l'assegnamento non viene copiato il riferimento della stringa ma l'intero oggetto stringa. s1 = \"ciao\" s2 = s1 s2 = \"ciaociao\" print ( s2 ) #ciaociao print ( s1 ) #ciao Ecco una dimostrazione approfondita andando ad scavare tra gli indirizzi in memoria con la funzione id s1 = \"ciao\" print ( id ( s1 )) #140440511029104 s2 = s1 print ( id ( s2 )) #140440511029104 s2 = \"ciaociao\" print ( id ( s2 )) #140440511029168 print ( s2 ) #ciaociao print ( s1 ) #ciao Attenzione Eseguendo la copia s2 = s1 ancora non si assegna ad s2 un nuovo indirizzo in memoria per motivi di efficienza. Lo si assegna quando ad s2 si assegna un nuovo valore","title":"Le stringe"},{"location":"python/#interpolazione-di-stringhe-metodo-format","text":"Il metodo format() applicabile alle stringhe consente di inserire espressioni valutabili all'interno di stringhe w3schools - Python String format() Method . Il metodo format() formatta i valori specificati e li inserisce all'interno del segnaposto della stringa. Il segnaposto viene definito utilizzando le parentesi graffe: {}. Esempio: #sintassi 1 txt = \"1Kg di sale da cucina a solo {price} euro!\" print ( txt . format ( price = 2 )) #1Kg di sale da cucina a solo 2 euro! #sintassi 2 txt = \"1Kg di sale da cucina a solo {0} euro! Rimasti {1} pezzi\" print ( txt . format ( 2 , 500 )) #1Kg di sale da cucina a solo 2 euro! Rimasti 500 pezzi Esiste anche una sintassi leggermente diversa: myList = [ \"dentista\" , \"17:00\" ] print ( f \"Evento: { myList [ 0 ] } - Ora: { myList [ 1 ] } \" ) #Evento: dentista - Ora: 17:00","title":"Interpolazione di stringhe - Metodo format()"},{"location":"python/#lezione-11","text":"","title":"Lezione 11"},{"location":"python/#pypdf2-merge-all-pdf-v2","text":"Questa \u00e8 una versione migliorata dello script Merge All pdf . Aggiunge dei controlli sull'estensione del file e sulla natura del file. Controlla infatti se un file termina con formati \"strani\" come \".pdF\", \"PDf\" considerandoli comunque validi e controlla eventuali falsi file trappola come cartella che termina con estensione \".pdf\". Faremo uso di: os.path.isfile(path+file) : Ritorna true se il file specificato come parametro (eventualmente con un path relativo o assoluto) \u00e8 realmente un file. Metodo su stringhe .upper() : Ritorna una copia della stringa a cui si applica il metodo in caratteri maiscoli chaining condition and : Permette la concatenazione di condizioni logiche. Ritorna true se tutte le condizioni concatenate sono true Script completo e migliorato import PyPDF2 import os print ( \"**********************************************\" ) print ( \"Unisco i file pdf presenti in questa directory\" ) print ( \"**********************************************\" ) listaFiles = os . listdir () for nomeFile in listaFiles : if nomeFile . endswith ( '.pdf' ): print ( nomeFile ) print ( ' \\n ' ) #chiedo all'utente come vuole chiamare il file di output print ( \"Salvo il risultato con il nome:\" ) nomeFileDestinazione = input () #Apro il file in scrittura binaria PDF_Destinazione = open ( nomeFileDestinazione , \"wb\" ) print ( ' \\n ' ) merger = PyPDF2 . PdfFileMerger () print ( \"Elaborazione di..\" ) for nomeFile in listaFiles : #Elaboro solo i file con estensione \".pdf\" o \"PDF\" o \"PdF\" .. if os . path . isfile ( nomeFile ) and nomeFile . upper () . endswith ( '.PDF' ): #stampo il nome del file print ( nomeFile ) #lo apro in lettura binaria pdfFileInput = open ( nomeFile , \"rb\" ) #creo un'istanza della classe <PdfFileReader> sul file appena aperto PDF_Reader = PyPDF2 . PdfFileReader ( pdfFileInput ) #Appendo il file PDF in coda all'oggetto merger merger . append ( PDF_Reader ) #chiudo il file aperto pdfFileInput . close () print ( ' \\n ' ) #Operazione di scrittura print ( \"Scrittura su: \" + nomeFileDestinazione ) merger . write ( PDF_Destinazione ) PDF_Destinazione . close () print ( \"Finito..\" )","title":"PyPDF2 - Merge All pdf v2"},{"location":"python/#lezione-12","text":"","title":"Lezione 12"},{"location":"python/#introduzione-alla-manipolazione-dei-docx","text":"Con il seguente script inizieremo a manipolare i docx Da terminale puoi installare il modulo per la manipolazione dei docx con il comando: pip install python-docx Importa il modulo \"python-docx\" all'interno del tuo script con: import docx La documentazione ufficiale del modulo \"python-docx\" la puoi trovare su docx - documentazione . Del modulo \"python-docx\" utilizzeremo: docx.Document(docxFile) : Chiama il costruttore della classe Document passando come parametro di inizializzazione il file \"docx\" che intendiamo elaborare. Ritorna un'istanza della classe Document Metodo sections della classe Document : applicato a un'istanza della classe Document restituisce le sezioni del documento \"docx\"- Metodo paragraphs della classe Document : applicato a un'istanza della classe Document restituisce una lista dell'oggetto Paragraph Metodo text della classe Paragraph : applicato a un'istanza della classe Paragraph restituisce il testo di un paragrafo Utilizzeremo anche l'operatore * su stringa che permette di generare una ripetizione della stringa a cui si applica l'operatore. print ( \"ciao \" * 2 + \"!\" ) #ciao ciao ! Script completo: #Manipolazione docx import docx divina = docx . Document ( \"divina1.docx\" ) sezioni = divina . sections print ( \"il documento contine:\" ) #Utile quando ci sono diversi valori da valutare print ( \"- {0} sezioni\" . format ( len ( sezioni ))) #altrenativa >>> print(str( len(sezioni) ) + \" sezioni\" ) paragrafi = divina . paragraphs print ( \"- {0} paragrafi\" . format ( len ( paragrafi ))) #4 sezioni print ( \" \\n Stampo i paragrafi..\" ) print ( \"-\" * 50 ) #Per ogni elemento p estratto dalla lista paragrafi.. for p in paragrafi : #p.text restituisce il testo di un paragrafo print ( p . text ) #questo metodo su stringa genera una ripetizione print ( \"-\" * 50 )","title":"Introduzione alla manipolazione dei docx"},{"location":"python/#lezione-13","text":"","title":"Lezione 13"},{"location":"python/#python-while","text":"Con il ciclo while possiamo eseguire un insieme di istruzioni fintanto che una condizione \u00e8 vera. w3schools - Python While Loops Sintassi: while condition : #code Esempio: i = 1 while i < 6 : #1 < 6, true #2 < 6, true #3 < 6, true #4 < 6, true #5 < 6, true #6 < 6, false -> exit print ( i ) #1 #2 #3 #4 #5 i = i + 1 #i = 2 #i = 3 #i = 4 #i = 5 #i = 6 # 1 # 2 # 3 # 4 # 5","title":"Python while()"},{"location":"python/#comando-break","text":"Con l'istruzione break possiamo interrompere il ciclo anche se la condizione while \u00e8 vera: Sintassi: while condition : #code #code #.. break #esce Esempio: i = 1 while i < 6 : #1 < 6, true #2 < 6, true print ( i ) #1 #2 i = i + 1 #i = 2 #i = 3 if i == 3 : #i = 2, false #i = 3, true -> exit break # 1 # 2 Con i cicli c'\u00e8 sempre da tenere in considerazione quando viene effettuato il controllo delle condizioni di uscita ed entrata del ciclo e la sequenza con cui vengono eseguite le istruzioni all'interno del ciclo. Leggendo l'esempio di sopra non \u00e8 chiaro se il programmatore con la condizione i == 3 vuole che venga stampato il numero 3 oppure no. Un'ottima strategia \u00e8 quella di inserire tutte le condizioni di uscita del ciclo all'inizio ed eventuali istruzioni di controllo ciclo alla fine. Al centro del ciclo andranno tutte le istruzioni che verranno eseguite nel caso standard i = 1 while i < 6 : #1 < 6, true #2 < 6, true #3 < 6 #Condizione di uscita ciclo if i == 3 : #i = 1, false #i = 2, false #i = 3, true -> exit break print ( i ) #1 #2 #Condizione di controllo ciclo i = i + 1 #i = 2 #i = 3 # 1 # 2","title":"Comando break"},{"location":"python/#comando-continue","text":"Con l'istruzione continue possiamo interrompere l'iterazione corrente e continuare con la successiva Sintassi: while condition : #code #code #.. continue #esce Esempio i = 1 while i < 6 : #1 < 6, true #2 < 6, true #3 < 6, true #4 < 6, true #5 < 6, true #6 < 6, false -> exit if i == 3 : #i = 1, false #i = 2, false #i = 3, true #i = 4, false #i = 5, false print ( \"Numero \" + i ) #Numero 3 i = i + 1 #i = 4 continue #execute print ( i ) #1 #2 #4 #5 i = i + 1 #i = 2 #i = 3 #i = 4 #i = 5 #i = 6 # 1 # 2 # Numero 3 # 4 # 5","title":"Comando continue"},{"location":"python/#alcune-considerazioni-finali","text":"Python ha due comandi di loop primitivi: while loop for loop E' normale chiedersi quando usare uno e quando usare l'altro.. Riporto quindi una serie di caratteristiche dei due cicli iterativi in Python for loop \u00e8 un ciclo enumerativo. Andrebbe utilizzato quando \u00e8 noto a priori il numero di iterazioni totali while loop \u00e8 un ciclo indefinito. Andrebbe utilizzato quando non \u00e8 noto a priori il numero di iterazioni totali I comandi break e continue possono essere utilizzati indistintamente sia sul ciclo for che sul ciclo while","title":"Alcune considerazioni finali"},{"location":"python/#lezione-14","text":"","title":"Lezione 14"},{"location":"python/#esercizio-asta-online-v1","text":"Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: - L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo. E' consentita un'unica offerta per utente! In questa prima parte ci occuperemo dell'acquisizione dati da tastiera e della generazione di una struttura dati adeguata. offerte = [] #dato booleano di controllo ciclo altre_offerte = True while altre_offerte : #offerta contiene l'offerte in bitcoin offerta = input ( \"Inserisci l`offerta pervenuta (0 per terminare): \" ) #Converto il dato ricevuto da tastiera in intero offerta = int ( offerta ) #Il valore \"0\" \u00e8 il terminatore if offerta == 0 : altre_offerte = False continue if offerta < 0 : print ( \"Non possono essere fatte offerte negative!\" ) continue #Se l'offerta supera i controlli chiedo l'email email = input ( \"Inserire l`email dell`offerente: \" ) #Inserisco la coppia email-offerta nella lista delle offerte offerte . append ([ email , offerta ]) print ( \"Le offerte valide sono:\" ) print ( offerte ) Che cosa succede se l'utente inserisce dei valori di input non atesi? Ad esempio, invece che inserire un numero inserisce una stringa o qualche carattere non previsto? Vedremo nel capito successivo come trattare questi errori tramite il costrutto try Except","title":"Esercizio Asta online v1"},{"location":"python/#lezione-15","text":"","title":"Lezione 15"},{"location":"python/#costrutto-try-except","text":"Quando si verifica un errore (o un'eccezione), Python normalmente si ferma e genera un messaggio di errore. w3schools - Python Try Except Nell'esempio chiedo all'utente l'inserimento di un numero intero.. Fintanto che l'utente inserisce numeri interi tutto funziona correttamente ma quando per sbaglio l'utente inserisce un carattere non valido, un numero decimale o altro, che succede? while 1 : print ( \"inserisci un numero intero..\" ) x = int ( input ()) if x == 0 break print ( x ) #input() = 1 #1 #input() = 2 #2 #input() = dd # #Traceback (most recent call last): # File \"test.py\", line 3, in <module> # x = int(input()) #ValueError: invalid literal for int() with base 10: 'dd' Inserendo la stringa \"dd\" la conversione esplicita int() fallisce e restituisce un errore: #Traceback (most recent call last): # File \"test.py\", line 3, in <module> # x = int(input()) #ValueError: invalid literal for int() with base 10: 'dd' L'errore \u00e8 di tipo ValueError e la descrizione \u00e8: invalid literal for int() with base 10: 'dd' che significa che la costante letterale dd inserita non \u00e8 un tipo di dato valido per la conversione in base 10, cio\u00e8 in un numero decimale. Come gestisco queste situazioni di errore? Il costrutto try Except permette la gestione di queste situazioni. Sintassi: try : #code1 except #typeError: #code2 Significa: prova (try) ad eseguire code1 , se rilevi un'eccezione di tipo typeError esegui code2 ed \"ignora\" code1 ovvero fai finta che code1 non sia mai stato eseguito. Se non rilevi nessun errore nella fase di try allora esegui code1 Esempio: while 1 : print ( \"Inserisci un numero intero..\" ) try : x = int ( input ()) except ValueError : print ( \" \\n Non \u00e8 un numero intero, riprova..\" ) continue if x == 0 : break print ( \" \\n Il numero inserito \u00e8: \" + str ( x ) + \" \\n \" )","title":"Costrutto try Except"},{"location":"python/#lezione-16","text":"","title":"Lezione 16"},{"location":"python/#introduzione-alle-espressioni-regolari-con-python","text":"Una RegEx, o espressione regolare, \u00e8 una sequenza di caratteri che forma un modello di ricerca. Le RegEx possono essere utilizzate per verificare se una stringa contiene il modello di ricerca specificato. Python ha un modulo integrato chiamato re , che pu\u00f2 essere utilizzato per lavorare con le espressioni regolari. w3schools - Python RegEx","title":"Introduzione alle espressioni regolari con Python"},{"location":"python/#lezione-17","text":"","title":"Lezione 17"},{"location":"python/#esercizio-asta-online-v2","text":"Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: - L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo. E' consentita un'unica offerta per utente! In questa seconda parte ci occuperemo di inserire dei controlli aggiuntivi dei dati acquisiti. Aggiungeremo la possibilit\u00e0 di inserire numeri decimali \"floating point\". Per far ci\u00f2 utilizzeremo la funzione di conversione esplicita da stringa (l'input da tastiera) a numero decimale, float() Rileveremo tutti gli errori legati ad un'inserimento di un dato float non valido come una stringa o qualche altro carattere (come ad esempio Invio ) non interpretabile come numero decimale. Alla rivelazione dell'errore stamperemo il messaggio d'errore \"Formato non valido, riprova ..\" . Utilizzeremo il costrutto try-except Aggiungeremo un'espressione regolare abbastanza semplice per il controllo del formato dell'email. Per far ci\u00f2 utilizzeremo la funzione re.match(regExp, myVar) del modulo re . L'espressione regolare controlla se la stringa (nel nostro caso l'email) inizia ^ con la sequenza di caratteri minuscoli \"a-z\" , maiuscoli \"A-Z\" o numerici \"0-9\" ripetuti. E' seguita dal carattere @ , continua con la sequenza di caratteri minuscoli, maiuscoli o numerici, prosegue con il carattere . ed p seguita dal dominio che per noi sar\u00e0 nuovamente una sequenza di caratteri minuscoli, maiuscoli o numerici. import re offerte = [] altre_offerte = True while altre_offerte : offerta = input ( \"Inserisci l`offerta pervenuta (0 per terminare): \" ) try : offerta = float ( offerta ) except ValueError : print ( \"Formato non valido, riprova ...\" ) continue if offerta == 0 : altre_offerte = False continue if offerta < 0 : print ( \"Non possono essere fatte offerte negative!\" ) continue email = input ( \"Inserire l`email dell`offerente: \" ) if not re . match ( \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\" , email ): print ( \"Email non valida, riprova ...\" ) continue nuova_offerta = [ offerta , email ] print ( offerte )","title":"Esercizio Asta online v2"},{"location":"python/#lezione-18","text":"","title":"Lezione 18"},{"location":"python/#costrutto-if-in","text":"Analogamente al costrutto for ... in il costrutto if ... in si applica a collezioni di elementi in cui si richiede la ricerca di un particolare elemento in una lista if item in list : #code else : #code Esempio: myFruitsList = [ \"banana\" , \"mela\" , \"kiwi\" , \"mandarino\" , \"mela\" ] print ( \"Inserisci il nome di un frutto\" ) itemToSearch = input () if itemToSearch in myFruitsList : print ( \"C'\u00e8 almeno un/una: \" + itemToSearch + \" nella lista\" ) else : print ( \"Non \u00e8 presente nessuno/a \" + itemToSearch + \" nella lista\" )","title":"Costrutto if ... in"},{"location":"python/#lezione-19","text":"","title":"Lezione 19"},{"location":"python/#esercizio-asta-online-v3","text":"Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: - L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo. E' consentita un'unica offerta per utente! In questa terza parte contrellero che la coppia utente/offerta sia unica utilizzando il costrutto if ... in import re offerte = [] altre_offerte = True while altre_offerte : offerta = input ( \"Inserisci l`offerta pervenuta (0 per terminare): \" ) try : offerta = float ( offerta ) except ValueError : print ( \"Formato non valido, riprova ...\" ) continue if offerta == 0 : altre_offerte = False continue if offerta < 0 : print ( \"Non possono essere fatte offerte negative!\" ) continue email = input ( \"Inserire l`email dell`offerente: \" ) if not re . match ( \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\" , email ): print ( \"Email non valida, riprova ...\" ) continue nuova_offerta = [ email , offerta ] # controllo valido solo se viene fatta la stessa offerta con la stessa mail ... limitato! if nuova_offerta in offerte : print ( \"Questo utente ha gi\u00e0 fatto la sua unica offerta ... respinto!\" ) continue else : offerte . append ( nuova_offerta ) print ( \"Le offerte valide sono:\" ) print ( offerte ) Come si vede una coppia identica utente/bit coin viene catturata e rifiutata ma \u00e8 ancora permesso che un utente possa fare pi\u00f9 offerte","title":"Esercizio Asta online v3"},{"location":"python/#lezione-20","text":"","title":"Lezione 20"},{"location":"python/#introduzione-alle-funzioni","text":"Le funzioni vanno definite prima di utilizzarle Una funzione \u00e8 un blocco di codice che viene eseguito solo quando viene chiamata. \u00c8 possibile passare dei valori, chiamati parametri , in una funzione. Una funzione pu\u00f2 restituire dei valori come risultato. In Python una funzione viene definita utilizzando la parola chiave def . w3schools - Python Functions #definizione di una funzione def myFunc ( param ) #code #chiamata di una funzione myFunc ( value1 ) Esempio: def saluta ( nome ): print ( \"ciao: \" + nome + \"!\" ) saluta ( \"Emil\" ) saluta ( \"Tobias\" ) saluta ( \"Linus\" ) # ciao: Emil! # ciao: Tobias! # ciao: Linus!","title":"Introduzione alle Funzioni"},{"location":"python/#lezione-21","text":"","title":"Lezione 21"},{"location":"python/#esercizio-asta-online-v4","text":"Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: - L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo. In questa quarte parte introdurremo la funzione stampa_lista(lista_offerte) che riceve in ingresso la lista delle offerte e stampa il risultato secondo un formato specifico e la funzione inserisci_offerte() che rappresenta l'acquisizione dati da tastiera da parte dell'utente e il controllo sull'integrit\u00e0 dei dati ricevuti. Di fatto la complessit\u00e0 dello script si riduce alla chiamta di due funzioni: inserisci_offerte() e stampa_lista import re def stampa_lista ( lista_offerte ): for offerta in lista_offerte : print ( f \"Email Offerente: { offerta [ 0 ] } - Offerta: { offerta [ 1 ] } \" ) def inserisci_offerte (): lista = [] altre_offerte = True while altre_offerte : offerta = input ( \"Inserisci l`offerta pervenuta (0 per terminare): \" ) try : offerta = float ( offerta ) except ValueError : print ( \"Formato non valido, riprova ...\" ) continue if offerta == 0 : altre_offerte = False # USCITA DAL CICLO continue if offerta < 0 : print ( \"Non possono essere fatte offerte negative!\" ) continue email = input ( \"Inserire l`email dell`offerente: \" ) if not re . match ( \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\" , email ): print ( \"Email non valida, riprova ...\" ) continue nuova_offerta = [ email , offerta ] # controllo valido solo se viene fatta la stessa offerta con la stessa mail ... limitato! if nuova_offerta in lista : print ( \"Questo utente ha gi\u00e0 fatto la sua unica offerta ... respinto!\" ) continue else : lista . append ( nuova_offerta ) return lista # grazie all`uso di funzioni la complessit\u00e0 del programma principale # \u00e8 drasticamente ridotta offerte = inserisci_offerte () stampa_lista ( offerte )","title":"Esercizio Asta online v4"},{"location":"python/#lezione-22","text":"","title":"Lezione 22"},{"location":"python/#esercizio-asta-online-v5","text":"Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: - L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo. In questa quinta parte introdurremo le funzioni: trova_email(email, lista_offerte) : Riceve come parametro una stringa digitata in input dall'utente che rappresenta l'identificativo utente, email e la lista di tutte le offerte, lista_offerte . Ritorna un boolean True se trova l'identificativo email ricevuto come parametro come identificativo nella lista_offerte . Questa funzione controlla quindi se un utente ha gi\u00e0 fatto un'offerta. media_offerte(lista_offerte) : Riceve come parametro la lista di tutte le offert lista_offerte , calcola la media dei valori delle offerte che rappresentano i bit coin e ne ritorna il valore. Ritorna quindi un valore float minimo(lista_offerte) : Riceve come parametro la lista di tutte le offert lista_offerte , calcola il minimo dei valori delle offerte che rappresentano i bit coin e ne ritorna il valore. Ritorna quindi un valore float massimo(lista_offerte) : Riceve come parametro la lista di tutte le offert lista_offerte , calcola il massimo dei valori delle offerte che rappresentano i bit coin e ne ritorna il valore. Ritorna quindi un valore float import re def trova_email ( email , lista_offerte ): trovato = False for offerta in lista_offerte : if offerta [ 0 ] == email : trovato = True break return trovato def media_offerte ( lista_offerte ): somma = 0.0 for offerta in lista_offerte : somma += offerta [ 1 ] return somma / len ( lista_offerte ) # si assume che la lista non sia vuota def minimo ( lista_offerte ): #non si parte mai da un valore assoluto #prelevo solo il valore numerico dell'offerta #min \u00e8 un numero float min = lista_offerte [ 0 ][ 1 ] #lista_offerte[1:] ritorna una lista dal primo elemento fino all'ultimo #Itero ogni elemento della lista lista_offerte a partire dal primo for offerta in lista_offerte [ 1 :]: #se trovo un elemento pi\u00f9 piccolo dell'attuale <min>, aggiorno min if offerta [ 1 ] < min : min = offerta [ 1 ] return min # si assume che la lista non sia vuota def massimo ( lista_offerte ): max = lista_offerte [ 0 ][ 1 ] for offerta in lista_offerte [ 1 :]: if offerta [ 1 ] > max : max = offerta [ 1 ] return max def stampa_lista ( lista_offerte ): for offerta in lista_offerte : print ( f \"Email Offerente: { offerta [ 0 ] } - Offerta: { offerta [ 1 ] } \" ) def inserisci_offerte (): lista = [] altre_offerte = True while altre_offerte : offerta = input ( \"Inserisci l`offerta pervenuta (0 per terminare): \" ) try : offerta = float ( offerta ) except ValueError : print ( \"Formato non valido, riprova ...\" ) continue if offerta == 0 : altre_offerte = False # USCITA DAL CICLO continue if offerta < 0 : print ( \"Non possono essere fatte offerte negative!\" ) continue email = input ( \"Inserire l`email dell`offerente: \" ) if not re . match ( \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\" , email ): print ( \"Email non valida, riprova ...\" ) continue nuova_offerta = [ email , offerta ] # controllo valido solo se viene fatta la stessa offerta con la stessa mail ... limitato! # if nuova_offerta in offerte: # print(\"Questo utente ha gi\u00e0 fatto la sua unica offerta ... respinto!\") # continue # else: # offerte.append(nuova_offerta) if trova_email ( email , lista ): print ( \"Questo utente ha gi\u00e0 fatto la sua unica offerta ... respinto!\" ) continue else : lista . append ( nuova_offerta ) return lista # grazie all`uso di funzioni la complessit\u00e0 del programma principale # \u00e8 drasticamente ridotta offerte = inserisci_offerte () stampa_lista ( offerte ) print ( f \"Offerta Media: { media_offerte ( offerte ) } \" ) print ( f \"Offerta minima: { minimo ( offerte ) } \" )","title":"Esercizio Asta online v5"},{"location":"python/#lezione-23","text":"","title":"Lezione 23"},{"location":"python/#python-list-comprehension","text":"List Comprehension offre una sintassi pi\u00f9 breve quando si desidera creare un nuovo elenco basato sui valori di un elenco esistente. w3schools - Python - List Comprehension E' una sorta di RegEx utilizzata per il tipo List . Sintassi. newlist = [ expression for item in iterable if condition == True ] Nell'esempio che segue costruisco una lista non utilizzando List Comprehension : fruits = [ \"apple\" , \"banana\" , \"cherry\" , \"kiwi\" , \"mango\" ] newlist = [] #La nuova lista conterr\u00e0 soltanto elementi che contengono il carattere \"a\" for x in fruits : if \"a\" in x : newlist . append ( x ) print ( newlist ) #[\"apple\", \"banana\", \"mango\"] Il solito esempio utilizzando List Comprehension : fruits = [ \"apple\" , \"banana\" , \"cherry\" , \"kiwi\" , \"mango\" ] #List Comprehension newlist = [ x for x in fruits if \"a\" in x ] print ( newlist ) E' una sintassi molto vicina alla sintassi del linguaggio matematico.. Pu\u00f2 essere infatti tradotto nel seguente modo: << Cerca le \"x\" all'interno della lista \"fruits\" tali che il carattere \"a\" \u00e8 contenuto in \"x\">> Nel seguente esempio elenco i numeri dispari da 0 a 100 con una sola espressione List Comprehension : #Cerca le x da 0 a 100 tali che il risultato della divisione intera tra x e 2 moltiplicato successivamente per 2 sia diverso da x #es: 3/2 = 1 >> 1*2 = 2 >> 3!=2 >> print #es: 4/2 = 2 >> 2*2 = 4 >> 4=4 print ([ x for x in range ( 0 , 100 ) if x // 2 * 2 != x ])","title":"Python - List Comprehension"},{"location":"python/#lezione-24","text":"","title":"Lezione 24"},{"location":"python/#esercizio-asta-online-v6","text":"Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: - L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo. In questa sesta e ultima parte introdurremo le funzioni: offerta_minima(lista_offerte) : riceve la lista_offerte come parametro e ne identifica la lista con l'offerta minima. E' simile alla funzione minimo(lista_offerte) solo che invece di ritornare il valore decimale dell'offerta minima ritorna una lista comprendente la coppia email/offerta con offerta minima. offerta_massima(lista_offerte) : riceve la lista_offerte come parametro e ne identifica la lista con l'offerta massima. E' simile alla funzione massimo(lista_offerte) solo che invece di ritornare il valore decimale dell'offerta massima ritorna una lista comprendente la coppia email/offerta con offerta massima. Lo script filtrer\u00e0 inoltre le offerte che hanno una tolleranza del 10% calcolata sul valore medio. Infine, \u00e8 stata definita una funzione SIMULA_inserisci_offerte() per evitare di inserire i dati da tastiera e testare lo script import re def SIMULA_inserisci_offerte (): return [ [ 'a@a.com' , 1 ], [ 'b@b.com' , 3.3 ], [ 'c@c.com' , 4.1 ], [ 'd@d.com' , 3.8 ], [ 'e@e.com' , 12 ] ] def trova_email ( email , lista_offerte ): trovato = False for offerta in lista_offerte : if offerta [ 0 ] == email : trovato = True break return trovato def media_offerte ( lista_offerte ): somma = 0.0 for offerta in lista_offerte : somma += offerta [ 1 ] return somma / len ( lista_offerte ) # si assume che la lista non sia vuota def minimo ( lista_offerte ): min = lista_offerte [ 0 ][ 1 ] for offerta in lista_offerte [ 1 :]: if offerta [ 1 ] < min : min = offerta [ 1 ] return min # invece del solo valore minimo restituisce # l`intera offerta [email, valore_offerta] def offerta_minima ( lista_offerte ): min = lista_offerte [ 0 ] for offerta in lista_offerte [ 1 :]: if offerta [ 1 ] < min [ 1 ]: min = offerta #ritorna la coppia <email, valore_offerta> corrispondente al minimo di \"valore_offerta\" return min # si assume che la lista non sia vuota def massimo ( lista_offerte ): max = lista_offerte [ 0 ][ 1 ] for offerta in lista_offerte [ 1 :]: if offerta [ 1 ] > max : max = offerta [ 1 ] return max # invece del solo valore massimo restituisce # l`intera offerta [email, valore_offerta] def offerta_massima ( lista_offerte ): max = lista_offerte [ 0 ] for offerta in lista_offerte [ 1 :]: if offerta [ 1 ] > max [ 1 ]: max = offerta return max def stampa_lista ( lista_offerte ): for offerta in lista_offerte : print ( f \"Email Offerente: { offerta [ 0 ] } - Offerta: { offerta [ 1 ] } \" ) def inserisci_offerte (): lista = [] altre_offerte = True while altre_offerte : offerta = input ( \"Inserisci l`offerta pervenuta (0 per terminare): \" ) try : offerta = float ( offerta ) except ValueError : print ( \"Formato non valido, riprova ...\" ) continue if offerta == 0 : altre_offerte = False # USCITA DAL CICLO continue if offerta < 0 : print ( \"Non possono essere fatte offerte negative!\" ) continue email = input ( \"Inserire l`email dell`offerente: \" ) if not re . match ( \"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\" , email ): print ( \"Email non valida, riprova ...\" ) continue nuova_offerta = [ email , offerta ] if trova_email ( email , lista ): print ( \"Questo utente ha gi\u00e0 fatto la sua unica offerta ... respinto!\" ) continue else : lista . append ( nuova_offerta ) return lista print ( \"\"\" Il seguente script vuole simulare l \\' andamento di un \\' asta online con la seguente regola: << L \\' asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri.>> L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo\"\"\" ) print ( \"-\" * 40 ) # grazie all`uso di funzioni la complessit\u00e0 del programma principale # \u00e8 drasticamente ridotta print ( \" \\n Stampo una lista di offerte predefinite, evito l'input da tastiera\" ) offerte = SIMULA_inserisci_offerte () stampa_lista ( offerte ) print ( \"-\" * 40 ) # eliminiamo l`offerta minima e massima print ( \" \\n Elimino l'offerta pi\u00f9 alta e l'offerta pi\u00f9 bassa\" ) offerte . remove ( offerta_minima ( offerte )) offerte . remove ( offerta_massima ( offerte )) stampa_lista ( offerte ) print ( \"-\" * 40 ) # costruiamo una nuova lista con gli elementi rimasti # che non si discostano pi\u00f9 del 10% dalla media dei rimasti offerta_media = media_offerte ( offerte ) print ( f \"Media: { offerta_media } \" ) tolleranza = offerta_media / 100 * 10 print ( f \"Tolleranza 10%: { tolleranza } \" ) print ( \"-\" * 40 ) offerte_filtrate = [ x for x in offerte if abs ( x [ 1 ] - offerta_media ) < tolleranza ] print ( \" \\n Offerte filtrate in base alla tolleranza..\" ) stampa_lista ( offerte_filtrate ) #Il seguente script vuole simulare l'andamento di un'asta online con la seguente regola: #<< L'asta verr\u00e0 aggiudicata da chi avr\u00e0 fatto un'offerta la pi\u00f9 vicina alla media delle offerte degli altri.>> #L'utente dovr\u00e0 inserire un'offerta in bit coin e una email che rappresenter\u00e0 l'identificativo #---------------------------------------- # #Stampo una lista di offerte predefinite, evito l'input da tastiera #Email Offerente: a@a.com - Offerta: 1 #Email Offerente: b@b.com - Offerta: 3.3 #Email Offerente: c@c.com - Offerta: 4.1 #Email Offerente: d@d.com - Offerta: 3.8 #Email Offerente: e@e.com - Offerta: 12 #---------------------------------------- # #Elimino l'offerta pi\u00f9 alta e l'offerta pi\u00f9 bassa #Email Offerente: b@b.com - Offerta: 3.3 #Email Offerente: c@c.com - Offerta: 4.1 #Email Offerente: d@d.com - Offerta: 3.8 #---------------------------------------- #Media: 3.733333333333333 #Tolleranza 10%: 0.3733333333333333 #---------------------------------------- # #Offerte filtrate in base alla tolleranza.. #Email Offerente: c@c.com - Offerta: 4.1 #Email Offerente: d@d.com - Offerta: 3.8","title":"Esercizio Asta online v6"},{"location":"raspberry-pi-pico/readme/","text":"Raspberry pi pico e Micropython Pinout Strumenti necessari Per iniziare con il primo programma e micropython vai su Getting started with MicroPython e segui le istruzioni, sono complete e fatte bene. In pratica dovrai collegare raspberry pi pico al PC in modalit\u00e0 \"Mass storage\" cio\u00e8 come una normale chiavetta USB e copiare un particolare file in formato UF2 che trovi su Getting started with MicroPython . Per collegare raspberry pi pico al PC in modalit\u00e0 \"Mass Storage\" dovrai prima premere il tasto presente sulla board poi collegare raspberry all'USB come suggerito dall'immagine Se sei curioso di conoscere qualcosa di pi\u00f9 sul formato UF2 vai su uf2 Link Utili Pagina ufficiale raspberry pi pico Esempi di programmazione in c/c++ Esempi di programmazione in micropython Micropython docuementazione ufficiale Python documentazione ufficiale Python asincrono Coroutines and Tasks Primo script async def blink ( led , period_ms ): while True : led . on () await uasyncio . sleep_ms ( 500 ) led . off () await uasyncio . sleep_ms ( period_ms ) async def main ( led1 , led2 ): uasyncio . create_task ( blink ( led1 , 1000 )) uasyncio . create_task ( blink ( led2 , 2000 )) while True : await uasyncio . sleep_ms ( 20_000 ) # Running on a generic board from machine import Pin uasyncio . run ( main ( Pin ( 25 , Pin . OUT ), Pin ( 16 , Pin . OUT ))) Binary Clock Per l'orologio binario avrai bisogno della libreria max7219 . A questo punto devi caricare lo script max7219.py su raspberry pi pico. Se usi Thonny puoi farlo con il tasto \"salva\", ricordando di specificare \"salva su dispositivo\". Una volta che lo script \u00e8 all'interno di raspberry pico puoi scrivere il seguente script ed eseguirlo. Se vuoi rendere lo script funzionante stand alone, ovvero senza eseguirlo necessariamente da Thonny puoi salvare questo script all'interno della memoria di raspberry pico chiamandolo boot.py #Binary CLOCK #V1.00 import max7219 from machine import Pin , SPI import time # https://github.com/FideliusFalcon/rpi_pico_max7219 # VCC -> VBUS, pico number: 40 # GND -> GND, pico number: 38 # DIN -> MOSI (SPI0 TX) GP7, pico number: 10 # CS -> SPI0 CSn GP5, pico number: 7 # CLK -> SCK GP6, pico number: 9 MAX7219_NUM = 4 cs_pin = 5 spi = SPI ( 0 ) display = max7219 . Matrix8x8 ( spi = spi , cs = Pin ( cs_pin ), num = MAX7219_NUM ) def seconds_unit ( i ): display . pixel ( 7 , 7 ,( i >> 0 ) & 1 ) display . pixel ( 6 , 7 ,( i >> 1 ) & 1 ) display . pixel ( 5 , 7 ,( i >> 2 ) & 1 ) display . pixel ( 4 , 7 ,( i >> 3 ) & 1 ) def seconds_dozens ( i ): display . pixel ( 7 , 6 ,( i >> 0 ) & 1 ) display . pixel ( 6 , 6 ,( i >> 1 ) & 1 ) display . pixel ( 5 , 6 ,( i >> 2 ) & 1 ) display . pixel ( 4 , 6 ,( i >> 3 ) & 1 ) def minutes_unit ( i ): display . pixel ( 7 , 4 ,( i >> 0 ) & 1 ) display . pixel ( 6 , 4 ,( i >> 1 ) & 1 ) display . pixel ( 5 , 4 ,( i >> 2 ) & 1 ) display . pixel ( 4 , 4 ,( i >> 3 ) & 1 ) def minutes_dozens ( i ): display . pixel ( 7 , 3 ,( i >> 0 ) & 1 ) display . pixel ( 6 , 3 ,( i >> 1 ) & 1 ) display . pixel ( 5 , 3 ,( i >> 2 ) & 1 ) display . pixel ( 4 , 3 ,( i >> 3 ) & 1 ) def hours_unit ( i ): display . pixel ( 7 , 1 ,( i >> 0 ) & 1 ) display . pixel ( 6 , 1 ,( i >> 1 ) & 1 ) display . pixel ( 5 , 1 ,( i >> 2 ) & 1 ) display . pixel ( 4 , 1 ,( i >> 3 ) & 1 ) def hours_dozens ( i ): display . pixel ( 7 , 0 ,( i >> 0 ) & 1 ) display . pixel ( 6 , 0 ,( i >> 1 ) & 1 ) display . pixel ( 5 , 0 ,( i >> 2 ) & 1 ) display . pixel ( 4 , 0 ,( i >> 3 ) & 1 ) seconds = 30 minutes = 2 hours = 23 while True : seconds_unit ( seconds % 10 ) seconds_dozens ( seconds // 10 ) minutes_unit ( minutes % 10 ) minutes_dozens ( minutes // 10 ) hours_unit ( hours % 10 ) hours_dozens ( hours // 10 ) display . show () seconds = seconds + 1 if ( seconds == 60 ): seconds = 0 minutes = minutes + 1 if ( minutes == 60 ): minutes = 0 hours = hours + 1 if ( hours == 24 ): hours = 0 time . sleep_ms ( 1000 ) # sleep for 500 milliseconds","title":"Raspberry pi pico e Micropython"},{"location":"raspberry-pi-pico/readme/#raspberry-pi-pico-e-micropython","text":"","title":"Raspberry pi pico e Micropython"},{"location":"raspberry-pi-pico/readme/#pinout","text":"","title":"Pinout"},{"location":"raspberry-pi-pico/readme/#strumenti-necessari","text":"Per iniziare con il primo programma e micropython vai su Getting started with MicroPython e segui le istruzioni, sono complete e fatte bene. In pratica dovrai collegare raspberry pi pico al PC in modalit\u00e0 \"Mass storage\" cio\u00e8 come una normale chiavetta USB e copiare un particolare file in formato UF2 che trovi su Getting started with MicroPython . Per collegare raspberry pi pico al PC in modalit\u00e0 \"Mass Storage\" dovrai prima premere il tasto presente sulla board poi collegare raspberry all'USB come suggerito dall'immagine Se sei curioso di conoscere qualcosa di pi\u00f9 sul formato UF2 vai su uf2","title":"Strumenti necessari"},{"location":"raspberry-pi-pico/readme/#link-utili","text":"Pagina ufficiale raspberry pi pico Esempi di programmazione in c/c++ Esempi di programmazione in micropython Micropython docuementazione ufficiale Python documentazione ufficiale Python asincrono Coroutines and Tasks","title":"Link Utili"},{"location":"raspberry-pi-pico/readme/#primo-script","text":"async def blink ( led , period_ms ): while True : led . on () await uasyncio . sleep_ms ( 500 ) led . off () await uasyncio . sleep_ms ( period_ms ) async def main ( led1 , led2 ): uasyncio . create_task ( blink ( led1 , 1000 )) uasyncio . create_task ( blink ( led2 , 2000 )) while True : await uasyncio . sleep_ms ( 20_000 ) # Running on a generic board from machine import Pin uasyncio . run ( main ( Pin ( 25 , Pin . OUT ), Pin ( 16 , Pin . OUT )))","title":"Primo script"},{"location":"raspberry-pi-pico/readme/#binary-clock","text":"Per l'orologio binario avrai bisogno della libreria max7219 . A questo punto devi caricare lo script max7219.py su raspberry pi pico. Se usi Thonny puoi farlo con il tasto \"salva\", ricordando di specificare \"salva su dispositivo\". Una volta che lo script \u00e8 all'interno di raspberry pico puoi scrivere il seguente script ed eseguirlo. Se vuoi rendere lo script funzionante stand alone, ovvero senza eseguirlo necessariamente da Thonny puoi salvare questo script all'interno della memoria di raspberry pico chiamandolo boot.py #Binary CLOCK #V1.00 import max7219 from machine import Pin , SPI import time # https://github.com/FideliusFalcon/rpi_pico_max7219 # VCC -> VBUS, pico number: 40 # GND -> GND, pico number: 38 # DIN -> MOSI (SPI0 TX) GP7, pico number: 10 # CS -> SPI0 CSn GP5, pico number: 7 # CLK -> SCK GP6, pico number: 9 MAX7219_NUM = 4 cs_pin = 5 spi = SPI ( 0 ) display = max7219 . Matrix8x8 ( spi = spi , cs = Pin ( cs_pin ), num = MAX7219_NUM ) def seconds_unit ( i ): display . pixel ( 7 , 7 ,( i >> 0 ) & 1 ) display . pixel ( 6 , 7 ,( i >> 1 ) & 1 ) display . pixel ( 5 , 7 ,( i >> 2 ) & 1 ) display . pixel ( 4 , 7 ,( i >> 3 ) & 1 ) def seconds_dozens ( i ): display . pixel ( 7 , 6 ,( i >> 0 ) & 1 ) display . pixel ( 6 , 6 ,( i >> 1 ) & 1 ) display . pixel ( 5 , 6 ,( i >> 2 ) & 1 ) display . pixel ( 4 , 6 ,( i >> 3 ) & 1 ) def minutes_unit ( i ): display . pixel ( 7 , 4 ,( i >> 0 ) & 1 ) display . pixel ( 6 , 4 ,( i >> 1 ) & 1 ) display . pixel ( 5 , 4 ,( i >> 2 ) & 1 ) display . pixel ( 4 , 4 ,( i >> 3 ) & 1 ) def minutes_dozens ( i ): display . pixel ( 7 , 3 ,( i >> 0 ) & 1 ) display . pixel ( 6 , 3 ,( i >> 1 ) & 1 ) display . pixel ( 5 , 3 ,( i >> 2 ) & 1 ) display . pixel ( 4 , 3 ,( i >> 3 ) & 1 ) def hours_unit ( i ): display . pixel ( 7 , 1 ,( i >> 0 ) & 1 ) display . pixel ( 6 , 1 ,( i >> 1 ) & 1 ) display . pixel ( 5 , 1 ,( i >> 2 ) & 1 ) display . pixel ( 4 , 1 ,( i >> 3 ) & 1 ) def hours_dozens ( i ): display . pixel ( 7 , 0 ,( i >> 0 ) & 1 ) display . pixel ( 6 , 0 ,( i >> 1 ) & 1 ) display . pixel ( 5 , 0 ,( i >> 2 ) & 1 ) display . pixel ( 4 , 0 ,( i >> 3 ) & 1 ) seconds = 30 minutes = 2 hours = 23 while True : seconds_unit ( seconds % 10 ) seconds_dozens ( seconds // 10 ) minutes_unit ( minutes % 10 ) minutes_dozens ( minutes // 10 ) hours_unit ( hours % 10 ) hours_dozens ( hours // 10 ) display . show () seconds = seconds + 1 if ( seconds == 60 ): seconds = 0 minutes = minutes + 1 if ( minutes == 60 ): minutes = 0 hours = hours + 1 if ( hours == 24 ): hours = 0 time . sleep_ms ( 1000 ) # sleep for 500 milliseconds","title":"Binary Clock"},{"location":"react-js/","text":"React.js React.js Prerequisiti React.js in pratica Strumenti necessari Hello react! Folder structure react app Package.json Folder public Folder src App.js Index.js React component Partiamo da zero Divertiamoci un po' Creaiamo Qualcosa di pi\u00f9 interessante Aggiungiamo un po' di stile Props Stato Hooks Prerequisiti React \u00e8 una libreria Javascript utilizzata per creare applicazioni web e usa la sintassi jsx , un mix tra html e javascript . Per poter padroneggiare react avrai bisogno di conoscere Javascript, html e css. React.js in pratica Puoi trovare un tutorial ben fatto sulla pagina ufficiale di react.js . Ti proporr\u00e0 due tipi di tutorial, uno pratico basato sulla costruzione del gioco del tris e uno passo passo in cui potrai apprendere i concetti di react un po' alla volta. Strumenti necessari Per creare un'app react avrai bisogno di: - nodejs - script create-react-app Se hai una delle ultime versioni di nodejs, avrai incluso anche npx un comando che ti permette di installare degli script come create-react-app , eseguirlo e successivamente cancellarlo. In questo modo eviti di installare script a livello globale. Hello react! Se vuoi creare un'applicazione react, digita da terminale: npx create-react-app my-app Il comando crea la cartella my-app , installa le librerie React e React-DOM con le loro dipendenze, configura il package.json e crea i file di un'applicazione di esempio.. Success! Created my-app at /home/s/Repository/corso-react/my-app Inside that directory, you can run several commands: npm start Starts the development server. npm run build Bundles the app into static files for production. npm test Starts the test runner. npm run eject Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can\u2019t go back! We suggest that you begin by typing: cd my-app npm start Happy hacking! Se, come suggerito, entri nella root principale della tua applicazione e lanci il comando npm start vedrai partire un'app di default cd my-app npm start Folder structure react app Lanciando lo script crete-react-app verr\u00e0 creat una folder structure di questo tipo: my-app \u251c\u2500\u2500 README.md \u251c\u2500\u2500 node_modules \u251c\u2500\u2500 package.json \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 public \u2502 \u251c\u2500\u2500 favicon.ico \u2502 \u251c\u2500\u2500 index.html \u2502 \u2514\u2500\u2500 manifest.json \u2514\u2500\u2500 src \u251c\u2500\u2500 App.css \u251c\u2500\u2500 App.js \u251c\u2500\u2500 App.test.js \u251c\u2500\u2500 index.css \u251c\u2500\u2500 index.js \u251c\u2500\u2500 logo.svg \u2514\u2500\u2500 serviceWorker.js \u2514\u2500\u2500 setupTests.js Package.json Il file package.json \u00e8 un file di configurazione e contiene tra le altre cose il nome dell'applicazione, la versione, le dipendeze ovvero i pacchetti npm necessari a react, scripts.. { \"name\" : \"my-app\" , \"version\" : \"0.1.0\" , \"private\" : true , \"dependencies\" : { \"@testing-library/jest-dom\" : \"^5.11.9\" , \"@testing-library/react\" : \"^11.2.3\" , \"@testing-library/user-event\" : \"^12.6.2\" , \"react\" : \"^17.0.1\" , \"react-dom\" : \"^17.0.1\" , \"react-scripts\" : \"4.0.1\" , \"web-vitals\" : \"^0.2.4\" }, \"scripts\" : { \"start\" : \"react-scripts start\" , \"build\" : \"react-scripts build\" , \"test\" : \"react-scripts test\" , \"eject\" : \"react-scripts eject\" }, \"eslintConfig\" : { \"extends\" : [ \"react-app\" , \"react-app/jest\" ] }, \"browserslist\" : { \"production\" : [ \">0.2%\" , \"not dead\" , \"not op_mini all\" ], \"development\" : [ \"last 1 chrome version\" , \"last 1 firefox version\" , \"last 1 safari version\" ] } } Folder public \u251c\u2500\u2500 public \u2502 \u251c\u2500\u2500 favicon.ico \u2502 \u251c\u2500\u2500 index.html \u2502 \u2514\u2500\u2500 manifest.json Contiene il file index.html ovvero l'entry point dell'applicazione react. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" /> < link rel = \"icon\" href = \"%PUBLIC_URL%/favicon.ico\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" /> < meta name = \"theme-color\" content = \"#000000\" /> < meta name = \"description\" content = \"Web site created using create-react-app\" /> < link rel = \"apple-touch-icon\" href = \"%PUBLIC_URL%/logo192.png\" /> <!-- manifest.json provides metadata used when your web app is installed on a user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/ --> < link rel = \"manifest\" href = \"%PUBLIC_URL%/manifest.json\" /> <!-- Notice the use of %PUBLIC_URL% in the tags above. It will be replaced with the URL of the `public` folder during the build. Only files inside the `public` folder can be referenced from the HTML. Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will work correctly both with client-side routing and a non-root public URL. Learn how to configure a non-root public URL by running `npm run build`. --> < title > React App </ title > </ head > < body > < noscript > You need to enable JavaScript to run this app. </ noscript > < div id = \"root\" ></ div > <!-- This HTML file is a template. If you open it directly in the browser, you will see an empty page. You can add webfonts, meta tags, or analytics to this file. The build step will place the bundled scripts into the <body> tag. To begin the development, run `npm start` or `yarn start`. To create a production bundle, use `npm run build` or `yarn build`. --> </ body > </ html > La cosa da notare \u00e8 che il body non contiene niente tranne un div vuoto con id=\"root\" . Folder src \u2514\u2500\u2500 src \u251c\u2500\u2500 App.css \u251c\u2500\u2500 App.js \u251c\u2500\u2500 App.test.js \u251c\u2500\u2500 index.css \u251c\u2500\u2500 index.js \u251c\u2500\u2500 logo.svg \u2514\u2500\u2500 serviceWorker.js \u2514\u2500\u2500 setupTests.js L'applicazione react si sviluppa intorno ai file: App.js e index.js App.js import logo from './logo.svg'; import './App.css'; function App() { return ( <div className=\"App\"> <header className=\"App-header\"> <img src={logo} className=\"App-logo\" alt=\"logo\" /> <p> Edit <code>src/App.js</code> and save to reload. </p> <a className=\"App-link\" href=\"https://reactjs.org\" target=\"_blank\" rel=\"noopener noreferrer\" > Learn React </a> </header> </div> ); } export default App; Osserva che tutto \u00e8 racchiuso dentro una funzione Javascript chiamata App function App() { return ( //.. ); } La funzione App ha come valore di return delle linee di codice molto somiglianti ad html anche se viene compilato e tradotto in javascript. Questa particolare sintassi \u00e8 chiamata JSX < div className = \"App\" > < header className = \"App-header\" > < img src = {logo} className = \"App-logo\" alt = \"logo\" /> < p > Edit < code > src/App.js </ code > and save to reload. </ p > < a className = \"App-link\" href = \"https://reactjs.org\" target = \"_blank\" rel = \"noopener noreferrer\" > Learn React </ a > </ header > </ div > la funzione App \u00e8 esportata esternamente. export default App; Index.js import React from 'react'; import ReactDOM from 'react-dom'; import './index.css'; import App from './App'; import reportWebVitals from './reportWebVitals'; ReactDOM.render( <React.StrictMode> <App /> </React.StrictMode>, document.getElementById('root') ); // If you want to start measuring performance in your app, pass a function // to log results (for example: reportWebVitals(console.log)) // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals reportWebVitals(); React component Un componente in react \u00e8 un file che rappresenta un elemento grafico. Un componente contiene tutto il codice necessario per poter essere rappresentato quindi codice html, css, javascript . La forza di react sta nel poter creare un componente e riutilizzarlo a piacimento in ogni punto dell'applicazione Partiamo da zero Entra nel file App.js e sentiti libero di cancellare tutto. Partiamo da qualcosa di pi\u00f9 semplice //App.js import React from 'react' ; function App (){ return ( < div > < h2 > Ciao React < /h2> < /div> ) } //Equivale a //React.createElement(div) export default App ; Otterrai: Quello che hai fatto \u00e8 scrivere codice JSX cio\u00e8 codice simil-html compilato da react in modo che appaia come codice javascript. Apri anche il file index.js e osserva le importazioni //index.js import React from 'react' ; import ReactDOM from 'react-dom' ; import './index.css' ; import App from './App' ; import reportWebVitals from './reportWebVitals' ; ReactDOM . render ( < React . StrictMode > < App /> < /React.StrictMode>, document . getElementById ( 'root' ) ); // If you want to start measuring performance in your app, pass a function // to log results (for example: reportWebVitals(console.log)) // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals reportWebVitals (); Noterai l'importazione di App import App from './App' ; Nota anche come react si connette alla vera pagina in esecuzione /public/index.html , cio\u00e8 attraverso il metodo ReactDOM.render() document.getElementById('root') ReactDOM . render ( < React . StrictMode > < App /> < /React.StrictMode>, document . getElementById ( 'root' ) ); Ricordiamo infatti che la pagina in esecuzione \u00e8 proprio /public/index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" /> < link rel = \"icon\" href = \"%PUBLIC_URL%/favicon.ico\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" /> < meta name = \"theme-color\" content = \"#000000\" /> < meta name = \"description\" content = \"Web site created using create-react-app\" /> < link rel = \"apple-touch-icon\" href = \"%PUBLIC_URL%/logo192.png\" /> <!-- manifest.json provides metadata used when your web app is installed on a user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/ --> < link rel = \"manifest\" href = \"%PUBLIC_URL%/manifest.json\" /> <!-- Notice the use of %PUBLIC_URL% in the tags above. It will be replaced with the URL of the `public` folder during the build. Only files inside the `public` folder can be referenced from the HTML. Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will work correctly both with client-side routing and a non-root public URL. Learn how to configure a non-root public URL by running `npm run build`. --> < title > React App </ title > </ head > < body > < noscript > You need to enable JavaScript to run this app. </ noscript > < div id = \"root\" ></ div > <!-- This HTML file is a template. If you open it directly in the browser, you will see an empty page. You can add webfonts, meta tags, or analytics to this file. The build step will place the bundled scripts into the <body> tag. To begin the development, run `npm start` or `yarn start`. To create a production bundle, use `npm run build` or `yarn build`. --> </ body > </ html > In particolare ti faccio notare: < body > < noscript > You need to enable JavaScript to run this app. </ noscript > < div id = \"root\" ></ div > <!-- This HTML file is a template. If you open it directly in the browser, you will see an empty page. You can add webfonts, meta tags, or analytics to this file. The build step will place the bundled scripts into the <body> tag. To begin the development, run `npm start` or `yarn start`. To create a production bundle, use `npm run build` or `yarn build`. --> </ body > In pratica, quello che viene fatto dal metodo ReactDOM.render() \u00e8 prendere il componente App e inserirlo all'interno di <div id=\"root\"></div> Divertiamoci un po' Adesso aggiunger\u00f2 un tasto e l'evento click import React from 'react' ; function App (){ return ( < div > < h2 > Ciao React < /h2> < button onClick = {() => console . log ( 'tasto cliccato' )} > cliccami < /button> < /div> ) } //Equivale a //React.createElement(div) export default App ; Cliccando il tasto otterrai una stampa su console, \"tasto cliccato\" Puoi farlo in un modo alternativo facendo uso di un metodo: import React from 'react' ; function App (){ const stampa = () => { console . log ( 'tasto cliccato' ) } return ( < div > < h2 > Ciao React < /h2> < button onClick = { stampa } > cliccami < /button> < /div> ) } //Equivale a //React.createElement(div) export default App ; Un altro modo \u00e8 quello di creare un componente esterno All'interno di src creo un nuovo file ad esempio Stampa.js //Stampa.js import React from 'react' function Stampa () { const stampa = () => { console . log ( 'stampa' ); } return ( < button onClick = { stampa } > cliccami < /button> ) } export default Stampa ; A questo punto devo importarlo in App.js e mandando in esecuzione, tutto funzioner\u00e0 come prima import React from 'react' ; import Stampa from './Stampa' ; //JSX function App (){ return ( < div > < h2 > Ciao React < /h2> < Stampa /> < /div> ) } //Equivale a //React.createElement(div) export default App ; Una creato un componente puoi riutilizzarlo ovunque, baster\u00e0 importarlo import React from 'react' ; import Stampa from './Stampa' ; //JSX function App (){ return ( < div > < h2 > Ciao React < /h2> < Stampa /> < Stampa /> < Stampa /> < /div> ) } //Equivale a //React.createElement(div) export default App ; Creaiamo Qualcosa di pi\u00f9 interessante Creo un componete FacebookPosts.js : //FacebookPosts.js import React from 'react' ; function Post () { return ( < div > < h2 > Autore < /h2> < h4 > Questo \u00e8 il mio post < /h4> < button > Like < /button> < /div> ) } export default Post ; Lo importo nella App.js //App.js import React from 'react' ; import Post from './FacebookPosts' ; //JSX function App (){ return ( < div > < h1 > Home < /h1> < Post /> < /div> ) } //Equivale a //React.createElement(div) export default App ; Apparir\u00e0 qualcosa del tipo: Aggiungiamo un po' di stile Per aggiungere stile, puoi farlo in moduli css . In questo esempio aggiungeremo stile al componente FacebookPosts.js attraverso il file App.css //FacebookPosts.js import React from 'react' ; import './App.css' ; function Post () { return ( < div className = \"Post\" > < h2 > Autore < /h2> < h4 > Questo \u00e8 il mio post < /h4> < button > Like < /button> < /div> ) } export default Post ; /*App.css*/ . Post { border : 1 px solid #555 ; border-radius : 5 px ; margin : 5 px 5 px 0 px 5 px ; display : flexbox ; flex-direction : column ; justify-content : center ; width : 300 px ; } ; Apparir\u00e0 qualcosa del tipo: Puoi modificare anche il file index.css che rappresenta lo stile generale di tutta la pagina html Props Per passare valori tra i componenti puoi usare props . Ti faccio vedere un esempio in cui aggiungo dei Post e a ogni Post passo l'autore del post //App.js import React from 'react' ; import Post from './FacebookPosts' ; //JSX function App (){ return ( < div > < h1 > Home < /h1> < Post autore = \"Andrea\" /> < Post autore = \"Bob\" /> < Post autore = \"Jenny\" /> < Post autore = \"Mile\" /> < /div> ) } //Equivale a //React.createElement(div) export default App ; //FacebookPost.js import React from 'react' ; import './App.css' ; function Post ( props ) { return ( < div className = \"Post\" > < h2 > { props . autore } < /h2> < h4 > Questo \u00e8 il mio post < /h4> < button > Like < /button> < /div> ) } export default Post ; Otterrai: props \u00e8 un oggetto che contiene propriet\u00e0 da noi definite. Vediamo un altro esempio. //App.js import React from 'react' ; import Post from './FacebookPosts' ; //JSX function App (){ return ( < div > < h1 > Home < /h1> < Post autore = \"Andrea\" description = \"Mi piace il gelato\" /> < Post autore = \"Bob\" description = \"E' una bella giornata\" /> < Post autore = \"Jenny\" description = \"Mi piace il gatto\" /> < Post autore = \"Mile\" description = \"Mi piace il cane\" /> < /div> ) } //Equivale a //React.createElement(div) export default App ; //FacebookPost.js import React from 'react' ; import './App.css' ; function Post ( props ) { return ( < div className = \"Post\" > < h2 > { props . autore } < /h2> < h4 > { props . description } < /h4> < button > Like < /button> < /div> ) } export default Post ; Stato Immagina queso problema semplice. Con un tasto voglio cambiare il valore di una varibile //App.js import React from 'react' ; import Post from './FacebookPosts' ; //JSX function App (){ return ( < div className = \"Container\" > < h1 > Home < /h1> < button > Incrementa < /button> < h4 > Counter : 4 < /h4> < /div> ) } //Equivale a //React.createElement(div) export default App ; In particolare, quello che vorrei fare \u00e8 far s\u00ec che premendo il tasto Incrementa si incrementasse il valore che adesso \u00e8 fisso a 4 Come si fa? Dobbiamo introdurre il concetto di Stato . Mostro la soluzione, poi ne parliamo. //App.js import React from 'react' ; import Post from './FacebookPosts' ; //JSX class App extends React . Component { state = { number : 0 } increment = () => { this . setState ({ number : this . state . number + 1 }) } render (){ return ( < div className = \"Container\" > < h1 > Home < /h1> < button onClick = { this . increment } > Incrementa < /button> < h4 > Counter : { this . state . number } < /h4> < /div> ); } } export default App ; Osserva che ho trasformato la funzione App in una classe. In particolare una classe che estende la classe React.component class App extends React . Component { render (){ return ( ) ); } Ho definito l'oggetto state che contiene la property number . state \u00e8 un oggetto, una variabile che contiene lo stato del componente class App extends React . Component { state = { number : 0 } render (){ return ( ) ); } Per accedere alla property number ho usato this.state.number class App extends React . Component { state = { number : 0 } render (){ return ( < div className = \"Container\" > < h1 > Home < /h1> < button > Incrementa < /button> < h4 > Counter : { this . state . number } < /h4> < /div> ); } Ho definito un metodo che potesse incrementare la property definita increment = () => { this . setState ({ number : this . state . number + 1 }) } Hooks Con gli Hooks \u00e8 possibile cambiare lo stato con la notazione a funzione anzich\u00e8 quella di classe. Vediamo un esempio pratico. //App.js import React , { useState } from 'react' ; //JSX function App (){ const [ count , setCount ] = useState ( 0 ); const increment = () => { setCount ( count + 1 ); } return ( < div className = \"Cnt\" > < h1 > Home < /h1> < button onClick = { increment } > Incrementa < /button> < h4 > Counter : { count } < /h4> < /div> ); } //Equivale a //React.createElement(div) export default App ; Per adesso, continueremo a gestire lo stato con la notazione a classe. Pi\u00f9 avanti approfondiremo il concetto di hooks e sarai libero di utilizzare la notazione che pi\u00f9 ti piace. E' importante tuttavia conoscere entrambe le sintassi poich\u00e8 in rete si trovano esempi con entrambi i metodi. E' bene tu sappia che React verte per utilizzare la notazione funzionale attraverso gli hooks.","title":"React.js"},{"location":"react-js/#reactjs","text":"React.js Prerequisiti React.js in pratica Strumenti necessari Hello react! Folder structure react app Package.json Folder public Folder src App.js Index.js React component Partiamo da zero Divertiamoci un po' Creaiamo Qualcosa di pi\u00f9 interessante Aggiungiamo un po' di stile Props Stato Hooks","title":"React.js"},{"location":"react-js/#prerequisiti","text":"React \u00e8 una libreria Javascript utilizzata per creare applicazioni web e usa la sintassi jsx , un mix tra html e javascript . Per poter padroneggiare react avrai bisogno di conoscere Javascript, html e css.","title":"Prerequisiti"},{"location":"react-js/#reactjs-in-pratica","text":"Puoi trovare un tutorial ben fatto sulla pagina ufficiale di react.js . Ti proporr\u00e0 due tipi di tutorial, uno pratico basato sulla costruzione del gioco del tris e uno passo passo in cui potrai apprendere i concetti di react un po' alla volta.","title":"React.js in pratica"},{"location":"react-js/#strumenti-necessari","text":"Per creare un'app react avrai bisogno di: - nodejs - script create-react-app Se hai una delle ultime versioni di nodejs, avrai incluso anche npx un comando che ti permette di installare degli script come create-react-app , eseguirlo e successivamente cancellarlo. In questo modo eviti di installare script a livello globale.","title":"Strumenti necessari"},{"location":"react-js/#hello-react","text":"Se vuoi creare un'applicazione react, digita da terminale: npx create-react-app my-app Il comando crea la cartella my-app , installa le librerie React e React-DOM con le loro dipendenze, configura il package.json e crea i file di un'applicazione di esempio.. Success! Created my-app at /home/s/Repository/corso-react/my-app Inside that directory, you can run several commands: npm start Starts the development server. npm run build Bundles the app into static files for production. npm test Starts the test runner. npm run eject Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can\u2019t go back! We suggest that you begin by typing: cd my-app npm start Happy hacking! Se, come suggerito, entri nella root principale della tua applicazione e lanci il comando npm start vedrai partire un'app di default cd my-app npm start","title":"Hello react!"},{"location":"react-js/#folder-structure-react-app","text":"Lanciando lo script crete-react-app verr\u00e0 creat una folder structure di questo tipo: my-app \u251c\u2500\u2500 README.md \u251c\u2500\u2500 node_modules \u251c\u2500\u2500 package.json \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 public \u2502 \u251c\u2500\u2500 favicon.ico \u2502 \u251c\u2500\u2500 index.html \u2502 \u2514\u2500\u2500 manifest.json \u2514\u2500\u2500 src \u251c\u2500\u2500 App.css \u251c\u2500\u2500 App.js \u251c\u2500\u2500 App.test.js \u251c\u2500\u2500 index.css \u251c\u2500\u2500 index.js \u251c\u2500\u2500 logo.svg \u2514\u2500\u2500 serviceWorker.js \u2514\u2500\u2500 setupTests.js","title":"Folder structure react app"},{"location":"react-js/#packagejson","text":"Il file package.json \u00e8 un file di configurazione e contiene tra le altre cose il nome dell'applicazione, la versione, le dipendeze ovvero i pacchetti npm necessari a react, scripts.. { \"name\" : \"my-app\" , \"version\" : \"0.1.0\" , \"private\" : true , \"dependencies\" : { \"@testing-library/jest-dom\" : \"^5.11.9\" , \"@testing-library/react\" : \"^11.2.3\" , \"@testing-library/user-event\" : \"^12.6.2\" , \"react\" : \"^17.0.1\" , \"react-dom\" : \"^17.0.1\" , \"react-scripts\" : \"4.0.1\" , \"web-vitals\" : \"^0.2.4\" }, \"scripts\" : { \"start\" : \"react-scripts start\" , \"build\" : \"react-scripts build\" , \"test\" : \"react-scripts test\" , \"eject\" : \"react-scripts eject\" }, \"eslintConfig\" : { \"extends\" : [ \"react-app\" , \"react-app/jest\" ] }, \"browserslist\" : { \"production\" : [ \">0.2%\" , \"not dead\" , \"not op_mini all\" ], \"development\" : [ \"last 1 chrome version\" , \"last 1 firefox version\" , \"last 1 safari version\" ] } }","title":"Package.json"},{"location":"react-js/#folder-public","text":"\u251c\u2500\u2500 public \u2502 \u251c\u2500\u2500 favicon.ico \u2502 \u251c\u2500\u2500 index.html \u2502 \u2514\u2500\u2500 manifest.json Contiene il file index.html ovvero l'entry point dell'applicazione react. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" /> < link rel = \"icon\" href = \"%PUBLIC_URL%/favicon.ico\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" /> < meta name = \"theme-color\" content = \"#000000\" /> < meta name = \"description\" content = \"Web site created using create-react-app\" /> < link rel = \"apple-touch-icon\" href = \"%PUBLIC_URL%/logo192.png\" /> <!-- manifest.json provides metadata used when your web app is installed on a user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/ --> < link rel = \"manifest\" href = \"%PUBLIC_URL%/manifest.json\" /> <!-- Notice the use of %PUBLIC_URL% in the tags above. It will be replaced with the URL of the `public` folder during the build. Only files inside the `public` folder can be referenced from the HTML. Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will work correctly both with client-side routing and a non-root public URL. Learn how to configure a non-root public URL by running `npm run build`. --> < title > React App </ title > </ head > < body > < noscript > You need to enable JavaScript to run this app. </ noscript > < div id = \"root\" ></ div > <!-- This HTML file is a template. If you open it directly in the browser, you will see an empty page. You can add webfonts, meta tags, or analytics to this file. The build step will place the bundled scripts into the <body> tag. To begin the development, run `npm start` or `yarn start`. To create a production bundle, use `npm run build` or `yarn build`. --> </ body > </ html > La cosa da notare \u00e8 che il body non contiene niente tranne un div vuoto con id=\"root\" .","title":"Folder public"},{"location":"react-js/#folder-src","text":"\u2514\u2500\u2500 src \u251c\u2500\u2500 App.css \u251c\u2500\u2500 App.js \u251c\u2500\u2500 App.test.js \u251c\u2500\u2500 index.css \u251c\u2500\u2500 index.js \u251c\u2500\u2500 logo.svg \u2514\u2500\u2500 serviceWorker.js \u2514\u2500\u2500 setupTests.js L'applicazione react si sviluppa intorno ai file: App.js e index.js","title":"Folder src"},{"location":"react-js/#appjs","text":"import logo from './logo.svg'; import './App.css'; function App() { return ( <div className=\"App\"> <header className=\"App-header\"> <img src={logo} className=\"App-logo\" alt=\"logo\" /> <p> Edit <code>src/App.js</code> and save to reload. </p> <a className=\"App-link\" href=\"https://reactjs.org\" target=\"_blank\" rel=\"noopener noreferrer\" > Learn React </a> </header> </div> ); } export default App; Osserva che tutto \u00e8 racchiuso dentro una funzione Javascript chiamata App function App() { return ( //.. ); } La funzione App ha come valore di return delle linee di codice molto somiglianti ad html anche se viene compilato e tradotto in javascript. Questa particolare sintassi \u00e8 chiamata JSX < div className = \"App\" > < header className = \"App-header\" > < img src = {logo} className = \"App-logo\" alt = \"logo\" /> < p > Edit < code > src/App.js </ code > and save to reload. </ p > < a className = \"App-link\" href = \"https://reactjs.org\" target = \"_blank\" rel = \"noopener noreferrer\" > Learn React </ a > </ header > </ div > la funzione App \u00e8 esportata esternamente. export default App;","title":"App.js"},{"location":"react-js/#indexjs","text":"import React from 'react'; import ReactDOM from 'react-dom'; import './index.css'; import App from './App'; import reportWebVitals from './reportWebVitals'; ReactDOM.render( <React.StrictMode> <App /> </React.StrictMode>, document.getElementById('root') ); // If you want to start measuring performance in your app, pass a function // to log results (for example: reportWebVitals(console.log)) // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals reportWebVitals();","title":"Index.js"},{"location":"react-js/#react-component","text":"Un componente in react \u00e8 un file che rappresenta un elemento grafico. Un componente contiene tutto il codice necessario per poter essere rappresentato quindi codice html, css, javascript . La forza di react sta nel poter creare un componente e riutilizzarlo a piacimento in ogni punto dell'applicazione","title":"React component"},{"location":"react-js/#partiamo-da-zero","text":"Entra nel file App.js e sentiti libero di cancellare tutto. Partiamo da qualcosa di pi\u00f9 semplice //App.js import React from 'react' ; function App (){ return ( < div > < h2 > Ciao React < /h2> < /div> ) } //Equivale a //React.createElement(div) export default App ; Otterrai: Quello che hai fatto \u00e8 scrivere codice JSX cio\u00e8 codice simil-html compilato da react in modo che appaia come codice javascript. Apri anche il file index.js e osserva le importazioni //index.js import React from 'react' ; import ReactDOM from 'react-dom' ; import './index.css' ; import App from './App' ; import reportWebVitals from './reportWebVitals' ; ReactDOM . render ( < React . StrictMode > < App /> < /React.StrictMode>, document . getElementById ( 'root' ) ); // If you want to start measuring performance in your app, pass a function // to log results (for example: reportWebVitals(console.log)) // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals reportWebVitals (); Noterai l'importazione di App import App from './App' ; Nota anche come react si connette alla vera pagina in esecuzione /public/index.html , cio\u00e8 attraverso il metodo ReactDOM.render() document.getElementById('root') ReactDOM . render ( < React . StrictMode > < App /> < /React.StrictMode>, document . getElementById ( 'root' ) ); Ricordiamo infatti che la pagina in esecuzione \u00e8 proprio /public/index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" /> < link rel = \"icon\" href = \"%PUBLIC_URL%/favicon.ico\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" /> < meta name = \"theme-color\" content = \"#000000\" /> < meta name = \"description\" content = \"Web site created using create-react-app\" /> < link rel = \"apple-touch-icon\" href = \"%PUBLIC_URL%/logo192.png\" /> <!-- manifest.json provides metadata used when your web app is installed on a user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/ --> < link rel = \"manifest\" href = \"%PUBLIC_URL%/manifest.json\" /> <!-- Notice the use of %PUBLIC_URL% in the tags above. It will be replaced with the URL of the `public` folder during the build. Only files inside the `public` folder can be referenced from the HTML. Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will work correctly both with client-side routing and a non-root public URL. Learn how to configure a non-root public URL by running `npm run build`. --> < title > React App </ title > </ head > < body > < noscript > You need to enable JavaScript to run this app. </ noscript > < div id = \"root\" ></ div > <!-- This HTML file is a template. If you open it directly in the browser, you will see an empty page. You can add webfonts, meta tags, or analytics to this file. The build step will place the bundled scripts into the <body> tag. To begin the development, run `npm start` or `yarn start`. To create a production bundle, use `npm run build` or `yarn build`. --> </ body > </ html > In particolare ti faccio notare: < body > < noscript > You need to enable JavaScript to run this app. </ noscript > < div id = \"root\" ></ div > <!-- This HTML file is a template. If you open it directly in the browser, you will see an empty page. You can add webfonts, meta tags, or analytics to this file. The build step will place the bundled scripts into the <body> tag. To begin the development, run `npm start` or `yarn start`. To create a production bundle, use `npm run build` or `yarn build`. --> </ body > In pratica, quello che viene fatto dal metodo ReactDOM.render() \u00e8 prendere il componente App e inserirlo all'interno di <div id=\"root\"></div>","title":"Partiamo da zero"},{"location":"react-js/#divertiamoci-un-po","text":"Adesso aggiunger\u00f2 un tasto e l'evento click import React from 'react' ; function App (){ return ( < div > < h2 > Ciao React < /h2> < button onClick = {() => console . log ( 'tasto cliccato' )} > cliccami < /button> < /div> ) } //Equivale a //React.createElement(div) export default App ; Cliccando il tasto otterrai una stampa su console, \"tasto cliccato\" Puoi farlo in un modo alternativo facendo uso di un metodo: import React from 'react' ; function App (){ const stampa = () => { console . log ( 'tasto cliccato' ) } return ( < div > < h2 > Ciao React < /h2> < button onClick = { stampa } > cliccami < /button> < /div> ) } //Equivale a //React.createElement(div) export default App ; Un altro modo \u00e8 quello di creare un componente esterno All'interno di src creo un nuovo file ad esempio Stampa.js //Stampa.js import React from 'react' function Stampa () { const stampa = () => { console . log ( 'stampa' ); } return ( < button onClick = { stampa } > cliccami < /button> ) } export default Stampa ; A questo punto devo importarlo in App.js e mandando in esecuzione, tutto funzioner\u00e0 come prima import React from 'react' ; import Stampa from './Stampa' ; //JSX function App (){ return ( < div > < h2 > Ciao React < /h2> < Stampa /> < /div> ) } //Equivale a //React.createElement(div) export default App ; Una creato un componente puoi riutilizzarlo ovunque, baster\u00e0 importarlo import React from 'react' ; import Stampa from './Stampa' ; //JSX function App (){ return ( < div > < h2 > Ciao React < /h2> < Stampa /> < Stampa /> < Stampa /> < /div> ) } //Equivale a //React.createElement(div) export default App ;","title":"Divertiamoci un po'"},{"location":"react-js/#creaiamo-qualcosa-di-piu-interessante","text":"Creo un componete FacebookPosts.js : //FacebookPosts.js import React from 'react' ; function Post () { return ( < div > < h2 > Autore < /h2> < h4 > Questo \u00e8 il mio post < /h4> < button > Like < /button> < /div> ) } export default Post ; Lo importo nella App.js //App.js import React from 'react' ; import Post from './FacebookPosts' ; //JSX function App (){ return ( < div > < h1 > Home < /h1> < Post /> < /div> ) } //Equivale a //React.createElement(div) export default App ; Apparir\u00e0 qualcosa del tipo:","title":"Creaiamo Qualcosa di pi\u00f9 interessante"},{"location":"react-js/#aggiungiamo-un-po-di-stile","text":"Per aggiungere stile, puoi farlo in moduli css . In questo esempio aggiungeremo stile al componente FacebookPosts.js attraverso il file App.css //FacebookPosts.js import React from 'react' ; import './App.css' ; function Post () { return ( < div className = \"Post\" > < h2 > Autore < /h2> < h4 > Questo \u00e8 il mio post < /h4> < button > Like < /button> < /div> ) } export default Post ; /*App.css*/ . Post { border : 1 px solid #555 ; border-radius : 5 px ; margin : 5 px 5 px 0 px 5 px ; display : flexbox ; flex-direction : column ; justify-content : center ; width : 300 px ; } ; Apparir\u00e0 qualcosa del tipo: Puoi modificare anche il file index.css che rappresenta lo stile generale di tutta la pagina html","title":"Aggiungiamo un po' di stile"},{"location":"react-js/#props","text":"Per passare valori tra i componenti puoi usare props . Ti faccio vedere un esempio in cui aggiungo dei Post e a ogni Post passo l'autore del post //App.js import React from 'react' ; import Post from './FacebookPosts' ; //JSX function App (){ return ( < div > < h1 > Home < /h1> < Post autore = \"Andrea\" /> < Post autore = \"Bob\" /> < Post autore = \"Jenny\" /> < Post autore = \"Mile\" /> < /div> ) } //Equivale a //React.createElement(div) export default App ; //FacebookPost.js import React from 'react' ; import './App.css' ; function Post ( props ) { return ( < div className = \"Post\" > < h2 > { props . autore } < /h2> < h4 > Questo \u00e8 il mio post < /h4> < button > Like < /button> < /div> ) } export default Post ; Otterrai: props \u00e8 un oggetto che contiene propriet\u00e0 da noi definite. Vediamo un altro esempio. //App.js import React from 'react' ; import Post from './FacebookPosts' ; //JSX function App (){ return ( < div > < h1 > Home < /h1> < Post autore = \"Andrea\" description = \"Mi piace il gelato\" /> < Post autore = \"Bob\" description = \"E' una bella giornata\" /> < Post autore = \"Jenny\" description = \"Mi piace il gatto\" /> < Post autore = \"Mile\" description = \"Mi piace il cane\" /> < /div> ) } //Equivale a //React.createElement(div) export default App ; //FacebookPost.js import React from 'react' ; import './App.css' ; function Post ( props ) { return ( < div className = \"Post\" > < h2 > { props . autore } < /h2> < h4 > { props . description } < /h4> < button > Like < /button> < /div> ) } export default Post ;","title":"Props"},{"location":"react-js/#stato","text":"Immagina queso problema semplice. Con un tasto voglio cambiare il valore di una varibile //App.js import React from 'react' ; import Post from './FacebookPosts' ; //JSX function App (){ return ( < div className = \"Container\" > < h1 > Home < /h1> < button > Incrementa < /button> < h4 > Counter : 4 < /h4> < /div> ) } //Equivale a //React.createElement(div) export default App ; In particolare, quello che vorrei fare \u00e8 far s\u00ec che premendo il tasto Incrementa si incrementasse il valore che adesso \u00e8 fisso a 4 Come si fa? Dobbiamo introdurre il concetto di Stato . Mostro la soluzione, poi ne parliamo. //App.js import React from 'react' ; import Post from './FacebookPosts' ; //JSX class App extends React . Component { state = { number : 0 } increment = () => { this . setState ({ number : this . state . number + 1 }) } render (){ return ( < div className = \"Container\" > < h1 > Home < /h1> < button onClick = { this . increment } > Incrementa < /button> < h4 > Counter : { this . state . number } < /h4> < /div> ); } } export default App ; Osserva che ho trasformato la funzione App in una classe. In particolare una classe che estende la classe React.component class App extends React . Component { render (){ return ( ) ); } Ho definito l'oggetto state che contiene la property number . state \u00e8 un oggetto, una variabile che contiene lo stato del componente class App extends React . Component { state = { number : 0 } render (){ return ( ) ); } Per accedere alla property number ho usato this.state.number class App extends React . Component { state = { number : 0 } render (){ return ( < div className = \"Container\" > < h1 > Home < /h1> < button > Incrementa < /button> < h4 > Counter : { this . state . number } < /h4> < /div> ); } Ho definito un metodo che potesse incrementare la property definita increment = () => { this . setState ({ number : this . state . number + 1 }) }","title":"Stato"},{"location":"react-js/#hooks","text":"Con gli Hooks \u00e8 possibile cambiare lo stato con la notazione a funzione anzich\u00e8 quella di classe. Vediamo un esempio pratico. //App.js import React , { useState } from 'react' ; //JSX function App (){ const [ count , setCount ] = useState ( 0 ); const increment = () => { setCount ( count + 1 ); } return ( < div className = \"Cnt\" > < h1 > Home < /h1> < button onClick = { increment } > Incrementa < /button> < h4 > Counter : { count } < /h4> < /div> ); } //Equivale a //React.createElement(div) export default App ; Per adesso, continueremo a gestire lo stato con la notazione a classe. Pi\u00f9 avanti approfondiremo il concetto di hooks e sarai libero di utilizzare la notazione che pi\u00f9 ti piace. E' importante tuttavia conoscere entrambe le sintassi poich\u00e8 in rete si trovano esempi con entrambi i metodi. E' bene tu sappia che React verte per utilizzare la notazione funzionale attraverso gli hooks.","title":"Hooks"},{"location":"react-js/test/my-app/","text":"Getting Started with Create React App This project was bootstrapped with Create React App . Available Scripts In the project directory, you can run: npm start Runs the app in the development mode.\\ Open http://localhost:3000 to view it in the browser. The page will reload if you make edits.\\ You will also see any lint errors in the console. npm test Launches the test runner in the interactive watch mode.\\ See the section about running tests for more information. npm run build Builds the app for production to the build folder.\\ It correctly bundles React in production mode and optimizes the build for the best performance. The build is minified and the filenames include the hashes.\\ Your app is ready to be deployed! See the section about deployment for more information. npm run eject Note: this is a one-way operation. Once you eject , you can\u2019t go back! If you aren\u2019t satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you\u2019re on your own. You don\u2019t have to ever use eject . The curated feature set is suitable for small and middle deployments, and you shouldn\u2019t feel obligated to use this feature. However we understand that this tool wouldn\u2019t be useful if you couldn\u2019t customize it when you are ready for it. Learn More You can learn more in the Create React App documentation . To learn React, check out the React documentation . Code Splitting This section has moved here: https://facebook.github.io/create-react-app/docs/code-splitting Analyzing the Bundle Size This section has moved here: https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size Making a Progressive Web App This section has moved here: https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app Advanced Configuration This section has moved here: https://facebook.github.io/create-react-app/docs/advanced-configuration Deployment This section has moved here: https://facebook.github.io/create-react-app/docs/deployment npm run build fails to minify This section has moved here: https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify","title":"Getting Started with Create React App"},{"location":"react-js/test/my-app/#getting-started-with-create-react-app","text":"This project was bootstrapped with Create React App .","title":"Getting Started with Create React App"},{"location":"react-js/test/my-app/#available-scripts","text":"In the project directory, you can run:","title":"Available Scripts"},{"location":"react-js/test/my-app/#npm-start","text":"Runs the app in the development mode.\\ Open http://localhost:3000 to view it in the browser. The page will reload if you make edits.\\ You will also see any lint errors in the console.","title":"npm start"},{"location":"react-js/test/my-app/#npm-test","text":"Launches the test runner in the interactive watch mode.\\ See the section about running tests for more information.","title":"npm test"},{"location":"react-js/test/my-app/#npm-run-build","text":"Builds the app for production to the build folder.\\ It correctly bundles React in production mode and optimizes the build for the best performance. The build is minified and the filenames include the hashes.\\ Your app is ready to be deployed! See the section about deployment for more information.","title":"npm run build"},{"location":"react-js/test/my-app/#npm-run-eject","text":"Note: this is a one-way operation. Once you eject , you can\u2019t go back! If you aren\u2019t satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you\u2019re on your own. You don\u2019t have to ever use eject . The curated feature set is suitable for small and middle deployments, and you shouldn\u2019t feel obligated to use this feature. However we understand that this tool wouldn\u2019t be useful if you couldn\u2019t customize it when you are ready for it.","title":"npm run eject"},{"location":"react-js/test/my-app/#learn-more","text":"You can learn more in the Create React App documentation . To learn React, check out the React documentation .","title":"Learn More"},{"location":"react-js/test/my-app/#code-splitting","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/code-splitting","title":"Code Splitting"},{"location":"react-js/test/my-app/#analyzing-the-bundle-size","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size","title":"Analyzing the Bundle Size"},{"location":"react-js/test/my-app/#making-a-progressive-web-app","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app","title":"Making a Progressive Web App"},{"location":"react-js/test/my-app/#advanced-configuration","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/advanced-configuration","title":"Advanced Configuration"},{"location":"react-js/test/my-app/#deployment","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/deployment","title":"Deployment"},{"location":"react-js/test/my-app/#npm-run-build-fails-to-minify","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify","title":"npm run build fails to minify"},{"location":"react-js/test/my-app-2/","text":"Getting Started with Create React App This project was bootstrapped with Create React App . Available Scripts In the project directory, you can run: npm start Runs the app in the development mode.\\ Open http://localhost:3000 to view it in the browser. The page will reload if you make edits.\\ You will also see any lint errors in the console. npm test Launches the test runner in the interactive watch mode.\\ See the section about running tests for more information. npm run build Builds the app for production to the build folder.\\ It correctly bundles React in production mode and optimizes the build for the best performance. The build is minified and the filenames include the hashes.\\ Your app is ready to be deployed! See the section about deployment for more information. npm run eject Note: this is a one-way operation. Once you eject , you can\u2019t go back! If you aren\u2019t satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you\u2019re on your own. You don\u2019t have to ever use eject . The curated feature set is suitable for small and middle deployments, and you shouldn\u2019t feel obligated to use this feature. However we understand that this tool wouldn\u2019t be useful if you couldn\u2019t customize it when you are ready for it. Learn More You can learn more in the Create React App documentation . To learn React, check out the React documentation . Code Splitting This section has moved here: https://facebook.github.io/create-react-app/docs/code-splitting Analyzing the Bundle Size This section has moved here: https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size Making a Progressive Web App This section has moved here: https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app Advanced Configuration This section has moved here: https://facebook.github.io/create-react-app/docs/advanced-configuration Deployment This section has moved here: https://facebook.github.io/create-react-app/docs/deployment npm run build fails to minify This section has moved here: https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify","title":"Getting Started with Create React App"},{"location":"react-js/test/my-app-2/#getting-started-with-create-react-app","text":"This project was bootstrapped with Create React App .","title":"Getting Started with Create React App"},{"location":"react-js/test/my-app-2/#available-scripts","text":"In the project directory, you can run:","title":"Available Scripts"},{"location":"react-js/test/my-app-2/#npm-start","text":"Runs the app in the development mode.\\ Open http://localhost:3000 to view it in the browser. The page will reload if you make edits.\\ You will also see any lint errors in the console.","title":"npm start"},{"location":"react-js/test/my-app-2/#npm-test","text":"Launches the test runner in the interactive watch mode.\\ See the section about running tests for more information.","title":"npm test"},{"location":"react-js/test/my-app-2/#npm-run-build","text":"Builds the app for production to the build folder.\\ It correctly bundles React in production mode and optimizes the build for the best performance. The build is minified and the filenames include the hashes.\\ Your app is ready to be deployed! See the section about deployment for more information.","title":"npm run build"},{"location":"react-js/test/my-app-2/#npm-run-eject","text":"Note: this is a one-way operation. Once you eject , you can\u2019t go back! If you aren\u2019t satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you\u2019re on your own. You don\u2019t have to ever use eject . The curated feature set is suitable for small and middle deployments, and you shouldn\u2019t feel obligated to use this feature. However we understand that this tool wouldn\u2019t be useful if you couldn\u2019t customize it when you are ready for it.","title":"npm run eject"},{"location":"react-js/test/my-app-2/#learn-more","text":"You can learn more in the Create React App documentation . To learn React, check out the React documentation .","title":"Learn More"},{"location":"react-js/test/my-app-2/#code-splitting","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/code-splitting","title":"Code Splitting"},{"location":"react-js/test/my-app-2/#analyzing-the-bundle-size","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size","title":"Analyzing the Bundle Size"},{"location":"react-js/test/my-app-2/#making-a-progressive-web-app","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app","title":"Making a Progressive Web App"},{"location":"react-js/test/my-app-2/#advanced-configuration","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/advanced-configuration","title":"Advanced Configuration"},{"location":"react-js/test/my-app-2/#deployment","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/deployment","title":"Deployment"},{"location":"react-js/test/my-app-2/#npm-run-build-fails-to-minify","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify","title":"npm run build fails to minify"},{"location":"react-js/test/shoppy-world/","text":"Getting Started with Create React App This project was bootstrapped with Create React App . Available Scripts In the project directory, you can run: npm start Runs the app in the development mode.\\ Open http://localhost:3000 to view it in the browser. The page will reload if you make edits.\\ You will also see any lint errors in the console. npm test Launches the test runner in the interactive watch mode.\\ See the section about running tests for more information. npm run build Builds the app for production to the build folder.\\ It correctly bundles React in production mode and optimizes the build for the best performance. The build is minified and the filenames include the hashes.\\ Your app is ready to be deployed! See the section about deployment for more information. npm run eject Note: this is a one-way operation. Once you eject , you can\u2019t go back! If you aren\u2019t satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you\u2019re on your own. You don\u2019t have to ever use eject . The curated feature set is suitable for small and middle deployments, and you shouldn\u2019t feel obligated to use this feature. However we understand that this tool wouldn\u2019t be useful if you couldn\u2019t customize it when you are ready for it. Learn More You can learn more in the Create React App documentation . To learn React, check out the React documentation . Code Splitting This section has moved here: https://facebook.github.io/create-react-app/docs/code-splitting Analyzing the Bundle Size This section has moved here: https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size Making a Progressive Web App This section has moved here: https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app Advanced Configuration This section has moved here: https://facebook.github.io/create-react-app/docs/advanced-configuration Deployment This section has moved here: https://facebook.github.io/create-react-app/docs/deployment npm run build fails to minify This section has moved here: https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify","title":"Getting Started with Create React App"},{"location":"react-js/test/shoppy-world/#getting-started-with-create-react-app","text":"This project was bootstrapped with Create React App .","title":"Getting Started with Create React App"},{"location":"react-js/test/shoppy-world/#available-scripts","text":"In the project directory, you can run:","title":"Available Scripts"},{"location":"react-js/test/shoppy-world/#npm-start","text":"Runs the app in the development mode.\\ Open http://localhost:3000 to view it in the browser. The page will reload if you make edits.\\ You will also see any lint errors in the console.","title":"npm start"},{"location":"react-js/test/shoppy-world/#npm-test","text":"Launches the test runner in the interactive watch mode.\\ See the section about running tests for more information.","title":"npm test"},{"location":"react-js/test/shoppy-world/#npm-run-build","text":"Builds the app for production to the build folder.\\ It correctly bundles React in production mode and optimizes the build for the best performance. The build is minified and the filenames include the hashes.\\ Your app is ready to be deployed! See the section about deployment for more information.","title":"npm run build"},{"location":"react-js/test/shoppy-world/#npm-run-eject","text":"Note: this is a one-way operation. Once you eject , you can\u2019t go back! If you aren\u2019t satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you\u2019re on your own. You don\u2019t have to ever use eject . The curated feature set is suitable for small and middle deployments, and you shouldn\u2019t feel obligated to use this feature. However we understand that this tool wouldn\u2019t be useful if you couldn\u2019t customize it when you are ready for it.","title":"npm run eject"},{"location":"react-js/test/shoppy-world/#learn-more","text":"You can learn more in the Create React App documentation . To learn React, check out the React documentation .","title":"Learn More"},{"location":"react-js/test/shoppy-world/#code-splitting","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/code-splitting","title":"Code Splitting"},{"location":"react-js/test/shoppy-world/#analyzing-the-bundle-size","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size","title":"Analyzing the Bundle Size"},{"location":"react-js/test/shoppy-world/#making-a-progressive-web-app","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app","title":"Making a Progressive Web App"},{"location":"react-js/test/shoppy-world/#advanced-configuration","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/advanced-configuration","title":"Advanced Configuration"},{"location":"react-js/test/shoppy-world/#deployment","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/deployment","title":"Deployment"},{"location":"react-js/test/shoppy-world/#npm-run-build-fails-to-minify","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify","title":"npm run build fails to minify"},{"location":"reg-expr/","text":"Regular Expression Un' espressione regolare \u00e8 una stringa di caratteri opportunamente codificata che filtra un'insieme di stringhe. E' possibile, con un'espressione regolare creare dei filtri per le ricerche di testo all'interno di un file o un determinato modello. Strumenti necessari Puoi imparare la sintassi delle espressioni regolari su un motore online come RegExpr . E' un ottimo strumento poich\u00e8 oltre ad evidenziare nel testo l'insieme di caratteri filtrati dall'espressione regolare fornisce anche una spiegazione per ogni costrutto utilizzato nell'espressione regolare. Qualche esempio Selezione 1 Vediamo subito un esempio. La seguente \u00e8 un'espressione regolare che seleziona tutte le lettere maiuscole e minuscole RegExpr /[a-zA-Z]/g Input Ciao a tutti!! 12 volte grazie.. Output C,i,a,o,a,t,u,t,t,i,v,o,l,t,e,g,r,a,z,i,e Nota: Ho utato la , per separare la selezione. Con questo si vuol evidenziare che gli spazi vengono ignorati Selezione 2 La seguente espressione regolare invece selezioner\u00e0 soltanto i caratteri numerici RegExpr /[0-9]/g Input Ciao a tutti!! 12 volte grazie.. Output 1,2 Partiamo dall'inizio I metacaratteri Descrizione . indica qualsiasi carattere (escluso un accapo) ^ indica l\u2019inizio della stringa (o, se all\u2019interno di una classe di caratteri, la negazione della stessa) $ indica la fine della stringa \\| indica l\u2019operatore OR \\ il carattere di escape dei caratteri speciali () Contengono una sottostringa. Utili per il raggruppamento [] Contengono una \u2018classe\u2019 di caratteri I quantificatori Descrizione * indica zero o pi\u00f9 occorrenze (di un carattere o di un gruppo di caratteri) + indica una o pi\u00f9 occorrenze (di un carattere o di un gruppo di caratteri) ? indica zero o una occorrenza (di un carattere o di un gruppo di caratteri) {} le parentesi graffe, che indicano il numero esatto, o minimo, o massimo, o l\u2019intervallo di occorrenze (di un carattere o di un gruppo di caratteri) Qualche esempio RegExpr /./g Input Ciao a tutti!! 12 volte grazie.. Output Ciao a tutti!! 12 volte grazie.. RegExpr /[^0-9]/g Input Ciao a tutti!! 12 volte grazie.. Output C,i,a,o, ,a, ,t,u,t,t,i,!,!, , ,v,o,l,t,e, ,g,r,a,z,i,e,.,., RegExpr /t*/g Input Ciao a tutti!! 12 volte grazie.. Output t,tt,t RegExpr /t?/g Input Ciao a tutti!! 12 volte grazie.. Output t,t,t,t RegExpr /[0-9]{1}/g Input Ciao a tutti!! 12 volte grazie.. Output 1,2 RegExpr /[0-9]{2}/g Input Ciao a tutti!! 12 volte grazie.. Output 12 RegExpr /[a-z]{5,6}/g Input Ciao a tutti!! 12 volte grazie.. Output tutti,volte,grazie RegExpr /[a-z]+/g Input Ciao a tutti!! 12 volte grazie.. Output iao,a,tutti,volte,grazie RegExpr /[0-9]+/g Input Ciao a tutti!! 12 volte grazie.. Output 12 RegExpr /volte\\|grazie/g Input Ciao a tutti!! 12 volte grazie.. Output volte,grazie Le classi di caratteri e i POSIX Le classi di caratteri e i POSIX servono per specificare una serie di caratteri allo stesso tempo, senza dover scomodare i gruppi. Classe Equivalente Descrizione \\w [[:word:]] [a-zA-Z0-9_] ricerca un carattere \u201cparola\u201d (w sta per word), cio\u00e8 lettere, numeri e \u201c_\u201d \\d [[:digit:]] [0-9] ricerca un numero (d sta per digit) \\s [[:space:]] [ \\t\\r\\n\\v\\f] ricerca uno spazio, comprese tabulazioni e caratteri di fine riga --- --- --- \\W [^a-zA-Z0-9_] ricerca un carattere che non sia \\w , cio\u00e8 tutto quello che non \u00e8 lettere, numeri o \u201c_\u201d\u201d \\D [^0-9] l\u2019opposto di \\d , ricerca qualsiasi cosa che non sia un numero \\S [^ \\t\\r\\n\\v\\f] l\u2019inverso di \\s , ricerca qualsiasi cosa che non sia uno spazio, una tabulazione o dei caratteri di fine riga --- --- --- [[:alnum:]] [a-zA-Z0-9] Ricerca caratteri alfanumerici, senza \u201c_\u201d [[:alpha:]] [a-zA-Z] Ricerca caratteri alfabetici [[:blank:]] [ \\t] ricerca solo spazi e tabulazioni [[:lower:]] [a-z] ricerca lettere minuscole [[:upper:]] [A-Z] ricerca lettere maiuscole [[:graph:]] [\\x21-x7E] ricerca tutti i caratteri visibili a video della tabella ascii non estesa, dal numero 33 (!) al 126 (~). [[:print:]] [\\x20-x7E] ricerca tutti i caratteri visibili a video della tabella ascii non estesa, dal numero 32 (spazio) al 126 (~). [[:punct:]] ricerca tutti i caratteri di punteggiatura come -!\u201d#$%&'()*+,.\\/:;<=>?@[]^_`{ [[:cntrl:]] [\\x00-x1F\\x7F] ricerca solo i caratteri di controllo Esercizio - ricerca di una email semplice 1 RegExpr /[\\w]+@[\\w]+\\.[\\w]+/g Input Ciao, ricordati di scrivermi alla mia email personale per l'acconto articolo DKR#123, qt.2, ID@12901, email: prova@gmail.com Output prova@gmail.com Nell'espressione regolare sto cercando uno o pi\u00f9 caratteri seguiti dal simbolo @ seguiti da uno o pi\u00f9 caratteri, seguiti da . seguito da uno o pi\u00f9 caratteri. Ricordo che \\w ricerca tutte le lettere maiuscole/minuscole compreso il carattere _ e le cifre. Nota: Per quanto possa sembrare semplice e completo, questo esempio non include le email del tipo prova.prova@gmail.com Esercizio - ricerca di una email semplice 2 L'esempio precedente non raccoglie email del tipo prova.prova@gmail.com , infatti: RegExpr /[\\w]+@[\\w]+\\.[\\w]+/g Input Ciao, ricordati di scrivermi alla mia email personale per l'acconto articolo DKR#123, qt.2, ID@12901, email1: mario.rossi78@gmail.com Output rossi78@gmail.com Ecco allora una piccola modifica per aggiungere nella prima parte una selezione opzionale del carattere . RegExpr /([\\w]\\.?)+@[\\w]+\\.[\\w]+/g Input Ciao, ricordati di scrivermi alla mia email personale per l'acconto articolo DKR#123, qt.2, ID@12901, email1: mario.rossi78@gmail.com Output mario.rossi78@gmail.com Esercizio - ricerca di una url Questo esercizio ricerca una url semplice ma non completa RegExpr /(https?)\\:\\/{2}([\\w\\.]+\\/?)+([\\w\\#\\-\\.]+\\/?)+/g Input Ciao, ricordati di visualizzare i seguenti link, link: https://regexr.com, link: http://regexr.com/5mpk9, link: https://it.wikipedia.org/wiki/Posta_elettronica, link: https://github.com/CodeCoagious19, link: https://webmail.intecs.it/mail#1, link: https://github.com/CodeCoagious19/corsi-programmazione/blob/master/README.md#programmazione-desktop Output https://regexr.com,http://regexr.com/5mpk9,https://it.wikipedia.org/wiki/Posta_elettronica,https://github.com/CodeCoagious19,https://webmail.intecs.it/mail#1,https://github.com/CodeCoagious19/corsi-programmazione/blob/master/README.md#programmazione-desktop L'espressione regolare parte con il cercare https o http , prosegue alla ricerca di // . Nel primo gruppo ricerca testo che sia composto da una o pi\u00f9 lettere comprensive del carattere . ed eventualmente il carattere / . Nel secondo gruppo invece, opzionale e pi\u00f9 complesso ricerca del testo che contenga uno o pi\u00f9 lettere compresensive eventualmente del carattere - , . o # , anche questo gruppo ha opzionale il caratere / . Ripeto inoltre la ricerca di questo gruppo.","title":"Regular Expression"},{"location":"reg-expr/#regular-expression","text":"Un' espressione regolare \u00e8 una stringa di caratteri opportunamente codificata che filtra un'insieme di stringhe. E' possibile, con un'espressione regolare creare dei filtri per le ricerche di testo all'interno di un file o un determinato modello.","title":"Regular Expression"},{"location":"reg-expr/#strumenti-necessari","text":"Puoi imparare la sintassi delle espressioni regolari su un motore online come RegExpr . E' un ottimo strumento poich\u00e8 oltre ad evidenziare nel testo l'insieme di caratteri filtrati dall'espressione regolare fornisce anche una spiegazione per ogni costrutto utilizzato nell'espressione regolare.","title":"Strumenti necessari"},{"location":"reg-expr/#qualche-esempio","text":"","title":"Qualche esempio"},{"location":"reg-expr/#selezione-1","text":"Vediamo subito un esempio. La seguente \u00e8 un'espressione regolare che seleziona tutte le lettere maiuscole e minuscole RegExpr /[a-zA-Z]/g Input Ciao a tutti!! 12 volte grazie.. Output C,i,a,o,a,t,u,t,t,i,v,o,l,t,e,g,r,a,z,i,e Nota: Ho utato la , per separare la selezione. Con questo si vuol evidenziare che gli spazi vengono ignorati","title":"Selezione 1"},{"location":"reg-expr/#selezione-2","text":"La seguente espressione regolare invece selezioner\u00e0 soltanto i caratteri numerici RegExpr /[0-9]/g Input Ciao a tutti!! 12 volte grazie.. Output 1,2","title":"Selezione 2"},{"location":"reg-expr/#partiamo-dallinizio","text":"","title":"Partiamo dall'inizio"},{"location":"reg-expr/#i-metacaratteri","text":"Descrizione . indica qualsiasi carattere (escluso un accapo) ^ indica l\u2019inizio della stringa (o, se all\u2019interno di una classe di caratteri, la negazione della stessa) $ indica la fine della stringa \\| indica l\u2019operatore OR \\ il carattere di escape dei caratteri speciali () Contengono una sottostringa. Utili per il raggruppamento [] Contengono una \u2018classe\u2019 di caratteri","title":"I metacaratteri"},{"location":"reg-expr/#i-quantificatori","text":"Descrizione * indica zero o pi\u00f9 occorrenze (di un carattere o di un gruppo di caratteri) + indica una o pi\u00f9 occorrenze (di un carattere o di un gruppo di caratteri) ? indica zero o una occorrenza (di un carattere o di un gruppo di caratteri) {} le parentesi graffe, che indicano il numero esatto, o minimo, o massimo, o l\u2019intervallo di occorrenze (di un carattere o di un gruppo di caratteri)","title":"I quantificatori"},{"location":"reg-expr/#qualche-esempio_1","text":"RegExpr /./g Input Ciao a tutti!! 12 volte grazie.. Output Ciao a tutti!! 12 volte grazie.. RegExpr /[^0-9]/g Input Ciao a tutti!! 12 volte grazie.. Output C,i,a,o, ,a, ,t,u,t,t,i,!,!, , ,v,o,l,t,e, ,g,r,a,z,i,e,.,., RegExpr /t*/g Input Ciao a tutti!! 12 volte grazie.. Output t,tt,t RegExpr /t?/g Input Ciao a tutti!! 12 volte grazie.. Output t,t,t,t RegExpr /[0-9]{1}/g Input Ciao a tutti!! 12 volte grazie.. Output 1,2 RegExpr /[0-9]{2}/g Input Ciao a tutti!! 12 volte grazie.. Output 12 RegExpr /[a-z]{5,6}/g Input Ciao a tutti!! 12 volte grazie.. Output tutti,volte,grazie RegExpr /[a-z]+/g Input Ciao a tutti!! 12 volte grazie.. Output iao,a,tutti,volte,grazie RegExpr /[0-9]+/g Input Ciao a tutti!! 12 volte grazie.. Output 12 RegExpr /volte\\|grazie/g Input Ciao a tutti!! 12 volte grazie.. Output volte,grazie","title":"Qualche esempio"},{"location":"reg-expr/#le-classi-di-caratteri-e-i-posix","text":"Le classi di caratteri e i POSIX servono per specificare una serie di caratteri allo stesso tempo, senza dover scomodare i gruppi. Classe Equivalente Descrizione \\w [[:word:]] [a-zA-Z0-9_] ricerca un carattere \u201cparola\u201d (w sta per word), cio\u00e8 lettere, numeri e \u201c_\u201d \\d [[:digit:]] [0-9] ricerca un numero (d sta per digit) \\s [[:space:]] [ \\t\\r\\n\\v\\f] ricerca uno spazio, comprese tabulazioni e caratteri di fine riga --- --- --- \\W [^a-zA-Z0-9_] ricerca un carattere che non sia \\w , cio\u00e8 tutto quello che non \u00e8 lettere, numeri o \u201c_\u201d\u201d \\D [^0-9] l\u2019opposto di \\d , ricerca qualsiasi cosa che non sia un numero \\S [^ \\t\\r\\n\\v\\f] l\u2019inverso di \\s , ricerca qualsiasi cosa che non sia uno spazio, una tabulazione o dei caratteri di fine riga --- --- --- [[:alnum:]] [a-zA-Z0-9] Ricerca caratteri alfanumerici, senza \u201c_\u201d [[:alpha:]] [a-zA-Z] Ricerca caratteri alfabetici [[:blank:]] [ \\t] ricerca solo spazi e tabulazioni [[:lower:]] [a-z] ricerca lettere minuscole [[:upper:]] [A-Z] ricerca lettere maiuscole [[:graph:]] [\\x21-x7E] ricerca tutti i caratteri visibili a video della tabella ascii non estesa, dal numero 33 (!) al 126 (~). [[:print:]] [\\x20-x7E] ricerca tutti i caratteri visibili a video della tabella ascii non estesa, dal numero 32 (spazio) al 126 (~). [[:punct:]] ricerca tutti i caratteri di punteggiatura come -!\u201d#$%&'()*+,.\\/:;<=>?@[]^_`{ [[:cntrl:]] [\\x00-x1F\\x7F] ricerca solo i caratteri di controllo","title":"Le classi di caratteri e i POSIX"},{"location":"reg-expr/#esercizio-ricerca-di-una-email-semplice-1","text":"RegExpr /[\\w]+@[\\w]+\\.[\\w]+/g Input Ciao, ricordati di scrivermi alla mia email personale per l'acconto articolo DKR#123, qt.2, ID@12901, email: prova@gmail.com Output prova@gmail.com Nell'espressione regolare sto cercando uno o pi\u00f9 caratteri seguiti dal simbolo @ seguiti da uno o pi\u00f9 caratteri, seguiti da . seguito da uno o pi\u00f9 caratteri. Ricordo che \\w ricerca tutte le lettere maiuscole/minuscole compreso il carattere _ e le cifre. Nota: Per quanto possa sembrare semplice e completo, questo esempio non include le email del tipo prova.prova@gmail.com","title":"Esercizio - ricerca di una email semplice 1"},{"location":"reg-expr/#esercizio-ricerca-di-una-email-semplice-2","text":"L'esempio precedente non raccoglie email del tipo prova.prova@gmail.com , infatti: RegExpr /[\\w]+@[\\w]+\\.[\\w]+/g Input Ciao, ricordati di scrivermi alla mia email personale per l'acconto articolo DKR#123, qt.2, ID@12901, email1: mario.rossi78@gmail.com Output rossi78@gmail.com Ecco allora una piccola modifica per aggiungere nella prima parte una selezione opzionale del carattere . RegExpr /([\\w]\\.?)+@[\\w]+\\.[\\w]+/g Input Ciao, ricordati di scrivermi alla mia email personale per l'acconto articolo DKR#123, qt.2, ID@12901, email1: mario.rossi78@gmail.com Output mario.rossi78@gmail.com","title":"Esercizio - ricerca di una email semplice 2"},{"location":"reg-expr/#esercizio-ricerca-di-una-url","text":"Questo esercizio ricerca una url semplice ma non completa RegExpr /(https?)\\:\\/{2}([\\w\\.]+\\/?)+([\\w\\#\\-\\.]+\\/?)+/g Input Ciao, ricordati di visualizzare i seguenti link, link: https://regexr.com, link: http://regexr.com/5mpk9, link: https://it.wikipedia.org/wiki/Posta_elettronica, link: https://github.com/CodeCoagious19, link: https://webmail.intecs.it/mail#1, link: https://github.com/CodeCoagious19/corsi-programmazione/blob/master/README.md#programmazione-desktop Output https://regexr.com,http://regexr.com/5mpk9,https://it.wikipedia.org/wiki/Posta_elettronica,https://github.com/CodeCoagious19,https://webmail.intecs.it/mail#1,https://github.com/CodeCoagious19/corsi-programmazione/blob/master/README.md#programmazione-desktop L'espressione regolare parte con il cercare https o http , prosegue alla ricerca di // . Nel primo gruppo ricerca testo che sia composto da una o pi\u00f9 lettere comprensive del carattere . ed eventualmente il carattere / . Nel secondo gruppo invece, opzionale e pi\u00f9 complesso ricerca del testo che contenga uno o pi\u00f9 lettere compresensive eventualmente del carattere - , . o # , anche questo gruppo ha opzionale il caratere / . Ripeto inoltre la ricerca di questo gruppo.","title":"Esercizio - ricerca di una url"},{"location":"sw-dev-methods/","text":"Metodologie di sviluppo software Essere Agili\u2026 Si ritiene che la metodologia #Agile (si pronuncia agiail , ma anche egil ) sia forse la innovazione pi\u00f9 rilevante a partire da inizio anni 2000 per quanto riguarda lo sviluppo del software. Innovazione con un carattere \u201crivoluzionario\u201d. Si contesta infatti l\u2019approccio tradizionale di sviluppo del software per \u201cfasi successive\u201d (es. scrittura dei requisiti, architettura, codifica, test, etc.) a vantaggio di uno sviluppo per \u201cfunzionalit\u00e0 successive \u201d ovvero il software viene sviluppato implementando progressivamente nuove funzionalit\u00e0. Nel mondo Agile le funzionalit\u00e0 sono espresse come \u201c user stories \u201d ovvero requisiti scritti con l\u2019ottica utente per descrivere come si interagisce con il sistema per fare qualcosa.L\u2019approccio Agile stava gi\u00e0 lentamente maturando da decenni. Il modello a cascata tradizionale ( waterfall model ) , manifestava i propri limiti: difficile procedere per fasi, quando i requisiti cambiano spesso forzando a ritornare sulle fasi gi\u00e0 fatte. Sono nati allora gli approcci incrementali, evolutivi, a spirale, iterativi, etc. tanti modi diversi che esprimono per\u00f2 il concetto di sviluppare versioni successive del software ( release ) via via inserendo funzionalit\u00e0 aggiuntive. La metodologia Agile ha portato all\u2019estremo tale approccio forzando release successive in tempi rapidi e fissi (es. ogni 2 settimane), chiamati \u201c sprint \u201d. Dopo 2 settimane devi consegnare una nuova release: non ti \u00e8 concesso un ritardo, devi consegnare comunque con le sole funzionalit\u00e0 implementate fino a quel momento. Il \u201critardo\u201d sar\u00e0 cosi sempre palese e quantificabile in termini di funzionalit\u00e0 attese ma non ancora presenti.Procedere per sprint si \u00e8 rivelato un potente acceleratore degli sviluppi e consente un monitoraggio stretto del progetto. L\u2019approccio Agile pi\u00f9 affermato \u00e8 #SCRUM .La INTECS da tempo utilizza approcci Agile in alcuni progetti. Abbiamo anche scritto articoli su Agile per conferenze internazionali sia nel settore Automotive che nel settore Railway ( Giancarlo Gennaro . Inoltre abbiamo attivamente partecipato Silvia Mazzini a definire l'approccio Agile pubblicato dalla European Space Agency . Abbiamo tenuto corsi e conferenze sui metodi Agili. Il collega John Favaro ha pure scritto un libro sul tema. Altri hanno preso la certificazione di SCRUM \"Master\" (es. Diodato Mauri . Chi vi scrive ha tenuto una consulenza Agile alla BBC Inglese.Qui abbiamo solo citati gli elementi fondanti ma L\u2019approccio Agile ha numerosi altri aspetti che potete trovare elencati in Wikipedia .Per un affondo su SCRUM si suggerisce il testo \" Una guida snella alla teoria e alla pratica di Scrum Configuration Management\u2026 ovvero come tenere in ordine il progetto Quando si lavora ad un progetto il risultato finale product \u00e8 un software da consegnare al cliente, ma durante il processo vengono preparati anche molti risultati intermedi work products che consistono in requisiti, architettura, file sorgente, piani di test, piani di progetto, verbali di riunioni, rapporti di test, etc.Questi \"work-products\" li possiamo chiamare configuration item , item . Ogni configuration item deve essere univocamente identificabile con un nome od un codice ed una versione. Importante \u00e8 anche registrare l'autore, il revisore, la data di creazione, etc. Chiamiamo queste informazioni \"attributi\" del configuration item.I configuration item rappresentano i risultati delle attivit\u00e0 di progetto e devono essere custoditi gelosamente in una area di progetto Repository ad accesso controllato e sottoposto a regolare back up. Il repository \u00e8 un po' come una teca dove inseriamo e conserviamo i gioielli via via prodotti ed eventualmente poi modificati dal progetto. Normalmente la teca \u00e8 accessibile a tutti i partecipanti del progetto ma in sola lettura mentre l'accesso in scrittura \u00e8 concesso a poche persone e magari solo su certi scaffali della teca.Normalmente si nomina un Configuration Manager che svolge il ruolo di \"custode della teca\" oppure lo fa direttamente il capo progetto.Una volta inserito un item nella teca se procediamo ad una sua revisione, inseriremo nella teca l'item aggiornato con un nuovo numero di versione, mantenendo comunque sempre anche la versione precedente (storicizzazione). Sar\u00e0 cos\u00ec sempre possibile sapere cosa \u00e8 cambiato, quando, da chi, etc.Quando il progetto raggiunge una milestone o un attimo prima di una consegna, allora si fa una fotografia (\"snapshot\") dell'intero progetto in quel momento, per cristallizzare la situazione. Questo concetto \u00e8 noto come baseline di progetto. Le bassline saranno sempre accessibili in futuro.Se due o pi\u00f9 persone accedono alla teca contemporaneamente rischiamo di \"sovrapporci\" ed ostacolarci a vicenda. Normalmente si prelevano dalla teca gli item che dobbiamo modificare ( check out ), si lavora su tali item e poi con un check-in si reinseriscono nella teca modificati. Nel frattempo altre persone non possono modificare tali item, evitando cos\u00ec di sovrapporsi. In altri casi addirittura si crea una copia della intera teca \"provvisoria\" (detta un branch dell'intero progetto in quel momento, per cristallizzare la situazione. Questo concetto \u00e8 noto come baseline di progetto. Le bassline saranno sempre accessibili in futuro. Se due o pi\u00f9 persone accedono alla teca contemporaneamente rischiamo di \"sovrapporci\" ed ostacolarci a vicenda. Normalmente si prelevano dalla teca gli item che dobbiamo modificare ( check out ), si lavora su tali item e poi con un check-in si reinseriscono nella teca modificati. Nel frattempo altre persone non possono modificare tali item, evitando cos\u00ec di sovrapporsi. In altri casi addirittura si crea una copia della intera teca \"provvisoria\" (detta un branch tutta per noi sulla quale lavoriamo senza interferenze. Alla fine il branch viene ricongiunto merge con il repository principale. In altri casi il branch continua a vivere di vita propria, ad esempio per una variante del prodotto.Questi sono i concetti generali e chiedo a Patrizia Nencioni ed a Roberto Fiorentino se vogliono aggiungere qualcosa di specifico ad un certo settore/mercato/cliente.Gli strumenti pi\u00f9 affermati per la gestione della configurazione sono entrambi open source GIT ed SVN (subversion). Spesso in combinazione con Tortoise , una elegante applicazione client che ne semplifica l\u2019accesso. Per approfondimenti vedi anche IEEE 828:2012 Standard for Configuration Management in systems and software engineering","title":"Metodologie di sviluppo software"},{"location":"sw-dev-methods/#metodologie-di-sviluppo-software","text":"","title":"Metodologie di sviluppo software"},{"location":"sw-dev-methods/#essere-agili","text":"Si ritiene che la metodologia #Agile (si pronuncia agiail , ma anche egil ) sia forse la innovazione pi\u00f9 rilevante a partire da inizio anni 2000 per quanto riguarda lo sviluppo del software. Innovazione con un carattere \u201crivoluzionario\u201d. Si contesta infatti l\u2019approccio tradizionale di sviluppo del software per \u201cfasi successive\u201d (es. scrittura dei requisiti, architettura, codifica, test, etc.) a vantaggio di uno sviluppo per \u201cfunzionalit\u00e0 successive \u201d ovvero il software viene sviluppato implementando progressivamente nuove funzionalit\u00e0. Nel mondo Agile le funzionalit\u00e0 sono espresse come \u201c user stories \u201d ovvero requisiti scritti con l\u2019ottica utente per descrivere come si interagisce con il sistema per fare qualcosa.L\u2019approccio Agile stava gi\u00e0 lentamente maturando da decenni. Il modello a cascata tradizionale ( waterfall model ) , manifestava i propri limiti: difficile procedere per fasi, quando i requisiti cambiano spesso forzando a ritornare sulle fasi gi\u00e0 fatte. Sono nati allora gli approcci incrementali, evolutivi, a spirale, iterativi, etc. tanti modi diversi che esprimono per\u00f2 il concetto di sviluppare versioni successive del software ( release ) via via inserendo funzionalit\u00e0 aggiuntive. La metodologia Agile ha portato all\u2019estremo tale approccio forzando release successive in tempi rapidi e fissi (es. ogni 2 settimane), chiamati \u201c sprint \u201d. Dopo 2 settimane devi consegnare una nuova release: non ti \u00e8 concesso un ritardo, devi consegnare comunque con le sole funzionalit\u00e0 implementate fino a quel momento. Il \u201critardo\u201d sar\u00e0 cosi sempre palese e quantificabile in termini di funzionalit\u00e0 attese ma non ancora presenti.Procedere per sprint si \u00e8 rivelato un potente acceleratore degli sviluppi e consente un monitoraggio stretto del progetto. L\u2019approccio Agile pi\u00f9 affermato \u00e8 #SCRUM .La INTECS da tempo utilizza approcci Agile in alcuni progetti. Abbiamo anche scritto articoli su Agile per conferenze internazionali sia nel settore Automotive che nel settore Railway ( Giancarlo Gennaro . Inoltre abbiamo attivamente partecipato Silvia Mazzini a definire l'approccio Agile pubblicato dalla European Space Agency . Abbiamo tenuto corsi e conferenze sui metodi Agili. Il collega John Favaro ha pure scritto un libro sul tema. Altri hanno preso la certificazione di SCRUM \"Master\" (es. Diodato Mauri . Chi vi scrive ha tenuto una consulenza Agile alla BBC Inglese.Qui abbiamo solo citati gli elementi fondanti ma L\u2019approccio Agile ha numerosi altri aspetti che potete trovare elencati in Wikipedia .Per un affondo su SCRUM si suggerisce il testo \" Una guida snella alla teoria e alla pratica di Scrum","title":"Essere Agili\u2026"},{"location":"sw-dev-methods/#configuration-management-ovvero-come-tenere-in-ordine-il-progetto","text":"Quando si lavora ad un progetto il risultato finale product \u00e8 un software da consegnare al cliente, ma durante il processo vengono preparati anche molti risultati intermedi work products che consistono in requisiti, architettura, file sorgente, piani di test, piani di progetto, verbali di riunioni, rapporti di test, etc.Questi \"work-products\" li possiamo chiamare configuration item , item . Ogni configuration item deve essere univocamente identificabile con un nome od un codice ed una versione. Importante \u00e8 anche registrare l'autore, il revisore, la data di creazione, etc. Chiamiamo queste informazioni \"attributi\" del configuration item.I configuration item rappresentano i risultati delle attivit\u00e0 di progetto e devono essere custoditi gelosamente in una area di progetto Repository ad accesso controllato e sottoposto a regolare back up. Il repository \u00e8 un po' come una teca dove inseriamo e conserviamo i gioielli via via prodotti ed eventualmente poi modificati dal progetto. Normalmente la teca \u00e8 accessibile a tutti i partecipanti del progetto ma in sola lettura mentre l'accesso in scrittura \u00e8 concesso a poche persone e magari solo su certi scaffali della teca.Normalmente si nomina un Configuration Manager che svolge il ruolo di \"custode della teca\" oppure lo fa direttamente il capo progetto.Una volta inserito un item nella teca se procediamo ad una sua revisione, inseriremo nella teca l'item aggiornato con un nuovo numero di versione, mantenendo comunque sempre anche la versione precedente (storicizzazione). Sar\u00e0 cos\u00ec sempre possibile sapere cosa \u00e8 cambiato, quando, da chi, etc.Quando il progetto raggiunge una milestone o un attimo prima di una consegna, allora si fa una fotografia (\"snapshot\") dell'intero progetto in quel momento, per cristallizzare la situazione. Questo concetto \u00e8 noto come baseline di progetto. Le bassline saranno sempre accessibili in futuro.Se due o pi\u00f9 persone accedono alla teca contemporaneamente rischiamo di \"sovrapporci\" ed ostacolarci a vicenda. Normalmente si prelevano dalla teca gli item che dobbiamo modificare ( check out ), si lavora su tali item e poi con un check-in si reinseriscono nella teca modificati. Nel frattempo altre persone non possono modificare tali item, evitando cos\u00ec di sovrapporsi. In altri casi addirittura si crea una copia della intera teca \"provvisoria\" (detta un branch dell'intero progetto in quel momento, per cristallizzare la situazione. Questo concetto \u00e8 noto come baseline di progetto. Le bassline saranno sempre accessibili in futuro. Se due o pi\u00f9 persone accedono alla teca contemporaneamente rischiamo di \"sovrapporci\" ed ostacolarci a vicenda. Normalmente si prelevano dalla teca gli item che dobbiamo modificare ( check out ), si lavora su tali item e poi con un check-in si reinseriscono nella teca modificati. Nel frattempo altre persone non possono modificare tali item, evitando cos\u00ec di sovrapporsi. In altri casi addirittura si crea una copia della intera teca \"provvisoria\" (detta un branch tutta per noi sulla quale lavoriamo senza interferenze. Alla fine il branch viene ricongiunto merge con il repository principale. In altri casi il branch continua a vivere di vita propria, ad esempio per una variante del prodotto.Questi sono i concetti generali e chiedo a Patrizia Nencioni ed a Roberto Fiorentino se vogliono aggiungere qualcosa di specifico ad un certo settore/mercato/cliente.Gli strumenti pi\u00f9 affermati per la gestione della configurazione sono entrambi open source GIT ed SVN (subversion). Spesso in combinazione con Tortoise , una elegante applicazione client che ne semplifica l\u2019accesso. Per approfondimenti vedi anche IEEE 828:2012 Standard for Configuration Management in systems and software engineering","title":"Configuration Management\u2026 ovvero come tenere in ordine il progetto"},{"location":"text-editor/readme/","text":"Quale editor di testo? Prima o poi ogni programmatore si trover\u00e0 ad affrontare il dilemma dell'editor di testo. Meglio Visual Studio Code o Atom? Perch\u00e8 non optare per un editor di testo online? Di quali estensioni ho bisogno? In questo articolo vedremo di rispondere ad ognuna di queste domande. Editor di testo online Non scartare a priori la possibilit\u00e0 di usare un editor online. Certo, avere un editor installato e piazzato sul PC da pi\u00f9 sicurezza e la possibilit\u00e0 di lavorare con o senza la connessione ma \u00e8 bene comunque conoscere le potenzialit\u00e0 di un editor online. Un editor online \u00e8 comodo in generale perch\u00e8: Non devi usare una Workspace(file e cartelle) sul tuo PC. Normalmente ti offre gi\u00e0 una scaffolding (impalcatura) del tuo progetto a seconda del linguaggio di programmazione. Basta connettersi con un account per accedere ai progetti. Normalmente puoi connetterti con il tuo account GitHub e importare/esportare progetti Normalmente ti permette di condividere il codice ad un amico o un collega condividendo direttamente l'url. atom vs code Atom Estensioni utili atom-ide ide-typescript platformio-ide-terminal minimap file-icons Emmet","title":"Quale editor di testo?"},{"location":"text-editor/readme/#quale-editor-di-testo","text":"Prima o poi ogni programmatore si trover\u00e0 ad affrontare il dilemma dell'editor di testo. Meglio Visual Studio Code o Atom? Perch\u00e8 non optare per un editor di testo online? Di quali estensioni ho bisogno? In questo articolo vedremo di rispondere ad ognuna di queste domande.","title":"Quale editor di testo?"},{"location":"text-editor/readme/#editor-di-testo-online","text":"Non scartare a priori la possibilit\u00e0 di usare un editor online. Certo, avere un editor installato e piazzato sul PC da pi\u00f9 sicurezza e la possibilit\u00e0 di lavorare con o senza la connessione ma \u00e8 bene comunque conoscere le potenzialit\u00e0 di un editor online. Un editor online \u00e8 comodo in generale perch\u00e8: Non devi usare una Workspace(file e cartelle) sul tuo PC. Normalmente ti offre gi\u00e0 una scaffolding (impalcatura) del tuo progetto a seconda del linguaggio di programmazione. Basta connettersi con un account per accedere ai progetti. Normalmente puoi connetterti con il tuo account GitHub e importare/esportare progetti Normalmente ti permette di condividere il codice ad un amico o un collega condividendo direttamente l'url. atom vs code","title":"Editor di testo online"},{"location":"text-editor/readme/#atom","text":"","title":"Atom"},{"location":"text-editor/readme/#estensioni-utili","text":"atom-ide ide-typescript platformio-ide-terminal minimap file-icons Emmet","title":"Estensioni utili"},{"location":"typescript/","text":"Typescript E' un linguaggio open source creato da Microsoft che estende Javascript introducendo tipi statici, mancanti nel linguaggio Javascript.","title":"Typescript"},{"location":"typescript/#typescript","text":"E' un linguaggio open source creato da Microsoft che estende Javascript introducendo tipi statici, mancanti nel linguaggio Javascript.","title":"Typescript"}]}